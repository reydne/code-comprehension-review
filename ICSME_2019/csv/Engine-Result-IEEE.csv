Document Title,Authors,Author Affiliations,Publication Title,Date Added To Xplore,Publication_Year,Volume,Issue,Start Page,End Page,Abstract,ISSN,ISBNs,DOI,Funding Information,PDF Link,Author Keywords,IEEE Terms,INSPEC Controlled Terms,INSPEC Non-Controlled Terms,Mesh_Terms,Article Citation Count,Reference Count,License,Online Date,Issue Date,Meeting Date,Publisher,Document Identifier
Using Eye Tracking Technology to Analyze the Impact of Stylistic Inconsistency on Code Readability,Q. Mi; J. Keung; J. Huang; Y. Xiao,NA; NA; NA; NA,"2017 IEEE International Conference on Software Quality, Reliability and Security Companion (QRS-C)",,2017,,,579,580,"A number of research efforts have focused in the area of programming style. However, to the best of our knowledge, there is little sound and solid evidence of how and to what extent can stylistic inconsistency impact the readability and maintainability of the source code. To bridge the research gap, we design an empirical experiment in which eye tracking technology is introduced to quantitatively reflect developers' cog.nitive efforts and mental processes when encountering the inconsistency issue.",,978-1-5386-2072-4978-1-5386-2073,10.1109/QRS-C.2017.102,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8004381,programming style;stylistic inconsistency;eye tracking technology;code readability;program comprehension,Gaze tracking;Visualization;Bridges;Software engineering;Indexes;Programming profession,software maintenance;source code (software),eye tracking technology;stylistic inconsistency;code readability;programming style;source code;research gap;cognitive efforts;mental processes;inconsistency issue;maintainability,,,3,,,,,IEEE,IEEE Conferences
"Linking Code Readability, Structure, and Comprehension Among Novices: It's Complicated",E. Wiese; A. Rafferty; A. Fox,"University of Utah; Carleton College; University of California, Berkeley",2019 IEEE/ACM 41st International Conference on Software Engineering: Software Engineering Education and Training (ICSE-SEET),,2019,,,84,94,"Novices' functionally-correct code is often redundant, verbose, or un-idiomatic. Such code could indicate shallow understanding of the programming language, or unfamiliarity with experts' preferences for code structure. Understanding why novices write poorly is important for designing instruction and tools to help novices write elegantly. 231 novices judged style and readability for sets of code snippets targeting seven topics. Within each set, functionality was the same, but the writing followed either common novice patterns or a more elegant, ""expert"" pattern. Overall, 76% of novices thought the ""expert"" snippets had the best style, but only 64% said those snippets were most readable. However, comprehension was similar for both ""expert"" and novice patterns, regardless of readability preferences. This suggests that students who prefer novice patterns do not necessarily have deep misunderstandings about the programming language. One topic included a code-writing task, and students' readability preferences were predictive of their code-writing patterns, suggesting that readability preferences reflect writing choices rather than comprehension. Thus, novices may benefit from lightweight tools that identify common patterns and suggest an ""expert"" solution, while helping them see that the ""expert"" solution is more readable than they think.",,978-1-7281-1000-4978-1-7281-1001,10.1109/ICSE-SEET.2019.00017,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8802116,computer science education;code readability;novice code comprehension,,,,,,28,,,,,IEEE,IEEE Conferences
Influence of Synchronized Domain Visualizations on Program Comprehension,N. Oliveira; M. J. V. Pereira; D. da Cruz; M. Berón,NA; NA; NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,192,195,"An effective program comprehension is reached when it is possible to view and relate what happens when the program is executed, synchronized with its effects in the real world concepts. This enables the interconnection of program's meaning at both problem and program domains. To sustain this statement we need (i) to develop a tool which provides and synchronizes views at both domains, and (ii) to perform an experiment to measure the actual impact of this approach. So, in this working session we aim at discussing the benefits of providing synchronized domain visualizations. We also envisage to discuss the preparation and conduction of appropriate experiments that will test that benefits. A case study will be used and the discussion will be supported by experimental material specially prepared for the occasion, but adapted from material already used in previous experiments.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.21,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521744,DSL comprehension;Program comprehension experiments;Program comprehension tools;Synchronized program visualizations,Visualization;Testing;DSL;Conducting materials;Animation;Performance evaluation;Cause effect analysis;Data mining;Humans;Graphics,data visualisation;synchronisation,synchronized domain visualizations;effective program comprehension,,,11,,,,,IEEE,IEEE Conferences
Towards an e-assessment approach of algorithmic problem-solving skills using plan-based program understanding approach,A. Bey; T. Bensebaa,"Laboratoire de Recherche en Informatique -LRI-Department of Computer Science Badji Mokhtar-Annaba University P.O. Box 12, 23000 Annaba, Algeria; Laboratoire de Recherche en Informatique -LRI-Department of Computer Science Badji Mokhtar-Annaba University P.O. Box 12, 23000 Annaba, Algeria",International Conference on Education and e-Learning Innovations,,2012,,,1,4,"The majority of the students of Computer Science often start directly writing a program code when they have been asked to resolve a problem in algorithms. Although, what is way more important is the algorithm the code has to represent. Learning how to design an algorithm which resolves a given problem it is not easy. In this paper, we propose a formative-diagnostic assessment approach which helps students on acquiring problem-solving skills that enable them to cope with problems and to design more efficient and elegant solutions. Aside from the fact that this approach brings a solution for delicate problem of e-assessment of algorithmic skills, in addition it is formative aiming at strengthening algorithmic competencies. Drawing inspiration from the basic principles of the algorithms field itself, it is based on using known components called: Basic Operations which are organized in a library. For modeling, solutions of each problem are regrouped in a bunch and each solution is represented by a plan which is the canonical representation of a program in an approach of program understanding. The purpose of this approach is to provide a formative and diagnostic assessment in order to empower the learner to acquire algorithmic problem-solving skills. Even if it has been conceived for algorithmic competencies assessment, this approach can easily be adapted to any field to assess its know-how.",,978-1-4673-2225-6978-1-4673-2226-3978-1-4673-2224,10.1109/ICEELI.2012.6360666,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6360666,Learning Environment;Diagnostic assessment;formative assessment;program understanding approach;algorithmic problem-solving skills,Educational institutions;Abstracts;Algorithm design and analysis;Problem-solving;Libraries;Programming,computer aided instruction;computer science education;problem solving,e-assessment approach;algorithmic problem solving skills;plan-based program understanding;computer science;program code;learning;formative-diagnostic assessment,,2,13,,,,,IEEE,IEEE Conferences
Trend analysis on the metadata of program comprehension papers,M. Sulír; J. Porubän,"Department of Computers and Informatics, Faculty of Electrical Engineering and Informatics, Technical University of Košice, Slovakia; Department of Computers and Informatics, Faculty of Electrical Engineering and Informatics, Technical University of Košice, Slovakia",2015 13th International Conference on Engineering of Modern Electric Systems (EMES),,2015,,,1,4,"As program comprehension is a vast research area, it is necessary to get an overview of its rising and falling trends. We performed an n-gram frequency analysis on titles, abstracts and keywords of 1885 articles about program comprehension from the years 2000-2014. According to this analysis, the most rising trends are feature location and open source systems, the most falling ones are program slicing and legacy systems.",,978-1-4799-7650-8978-1-4799-7649-2978-1-4799-7648,10.1109/EMES.2015.7158425,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7158425,Program comprehension;bibliography;trends;n-grams,Market research;Software;IEEE Xplore;Bibliographies;Software engineering;Visualization,meta data;program slicing;software maintenance,trend analysis;meta data;program comprehension;n-gram frequency analysis;program slicing;legacy systems,,,12,,,,,IEEE,IEEE Conferences
Industrial Realities of Program Comprehension (IRPC 2008),T. Dean; J. Visser,NA; NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,283,284,"In the working session on Industrial Realities of Program Comprehension (IRPC 2008), experience and ideas are shared regarding the challenges and opportunities of industrial application of program comprehension techniques. Participants work together to formulate a set of useful guidelines for introducing new program comprehension techniques into industrial practice as well as consolidating and increasing their use.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.43,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556145,Program comprehension;working session,Computer industry;Guidelines;Packaging;Business;Application software;Environmental economics;Testing;Quality assessment;Companies;Licenses,business data processing;software engineering,industrial realities;program comprehension techniques;industrial practice,,,2,,,,,IEEE,IEEE Conferences
CodersMUSE: Multi-Modal Data Exploration of Program-Comprehension Experiments,N. Peitek; S. Apel; A. Brechmann; C. Parnin; J. Siegmund,"Leibniz Institute for Neurobiology Magdeburg, Germany; University of Passau, Germany; Leibniz Institute for Neurobiology Magdeburg, Germany; NC State University, USA; University of Passau, Germany",2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC),,2019,,,126,129,"Program comprehension is a central cognitive process in programming. It has been in the focus of researchers for decades, but is still not thoroughly unraveled. Multi-modal psycho-physiological and neurobiological measurement methods have proved successful to gain a more holistic understanding of program comprehension. However, there is no proper tool support that lets researchers explore synchronized, conjoint multi-modal data, specifically designed for the needs in program-comprehension research. In this paper, we present CodersMUSE, a prototype implementation that aims to satisfy this crucial need.",2643-7171;2643-7147,978-1-7281-1519-1978-1-7281-1520,10.1109/ICPC.2019.00027,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813268,"program comprehension, data exploration, functional magnetic resonance imaging",,,,,,16,,,,,IEEE,IEEE Conferences
Program comprehension: A method of generating visualized UML class diagram,GuHui; WangHui,"College of Computer Science and Technology, Zhejiang University of Technology, ZJUT, Hangzhou, China; College of Computer Science and Technology, Zhejiang University of Technology, ZJUT, Hangzhou, China",The 2nd International Conference on Information Science and Engineering,,2010,,,6775,6776,"Program comprehension is an important research content of software engineering. This paper presents a Program comprehension visualization method of using UML class diagram. This method has two parts, first, The program source code is abstracted into database table, the form used to summarize and express program structure and key information, Then, the table was transformed into UML class diagrams, The class diagram can be effective to help understanding program structure and other key information.",2160-1283;2160-1291,978-1-4244-7618-3978-1-4244-7616-9978-1-4244-7617,10.1109/ICISE.2010.5690312,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5690312,program comprehension;table abstract;UML class diagram;visualization,Unified modeling language;Visualization;Software engineering;Educational institutions;Software maintenance,,,,,,,,,,IEEE,IEEE Conferences
Structural Knowledge and Language Notational Properties in Program Comprehension,P. Romero; B. du Boulay,"University of Sussex, UK; NA",2004 IEEE Symposium on Visual Languages - Human Centric Computing,,2004,,,223,225,"Several accounts of program comprehension have taken the theory of text comprehension by Kinstch as a starting point to model the mental representations built when programmers understand a computer program. A crucial point that these accounts try to explain is how these mental representations are organised. According to Kintsch's theory, the mental representations built as a product of the text comprehension process are interrelated propositional networks whose organisation is determined by the main idea of the text. In program comprehension, this main idea has been understood in terms of functionality. This paper contends this notion, proposing that in program understanding programmer's mental representations are multifaceted and organised through several criteria. Which of these is the most important one depends on the programming language employed among other factors. The fact that functional information appeared as crucial might have been because most of the empirical research that has been undertaken has employed procedural languages. This claim is tested empirically by analysing the mental representations of programmers in Prolog, a declarative programming language. The results support our claim by showing that in this case data structure information is more important than function",,0-7803-8696,10.1109/VLHCC.2004.50,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1372324,knowledge representation;program debugging;program comprehension,Programming profession;Computer languages;Humans;Data structures;Testing;Knowledge representation;Debugging,data structures;PROLOG;reverse engineering,structural knowledge;language notational property;program comprehension;text comprehension;mental representations;programmers;computer program;Kintsch theory;propositional networks;programming language;procedural languages;Prolog;data structure information,,,17,,,,,IEEE,IEEE Conferences
Supporting program comprehension with source code summarization,S. Haiduc; J. Aponte; A. Marcus,"Wayne State University, Detroit, MI; Universidad Nacional de Colombia, Bogot&#x0E1;, Colombia; Wayne State University, Detroit, MI",2010 ACM/IEEE 32nd International Conference on Software Engineering,,2010,2,,223,226,"One of the main challenges faced by today's developers is keeping up with the staggering amount of source code that needs to be read and understood. In order to help developers with this problem and reduce the costs associated with it, one solution is to use simple textual descriptions of source code entities that developers can grasp easily, while capturing the code semantics precisely. We propose an approach to automatically determine such descriptions, based on automated text summarization technology.",1558-1225;0270-5257,978-1-60558-719,10.1145/1810295.1810335,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6062165,program comprehension;summary;text summarization,Semantics;Natural languages;Large scale integration;Software engineering;Tagging;Software systems,reverse engineering;software cost estimation;software maintenance,program comprehension;source code summarization;cost reduction;textual description;code semantics;automated text summarization;software maintenance,,37,12,,,,,IEEE,IEEE Conferences
Experimental Settings in Program Comprehension: Challenges and Open Issues,G. A. Di Lucca; M. Di Penta,"University of Sannio, Benevento, Italy; NA",14th IEEE International Conference on Program Comprehension (ICPC'06),,2006,,,229,234,"Several approaches to program comprehension have been proposed along the years, ranging from fact extraction to sophisticated visualization tools. In order to effectively assess the benefits of each approach, or to properly compare different techniques, it is necessary to carry out a proper, well-defined experimentation. This work session aims to discuss the main issues in preparing experimental settings related to the evaluation of approaches and tools supporting program comprehension, as well as to promote networking aiming to carry on collaborative experimentations",1092-8138,0-7695-2601,10.1109/ICPC.2006.23,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631125,Empirical studies;program comprehension,Software tools;Visualization;Collaborative tools;Collaborative work;Human factors;Software maintenance;Instruments;Software systems;Performance evaluation;Packaging,program visualisation;reverse engineering;software maintenance,program comprehension;program visualization tool,,4,11,,,,,IEEE,IEEE Conferences
A study on the impact of emotional quotient on program comprehension,A. Savarimuthu; L. Arockiam; A. Aloysius,"Human resource Management, St. Joseph's College, Tiruchirappalli - 2, India; Computer Science, St. Joseph's College, Tiruchirappalli - 2, India; Computer Science, St. Joseph's College, Tiruchirappalli - 2, India",2010 International Conference on Communication and Computational Intelligence (INCOCCI),,2010,,,357,361,"Emotional Quotient (aka. Emotional Intelligence Quotient (EIQ)) can be described as the capacity for recognizing our own feelings and those of others, for motivating ourselves, and for managing emotions well in us and in our relationships. The primary objective of this work is to study the impact of EQ on the primary cognitive processes namely comprehension in Object oriented Systems. Comprehension is an understanding of the program code. The PG students were involved in all the experiments conducted. Java programs with various features of OO programming were given for comprehension. From the experiments that were conducted to find the relation between the program comprehension ability and the EQ values, it is identified that the EQ values have an impact on the program comprehension in the various OO features such as Inheritance and Polymorphism. The results of the experiments conducted may be used by the recruiter to carefully select the candidates for OO software development.",,978-81-8371-369,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5738757,Emotional Quotient (aka. Emotional Intelligence Quotient (EIQ));Program Comprehension;OO Systems,Programming profession;Humans;Educational institutions;Psychology;Training;Debugging,cognition;human computer interaction;Java;object-oriented methods;object-oriented programming;software engineering,emotional quotient;program comprehension;emotional intelligence quotient;primary cognitive process;object oriented system;Java program;OO programming;program comprehension ability;polymorphism;OO software development,,,26,,,,,IEEE,IEEE Conferences
Scalable Program Comprehension for Analyzing Complex Defects,S. C. Kothari,NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,3,4,"We describe the query-model-refine (QMR) approach for retrieving and modeling information for program comprehension. The QMR approach allows the flexibility to design and execute application-specific problem-solving strategies to suit particular program comprehension goals. The QMR approach has been used for building a number of program comprehension tools for different applications: interactive automatic parallelization, business rule analysis, auditing safety-critical control software, and defect analysis. This presentation will be about a program comprehension tool called Atlas and we will show its use for analyzing complex defects.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.44,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556111,Scalable;Program Comprehension;Complex Defects,Humans;Software tools;Information retrieval;Application software;Software safety;Information analysis;Artificial intelligence;Aerospace electronics;Space technology;Operating systems,program debugging;program diagnostics;query processing,scalable program comprehension;query-model-refine approach;problem-solving strategy;interactive automatic parallelization;business rule analysis;safety-critical control software;Atlas,,2,5,,,,,IEEE,IEEE Conferences
A retrospective view on: The role of concepts in program comprehension: (MIP award),V. Rajlich; N. Wilde,"Department of Computer Science, Wayne State University, Detroit, MI, U.S.A.; Department of Computer Science, University of West Florida, Pensacola, FL, U.S.A.",2012 20th IEEE International Conference on Program Comprehension (ICPC),,2012,,,12,13,"This retrospective briefly recapitulates highlights of the original paper that was published at IWPC 2002. Then it overviews research directions of the last 10 years: research in tools and techniques of concept location a that aim to support software developer, research of integrated model of software change, creation of software engineering course that emphasizes the role of software developer in iterative and agile software processes, and further basic research into the role and properties of concepts.",1092-8138,978-1-4673-1216-5978-1-4673-1213-4978-1-4673-1215,10.1109/ICPC.2012.6240480,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240480,partial program comprehension;as needed comprehension;concepts and features;concept location;software as repository of knowledge;constructivist learning,Software engineering;Pragmatics;Software tools;Education;Ontologies,iterative methods;software engineering,retrospective view;program comprehension;MIP award;concept location;software developer;integrated model;software change;software engineering course;agile software processes;iterative processes,,,12,,,,,IEEE,IEEE Conferences
Overview of Program Comprehension,W. Kechao; W. Tiantian; S. Xiaohong; M. Peijun,NA; NA; NA; NA,2012 International Conference on Computer Science and Electronics Engineering,,2012,1,,601,605,"With the increasing of software requirements, software is becoming larger and larger. It becomes an important problem to maintain the software. Thus understanding the program exactly, rapidly and comprehensively plays an important role. This paper has presented the related research of program comprehension, summarized six typical program comprehension strategies and compared these strategies.",,978-0-7695-4647-6978-1-4673-0689,10.1109/ICCSEE.2012.285,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6187918,software maintenance;program comprehension,Educational institutions;Knowledge based systems;Semantics;Programming;Software maintenance;Conferences,formal specification;reverse engineering;software maintenance,program comprehension overview;software requirements;software maintenance;program comprehension strategies,,,15,,,,,IEEE,IEEE Conferences
User evaluation of a domain specific program comprehension tool,L. Moonen,"Simula Research Laboratory, P.O. Box 134, N-1325 Lysaker, Norway",2012 First International Workshop on User Evaluation for Software Engineering Researchers (USER),,2012,,,45,48,"The user evaluation in this paper concerns a domain-specific tool to support the comprehension of large safety-critical component-based software systems for the maritime sector. We discuss the context and motivation of our research, and present the user-specific details of our tool, called FlowTracker. We include a walk-through of the system and present the profiles of our prospective users. Next, we discuss the design of an exploratory qualitative study that we have conducted to evaluate the usability and effectiveness of our tool. We conclude with a summary of lessons learned and challenges that we see for user evaluation of such domain-specific program comprehension tools.",,978-1-4673-1859-4978-1-4673-1858,10.1109/USER.2012.6226583,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6226583,user evaluation;domain specific tooling;program comprehension;software visualization,Actuators;Safety;Software;Navigation;Visualization;Sensor systems,marine engineering;object-oriented programming;reverse engineering;safety-critical software;software tools,user evaluation;domain specific program comprehension tool;large safety-critical component-based software system;maritime sector;FlowTracker;tool usability;tool effectiveness,,,13,,,,,IEEE,IEEE Conferences
[Journal First] A Comparison of Program Comprehension Strategies by Blind and Sighted Programmers,A. Armaly; P. Rodeghero; C. McMillan,NA; NA; NA,2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE),,2018,,,788,788,"Programmers who are blind use a screen reader to speak source code one word at a time, as though the code were text. This process of reading is in stark contrast to sighted programmers, who skim source code rapidly with their eyes. At present, it is not known whether the difference in these processes has effects on the program comprehension gained from reading code. These effects are important because they could reduce both the usefulness of accessibility tools and the generalizability of software engineering studies to persons with low vision. In this paper, we present an empirical study comparing the program comprehension of blind and sighted programmers. We found that both blind and sighted programmers prioritize reading method signatures over other areas of code. Both groups obtained an equal and high degree of comprehension, despite the different reading processes.",1558-1225,978-1-4503-5638-1978-1-5386-5293,10.1145/3180155.3182544,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453151,Program comprehension;accessibility technology;blindness,Software engineering;Tools;Java;Measurement;Software maintenance;Visualization,handicapped aids;programming environments;public domain software;software engineering,program comprehension strategies;sighted programmers;source code;reading processes,,,,,,,,IEEE,IEEE Conferences
Infusing Topic Modeling into Interactive Program Comprehension: An Empirical Study,T. Wang; Y. Liu,NA; NA,2017 IEEE 41st Annual Computer Software and Applications Conference (COMPSAC),,2017,2,,260,261,"Automatic and semi-automatic approaches supporting program comprehension are sought by researchers and practitioners to facilitate software engineering tasks, such as development, maintenance, extension and so on. Using topic modeling is a promising way to automatically discover feature and structure from textual software assets. However, there are gaps between knowing and doing when applying topic modeling to software engineering practice. In this paper, we explored how to infuse topic modeling into understanding Java programs in a generic level, and summarized the whole procedure as a methodology called MAT. MAT utilizes essential information automatically generated from Java projects to establish a project overview and to bring search capability for software engineers. Experiments on two open source Java projects suggest that MAT can support program comprehension for Java software engineers during carrying on software maintenance and extension tasks.",0730-3157,978-1-5386-0367-3978-1-5386-0368,10.1109/COMPSAC.2017.151,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8029929,Mining software assets;Java program comprehension;Topic models,Software;Java;Software engineering;Computational modeling;Maintenance engineering;Analytical models;Semantics,data mining;document handling;Java;project management;public domain software;software maintenance;software management,topic modeling;interactive program comprehension;software engineering tasks;feature discovery;textual software assets;Java programs;MAT;open source Java projects;software maintenance;document collection,,,7,,,,,IEEE,IEEE Conferences
SymAnalyzer: A Symbolic Analysis Tool for Program Comprehension,E. Laitila,NA,2009 13th European Conference on Software Maintenance and Reengineering,,2009,,,325,326,"In this paper, we present a program comprehension tool, called SymAnalyzer, which uses symbolic analysis as its main mechanism to help software engineers understand symbolic flows of the the most relevant sequences. Captured information is useful in troubleshooting and familiarization.",1534-5351,978-1-4244-3755-9978-0-7695-3589,10.1109/CSMR.2009.56,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812787,Program comprehension;symbolic analysis,Software maintenance;Information analysis;Space technology;Analytical models;Computational modeling;Logic programming;Tin;Software tools;Software systems;Data mining,program diagnostics;software tools,SymAnalyzer;symbolic analysis tool;program comprehension tool;software engineering,,,2,,,,,IEEE,IEEE Conferences
Poster: Knowledge Transfer from Research to Industry: A Survey on Program Comprehension,I. von Nostitz-Wallwitz; J. Krüger; J. Siegmund; T. Leich,NA; NA; NA; NA,2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion),,2018,,,300,301,"The number of scientific publications is continuously increasing, with most publications describing research that is also interesting for industrial software engineers. Program comprehension in particular is an essential and time consuming task in industry, but new approaches are rarely adopted.We conducted a survey with 89 participants from research and industry to investigate this problem. Our results indicate that researchers have to integrate other ways to communicate their work and make evaluations more practical.",2574-1934,978-1-4503-5663-3978-1-5386-6479,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449549,Program comprehension;survey;knowledge transfer,Tools;Knowledge transfer;Task analysis;Industries;Jacobian matrices;Software engineering;Programming,knowledge management;program diagnostics;software engineering,knowledge transfer;program comprehension;industrial software engineers,,,,,,,,IEEE,IEEE Conferences
Workshop on Program Comprehension Through Dynamic Analysis (PCODA'08),A. Zaidman; A. Hamou-Lhadj; O. Greevy; D. Röthlisberger,NA; NA; NA; NA,2008 15th Working Conference on Reverse Engineering,,2008,,,345,346,"Applying program comprehension techniques may render software maintenance and evolution easier. Understanding a software system typically requires a combination of static and dynamic analysis techniques. The aim of this workshop is to bring together researchers and practitioners working in the area of program comprehension with an emphasis on dynamic analysis. We are interested in investigating how dynamic analysis techniques are used or can be used to enable better comprehension of a software system. The objective is to compare existing techniques, identify common case studies and possible symbioses for existing solutions. Building upon three previous editions of the workshop, we aim to set up a forum for exchanging experiences, discussing solutions, and exploring new ideas.",1095-1350;2375-5369,978-0-7695-3429,10.1109/WCRE.2008.21,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656435,dynamic analysis;program comprehension,Conferences;Performance analysis;Reverse engineering;Software;Evolution (biology);Software maintenance;Special issues and sections,program diagnostics;software maintenance,program comprehension techniques;dynamic analysis techniques;software maintenance;software evolution;software system;static analysis techniques,,1,3,,,,,IEEE,IEEE Conferences
Measuring Program Comprehension: A Large-Scale Field Study with Professionals,X. Xia; L. Bao; D. Lo; Z. Xing; A. E. Hassan; S. Li,NA; NA; NA; NA; NA; NA,2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE),,2018,,,584,584,"This paper is published in IEEE Transaction on Software Engineering (DOI: 10.1109/TSE.2017.2734091). Comparing with previous programming comprehension studies that are usually in controlled settings or have a small number of participants, we perform a more realistic investigation of program comprehension activities. To do this, we extend our ActivitySpace framework to collect and analyze Human-Computer Interaction (HCI) data across many applications (not just the IDEs). We collect 3,148 working hour data from 78 professional developers in a field study. We follow Minelli et al.'s approach to assign developers' activities into four categories: navigation, editing, comprehension, and other. Then we measure comprehension time by calculating the time that developers spend on program comprehension. We find that on average developers spend ~58% of their time on program comprehension activities, and that they frequently use web browsers and document editors to perform program comprehension activities. We also investigate the impact of programming language, developers' experience, and project phase on the time that is spent on program comprehension.",1558-1225,978-1-4503-5638-1978-1-5386-5293,10.1145/3180155.3182538,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453126,Program Comprehension;Field Study;Inference Model,Computer science;Software;Software engineering;Australia;Conferences;Software measurement;Information technology,online front-ends;reverse engineering;software engineering;software maintenance,large-scale field study;program comprehension activities;measure comprehension time;professional developers;program comprehension measurement,,,,,,,,IEEE,IEEE Conferences
Context and Vision: Studying Two Factors Impacting Program Comprehension,Z. Soh,NA,2011 IEEE 19th International Conference on Program Comprehension,,2011,,,258,261,"Linguistic information derived from identifiers and comments has a paramount role in program comprehension. Indeed, very often, program documentation is scarce and when available, it is almost always outdated. Previous research works showed that program comprehension is often solely grounded on identifiers and comments and that, ultimately, it is the quality of comments and identifiers that impact the accuracy and efficiency of program comprehension. Previous works also investigated the factors influencing program comprehension. However, they are limited by the available tools used to establish relations between cognitive processes and program comprehension. The goal of our research work is to foster our understanding of program comprehension by better understanding its implied underlying cognitive processes. We plan to study vision as the fundamental mean used by developers to understand a code in the context of a given program. Vision is indeed the trigger mechanism starting any cognitive process, in particular in program comprehension. We want to provide supporting evidence that context guides the cognitive process toward program comprehension. Therefore, we will perform a series of empirical studies to collect observations related to the use of context and vision in program comprehension. Then, we will propose laws and then derive a theory to explain the observable facts and predict new facts. The theory could be used in future empirical studies and will provide the relation between program comprehension and cognitive processes.",1092-8138;1092-8138,978-1-61284-308-7978-0-7695-4398,10.1109/ICPC.2011.37,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970176,Program comprehension;cognitive process;vision science;program context,Context;Conferences;Visualization;Software;Software engineering;Maintenance engineering;Computers,software development management;system documentation,program comprehension;linguistic information;program documentation;cognitive processes,,1,25,,,,,IEEE,IEEE Conferences
Case studies of optimized sequence diagram for program comprehension,M. Srinivasan; Jeong Yang; Young Lee,"Electrical Engineering and Computer Science, Texas A&M University- Kingsville, USA; Electrical Engineering and Computer Science, Texas A&M University- Kingsville, USA; Electrical Engineering and Computer Science, Texas A&M University- Kingsville, USA",2016 IEEE 24th International Conference on Program Comprehension (ICPC),,2016,,,1,4,"In large project, source code becomes increasing complex and lengthy so program comprehension plays an important and significant role for developers. Sequence diagram generated using static source code or dynamic only approach provides limited execution coverage, additionally contains redundant, dead and fault driven methods, which increase the size of the diagram and complexity. In this paper, to address the problems, optimized sequence diagrams were developed by combining static source code and dynamic only approach, also incorporating various levels of abstraction in order to reduce complexity and provide complete behavior of the system. Case studies determined from the sequence diagram for three systems generated based on source code only and fully dynamic approach proved that the proposed optimized sequence diagrams were less complex and provided more detailed description of the functionality of the system.",,978-1-5090-1428,10.1109/ICPC.2016.7503734,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7503734,sequence diagram;polymorphism;object-oriented;visualization;program comprehension,Animals;Visualization;Measurement;Java;Complexity theory;Conferences;Reverse engineering,object-oriented methods;source code (software),program comprehension;static source code;fault driven methods;complexity;optimized sequence diagrams,,5,14,,,,,IEEE,IEEE Conferences
Studying Onboarding to Improve Program Comprehension Tool Support,R. Yates,NA,2010 IEEE Symposium on Visual Languages and Human-Centric Computing,,2010,,,257,258,"Gaining an understanding of unfamiliar software systems is hard. Existing support tools are based on studies of the information sought by software developers, but often the developers themselves do not know what to look for. Here an alternative is proposed: by studying the information `pushed' from software experts to new developers during onboarding, the information provided by the experts can be analysed and compared to the information `pulled' by the new developers. The content and presentation of this data will inform tool design for onboarding support.",1943-6106;1943-6092,978-1-4244-8485,10.1109/VLHCC.2010.47,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5635249,onboarding;program comprehension,Software;Programming;Conferences;Data visualization;USA Councils;Companies;Computational modeling,software tools,program comprehension tool support;software system;software developer;tool design,,,11,,,,,IEEE,IEEE Conferences
Applying Code Analysis and 3D Design Pattern Grouping to Facilitate Program Comprehension,J. Rilling; V. Nguyen,"Department of Computer Science and Software Engineering, Concordia University, Montreal, QC, Canada; NA",3rd IEEE International Workshop on Visualizing Software for Understanding and Analysis,,2005,,,1,2,"The increasing size and complexity of software systems introduces new challenges in comprehending the overall structure of programs. Modeling languages and notations were introduced to provide abstractions from existing source code during forward engineering. However, these same modeling techniques and notations fail during source code reverse engineering due to: (1) Information overload; and (2) the existence of a conceptual gap between the abstractions derived during forward and reverse engineered. Our tool uses a 3D representation for UML in combination with source code analysis to facilitate the comprehension process. We also address issues of crosscutting, navigation, and the use of animation to visualize design patterns",,0-7803-9540,10.1109/VISSOF.2005.1684320,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1684320,3D visualization;program comprehension;design patterns,Pattern analysis;Data visualization;Unified modeling language;Algorithm design and analysis;Bridges;Reverse engineering;Pattern recognition;Concrete;Production facilities;Computer science,data flow analysis;object-oriented programming;program visualisation;Unified Modeling Language,3D design pattern grouping;program comprehension;software systems;source code abstractions;forward engineering;source code reverse engineering;information overload;3D representation;UML;source code analysis;design pattern visualization,,1,6,,,,,IEEE,IEEE Conferences
Programmer eXperience: A Systematic Literature Review,J. Morales; C. Rusu; F. Botella; D. Quiñones,"Facultad de Ingeniería, Universidad Autónoma de Chile, Providencia, Chile; Escuela de Ingeniería Informática, Pontificia Universidad Católica de Valparaíso, Valparaíso, Chile; Instituto CIO, Universidad Miguel Hernández de Elche, Elche, Spain; Escuela de Ingeniería Informática, Pontificia Universidad Católica de Valparaíso, Valparaíso, Chile",IEEE Access,,2019,7,,71079,71094,"Programmers use various software development artifacts in their work, such as programming environments, design documents, and programming codes. These software artifacts can be studied and improved based on usability and User eXperience (UX) factors. In this paper, we consider programmers to be a specific case of users and analyze different elements that influence their experience in this specific context. We conducted a systematic literature review of papers published over the last ten years related to 1) the definition of the Programmer eXperience (PX); 2) the PX, UX, and usability factors regarding the programming environments, design documents, and programming codes; and 3) sets of heuristics to evaluate the software development artifacts mentioned before. We analyzed 73 articles, and the results obtained show that: 1) the important elements that influence the PX are the motivation of programmers and the choice of tools they use in their work, such as programming environments; 2) most of the identified studies (59%) aimed to evaluate the influence of the PX, UX, and usability on programming environments; 3) the majority of the studies (70%) used methods such as usability tests and/or heuristic evaluation methods; and 4) four sets of heuristics are used to evaluate software development artifacts in relation to programming environments, programming languages, and application programming interfaces. The results suggest that further research in this area is necessary to better understand and evaluate the concept of the PX.",2169-3536,,10.1109/ACCESS.2019.2920124,INF-PUCV Doctoral Scholarship; ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8727527,Heuristic evaluation;Programmer eXperience;systematic literature review;User eXperience;usability,Usability;Programming environments;Programming;User experience;Systematics;Bibliographies,application program interfaces;data analysis;human factors;software engineering;user interfaces,software development artifacts;programming environments;design documents;programming codes;software artifacts;PX;usability factors;application programming interfaces;programmer experience,,,102,,,,,IEEE,IEEE Journals
Quantifying Program Comprehension with Interaction Data,R. Minelli; A. Mocci; M. Lanza; T. Kobayashi,NA; NA; NA; NA,2014 14th International Conference on Quality Software,,2014,,,276,285,"It is common knowledge that program comprehension takes up a substantial part of software development. This ""urban legend"" is based on work that dates back decades, which throws up the question whether the advances in software development tools, techniques, and methodologies that have emerged since then may invalidate or confirm the claim. We present an empirical investigation which goal is to confirm or reject the claim, based on interaction data which captures the user interface activities of developers. We use interaction data to empirically quantify the distribution of different developer activities during software development: In particular, we focus on estimating the role of program comprehension. In addition, we investigate if and how different developers and session types influence the duration of such activities. We analyze interaction data from two different contexts: One comes from the ECLIPSE IDE on Java source code development, while the other comes from the PHARO IDE on Smalltalk source code development. We found evidence that code navigation and editing occupies only a small fraction of the time of developers, while the vast majority of the time is spent on reading & understanding source code. In essence, the importance of program comprehension was significantly underestimated by previous research.",1550-6002;2332-662X,978-1-4799-7198-5978-1-4799-7197,10.1109/QSIC.2014.11,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6958415,Program Comprehension;Program Understanding;Quantification;Interaction data;IDE,Navigation;History;Java;Inspection;Software;Browsers;Maintenance engineering,human computer interaction;Java;Smalltalk;software engineering;source code (software);user interfaces,program comprehension;interaction data;software development tools;software development techniques;software developer user interface activities;ECLIPSE IDE;Java source code development;PHARO IDE;Smalltalk source code development;code navigation;code editing,,12,24,,,,,IEEE,IEEE Conferences
A Gamification Technique for Motivating Students to Learn Code Readability in Software Engineering,Q. Mi; J. Keung; X. Mei; Y. Xiao; W. K. Chan,NA; NA; NA; NA; NA,2018 International Symposium on Educational Technology (ISET),,2018,,,250,254,"Code readability is one of the important software quality attributes that computer science students need to learn in their programming classes, unfortunately most of the students do not have the necessary work experience or background to appreciate the importance of code readability. Traditional methods of learning code readability tend to be less than interactive and practical in the classroom environment. With the advent of gamification technique, this study introduced a new interactive teaching method and implemented as GamiCRS, an online platform for students to learn code readability. The focus was on incorporating game-based mechanisms to enable students with positive attitudes towards a more interesting learning process. A complete incentive and reward model is proposed in the study together with a combination of both intrinsic and extrinsic motivators identified. To ensure its dynamic efficacy, a field experiment was carried out to compare GamiCRS with its non-gamified counterparts and to evaluate learning outcomes. The empirical results show a positive effect towards the application of GamiCRS in the classroom environment. As many learning activities in software engineering are typically challenging and seldom amusing, gamification can thus be applied as a compelling addition to supporting a wider variety of teaching tactics.",,978-1-5386-7209-9978-1-5386-7210,10.1109/ISET.2018.00062,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8456230,Code Readability;Gamification;Education;Crowdsourcing;Motivation;Technology Acceptance Model,Crowdsourcing;Education;Task analysis;Software engineering;Computer science;Urban areas;Software,computer aided instruction;computer games;computer science education;human factors;software engineering;software quality;teaching,gamification technique;code readability;software engineering;computer science students;student motivation;software quality attributes;interactive teaching method;GamiCRS;reward model;incentive model,,,14,,,,,IEEE,IEEE Conferences
Measurement of Source Code Readability Using Word Concreteness and Memory Retention of Variable Names,W. Xu; D. Xu; L. Deng,NA; NA; NA,2017 IEEE 41st Annual Computer Software and Applications Conference (COMPSAC),,2017,1,,33,38,"Source code readability is critical to software quality assurance and maintenance. In this paper, we present a novel approach to the automated measurement of source code readability based on Word Concreteness and Memory Retention (WCMR) of variable names. The approach considers programming and maintenance as processes of organizing variables and their operations to describe solutions to specific problems. The overall readability of given source code is calculated from the readability of all variables contained in the source code. The readability of each variable is determined by how easily its meaning is memorized (i.e., word concreteness) and how quickly they are forgotten over time (i.e., memory retention). Our empirical study has used 14 open source applications with over a half-million lines of code and 10,000 warning defects. The result shows that the WCMR-based source code readability negatively correlates strongly with overall warning defect rates, and particularly with such warning as bad programming practices, code vulnerability, and correctness bug warning.",0730-3157,978-1-5386-0367-3978-1-5386-0368,10.1109/COMPSAC.2017.166,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8029587,Code Readability;Variable Definitions and References;Word Concreteness;Memory Retention,Programming;Dictionaries;Maintenance engineering;Semantics;Software quality,program debugging;public domain software;software fault tolerance;software maintenance;software quality;source code (software),variable names;code vulnerability;software quality assurance;open source applications;software maintenance;source code readability measurement;word concreteness and memory retention;WCMR;warning defects;correctness bug warning,,,22,,,,,IEEE,IEEE Conferences
Pitekün: An Experimental Visual Tool to Assist Code Navigation and Code Understanding,J. Kubelka; A. Bergel; R. Robbes,NA; NA; NA,2014 33rd International Conference of the Chilean Computer Science Society (SCCC),,2014,,,135,137,"Studies show that software developers spend significantly more time navigating and understanding a codebase than actually writing code. Oddly, code navigation and comprehension are poorly supported by current programming environments. We present the main lines of the Pitekϋn programming environment to mitigate the gap between developer information needs and the current tool support. Pitekun uses three techniques to address the gap: (i) a spatial representation of the codebase, (ii) visual cues, and (iii) polymetric views. We conjecture that Pitekun improves navigation in the codebase and in answering the questions developers ask when learning the codebase.",1522-4902,978-1-5090-0421-8978-1-5090-0422,10.1109/SCCC.2014.31,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7559691,software engineering;development tool;code navigation,Visualization;Navigation;Context;Software;Maintenance engineering;Programming environments;Computer science,programming environments;reverse engineering;source code (software);visual programming,experimental visual tool;code navigation;code understanding;code comprehension;Pitekϋn programming environment;codebase spatial representation;visual cues;polymetric views,,,,,,,,IEEE,IEEE Conferences
Learning a Metric for Code Readability,R. P. L. Buse; W. R. Weimer,"University of Virginia, Charlottesville; University of Virginia, Charlottesville",IEEE Transactions on Software Engineering,,2010,36,4,546,558,"In this paper, we explore the concept of code readability and investigate its relation to software quality. With data collected from 120 human annotators, we derive associations between a simple set of local code features and human notions of readability. Using those features, we construct an automated readability measure and show that it can be 80 percent effective and better than a human, on average, at predicting readability judgments. Furthermore, we show that this metric correlates strongly with three measures of software quality: code changes, automated defect reports, and defect log messages. We measure these correlations on over 2.2 million lines of code, as well as longitudinally, over many releases of selected projects. Finally, we discuss the implications of this study on programming language design and engineering practice. For example, our data suggest that comments, in and of themselves, are less important than simple blank lines to local judgments of readability.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2009.70,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5332232,Software readability;program understanding;machine learning;software maintenance;code metrics;FindBugs.,Software quality;Humans;Software maintenance;Readability metrics;Documentation;Software measurement;Computer languages;Design engineering;Machine learning;Costs,human factors;software quality,code readability;software quality;local code features;human notions;code changes;automated defect reports;defect log messages;programming language design,,76,41,,,,,IEEE,IEEE Journals
Gaze as a Proxy for Cognition and Communication,P. Jermann; K. Sharma,NA; NA,2018 IEEE 18th International Conference on Advanced Learning Technologies (ICALT),,2018,,,152,154,"We investigate the potential of gaze as a predictor for the quality of dialogue and the level of understanding in collaborative problem-solving. We unveil a triangular relation among collaborators' dialogue, their gaze pattern, and their performance in the context of a pair programming task. Pairs of participants were asked to understand a JAVA program while their gaze was synchronously recorded. The performance was measured as the level of understanding attained by the pair at the end of the program comprehension task. Gaze patterns were analyzed based on probabilistic hit based areas of interest called gaze tokens. A novel dialogue coding scheme was developed to capture the program description as well as collaboration management aspect of pair program understanding. Both the areas of interest and the dialogue codes reflect top-down and bottom-up program comprehension strategies. Results show that it is possible to relate gaze to the level of abstraction in dialogue and to the level of understanding.",2161-377X,978-1-5386-6049-2978-1-5386-6050,10.1109/ICALT.2018.00043,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8433480,"Dual eye-tracking, program comprehension, program understanding, dialogue coding",Programming;Task analysis;Collaboration;Encoding;Synchronization;Java;Games,cognition;groupware;Java;probability;problem solving;reverse engineering,collaborative problem-solving;triangular relation;gaze pattern;pair programming task;JAVA program;program comprehension task;probabilistic hit based areas;collaboration management aspect;pair program understanding;dialogue codes;program comprehension strategies;Cognition;gaze tokens;dialogue coding scheme;gaze pattern analysis,,,10,,,,,IEEE,IEEE Conferences
Recognizing Algorithms Using Language Constructs; Software Metrics and Roles of Variables: An Experiment with Sorting Algorithms,A. Taherkhani; A. Korhonen; L. Malmi,NA; NA; NA,The Computer Journal,,2011,54,7,1049,1066,"Program comprehension (PC) is a research field that has been extensively studied from different points of view, including human program understanding and mental models, automated program understanding, etc. In this paper, we discuss algorithm recognition (AR) as a subfield of PC and explain their relationship. We present a method for automatic AR from Java source code. The method is based on static analysis of program code including various statistics of language constructs, software metrics, as well as analysis of roles of variables in the target program. In the first phase of the method, a number of different implementations of the supported algorithms are analyzed and stored in the knowledge base of the system as learning data, and in the second phase, previously unseen algorithms are recognized using this information. We have developed a prototype and successfully applied the method for recognition of sorting algorithms. This process is explained in the paper along with the experiment we have conducted to evaluate the performance of the method. Although the method, at its current state, is still sensitive to changes made to target algorithms, the encouraging results of the experiment demonstrate that it can be further developed to be used as a PC method in various applications, as an example, in automatic assessment tools to check the algorithms used by students, the functionality that is currently missing from these tools.",0010-4620;1460-2067,,10.1093/comjnl/bxq049,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8130420,algorithm recognition;program comprehension;program understanding;static program analysis;roles of variables,,,,,1,,,,,,OUP,OUP Journals
JTourBus: Simplifying Program Understanding by Documentation that Provides Tours Through the Source Code,C. Oezbek; L. Prechelt,"Freie Universität Berlin, Institut für Informatik, Takustr. 9, 14195 Berlin, Germany, oezbek@inf.fu-berlin.de; Freie Universität Berlin, Institut für Informatik, Takustr. 9, 14195 Berlin, Germany, prechelt@inf.fu-berlin.de",2007 IEEE International Conference on Software Maintenance,,2007,,,64,73,"Many small and medium-sized systems have little or no design documentation, which makes program understanding during maintenance enormously more difficult when performed by outsiders. Thus, if only minimal design documentation is available, which form should it take to maximize its usefulness? We suggest that it is helpful if the documentation describes a tour through the source code, leading the user directly to relevant details. This work reports an evaluation of this conceptual idea in the form of a controlled experiment with 59 student subjects working on a difficult program understanding task in the context of the 27 KLOC JHotDraw graphics framework. One group received a plain text documentation, the other received tour-structured documentation which they navigated by using an Eclipse plugin called JTourBus that we constructed for the experiment. The results indicate that program understanding can be achieved somewhat faster (albeit not more correctly) with JTourBus than with a plain text document.",1063-6773,978-1-4244-1255-6978-1-4244-1256,10.1109/ICSM.2007.4362619,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362619,program understanding;design documentation;delocalized concern,Documentation;Programming profession;Graphics;Navigation;Computer aided software engineering;Natural languages;Reverse engineering;Process design;Software design;Computer architecture,reverse engineering;system documentation,program understanding;source code;KLOC JHotDraw graphics framework;plain text documentation;tour-structured documentation;Eclipse plugin;JTourBus framework,,8,14,,,,,IEEE,IEEE Conferences
Visualizing serverless cloud application logs for program understanding,K. S. Chang; S. J. Fink,"IBM Research, 1101 Kitchawan Road, Yorktown Heights, NY 11109; IBM Watson, 1101 Kitchawan Road, Yorktown Heights, NY 11109",2017 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC),,2017,,,261,265,"A cloud platform records a wealth of information regarding program execution. Most cloud service providers offer dashboard monitoring tools that visualize resource usage and billing information, and support debugging. In this paper, we present a tool that visualizes cloud execution logs for a different goal - to facilitate program understanding and generate documentations for an application using runtime data. Our tool introduces a new timeline visualization, a new method and user interface to summarize multiple JSON objects and present the result, and interaction techniques that facilitate navigating among functions. Together, these features explain a serverless cloud application's composition, performance, dataflow and data schema. We report some initial user feedback from several expert developers that were involved in the tool's design and development process.",1943-6106,978-1-5386-0443-4978-1-5386-0444,10.1109/VLHCC.2017.8103476,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8103476,serverless computing;function as a service;program understanding;log visualization;cloud computing,Tools;Cloud computing;Data visualization;Unified modeling language;Bars;Computational modeling;Visualization,cloud computing;data flow analysis;data visualisation;program debugging;resource allocation;system monitoring;user interfaces,program understanding;runtime data;timeline visualization;user interface;serverless cloud application;cloud service providers;resource usage;billing information;debugging;cloud platform;program execution;dashboard monitoring tools;cloud execution logs;JSON objects,,,21,,,,,IEEE,IEEE Conferences
Abstracting runtime heaps for program understanding,M. Marron; C. Sanchez; Z. Su; M. Fahndrich,"Imdea Software Institute, Boadilla del Monte; Imdea Software Institute, Boadilla del Monte; University of California, Davis, Davis; Microsoft Research",IEEE Transactions on Software Engineering,,2013,39,6,774,786,"Modern programming environments provide extensive support for inspecting, analyzing, and testing programs based on the algorithmic structure of a program. Unfortunately, support for inspecting and understanding runtime data structures during execution is typically much more limited. This paper provides a general purpose technique for abstracting and summarizing entire runtime heaps. We describe the abstract heap model and the associated algorithms for transforming a concrete heap dump into the corresponding abstract model as well as algorithms for merging, comparing, and computing changes between abstract models. The abstract model is designed to emphasize high-level concepts about heap-based data structures, such as shape and size, as well as relationships between heap structures, such as sharing and connectivity. We demonstrate the utility and computational tractability of the abstract heap model by building a memory profiler. We use this tool to identify, pinpoint, and correct sources of memory bloat for programs from DaCapo.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2012.69,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6331492,Heap structure;runtime analysis;memory profiling;program understanding,Abstracts;Concrete;Shape;Runtime;Arrays;Computational modeling,data structures;merging;program diagnostics;program testing,program testing;program analysis;program inspection;program algorithmic structure;runtime data structure relationships;runtime heap abstracting;runtime heap summarization;concrete heap dump;program merging;program comparison;program computing;high-level concepts;heap structure sharing;heap structure connectivity;abstract heap model utility;abstract heap model computational tractability;memory profiler;memory bloat;DaCapo,,8,37,,,,,IEEE,IEEE Journals
PROUST: Knowledge-Based Program Understanding,W. L. Johnson; E. Soloway,"Department of Computer Science, Yale University; NA",IEEE Transactions on Software Engineering,,1985,SE-11,3,267,275,"This paper describes a program called PROUST which does on-line analysis and understanding of Pascal written by novice programmers. PROUST takes as input a program and a nonalgorithmic description of the program requirements, and finds the most likely mapping between the requirements and the code. This mapping is in essence a reconstruction of the design and implementation steps that the programmer went through in writing the program. A knowledge base of programming plans and strategies, together with common bugs associated with them, is used in constructing this mapping. Bugs are discovered in the process of relating plans to the code; PROUST can therefore give deep explanations of program bugs by relating the buggy code to its underlying intentions.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.1985.232210,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1702003,Artificial inteiligence;program debugging;programmer training;program understanding,Programming profession;Computer bugs;Writing;Debugging;Personnel;Psychology;Computer science;Machinery;Reactive power,,Artificial inteiligence;program debugging;programmer training;program understanding,,142,20,,,,,IEEE,IEEE Journals
Program understanding using program slivers-an experience report,A. Gupta,NA,1997 Proceedings International Conference on Software Maintenance,,1997,,,66,71,A large amount of legacy software is written in languages such as FORTRAN and COBOL. Hard-copy and inline documentation for this software is often inadequate to perform maintenance or re-implementation. These tasks are further hampered by legacy structures and programming style such as the use of &ldquo;goto&rdquo;. This paper describes our experience using simple pattern matching tools to obtain &ldquo;slivers&rdquo; from legacy process information systems. These slivers provided information that assisted in recovering program design. These slivers also helped in identifying segments which could cause problems with two-digit year fields at the turn of the century,1063-6773,0-8186-8013,10.1109/ICSM.1997.624232,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5726936,,,COBOL;FORTRAN;data integrity;information systems;pattern matching;program control structures;reverse engineering;software maintenance;software reusability;software tools;system documentation,COBOL;FORTRAN;Year 2000 problem;goto;hard-copy documentation;inline documentation;legacy process information systems;legacy software;pattern matching tools;program design recovery;program slivers;program understanding;programming style;software maintenance;software re-implementation;two-digit year fields,,,12,,,,,IEEE,IEEE Conferences
Atomic architectural component recovery for program understanding and evolution,R. Koschke,"Stuttgart Univ., Germany","International Conference on Software Maintenance, 2002. Proceedings.",,2002,,,478,481,"Component recovery and remodularization is a means to get back control on large and complex legacy systems suffering from ad-hoc changes by recovering logical components and restructuring the physical components accordingly to decrease coupling among components and increase cohesion of components. This thesis is on unifying, quantitatively and qualitatively evaluating, improving, and integrating automatic and semi-automatic methods for component recovery.",1063-6773,0-7695-1819,10.1109/ICSM.2002.1167807,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1167807,,Control systems;Automatic control;Costs;Software architecture;Computer architecture;Packaging;History;Manuals;Software maintenance;Humans,software architecture;software reusability;object-oriented programming;software maintenance;reverse engineering,atomic architectural component recovery;program understanding;program evolution;remodularization;complex legacy systems;logical components;software component restructuring;automatic methods;software maintenance;software reuse,,17,32,,,,,IEEE,IEEE Conferences
Designing self-explanation environment for multilayer understanding. In case of program understanding,M. Soga; A. Kashihari; J. -. Toyoda,"Dept. of Social Syst. Design, Wakayama Univ., Japan; NA; NA",1996 IEEE International Conference on Multi Media Engineering Education. Conference Proceedings,,1996,,,49,57,"This paper describes self-explanation for the objects, adopting program understanding as an example of the domain that has multiple aspects of understanding. Also, this paper describes how to use multimedia effectively to design a system that supports self-explanation environment.",,0-7803-3173,10.1109/MMEE.1996.570244,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=570244,,Nonhomogeneous media;Computer aided software engineering;Grain size;Multimedia systems;Environmental economics;Uniform resource locators;Toy industry;Layout;Educational programs;Electromagnetics,reverse engineering;multimedia systems;computer aided instruction,self-explanation environment;multilayer understanding;program understanding;multimedia,,1,4,,,,,IEEE,IEEE Conferences
Structural and behavioral code representation for program understanding,E. Merlo; K. Kontogiannis; J. F. Girard,"Centre de Recherche Inf. de Montreal, Que., Canada; Centre de Recherche Inf. de Montreal, Que., Canada; Centre de Recherche Inf. de Montreal, Que., Canada",[1992] Proceedings of the Fifth International Workshop on Computer-Aided Software Engineering,,1992,,,106,108,"Methodologies which could assist the software maintainer are reported, with emphasis on an approach which combines structural and behavioral representation of the code. Structural representation occurs at lower levels of abstraction and uses compiler technology techniques, graph parsing, abstract syntax trees, and control and data flow. Behavioral representation can be achieved at higher levels of abstraction by using some formal representation of source code semantics, such as process algebra, lambda calculus, or denotational semantics. The complexity, concurrency, and interaction levels of the system are good indicators of the best formalism to be chosen. Artificial intelligence techniques can be used to define semantic distances between different behavioral representation plans in order to achieve a full or partial match of the source code to the underlying specifications.<<ETX>>",,0-8186-2960,10.1109/CASE.1992.200136,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=200136,,Tree graphs;Flow graphs;Performance analysis;Algebra;Calculus;Concurrent computing;Artificial intelligence;Hardware;Maintenance engineering;Data engineering,computational complexity;grammars;program compilers;software maintenance;tree data structures,structural code representation;artificial intelligence;behavioral code representation;program understanding;software maintainer;behavioral representation;compiler;graph parsing;abstract syntax trees;formal representation;source code semantics;process algebra;lambda calculus;denotational semantics;complexity;concurrency;interaction levels,,1,8,,,,,IEEE,IEEE Conferences
Deploying Smart Program Understanding on a Large Code Base,C. Ieva; A. Gotlieb; S. Kaci; N. Lazaar,Simula Research Laboratory; Simula Research Laboratory; University of Montpellier; University of Montpellier,2019 IEEE International Conference On Artificial Intelligence Testing (AITest),,2019,,,73,80,"Program understanding aims at discovering human-readable properties of a software project from the analysis of its source code. Recently, we proposed a smart approach based on hierarchical agglomerative clustering that extracts so-called program topoi from source code. These topoi are high-level observable properties of the project. Based on textual and structural representations of the source code, our multi-steps approach clusters program topoi in an effective and efficient way. In this paper, we depict novel exploitation tasks of this program understanding approach and report on its application to Software Heritage. Software Heritage is an ambitious project which aims at collecting and archiving the biggest corpus of publicly available software source code. One of the project goals is to provide a new scientific instrument for computer scientists to evaluate advanced machine learning and software engineering methods on a very large source code repository. Our in-depth experiments reveal that unsupervised learning is the appropriate tool to mine and understand the biggest corpus of software source code ever produced.",,978-1-7281-0492-8978-1-7281-0493,10.1109/AITest.2019.000-4,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8718219,Program topoi;Software Heritage;Software Clustering;Program comprehension,Software;Semantics;Feature extraction;Coherence;Task analysis;Machine learning;Tools,pattern clustering;program diagnostics;reverse engineering;software maintenance;unsupervised learning,publicly available software source code;project goals;software engineering methods;source code repository;software heritage;ambitious project;program understanding approach;clusters program topoi;structural representations;textual representations;high-level observable properties;hierarchical agglomerative clustering;smart approach;software project;human-readable properties;code base;smart program understanding,,,18,,,,,IEEE,IEEE Conferences
Program understanding behavior during adaptation of large scale software,A. von Mayrhauser; A. M. Vans,"Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA; NA",Proceedings. 6th International Workshop on Program Comprehension. IWPC'98 (Cat. No.98TB100242),,1998,,,164,172,"We report on a software understanding study during adaptation, of large-scale software. Participants were professional software maintenance engineers. The paper reports on the general understanding process, the types of actions programmers preferred during the adaptation task, and the level of abstraction, at which they were working. The results of the observation are also interpreted in terms of the information needs of these software engineers.",1092-8138,0-8186-8560,10.1109/WPC.1998.693345,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=693345,,Large-scale systems;Programming profession;Software maintenance;Computer science;Database systems;Computer bugs;Software systems;Design for experiments;Computer industry;Shafts,reverse engineering;software maintenance,program understanding behavior;large-scale software adaptation;software maintenance;general understanding process;adaptation task;abstraction;information needs,,20,23,,,,,IEEE,IEEE Conferences
On selecting software visualization tools for program understanding in an industrial context,S. Tilley; Shihong Huang,"Dept. of Comput. Sci., California Univ., Riverside, CA, USA; Dept. of Comput. Sci., California Univ., Riverside, CA, USA",Proceedings 10th International Workshop on Program Comprehension,,2002,,,285,288,"Discusses issues related to selecting software visualization tools for program understanding in an industrial context. Visualization tools are often advocated as an effective means of aiding program understanding by creating graphical representations of the subject system through reverse engineering. However, there are numerous practical considerations related to tool selection for large, real-world projects that are unaddressed. For example, the choices are often limited to commercial tools that are widely available, that have a low cost of deployment and training, and that easily integrate into existing software engineering processes. To illustrate some of these unique issues, two types of constraints imposed on the process of software visualization tool selection to support program understanding in the domain of embedded, real-time control systems are described.",1092-8138,0-7695-1495,10.1109/WPC.2002.1021350,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021350,,Software tools;Visualization;Computer industry;Documentation;Costs;Computer science;Software systems;Reverse engineering;Software engineering;Embedded software,reverse engineering;program visualisation;data visualisation;software selection;embedded systems;industrial control,software visualization tools;program understanding;graphical representations;reverse engineering;embedded real-time control systems,,3,8,,,,,IEEE,IEEE Conferences
An experiment in scientific program understanding,M. E. M. Stewart,"Dynacs Eng. Inc., Cleveland, OH, USA",Proceedings ASE 2000. Fifteenth IEEE International Conference on Automated Software Engineering,,2000,,,281,284,"This paper concerns automated analysis of the meaning or semantics of scientific and engineering code. The procedure involves taking a user's existing code, adding semantic declarations for some primitive variables, and automatically identifying formulae. Parsers encode domain knowledge and recognize formulae in different disciplines including physics, numerical methods, mathematics, and geometry. The parsers will automatically recognize and document some static, semantic concepts and help locate some program semantic errors. Results are shown for three intensively studied codes and seven blind test cases; all test cases are state of the art scientific codes. These techniques may apply to a wider range of scientific codes. If so, the techniques could reduce the time, risk, and effort required to develop and modify scientific codes.",1938-4300,0-7695-0710,10.1109/ASE.2000.873678,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=873678,,Testing;Acceleration;Physics;Object oriented programming;Software performance;Knowledge representation;Equations;Documentation;Manuals;Investments,reverse engineering;natural sciences computing;grammars,scientific program understanding;automated analysis;meaning;semantics;scientific code;engineering code;semantic declarations;primitive variables;parsers;domain knowledge encoding;formulae recognition;physics;numerical methods;mathematics;geometry;program semantic errors,,2,17,,,,,IEEE,IEEE Conferences
Object-oriented codes representation of program understanding system,N. F. M. Sani; A. M. Zin; S. Idris,"Fac. of Computer Science and Information Technology, Universiti Putra Malaysia, 43400 UPM Serdang, Selangor, Malaysia; Fac. of Information Science and Technology, Universiti Kebangsaan Malaysia, 43600 Bangi, Selangor, Malaysia; Fac. of Information Science and Technology, Universiti Kebangsaan Malaysia, 43600 Bangi, Selangor, Malaysia",2008 International Symposium on Information Technology,,2008,1,,1,5,"The purpose of this paper is to present and describe the representation of an object-oriented programming code in the program understanding system. The program’s representation that has been used and will be discussed is an Object-oriented Control Flow Graph (OO-CFG). OO-CFG was an added version on the notation of the traditional control flow graph (CFG). This new OO-CFG has been created since from the literature there are no researches specifically focus on the problem in presenting the communications between objects. Usually the communication between objects in object-oriented program code is by a process of message passing. In this paper, we are introducing the OO-CFG representation and also example on the usage.",2155-8973;2155-899X,978-1-4244-2327-9978-1-4244-2328,10.1109/ITSIM.2008.4631595,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4631595,,Programming;Message passing;Flow graphs;Java;Debugging;Software;Algorithm design and analysis,,,,1,8,,,,,IEEE,IEEE Conferences
A Method of Program Structure Division Based on Program Understanding,Z. Youwei; W. Yonghong; L. Xiaochun,NA; NA; NA,2009 International Conference on Computer Technology and Development,,2009,1,,363,366,"A method of program structure division is introduced in the paper, which is on the basis of program dependence graph. It can divide complex assemble source program into a certain number of program blocks by analyzing the structure of source program, extract the relation of these blocks and show them in a graphic structure called program dependence graph. The result of the test shows that this method has a better commonality and efficiency while being applied to program static understanding analysis.",,978-0-7695-3892,10.1109/ICCTD.2009.159,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5359691,program block;program dependence graph;calling relation;multi-entry,Data structures;Algorithm design and analysis;Paper technology;Assembly;Data mining;Graphics;Testing;Hardware;Software systems;Costs,data structures;feature extraction;graph theory,program structure division;program dependence graph;complex assemble source program;graphic structure;program static understanding analysis,,,8,,,,,IEEE,IEEE Conferences
Do class comments aid Java program understanding?,E. Nurvitadhi; Wing Wah Leung; C. Cook,"Oregon State Univ., Corvallis, OR, USA; NA; NA","33rd Annual Frontiers in Education, 2003. FIE 2003.",,2003,1,,T3C,T3C,"This paper describes an experiment that investigates the effects of class and method comments on Java program understanding among beginning programmers. Each of the 103 students from CS1 class at Oregon Slate University was given one of four versions (no comments, only method comments, only class comments, and both method and class comments) of a Java database program and answered questions about the program. The results indicated that method comments do increase low-level program understanding, while class comments did not increase high-level understanding. This raises questions about the role of class comments in object-oriented programs, as well as the kind of commenting guidelines that should be used in teaching CS1 classes.",0190-5848,0-7803-7961,10.1109/FIE.2003.1263332,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1263332,,Java;Guidelines;Programming profession;Databases;Books;Testing;Debugging,Java;computer science education,Java program;database program;program understanding;object-oriented programs;class comments;method comments,,9,12,,,,,IEEE,IEEE Conferences
Answering program understanding questions on demand with task-specific runtime information,B. Burg,"Computer Science & Engineering, University of Washington",2013 IEEE Symposium on Visual Languages and Human Centric Computing,,2013,,,167,168,"When debugging or otherwise understanding software, developers frequently ask questions such as “how did this function get called?” and “where did this value come from?”. Runtime data is a valuable yet underused resource for answering these questions. There are at least four major barriers to answering questions with runtime data: 1) Deciding what runtime data should be collected 2) Deciding how to collect relevant runtime data 3) Aggregating and summarizing collected data 4) Interpreting the results to make conclusions.",1943-6092;1943-6106,978-1-4799-0369,10.1109/VLHCC.2013.6645268,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6645268,,Runtime;Debugging;Context;Probes;Aerospace electronics;Manuals,program debugging;program diagnostics,runtime data;underused resource;software debugging;task-specific runtime information;program understanding questions,,,5,,,,,IEEE,IEEE Conferences
Method of software testing based on program understanding,Heping Tang; Shuguang Huang; Lei Bao; Yongliang Li,"Department of Network engineering, HeFei Electronic Engineering Institute, Anhui China; Department of Network engineering, HeFei Electronic Engineering Institute, Anhui China; Department of Network engineering, HeFei Electronic Engineering Institute, Anhui China; Department of Network engineering, HeFei Electronic Engineering Institute, Anhui China",2010 The 2nd International Conference on Computer and Automation Engineering (ICCAE),,2010,2,,811,814,"The large scale software system requires computational management techniques in engineering designs, implementations and maintains urgently. This paper discusses an approach of program understanding with mathematical foundations for computation of software behavior. Computational analyses automatically figure out possible behavior and security attributes of software components both for source files and binary executes. The results of program understanding in formula and concurrent assignments forms augment human intelligence in program analysis, testing and evaluation. Program understanding transforms specification verification, software product and security attribute into computational procedure that would achieve intelligent management in next generation Software Engineering.",,978-1-4244-5586-7978-1-4244-5569-0978-1-4244-5585,10.1109/ICCAE.2010.5451817,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5451817,Computational Function Language;Concurrent Assignment Form;Expression Propagation;Software Testing;Security Evaluation,Software testing;Engineering management;Security;Computational intelligence;Large-scale systems;Software systems;Maintenance engineering;Design engineering;Humans;Software engineering,formal specification;formal verification;program diagnostics;program testing;reverse engineering,software testing method;program understanding;computational management;program analysis,,,7,,,,,IEEE,IEEE Conferences
Understanding program understanding,F. Balmas; H. Wertz; J. Singer,Universite Paris; NA; NA,Proceedings IWPC 2000. 8th International Workshop on Program Comprehension,,2000,,,256,256,,1092-8138,0-7695-0656,10.1109/WPC.2000.852501,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852501,,US Department of Transportation;Information technology;Software engineering;Data mining;Guidelines,,,,5,,,,,,IEEE,IEEE Conferences
Use of a program understanding taxonomy at Hewlett-Packard,A. Padula,"Hewlett-Packard Co., Palo Alto, CA, USA",[1993] IEEE Second Workshop on Program Comprehension,,1993,,,66,70,"Summarizes the use of a program understanding taxonomy developed at Hewlett-Packard. The primary use of the taxonomy has been in the creation of a company internal document called the Software Tools Report. The Software Tools Report is a selection and evaluation guide to software tools that addresses key company software engineering areas which include program understanding. A description of the Report, how it was created, and how it is used is given.<<ETX>>",1092-8138,0-8186-4042,10.1109/WPC.1993.263905,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263905,,Taxonomy;Software maintenance;Software tools;Software systems;Maintenance engineering;Software engineering;Investments;Data engineering;Engineering management;Computer industry,software maintenance,program understanding taxonomy;Hewlett-Packard;Software Tools Report;software engineering areas,,1,5,,,,,IEEE,IEEE Conferences
Program understanding-does it offer hope for aging software?,L. Miller; L. Johnson; J. Q. Ning; A. Quilici; P. Devanbu,"Aerospace Corp., Los Angeles, CA, USA; NA; NA; NA; NA",Proceedings of the Seventh Knowledge-Based Software Engineering Conference,,1992,,,238,242,"Two questions are examined: what does it mean to understand a program? What solutions to the aging software crisis does program understanding offer? One view is that the aging software problem is a form of support for program maintenance. Another view is that the problem of applying program understanding techniques to aging software is one of both extending the life of existing relics, and mining them for valuable components. Yet another view is that domain specific cliches are necessary in program understanding and that program understanding support for software is how programmers can come to understand a program through cooperative interaction with a knowledge base. The work focuses on the flexibility provided by natural language interaction.<<ETX>>",1068-3062,0-8186-2880,10.1109/KBSE.1992.252917,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=252917,,Aging;Programming profession;Automatic testing;Libraries;Knowledge representation;Reverse engineering;Software maintenance,human factors;knowledge based systems;natural language interfaces;programming;software maintenance;software reusability,aging software crisis;aging software problem;program maintenance;existing relics;domain specific cliches;program understanding support;cooperative interaction;knowledge base;natural language interaction,,,,,,,,IEEE,IEEE Conferences
Dynamic Object Process Graph Extraction for Program Understanding and Protocol Recovery,J. Quante,"University of Bremen, Germany",11th European Conference on Software Maintenance and Reengineering (CSMR'07),,2007,,,345,348,"An object process graph (OPG) is a view on the control flow graph from the perspective of a single object. Such a graph can be extracted using static or dynamic program analysis. Similar to program slicing, OPG extraction is an enabling technique with applications in many reverse engineering tasks. This Ph.D. thesis is about dynamic extraction of such OPGs and their application for program understanding and protocol recovery. In a first step, the author introduced methods for online and offline construction of dynamic OPGs, supporting different languages. The second step is the further transformation and application of the resulting graphs. The goal of this thesis is to show how they can be used for program comprehension and protocol recovery, and that these two approaches are really beneficial",1534-5351,0-7695-2802,10.1109/CSMR.2007.21,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4145059,,Protocols;Flow graphs;Reverse engineering;Application software;Visualization;Data mining;Instruments;Java;Software systems;Learning automata,flow graphs;program slicing;protocols;reverse engineering,dynamic object process graph extraction;program understanding;protocol recovery;control flow graph;static program analysis;dynamic program analysis;program slicing;reverse engineering;program comprehension,,,18,,,,,IEEE,IEEE Conferences
Structure-behavior-function program understanding,E. Stroulia; T. Systa,University of Alberta; NA,Proceedings 9th International Workshop on Program Comprehension. IWPC 2001,,2001,,,120,120,,1092-8138,0-7695-1131,10.1109/WPC.2001.921723,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921723,,Reverse engineering;Object oriented modeling;Documentation;Software systems;Runtime environment;Computer science;Protocols;Radio access networks;Computer languages;Web sites,,,,,,,,,,IEEE,IEEE Conferences
Do Dynamic Object Process Graphs Support Program Understanding? - A Controlled Experiment.,J. Quante,NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,73,82,"Using automatic program analysis techniques for extracting architectural information and its visualization is widely considered useful for program understanding. However, it has to be empirically validated if a given technique is beneficial in practice. This is usually done by performing a set of case studies. To find out for sure whether a technique really has any effect, controlled experiments have to be conducted. Dynamic object process graphs are one such technique. These graphs describe the control flow of an application from the perspective of a single object. In previous research, we conducted case studies which indicated that they may be useful for program understanding, but this assumption has not been validated so far. We report on a controlled experiment which investigated this question: Does the availability of such graphs support program understanding or not? We describe the research questions that were investigated, the hypotheses, experimental setup, conduction, and discuss the results and lessons learned.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.15,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556119,controlled experiment;program comprehension;dynamic analysis;software maintenance,Software maintenance;Visualization;Flow graphs;Automatic control;Information analysis;Data mining;Programming;Unified modeling language;Sockets;Application software,program diagnostics;reverse engineering;software architecture;software maintenance,dynamic object process graphs;automatic program analysis techniques;architectural information;program understanding,,24,8,,,,,IEEE,IEEE Conferences
An architecture for interoperable program understanding tools,S. Woods; L. O'Brien; T. Lin; K. Gallagher; A. Quilici,"Software Eng. Inst., Carnegie Mellon Univ., Pittsburgh, PA, USA; NA; NA; NA; NA",Proceedings. 6th International Workshop on Program Comprehension. IWPC'98 (Cat. No.98TB100242),,1998,,,54,63,"Program understanding tools are currently not interoperable, leading researchers to waste significant resources reinventing already existing tools. Even commercial environments that have been designed to support the construction of program understanding tools have serious flaws in this regard. This paper discusses CORUM (Common Object-based Re-engineering Unified Model), an architecture to support interoperability between program understanding tools, and it provides several examples of CORUM's use in the construction of new tools for concept recognition and program visualization.",1092-8138,0-8186-8560,10.1109/WPC.1998.693285,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=693285,,Computer architecture;Data visualization;Software tools;Software engineering;Data mining;Decoding;Educational institutions;Data flow computing;Wheels;Control systems,reverse engineering;software tools;open systems;object-oriented programming;systems re-engineering;data visualisation,interoperable program understanding tools;commercial environments;CORUM;Common Object-based Re-engineering Unified Model;concept recognition;program visualization,,18,54,,,,,IEEE,IEEE Conferences
A static analysis for program understanding and debugging,R. Gaugne,"IRISA/INRIA, Rennes, France",Proceedings 12th IEEE International Conference Automated Software Engineering,,1997,,,297,298,"The paper presents a static pointer analysis technique for a subset of C. The tool supports user-defined assertions inserted in the body of the program. Assertions are of two kinds: static assertions automatically verified by the analyser, and hypothetical assertions treated as assumptions by the analyser. The technique deals with recursive data structures and it is accurate enough to handle circular structures.",,0-8186-7961,10.1109/ASE.1997.632853,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=632853,,Debugging;Data structures;Computer bugs;Logic;Computer languages;Programming profession;Mechanical factors;Testing;Costs;Tail,reverse engineering;program debugging;system monitoring;data structures;program verification;program verification,program understanding;program debugging;static pointer analysis technique;C subset;user-defined assertions;static assertions;automatic verification;hypothetical assertions;assumptions;recursive data structures;circular structures,,1,7,,,,,IEEE,IEEE Conferences
Workshop on graphical documentation for programmers: assessing the efficacy of UML diagrams for program understanding,Shihong Huang; S. Tilley,"Dept. of Comput. Sci., Univ. of California, Riverside, CA, USA; NA","11th IEEE International Workshop on Program Comprehension, 2003.",,2003,,,281,282,"Programmers often use graphical forms of documentation that rely on software visualization techniques to make complicated information easier to understand. However, it is an open question exactly which types of graphical documentation are most suitable for which types of program understanding tasks (and in which specific usage contexts). The Unified Modeling Language (UML) is the de facto standard for modeling modern software applications. This paper focuses on discussing techniques for the efficacy of UML diagrams in aid of program understanding. The majority of the workshop will involve participants analyzing a series of UML diagrams and answering a detailed questionnaire concerning a hypothetical software system.",1092-8138,0-7695-1883,10.1109/WPC.2003.1199213,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199213,,Reverse engineering;Specification languages;Visualization;Computer graphics,reverse engineering;specification languages;data visualisation;computer graphics,graphical documentation;UML diagrams;program understanding;graphical forms;software visualization;Unified Modeling Language,,1,4,,,,,IEEE,IEEE Conferences
A Multiple View Interactive Environment to Support MATLAB and GNU/Octave Program Comprehension,I. d. M. Lessa; G. d. F. Carneiro; M. J. T. P. Monteiro; F. B. e. Abreu,NA; NA; NA; NA,2015 12th International Conference on Information Technology - New Generations,,2015,,,552,557,"Program comprehension plays an important role in Software Engineering. In fact, many of the software lifecycle activities depend on program comprehension. Despite the importance of MATLAB and Octave programing languages in the Engineering and Statistical communities, little attention has been paid to the conception, implementation and characterization of tools and techniques for the comprehension of programs written in these languages. Considering this scenario, this paper presents a Multiple View Interactive Environment (MVIE) called Oct Miner that supports the comprehension of programs developed in the aforementioned languages. Oct Miner provides a set of coordinated visual metaphors that can be adjusted in accordance with the comprehension goals. An example is presented to illustrate the main functionalities of Oct Miner in a real scenario of program comprehension.",,978-1-4799-8828-0978-1-4799-8827,10.1109/ITNG.2015.93,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7113531,Program Comprehension;Software Visualization;MATLAB;Octave;Crosscutting Concerns,MATLAB;Visualization;Mathematical model;Image color analysis;Computer languages;Shape,interactive programming;mathematics computing;program visualisation;programming languages;software maintenance;Unix,software visualization;OctMiner;coordinated visual metaphors;MVIE;statistical communities;engineering communities;Octave programing languages;software lifecycle activities;software engineering;Octave program comprehension;GNU program comprehension;MATLAB;multiple view interactive environment,,2,15,,,,,IEEE,IEEE Conferences
A Neuro-Cognitive Perspective of Program Comprehension,N. Peitek,NA,2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion),,2018,,,496,499,"Program comprehension is the cognitive process of understanding code. Researchers have proposed several models to describe program comprehension. However, because program comprehension is an internal process and difficult to measure, the accuracy of the existing models are limited. Neuro-imaging methods, such as functional magnetic resonance imaging (fMRI), provide a novel neuro-cognitive perspective to program-comprehension research. With my thesis work, we aim at establishing fMRI as a new tool for program-comprehension and software-engineering studies. Furthermore, we seek to refine our existing framework for conducting fMRI studies by extending it with eye tracking and improved control conditions. We describe how we will apply our upgraded framework to extend our understanding of program comprehension. In the long-run, we would like to contribute insights from our fMRI studies into software-engineering practices by providing code-styling guidelines and programming tools, which reduce the required cognitive effort to comprehend code.",2574-1934,978-1-4503-5663-3978-1-5386-6479,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449636,program comprehension;top down comprehension;functional magnetic resonance imaging;eye tracking,Functional magnetic resonance imaging;Brain;Gaze tracking;Cognition;Task analysis;Tools;Electroencephalography,biomedical MRI;cognition;neurophysiology;software engineering,neuro-cognitive perspective;functional magnetic resonance imaging;fMRI;eye tracking;software-engineering practices;programming tools;code-styling guidelines;program-comprehension research,,,,,,,,IEEE,IEEE Conferences
Measuring Program Comprehension: A Large-Scale Field Study with Professionals,X. Xia; L. Bao; D. Lo; Z. Xing; A. E. Hassan; S. Li,"Zhejiang University, Hangzhou, China; Zhejiang University, Hangzhou, China; Singapore Management University, Singapore; Australian National University, Canberra, ACT, Australia; Queen’s University, Kingston, ON, Canada; Zhejiang University, Hangzhou, China",IEEE Transactions on Software Engineering,,2018,44,10,951,976,"During software development and maintenance, developers spend a considerable amount of time on program comprehension activities. Previous studies show that program comprehension takes up as much as half of a developer's time. However, most of these studies are performed in a controlled setting, or with a small number of participants, and investigate the program comprehension activities only within the IDEs. However, developers' program comprehension activities go well beyond their IDE interactions. In this paper, we extend our ActivitySpace framework to collect and analyze Human-Computer Interaction (HCI) data across many applications (not just the IDEs). We follow Minelli et al.'s approach to assign developers' activities into four categories: navigation, editing, comprehension, and other. We then measure the comprehension time by calculating the time that developers spend on program comprehension, e.g., inspecting console and breakpoints in IDE, or reading and understanding tutorials in web browsers. Using this approach, we can perform a more realistic investigation of program comprehension activities, through a field study of program comprehension in practice across a total of seven real projects, on 78 professional developers, and amounting to 3,148 working hours. Our study leverages interaction data that is collected across many applications by the developers. Our study finds that on average developers spend ~58 percent of their time on program comprehension activities, and that they frequently use web browsers and document editors to perform program comprehension activities. We also investigate the impact of programming language, developers' experience, and project phase on the time that is spent on program comprehension, and we find senior developers spend significantly less percentages of time on program comprehension than junior developers. Our study also highlights the importance of several research directions needed to reduce program comprehension time, e.g., building automatic detection and improvement of low quality code and documentation, construction of software-engineering-specific search engines, designing better IDEs that help developers navigate code and browse information more efficiently, etc.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2017.2734091,NSFC; National Key Technology R&D Program; Ministry of Science and Technology of China; ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7997917,Program comprehension;field study;inference model,Navigation;Software;Time measurement;Browsers;Maintenance engineering;Programming;Debugging,human computer interaction;Internet;program compilers;reverse engineering;search engines;software maintenance,program comprehension activities;program comprehension time;developers time;software development;software maintenance;IDE interactions;ActivitySpace framework;human computer interaction;Web browsers;programming language;project phase;software-engineering;search engines,,1,63,,,,,IEEE,IEEE Journals
Symbolic Reductionist Model for Program Comprehension,E. Laitila; S. Legrand,NA; NA,"2007 Sixth Mexican International Conference on Artificial Intelligence, Special Session (MICAI)",,2007,,,363,372,"This article presents the main features of a novel construction, symbolic analysis, for automatic source code processing. The method is superior to the known methods, because it uses a semiotic, interpretative approach. Its most important processes and characteristics are considered here. We describe symbolic information retrieval and the process of analysis in which it can be used in order to obtain pragmatic information. This, in turn, is useful in understanding a current Java program version when developing a new version.",,978-0-7695-3124,10.1109/MICAI.2007.7,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4659326,symbolic analysis;program comprehension;reverse engineering,Object oriented modeling;Java;Reverse engineering;Object oriented programming;Information retrieval;Information analysis;Turing machines;Information systems;Unified modeling language;Artificial intelligence,configuration management;Java;object-oriented programming;program diagnostics;reverse engineering;symbol manipulation,symbolic reductionist model;program comprehension;symbolic analysis;automatic source code processing;semiotic-interpretative approach;symbolic information retrieval;pragmatic information;Java program,,,17,,,,,IEEE,IEEE Conferences
Semantic-based extraction approach for generating source code summary towards program comprehension,R. Kadar; S. M. Syed-Mohamad; N. Abdul Rashid,"School of Computer Sciences, Universiti Sains Malaysia, Penang, MALAYSIA; School of Computer Sciences, Universiti Sains Malaysia, Penang, MALAYSIA; School of Computer Sciences, Universiti Sains Malaysia, Penang, MALAYSIA",2015 9th Malaysian Software Engineering Conference (MySEC),,2015,,,129,134,"Program comprehension is a vital process that involves much effort in software maintenance. A key challenge for the developers is to comprehend a software system to be maintained since it is difficult and time consuming. Nowadays, software systems have grown in size causing the increased of developers' tasks in exploring and understanding source code. Source code is a crucial resource for developers to become familiar with a software system since some system documentation is often unavailable or outdated. Although many researchers have discussed different strategies and techniques to overcome the program comprehension problem, there are still many challenges that they have not yet discovered when trying to understand a software system through reading source code. Therefore, this study attempts to overcome the problem of source code comprehension by suggesting a suitable comprehension technique. We propose a semantic-based extraction approach of source code and generating it as a summary. This work aims to explain the concepts and relationships of program by integrating utilization of ontology and UML class-based modeling approaches. It will be easier for maintainer to understand source code as well as create a better way for improving program comprehension.",,978-1-4673-8227-4978-1-4673-8226,10.1109/MySEC.2015.7475208,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7475208,program comprehension;information extraction;semantic relationship;graphical representation;visualization,Unified modeling language;Ontologies;Semantics;Software systems;Natural languages;Java;Object oriented modeling,ontologies (artificial intelligence);software maintenance;source code (software);Unified Modeling Language,UML class-based modeling;ontology;software systems;software maintenance;program comprehension;source code summary;semantic-based extraction,,,26,,,,,IEEE,IEEE Conferences
Indentation: Simply a Matter of Style or Support for Program Comprehension?,J. Bauer; J. Siegmund; N. Peitek; J. C. Hofmeister; S. Apel,University of Passau; University of Passau; Leibniz Institute for Neurobiology; University of Passau; University of Passau,2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC),,2019,,,154,164,"An early study showed that indentation is not a matter of style, but provides actual support for program comprehension. In this paper, we present a non-exact replication of this study. Our aim is to provide empirical evidence for the suggested level of indentation made by many style guides. Following Miara and others, we also included the perceived difficulty, and we extended the original design to gain additional insights into the influence of indentation on visual effort by employing an eye-tracker. In the course of our study, we asked 22 participants to calculate the output of Java code snippets with different levels of indentation, while we recorded their gaze behavior. We did not find any indication that the indentation levels affect program comprehension or visual effort, so we could not replicate the findings of Miara and others. Nevertheless, our modernization of the original experiment design is a promising starting point for future studies in this field.",2643-7171;2643-7147,978-1-7281-1519-1978-1-7281-1520,10.1109/ICPC.2019.00033,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813302,"Code Indentation, Program Comprehension, Visual Effort",,,,,,40,,,,,IEEE,IEEE Conferences
"Program Comprehension: Past, Present, and Future",J. Siegmund,NA,"2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)",,2016,5,,13,20,"Program comprehension is the main activity of the software developers. Although there has been substantial research to support the programmer, the high amount of time developers need to understand source code remained constant over thirty years. Beside more complex software, what might be the reason? In this paper, I explore the past of program-comprehension research, discuss the current state, and outline what future research on program comprehension might bring.",,978-1-5090-1855,10.1109/SANER.2016.35,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7476769,Program comprehension;empirical software engineering,Programming;Software;Computer languages;Protocols;Time factors;Atmospheric measurements;Particle measurements,software engineering;source code (software),program comprehension research;source code;time developers;programmer;software developers,,6,41,,,,,IEEE,IEEE Conferences
RTFM (Read the Factual Mails) - Augmenting Program Comprehension with Remail,A. Bacchelli; M. Lanza; V. Humpa,NA; NA; NA,2011 15th European Conference on Software Maintenance and Reengineering,,2011,,,15,24,"The advent of globalization has led to the adoption of distributed software development as a common practice. One of its drawbacks-the absence of impromptu meetings - is tackled with other communication means, such as emails, instant messaging, or forums. Mailing lists have proven to be effective for enabling developers' collaboration and coordination: Being asynchronous, emails can evade time zone barriers, being public, mailing lists maintain developers' awareness, being recorded, email archives offer information on system evolution. Emails can provide information about a task, clarify implementation details, or reveal hidden connections among entities, always within the clear context of a discussion. As a result, we argue that emails might help program comprehension. We devised Remail, an Eclipse plug in to integrate email communication in the IDE. It allows developers to seamlessly handle code entities and emails concerning the source code. Discussions relevant to chosen entities can be retrieved easily, thus providing an updated and effective form of complementary documentation. We present design and implementation of Remail, and illustrate, through a number of scenarios, how it can augment program comprehension.",1534-5351;1534-5351,978-1-61284-259-2978-0-7695-4343,10.1109/CSMR.2011.6,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5741255,email;program comprehension;remail;IDE plugin,Electronic mail;Databases;Context;Engines;Documentation;Programming;Joining processes,electronic mail;software maintenance,program comprehension;distributed software development;Remail plug-in;E-mail communication,,10,24,,,,,IEEE,IEEE Conferences
Facilitating Scenario-Based Program Comprehension with Topic Models,T. Wang; Y. Liu,NA; NA,2017 24th Asia-Pacific Software Engineering Conference (APSEC),,2017,,,642,647,"Researchers and practitioners have been seeking automatic and semi-automatic approaches to support program comprehension. However, not too much attention has been given to the discussion about program comprehension scenarios and further exploration based on scenarios. In this paper, we explored program comprehension from the perspective of developers, analyzed the demands of developers, refined two program comprehension scenarios (Program Users Scenario and Program Owners Scenario), and mainly researched on the latter. In the Program Users Scenario, where developers need help to quickly understand a program and be able to use it fast, we found that topic modeling provides a promising way to facilitate program comprehension. Using topic modeling, features and structures can be discovered automatically from textual software assets. We also developed JSEA, a tool that provides semi-automatic program comprehension assistance. JSEA utilizes essential information automatically generated from Java projects to construct a project overview and give developers search capability. Experiments with 12 volunteers on two open source Java projects suggest that JSEA can support Java developers in comprehending programs in the Program Users Scenario.",,978-1-5386-3681-7978-1-5386-3682,10.1109/APSEC.2017.78,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8305995,Mining software assets;Java program comprehension;Topic models,Java;Tools;Analytical models;Maintenance engineering;Task analysis;Software maintenance,Java;public domain software;reverse engineering;software maintenance,scenario-based program comprehension;program user scenario;program owner scenario;textual software assets;JSEA tool;open source Java projects;semiautomatic program comprehension assistance;topic modeling,,,22,,,,,IEEE,IEEE Conferences
A Controlled Experiment for Program Comprehension through Trace Visualization,B. Cornelissen; A. Zaidman; A. van Deursen,"Software Improvement Group, Amsterdam; Delft University of Technology, Delft; Delft University of Technology, Delft",IEEE Transactions on Software Engineering,,2011,37,3,341,355,"Software maintenance activities require a sufficient level of understanding of the software at hand that unfortunately is not always readily available. Execution trace visualization is a common approach in gaining this understanding, and among our own efforts in this context is Extravis, a tool for the visualization of large traces. While many such tools have been evaluated through case studies, there have been no quantitative evaluations to the present day. This paper reports on the first controlled experiment to quantitatively measure the added value of trace visualization for program comprehension. We designed eight typical tasks aimed at gaining an understanding of a representative subject system, and measured how a control group (using the Eclipse IDE) and an experimental group (using both Eclipse and Extravis) performed these tasks in terms of time spent and solution correctness. The results are statistically significant in both regards, showing a 22 percent decrease in time requirements and a 43 percent increase in correctness for the group using trace visualization.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2010.47,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5441291,Program comprehension;dynamic analysis;controlled experiment.,Visualization;Computer Society;Time measurement;Programming;Documentation;Scalability;Software maintenance;Gain measurement;Control systems;Performance evaluation,data visualisation;software maintenance,program comprehension;software maintenance;execution trace visualization,,55,56,,,,,IEEE,IEEE Journals
Synchronized UML diagrams for object-oriented program comprehension,J. Yang; Y. Lee; D. Gandhi; S. G. Valli,"Dept. of Computing and Cyber Security, Texas A&M University-San Antonio, San Antonio, U.S.A.; Dept. of Electrical Engineering and Computer Science, Texas A&M University-Kingsville, Kingsville, U.S.A.; Dept. of Electrical Engineering and Computer Science, Texas A&M University-Kingsville, Kingsville, U.S.A.; Dept. of Electrical Engineering and Computer Science, Texas A&M University-Kingsville, Kingsville, U.S.A.",2017 12th International Conference on Computer Science and Education (ICCSE),,2017,,,12,17,"We propose a novel approach for visualizing reverse-engineered Unified Modeling Language (UML) diagrams (class, object, and sequence) to improve Object-Oriented Program (OOP) comprehension on a web-based programming environment, JaguarCode. It aims to help students better understand static structure and dynamic behavior of Java programs and object-oriented programming concepts. This paper presents an evaluation of JaguarCode, supporting those UML diagrams to investigate its effectiveness and user satisfaction. The results of the experimental study revealed having synchronized UML diagrams positively impacted students' understanding of program execution. It was also observed that students were satisfied with the aspects of the synchronized visualizations of UML diagrams with source code.",2473-9464,978-1-5090-2508-4978-1-5090-2507-7978-1-5090-2509,10.1109/ICCSE.2017.8085455,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8085455,Program Comprehension;Object-Oriented Programming;UML Diagrams;Reverse Engineering,Java;Unified modeling language;Synchronization;Data visualization;Visualization;Programming;Runtime,computer science education;Internet;Java;object-oriented programming;program diagnostics;program visualisation;reverse engineering;Unified Modeling Language,synchronized UML diagrams;Java programs;program execution;synchronized visualizations;object-oriented program comprehension;reverse-engineered Unified Modeling Language diagram visualization;OOP comprehension;Web-based programming environment;static structure;dynamic behavior;JaguarCode evaluation;user satisfaction;source code,,,19,,,,,IEEE,IEEE Conferences
Ontology-based Program Comprehension Tool Supporting Website Architectural Evolution,Y. Zhang; R. Witte; J. Rilling; V. Haarslev,"Concordia University, Montreal, Canada; Universitat Karlsruhe, Germany; Concordia University, Montreal, Canada; Concordia University, Montreal, Canada",2006 Eighth IEEE International Symposium on Web Site Evolution (WSE'06),,2006,,,41,49,"A challenge of existing program comprehension approaches is to provide consistent and flexible representations for software systems. Maintainers have to match their mental models with the different representations these tools provide. In this paper, we present a novel approach that addresses this issue by providing a consistent ontological representation for both source code and documentation. The ontological representation unifies information from various sources, and therefore reduces the maintainers' comprehension efforts. In addition, representing software artifacts in a formal ontology enables maintainers to formulate hypotheses about various properties of software systems. These hypotheses can be validated through an iterative exploration of information derived by our ontology inference engine. The implementation of our approach is presented in detail, and a case study is provided to demonstrate the applicability of our approach during the architectural evolution of a Web site content management system",1550-4441,0-7695-2696,10.1109/WSE.2006.15,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4027205,Program Comprehension;Software Evolution;Ontology;Automated Reasoning,Ontologies;Cognitive science;Software systems;Software maintenance;Documentation;Software tools;Content management;Computer science;Software engineering;Engines,inference mechanisms;Internet;ontologies (artificial intelligence);reverse engineering;software architecture;software prototyping;Web sites,ontology-based program comprehension;Web site architectural evolution;ontological representation;software artifacts;formal ontology;iterative exploration;ontology inference engine;Web site content management system;software evolution;automated reasoning,,2,23,,,,,IEEE,IEEE Conferences
Evaluating software clustering algorithms in the context of program comprehension,A. Mahmoud; Nan Niu,"Computer Science and Engineering, Mississippi State University, USA; Computer Science and Engineering, Mississippi State University, USA",2013 21st International Conference on Program Comprehension (ICPC),,2013,,,162,171,"We propose a novel approach for evaluating software clustering algorithms in the context of program comprehension. Based on the assumption that program comprehension is a task-driven activity, our approach utilizes interaction logs from previous maintenance sessions to automatically devise multiple comprehension-aware and task-sensitive decompositions of software systems. These decompositions are then used as authoritative figures to evaluate the effectiveness of various clustering algorithms. Our approach addresses several challenges associated with evaluating clustering algorithms externally using expert-driven authoritative decompositions. Such limitations include the subjectivity of human experts, the availability of such authoritative figures, and the decaying structure of software systems. We conduct an experimental analysis using two datasets, including an open-source system and a proprietary system, to test the applicability of our approach and validate our research claims.",1092-8138,978-1-4673-3092,10.1109/ICPC.2013.6613844,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613844,Program comprehension;maintenance;software clustering,Clustering algorithms;Software algorithms;Software systems;Algorithm design and analysis;Maintenance engineering;Partitioning algorithms,pattern clustering;software maintenance,software clustering algorithms;program comprehension;task-driven activity;interaction logs;software systems;task-sensitive decompositions;multiple comprehension-awareness;software maintenance;expert-driven authoritative decompositions;decaying structure;authoritative figures;open-source system;proprietary system,,3,57,,,,,IEEE,IEEE Conferences
Program Comprehension and Implications of Human Navigational Approaches,S. Moorthy; M. H. Samadzadeh,NA; NA,2011 21st International Conference on Systems Engineering,,2011,,,189,193,"Cognitive scientists, psychologists, and other researchers have endeavored over the past three decades to identify the cognitive functions underpinning human navigation and its possible correlations with other characteristics. The answer to the basic question of how/why some people are good at following directions and some people are not, is yet to be determined conclusively. The scope of this research work included both theoretical and empirical studies of human direction sensitivity and the cognitive tests that attempt to test hypotheses about individual differences in spatial/temporal attention spans as well as a set of program comprehension questionnaire-based tests about the debugging/testing of computer programs and program comprehension. This work was done in the context of the relevant cognitive-based perceptual and spatial tests. The test results obtained suggest that programmers' directional detection skills appear to have some correlations with their program comprehension abilities.",,978-1-4577-1078,10.1109/ICSEng.2011.41,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6041560,navigation;program comprehension;perceptual and spatial tests,Navigation;Visualization;Humans;Correlation;Educational institutions;Particle measurements;Atmospheric measurements,cognition;navigation;program debugging;program testing;psychology,program comprehension;human navigational approach;human cognitive function;human direction sensitivity;cognitive test;spatial-temporal attention span;computer program debugging;computer program testing;cognitive-based perceptual test;cognitive-based spatial test;programmer directional detection skills,,,17,,,,,IEEE,IEEE Conferences
A Comparison of Program Comprehension Strategies by Blind and Sighted Programmers,A. Armaly; P. Rodeghero; C. McMillan,"Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN",IEEE Transactions on Software Engineering,,2018,44,8,712,724,"Programmers who are blind use a screen reader to speak source code one word at a time, as though the code were text. This process of reading is in stark contrast to sighted programmers, who skim source code rapidly with their eyes. At present, it is not known whether the difference in these processes has effects on the program comprehension gained from reading code. These effects are important because they could reduce both the usefulness of accessibility tools and the generalizability of software engineering studies to persons with low vision. In this paper, we present an empirical study comparing the program comprehension of blind and sighted programmers. We found that both blind and sighted programmers prioritize reading method signatures over other areas of code. Both groups obtained an equal and high degree of comprehension, despite the different reading processes.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2017.2729548,National Science Foundation Graduate Research Fellowship Program; US National Science Foundation; ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7987041,Program comprehension;accessibility technology;blindness,Tools;Software;Blindness;Navigation;Programming profession;Software engineering,programming environments;public domain software;software prototyping;source code (software),source code;sighted programmers;program comprehension strategies;reading processes;stark;program comprehension;reading method signature,,1,46,,,,,IEEE,IEEE Journals
Normalizing source code vocabulary to support program comprehension and software quality,L. Guerrouj,"DGIGL - SOCCER Lab, Ptidej Team, Polytechnique Montr&#x00E9;al, Qu&#x00E9;bec, Canada",2013 35th International Conference on Software Engineering (ICSE),,2013,,,1385,1388,"The literature reports that source code lexicon plays a paramount role in program comprehension, especially when software documentation is scarce, outdated or simply not available. In source code, a significant proportion of vocabulary can be either acronyms and-or abbreviations or concatenation of terms that can not be identified using consistent mechanisms such as naming conventions. It is, therefore, essential to disambiguate concepts conveyed by identifiers to support program comprehension and reap the full benefit of Information Retrieval-based techniques (e.g., feature location and traceability) whose linguistic information (i.e., source code identifiers and comments) used across all software artifacts (e.g., requirements, design, change requests, tests, and source code) must be consistent. To this aim, we propose source code vocabulary normalization approaches that exploit contextual information to align the vocabulary found in the source code with that found in other software artifacts. We were inspired in the choice of context levels by prior works and by our findings. Normalization consists of two tasks: splitting and expansion of source code identifiers. We also investigate the effect of source code vocabulary normalization approaches on software maintenance tasks. Results of our evaluation show that our contextual-aware techniques are accurate and efficient in terms of computation time than state of the art alternatives. In addition, our findings reveal that feature location techniques can benefit from vocabulary normalization when no dynamic information is available.",0270-5257;1558-1225,978-1-4673-3076-3978-1-4673-3073,10.1109/ICSE.2013.6606723,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6606723,Source code linguistic analysis;information retrieval;program comprehension;software quality,Context;Vocabulary;Software quality;Software maintenance;Dictionaries,reverse engineering;software maintenance;software quality;system documentation;ubiquitous computing;vocabulary,software quality;source code lexicon;program comprehension;software documentation;information retrieval-based techniques;linguistic information;source code comments;software artifacts;source code vocabulary normalization approaches;contextual information;context levels;source code identifiers splitting;source code identifiers expansion;software maintenance tasks;contextual-aware techniques;feature location,,7,26,,,,,IEEE,IEEE Conferences
Supporting Program Comprehension in Agile with Links to User Stories,S. Ratanotayanon; S. E. Sim; R. Gallardo-Valencia,NA; NA; NA,2009 Agile Conference,,2009,,,26,32,"Agile software development involves continuously making iterative and incremental changes to source code. When making changes, developers quickly focus on parts of code that they consider to be important, and sometimes miss other relevant parts. Therefore, tool support is needed to help developers locate conceptually related sections of code. In this paper, we present Zelda, a tool designed to work with Agile practices that captures and maintains links between high-level information and source code. We evaluated Zelda with a pilot study where subjects were required to make a change to a small web application (10 KLOCs). They were given a task description either on paper or in Zelda. We found that the Zelda Group made more accurate changes, were less likely to become disoriented, and were more willing to access additional information.",,978-0-7695-3768,10.1109/AGILE.2009.66,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5261112,user stories;program comprehension;link evolution;traceability links,Testing;Informatics;Programming;Light scattering;Java;Visualization;Software architecture;Software tools;Cognitive science;Writing,software tools,program comprehension;user stories;agile software development;Zelda;Web application,,3,23,,,,,IEEE,IEEE Conferences
InputTracer: A Data-Flow Analysis Tool for Manual Program Comprehension of x86 Binaries,U. Kargén; N. Shahmehri,NA; NA,2012 IEEE 12th International Working Conference on Source Code Analysis and Manipulation,,2012,,,138,143,"Third-party security analysis of closed-source programs has become an important part of a defense-in-depth approach to software security for many companies. In the absence of efficient tools, the analysis has generally been performed through manual reverse engineering of the machine code. As reverse engineering is an extremely time-consuming and costly task, much research has been performed to develop more powerful methods for analysis of program binaries. One such popular method is dynamic taint analysis (DTA), which is a type of runtime data-flow analysis, where certain input data is marked as tainted. By tracking the flow of tainted data, DTA can, for instance, be used to determine which computations in a program are affected by a certain part of the input. In this paper we present Input Tracer, a tool that utilizes DTA for aiding in manual program comprehension and analysis of unmodified x86 executables running in Linux. A brief overview of dynamic taint analysis is given, followed by a description of the tool and its implementation. We also demonstrate the tool's ability to provide exact information on the origin of tainted data through a detailed use case, where the tool is used to find the root cause of a memory corruption bug.",,978-0-7695-4783-1978-1-4673-2398,10.1109/SCAM.2012.16,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6392112,dynamic taint analysis;binary analysis;x86;program comprehension;Valgrind,Computer crashes;Security;Manuals;Performance analysis;Runtime;Instruments;Software,data flow analysis;Linux;program compilers;reverse engineering;security of data,InputTracer;data flow analysis tool;manual program comprehension;x86 binaries;security analysis;closed source programs;software security;reverse engineering;machine code;dynamic taint analysis;DTA;program comprehension;program analysis;Linux;memory corruption bug,,,21,,,,,IEEE,IEEE Conferences
A Systematic Survey of Program Comprehension through Dynamic Analysis,B. Cornelissen; A. Zaidman; A. van Deursen; L. Moonen; R. Koschke,"Delft University of Technology, The Netherlands; Delft University of Technology, The Netherlands; Delft University of Technology, The Netherlands; Simula Research Laboratory, Norway; University of Bremen, Germany",IEEE Transactions on Software Engineering,,2009,35,5,684,702,"Program comprehension is an important activity in software maintenance, as software must be sufficiently understood before it can be properly modified. The study of a program's execution, known as dynamic analysis, has become a common technique in this respect and has received substantial attention from the research community, particularly over the last decade. These efforts have resulted in a large research body of which currently there exists no comprehensive overview. This paper reports on a systematic literature survey aimed at the identification and structuring of research on program comprehension through dynamic analysis. From a research body consisting of 4,795 articles published in 14 relevant venues between July 1999 and June 2008 and the references therein, we have systematically selected 176 articles and characterized them in terms of four main facets: activity, target, method, and evaluation. The resulting overview offers insight in what constitutes the main contributions of the field, supports the task of identifying gaps and opportunities, and has motivated our discussion of several important research directions that merit additional consideration in the near future.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2009.28,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4815280,Survey;program comprehension;dynamic analysis.,Computer Society;Software maintenance;Software systems;Documentation;Software engineering;Data analysis;Information analysis;Availability;Runtime;Virtual machining,reverse engineering;software maintenance;system monitoring,program comprehension;dynamic analysis;software maintenance;systematic literature survey,,179,154,,,,,IEEE,IEEE Journals
Program comprehension with four-layered mental model,M. Nosál'; J. Porubän,"Department of Computers and Informatics, Faculty of Electrical Engineering and Informatics, Technical University of Košice, Letná 9, 042 00, Slovakia; Department of Computers and Informatics, Faculty of Electrical Engineering and Informatics, Technical University of Košice, Letná 9, 042 00, Slovakia",2015 13th International Conference on Engineering of Modern Electric Systems (EMES),,2015,,,1,4,"Program comprehension deals with an important problem of recreating mental model of the software system from the source code. This process is needed every time a new programmer joins the development team, or the old one forgets about the code. We designed the four-layered model of the developer's mental model that provides a deeper understanding of the mental model and of the program comprehension in general. The described model was verified by an observatory study with 3 subjects. This paper concludes with our findings and conclusions.",,978-1-4799-7650-8978-1-4799-7649-2978-1-4799-7648,10.1109/EMES.2015.7158420,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7158420,Program comprehension;comprehension model;mental model;study,Cognitive science;Object oriented modeling;Computational modeling;Computers;Java;Software systems;Programming,reverse engineering;software engineering,program comprehension;four-layered mental model;software system mental model;source code;developer mental model,,3,10,,,,,IEEE,IEEE Conferences
Language-Independent Information Flow Tracking Engine for Program Comprehension Tools,M. R. Azadmanesh; M. L. Van De Vanter; M. Hauswirth,NA; NA; NA,2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC),,2017,,,346,355,"Program comprehension tools are often developed for a specific programming language. Developing such a tool from scratch requires significant effort. In this paper, we report on our experience developing a language-independent framework that enables the creation of program comprehension tools, specifically tools gathering insight from deep dynamic analysis, with little effort. Our framework is language independent, because it is built on top of Truffle, an open-source platform, developed in Oracle Labs, for implementing dynamic languages in the form of AST interpreters. Our framework supports the creation of a diverse variety of program comprehension techniques, such as query, program slicing, and back-in-time debugging, because it is centered around a powerful information-flow tracking engine. Tools developed with our framework get access to the information-flow through a program execution. While it is possible to develop similarly powerful tools without our framework, for example by tracking information-flow through bytecode instrumentation, our approach leads to information that is closer to source code constructs, thus more comprehensible by the user. To demonstrate the effectiveness of our framework, we applied it to two of Truffle-based languages namely Simple Language and TruffleRuby, and we distill our experience into guidelines for developers of other Truffle-based languages who want to develop program comprehension tools for their language.",,978-1-5386-0535-6978-1-5386-0536,10.1109/ICPC.2017.5,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961535,Information flow;AST interpreter;Language-independent;Program comprehension;Tool;Dependency,Tools;Java;Runtime;Instruments;Program processors;Debugging;Libraries,program diagnostics;programming languages,language-independent information flow tracking engine;program comprehension tool;programming language;language-independent framework;deep dynamic analysis;Truffle open-source platform;Oracle Labs;AST interpreters;program execution;bytecode instrumentation;simple language;TruffleRuby,,,25,,,,,IEEE,IEEE Conferences
A Novel Approach Based on Gestalt Psychology for Abstracting the Content of Large Execution Traces for Program Comprehension,H. Pirzadeh; A. Hamou-Lhadj,NA; NA,2011 16th IEEE International Conference on Engineering of Complex Computer Systems,,2011,,,221,230,"The analysis of execution traces can reveal important information about the behavioral aspects of complex software systems, hence reducing the time and effort it takes to understand and maintain them. Traces, however, tend to be considerably large which hinders their effective analysis. Existing traces analysis tools rely on some sort of visualization techniques to help software engineers make sense of trace content. Many of these techniques have been studied and found to be limited in many ways. In this paper, we present a novel trace analysis technique that automatically divides the content of a large trace into meaningful segments that correspond to the program's main execution phases such as initializing variables, performing a specific computation, etc. These phases can simplify significantly the exploration of large traces by allowing software engineers to first understand the content of a trace at a high-level before they decide to dig into the details. Our phase detection method is inspired by Gestalt laws that characterize the proximity, similarity, and continuity of the elements of a data space. We model these concepts in the context of execution traces and show how they can be used as gravitational forces that yield the formation of dense groups of trace elements, which indicate candidate phases. We applied our approach to two software systems. The results are very promising.",,978-0-7695-4381-9978-1-61284-853,10.1109/ICECCS.2011.29,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5773396,Trace Analysis;Program Comprehension;Software Maintenance;Software Engineering,Gravity;Phase detection;Software;Complexity theory;Visualization;Context;Psychology,data visualisation;program diagnostics;psychology;reverse engineering;software maintenance,Gestalt psychology;large execution trace content analysis;program comprehension;complex software system;visualization technique;software engineers;phase detection method;software maintenance,,13,29,,,,,IEEE,IEEE Conferences
Analyzing Code Comments to Boost Program Comprehension,Y. Shinyama; Y. Arahori; K. Gondow,NA; NA; NA,2018 25th Asia-Pacific Software Engineering Conference (APSEC),,2018,,,325,334,"We are trying to find source code comments that help programmers understand a nontrivial part of source code. One of such examples would be explaining to assign a zero as a way to ""clear"" a buffer. Such comments are invaluable to programmers and identifying them correctly would be of great help. Toward this goal, we developed a method to discover explanatory code comments in a source code. We first propose 12 distinct categories of code comments. We then developed a decision-tree based classifier that can identify explanatory comments with 60% precision and 80% recall. We analyzed 2,000 GitHub projects that are written in two languages: Java and Python. This task is novel in that it focuses on a microscopic comment (""local comment"") within a method or function, in contrast to the prior efforts that focused on API- or method-level comments. We also investigated how different category of comments is used in different projects. Our key finding is that there are two dominant types of comments: preconditional and postconditional. Our findings also suggest that many English code comments have a certain grammatical structure that are consistent across different projects.",2640-0715;1530-1362,978-1-7281-1970-0978-1-7281-1971,10.1109/APSEC.2018.00047,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8719486,Program Comprehension;Source code comments;Natural language processing;decision tree;java;python;github,Syntactics;Java;Python;Natural languages;Semantics,application program interfaces;decision trees;Java;pattern classification;Python;software maintenance;source code (software),GitHub projects;code comments analysis;Java;Python;API;English code comments;method-level comments;microscopic comment;decision-tree based classifier;explanatory code comments;source code comments;boost program comprehension,,,26,,,,,IEEE,IEEE Conferences
Developing Application Specific Ontology for Program Comprehension by Combining Domain Ontology with Code Ontology,H. Zhou; F. Chen; H. Yang,NA; NA; NA,2008 The Eighth International Conference on Quality Software,,2008,,,225,234,"This paper proposes a novel approach to generating an ontological perspective for software system. This ontology is a combination of two other ontologies: domain ontology and class diagram ontology. Domain ontology is domain vocabulary which is built by domain experts, while class diagram ontology is automatically populated from source code to represent the knowledge in the code. Combining these two ontologies will generate a third ontology which is used in program comprehension. Firstly, the motivation and related work are introduced. Secondly, method of class diagram to ontology transformation and algorithm of ontology combination are presented. Thirdly, program comprehension from an ontological point of view is discussed. Fourthly, a case study is demonstrated by understanding a point of sale terminal (POST) system. Finally, the conclusion is drawn and further research directions are speculated.",1550-6002;2332-662X,978-0-7695-3312,10.1109/QSIC.2008.31,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4601548,Ontology;Program Comprehension;Class Diagram;Domain knowledge;Concepts;Relations,Ontologies;Software;Software systems;Knowledge representation;Software engineering;Object oriented modeling;Security,ontologies (artificial intelligence);point of sale systems;reverse engineering,application specific ontology;program comprehension;domain ontology;code ontology;software system;class diagram ontology;domain vocabulary;point of sale terminal system,,13,23,,,,,IEEE,IEEE Conferences
Comparing Trace Visualizations for Program Comprehension through Controlled Experiments,F. Fittkau; S. Finke; W. Hasselbring; J. Waller,NA; NA; NA; NA,2015 IEEE 23rd International Conference on Program Comprehension,,2015,,,266,276,"For efficient and effective program comprehension, it is essential to provide software engineers with appropriate visualizations of the program's execution traces. Empirical studies, such as controlled experiments, are required to assess the effectiveness and efficiency of proposed visualization techniques. We present controlled experiments to compare the trace visualization tools Extravis and Explor Viz in typical program comprehension tasks. We replicate the first controlled experiment with a second one targeting a differently sized software system. In addition to a thorough analysis of the strategies chosen by the participants, we report on common challenges comparing trace visualization techniques. Besides our own replication of the first experiment, we provide a package containing all our experimental data to facilitate the verifiability, reproducibility and further extensibility of our presented results. Although subjects spent similar time on program comprehension tasks with both tools for a small-sized system, analyzing a larger software system resulted in a significant efficiency advantage of 28 percent less time spent by using Explor Viz. Concerning the effectiveness (correct solutions for program comprehension tasks), we observed a significant improvement of correctness for both object system sizes of 39 and 61 percent with Explor Viz.",1092-8138,978-1-4673-8159-8978-1-4673-8158,10.1109/ICPC.2015.37,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181455,Software Visualization;Controlled Experiment;Trace Visualization;Program Comprehension,Visualization;Context;Cities and towns;Color;Software systems;Data visualization,data visualisation;software engineering,trace visualizations;program comprehension;controlled experiments;software engineers;program execution traces;visualization techniques;trace visualization tools;small sized system,,5,46,,,,,IEEE,IEEE Conferences
Program Comprehension for User-Assisted Test Oracle Generation,T. Kanstren,NA,2009 Fourth International Conference on Software Engineering Advances,,2009,,,118,127,"Software testing requires a test oracle that makes an assessment of the correctness of the tested program behaviour, based on a priori created model. While test automation is a popular research topic, there is only a limited amount of work in the subject of automating the process of creating test oracles. This lack of test oracle automation greatly limits the usefulness of automated testing techniques. One reason for this is the difficulty to automatically determine the correctness of previously unknown software. Instead the task of coming up with a useful oracle is often left to the user as a manual task. Program comprehension techniques are focused on supporting the building of human understanding for a previously un-known program, and as such are good candidates to assist in the test oracle creation process. This paper addresses the lack of automated support for test oracle creation by providing a framework for using program comprehension techniques to provide automated assistance to the user in creating test oracles. Based on analysis of existing work and theoretical background, the basic concept for this process is defined. A case example demonstrates the practical application of this concept with the generation of a model, including a test oracle, for model-based testing. From the existing approaches and the presented case example, a framework for this type of process is presented in order to provide a basis for providing more powerful techniques for user-assisted test oracle generation.",,978-1-4244-4779-4978-0-7695-3777,10.1109/ICSEA.2009.26,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5298488,test oracle;program comprehension;test automation,Automatic testing;Software testing;System testing;Humans;Software engineering;Electronic mail;Power generation;Design automation;Software tools;Costs,automatic test software;program testing,user-assisted test oracle generation;software testing;automated testing techniques;program comprehension techniques;model-based testing,,1,29,,,,,IEEE,IEEE Conferences
A case study of program comprehension effort and technical debt estimations,V. Singh; L. L. Pollock; W. Snipes; N. A. Kraft,"University of Delaware, Newark, USA; University of Delaware, Newark, USA; ABB Corporate Research, Raleigh, NC, USA; ABB Corporate Research, Raleigh, NC, USA",2016 IEEE 24th International Conference on Program Comprehension (ICPC),,2016,,,1,9,"This paper describes a case study of using developer activity logs as indicators of a program comprehension effort by analyzing temporal sequences of developer actions (e.g., navigation and edit actions). We analyze developer activity data spanning 109,065 events and 69 hours of work on a medium-sized industrial application. We examine potential correlations between different measures of developer activity, code change metrics and code smells to gain insight into questions that could direct future technical debt interest estimation. To gain more insights into the data, we follow our analysis with commit message analysis and a developer interview. Our results indicate that developer activity as an estimate of program comprehension effort is correlated with both change proneness and static metrics for code smells.",,978-1-5090-1428,10.1109/ICPC.2016.7503710,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7503710,program comprehension effort;technical debt interest;developer activity logging;code smells,Measurement;Couplings;Navigation;Software;Maintenance engineering;Correlation;History,program diagnostics;software metrics;source code (software),developer activity logs;program comprehension effort;temporal sequence analysis;developer activity data analysis;medium-sized industrial application;code change metrics;code smells;technical debt interest estimation;commit message analysis;change proneness;static metrics,,2,24,,,,,IEEE,IEEE Conferences
The impact of tools supported in integrated-development environments on program comprehension,T. Kosar; M. Mernik; J. C. Carver,"University of Maribor, Faculty of Electrical Engineering and Computer Science, Smetanova ulica 17, 2000, Slovenia; University of Maribor, Faculty of Electrical Engineering and Computer Science, Smetanova ulica 17, 2000, Slovenia; Department of Computer Science, University of Alabama, Tuscaloosa, USA","Proceedings of the ITI 2011, 33rd International Conference on Information Technology Interfaces",,2011,,,603,608,"Program comprehension is a cognitive task done by a software programmer. Task is usually done manually, but in some cases tool support inside integrated development environment can facilitate the hard work. In order to test those tools, a study between manual program comprehension and program comprehension with tool support is presented in this paper. An empirical study that faces the alternatives has been done. In experiment, the same test has been used twice (with and without tools) and results have been compared and statistically analyzed in terms of test correctness and efficiency. The results regarding program comprehension with students confirm significant benefits in terms of correctness when using tools for program comprehension.",1330-1012,978-1-61284-897-6978-953-7138-21,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5974091,program comprehension tools;integrated-development environments;controlled experiments,Manuals;Programming;Visualization;Atmospheric measurements;Software;Particle measurements,human factors;reverse engineering;software engineering,integrated-development environments;program comprehension tools;cognitive task,,,11,,,,,IEEE,IEEE Conferences
Program comprehension levels of abstraction for novices,A. Shargabi; S. A. Aljunid; M. Annamalai; S. Mohamed Shuhidan; A. Mohd Zin,"Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam 40450, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam 40450, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam 40450, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam 40450, Malaysia; Faculty of Information Science and Technology, Universiti Kebangsaan Malaysia, Bangi 43600, Malaysia","2015 International Conference on Computer, Communications, and Control Technology (I4CT)",,2015,,,211,215,"Although various program comprehension models exist, their levels of abstraction and the related terminologies do not fit the programming pedagogy perspective. In this study, we proposed five abstraction levels for novice's program comprehension: statement, block, module, program and domain. The expansion and the terminologies of the proposed abstraction levels are inspired by the application of decomposition concept in programming pedagogy. To comprehend a program, novices understand decomposed parts (i.e. statements, blocks, and modules) of that program and chunk those parts into a meaningful whole (i.e. program) within a specific domain. We supported our revised abstraction levels with a user study. The revised abstraction levels are able to describe hierarchical levels of novices' program comprehension that map appropriately with their mental model. The proposed abstraction levels can be applied in designing empirical studies of novices' program comprehension that distinctly capture their different abstraction levels.",,978-1-4799-7952-3978-1-4799-7951,10.1109/I4CT.2015.7219568,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7219568,program comprehension;mental model;abstraction level;novices;programming pedagogy,Error analysis;Adaptation models;Context;Education;Data models;Programming profession,computer science education;object-oriented methods,program comprehension levels;novice abstraction;program comprehension models;programming pedagogy perspective;novice program comprehension;decomposition concept,,1,16,,,,,IEEE,IEEE Conferences
"An Empirical Study of the Impact of Two Antipatterns, Blob and Spaghetti Code, on Program Comprehension",M. Abbes; F. Khomh; Y. Gueheneuc; G. Antoniol,NA; NA; NA; NA,2011 15th European Conference on Software Maintenance and Reengineering,,2011,,,181,190,"Antipatterns are ""poor"" solutions to recurring design problems which are conjectured in the literature to make object-oriented systems harder to maintain. However, little quantitative evidence exists to support this conjecture. We performed an empirical study to investigate whether the occurrence of antipatterns does indeed affect the understandability of systems by developers during comprehension and maintenance tasks. We designed and conducted three experiments, with 24 subjects each, to collect data on the performance of developers on basic tasks related to program comprehension and assessed the impact of two antipatterns and of their combinations: Blob and Spaghetti Code. We measured the developers' performance with: (1) the NASA task load index for their effort, (2) the time that they spent performing their tasks, and, (3) their percentages of correct answers. Collected data show that the occurrence of one antipattern does not significantly decrease developers' performance while the combination of two antipatterns impedes significantly developers. We conclude that developers can cope with one antipattern but that combinations of antipatterns should be avoided possibly through detection and refactorings.",1534-5351;1534-5351,978-1-61284-259-2978-0-7695-4343,10.1109/CSMR.2011.24,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5741260,Antipatterns;Blob;Spaghetti Code;Program Comprehension;Program Maintenance;Empirical Software Engineering,Maintenance engineering;Programming;Analysis of variance;Java;Indexes;NASA;Time measurement,object-oriented programming;software maintenance,antipatterns;blob;spaghetti code;program comprehension;recurring design problems;object-oriented systems;maintenance tasks;NASA task load index,,94,37,,,,,IEEE,IEEE Conferences
Using cognitive easiness metric for program comprehension,M. Yin; B. Li; C. Tao,"School of Computer Science and Engineering, Southeast University Nanjing, China; School of Computer Science and Engineering, Southeast University Nanjing, China; School of Computer Science and Engineering, Southeast University Nanjing, China",The 2nd International Conference on Software Engineering and Data Mining,,2010,,,134,139,"Program comprehension is one of the most critical phases in software maintenance. During program designing, the codes having related function and behavior are often scattered in different parts of program, which increases the difficulty of understanding program, and further obfuscates programmers. In this paper, we propose an approach to assisting comprehension process using cognitive easiness metric, which can predicate the easiness degree of a method to understand in various comprehension phases. The approach uses coarse-grained call graph slicing technique and intra-procedural coarse-grained slicing technique to compute the cognitive easiness of non-understood methods based on those understood methods in the program. It can not only guide programmers to investigate the non-understood codes in the program from the easier parts to the harder parts, but also support different guidance for different programmers. Finally, we evaluate the effectiveness and practicability of our approach by applying to a case study.",,978-89-88678-22-0978-1-4244-7324,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5542938,Cognitive Easiness Metric;Program Comprehension;Program Slicing;Call Graph Slice,Programming profession;Software maintenance;Software systems;Large-scale systems;Data mining;Computer science;Scattering;Aging;Humans;Research and development,program slicing;software maintenance;software metrics,cognitive easiness metric;program comprehension;software maintenance;assisting comprehension process;coarse grained call graph slicing technique;intraprocedural coarse grained slicing technique,,,21,,,,,IEEE,IEEE Conferences
Exploring Software Measures to Assess Program Comprehension,J. Feigenspan; S. Apel; J. Liebig; C. Kastner,NA; NA; NA; NA,2011 International Symposium on Empirical Software Engineering and Measurement,,2011,,,127,136,"Software measures are often used to assess program comprehension, although their applicability is discussed controversially. Often, their application is based on plausibility arguments, which, however, is not sufficient to decide whether software measures are good predictors for program comprehension. Our goal is to evaluate whether and how software measures and program comprehension correlate. To this end, we carefully designed an experiment. We used four different measures that are often used to judge the quality of source code: complexity, lines of code, concern attributes, and concern operations. We measured how subjects understood two comparable software systems that differ in their implementation, such that one implementation promised considerable benefits in terms of better software measures. We did not observe a difference in program comprehension of our subjects as the software measures suggested it. To explore how software measures and program comprehension could correlate, we used several variants of computing the software measures. This brought them closer to our observed result, however, not as close as to confirm a relationship between software measures and program comprehension. Having failed to establish a relationship, we present our findings as an open issue to the community and initiate a discussion on the role of software measures as comprehensibility predictors.",1949-3789;1949-3770;1938-6451,978-1-4577-2203-5978-0-7695-4604,10.1109/ESEM.2011.21,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6092561,Software measures;Program comprehension,Software measurement;Software;Java;Programming;Complexity theory;Size measurement;Time factors,software quality,software measurement;program comprehension assess;program comprehension;plausibility arguments;source code quality;code line;concern attributes;concern operations;software systems,,10,40,,,,,IEEE,IEEE Conferences
The effectiveness of Zoom Visual Flow (ZViF) technique in program comprehension activities,R. Kadar; S. Sulaiman,"Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Penang, Malaysia; School of Computer Sciences, Universiti Sains Malaysia, Penang, Malaysia",2010 International Symposium on Information Technology,,2010,1,,1,6,"Many techniques and tools have been developed to improve program comprehension but most tools are unsuitable for novices. Some tools are not user friendly, some designs are more suitable to expert programmers and some integrated development environments (IDEs) are very simple and fail to support program comprehension needs among the users. These factors hinder the learning process and may become obstacles to users who have no programming background. This paper attempts to improve program comprehension by using Zoom Visual Flow (ZViF) technique that represents source code in graphical views. It also gives some insights on how to improve visual presentation method in a program editor or an IDE. A lab experiment was conducted to determine the effectiveness of the technique. The respondents were asked to determine their preference between ZViF technique and Control Structured Diagram (CSD). CSD is one of the best techniques that uses graphic to visualize a program. The result shows that users prefer the proposed technique compared to CSD as the ZViF helps to improve program comprehension among novices.",2155-899X;2155-8973;2155-897,978-1-4244-6718-1978-1-4244-6715-0978-1-4244-6717,10.1109/ITSIM.2010.5561292,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5561292,program comprehension;program visualization;integrated development environment,Visualization;Color;Shape;Software;Programming;Switches;Computer languages,data visualisation;program visualisation,zoom visual flow technique;program comprehension activity;integrated development environments;learning process;source code;program editor;lab experiment;ZViF technique;control structured diagram;program visualization;visual presentation method;computer graphics,,,14,,,,,IEEE,IEEE Conferences
Tasks that can improve novices' program comprehension,A. Shargabi; S. A. Aljunid; M. Annamalai; S. M. Shuhidan; A. M. Zin,"Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Information Science and Technology, Universiti Kebangsaan Malaysia, Bangi, Malaysia","2015 IEEE Conference on e-Learning, e-Management and e-Services (IC3e)",,2015,,,32,37,"This study aims at identifying tasks that can effectively promote novices' program comprehension. Based on literature of program comprehension and computer science education, we identified 14 tasks and classified them into homogeneous categories based on the Revised Bloom Taxonomy. We conducted a survey to rank these tasks within each Bloom category based on their potential effectiveness in developing the novices' program comprehension. The survey respondents were 154 programming and software engineering instructors from 13 universities. The results of the survey indicated that: a) for the remember category, recall received higher ranking than line documentation; b) for the understand category, representation received higher ranking than summarization; c) for the analyze category, the tasks ordered from the highest to the lowest rank are: tracing, debugging, search and reordering; d) for the create category, the tasks ordered from the highest to the lowest rank are: modification, extension, reuse and restructuring. The apply and evaluate categories contain one task each; and thus were not ranked. The outcomes indicated that tasks that were more commonly applied in teaching were received higher rankings. For example, tracing and representation received higher ranking as compared to other less common teaching tasks such as summarization and searching respectively. The findings of this study recommend that program comprehension skills can be improved through exercises on the different types of tasks identified in this survey. The next step is to conduct experiments of these novices in universities to validate the results of the conducted survey.",,978-1-4673-9437-6978-1-4673-9436,10.1109/IC3e.2015.7403482,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7403482,program comprehension;task;novices;Revised Bloom taxonomy,Taxonomy;Documentation;Debugging;Programming;Conferences;Electronic learning,computer science education;software engineering,novices program comprehension;program comprehension;computer science education;revised bloom taxonomy;software engineering instructors;remember category;line category;understand category;tracing;debugging;search;reordering;modification;extension;reuse;restructuring,,3,36,,,,,IEEE,IEEE Conferences
Automatic Hierarchical Clustering of Static Call Graphs for Program Comprehension,G. Gharibi; R. Alanazi; Y. Lee,"School of Computing and Enigeering, University of Missouri-Kansas City, Kansas City, USA; School of Computing and Enigeering, University of Missouri-Kansas City, Kansas City, USA; School of Computing and Enigeering, University of Missouri-Kansas City, Kansas City, USA",2018 IEEE International Conference on Big Data (Big Data),,2018,,,4016,4025,"Program comprehension is an imperative and indispensable prerequisite for several software tasks, including testing, maintenance, and evolution. In practice, understanding the software system requires investigating the high-level system functionality and mapping it to its low-level implementation, i. e. source code. The implementation of a software system can be captured using a call graph. A call graph represents the system's functions and their interactions at a single level of granularity. While call graphs can facilitate understanding the inner system functionality, developers are still required to manually map the high-level system functionality to its call graph. This manual mapping process is expensive, time-consuming and creates a cognitive gap between the system's highly-level functionality and its implementation. In this paper, we present an innovative approach that can automatically (1) construct and visualize the static call graph for a system written in Python, (2) cluster the execution paths of the call graph into hierarchal abstractions, and (3) label the clusters according to their major functional behaviors. The goal is to bridge the cognitive gap between the high-level system functionality and its call graph, which can further facilitate system comprehension. To validate our approach, we conducted four case studies including code2graph, Detectron, Flask, and Keras. The results demonstrated that our approach is feasible to construct call graphs and hierarchically cluster them into abstraction levels with proper labels.",,978-1-5386-5035-6978-1-5386-5034-9978-1-5386-5036,10.1109/BigData.2018.8622426,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8622426,static call graph;static analysis;clustering;topic modeling;program comprehension;Python,Tools;Python;Software systems;Task analysis;Visualization;Maintenance engineering,medical computing;pattern clustering;software maintenance,automatic hierarchical clustering;static call graph;program comprehension;software system;high-level system functionality;low-level implementation;call graphs;inner system functionality;system comprehension;code2graph,,,41,,,,,IEEE,IEEE Conferences
Two User Perspectives in Program Comprehension: End Users and Developer Users,T. Roehm,NA,2015 IEEE 23rd International Conference on Program Comprehension,,2015,,,129,139,"Recent empirical studies identified an interest of software developers in high-level usage information, i.e. Why and how end users employ a software application. Furthermore, recent empirical work found that developers of interactive applications put themselves in the role of users by interacting with the user interface during program comprehension. This paper presents an exploratory case study investigating these two user perspectives in detail. The study focuses on information needs regarding software usage and developers in the role of users during program comprehension. 21 developers from six software companies were observed during program comprehension tasks and interviewed. The resulting observation protocols and interview minutes were analyzed using coding. We found that developers are interested in information about use cases and user behavior, user goals and user needs, failure reproduction steps, and application domain concepts. But such information is rarely available to them during program comprehension. This mismatch indicates a potential to improve program comprehension practices by capturing such information and providing it to developers. Furthermore, we found that developers interact with the user interface of an interactive application to reproduce failures, to find relevant source code, to test changes, to trigger the debugger, and to familiarize with an unknown part of the application. Also, developers conceptually map elements of the user interface to source code, data structures, and algorithms. We call this behavior ""UI-based comprehension"" and argue that it is part of a broader comprehension strategy together with comprehension activities like reading source code or debugging.",1092-8138,978-1-4673-8159-8978-1-4673-8158,10.1109/ICPC.2015.22,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181440,program comprehension;information needs;software usage;comprehension strategy;user interface (UI) comprehension;empirical study;case study;software maintenance;software evolution,Software;Interviews;Companies;User interfaces;Protocols;Observers;Java,data structures;program debugging;software engineering;source code (software);user interfaces,program comprehension;end users;developer users;software developers;user interface;coding;source code;data structures;debugging,,2,29,,,,,IEEE,IEEE Conferences
Integrative Levels of Program Comprehension,R. Schauer; R. K. Keller,NA; NA,2008 15th Working Conference on Reverse Engineering,,2008,,,145,154,"Integrative levels of program comprehension describe the evolution of our knowledge about a program from low-level program elements through successive and higher orders of knowledge integration. In this paper, we motivate, define, and illustrate integrative levels as a technique to organize the knowledge that we acquire in the course of program maintenance. We differentiate between understanding in extension and understanding in intension. We define five intensional integrative levels of program comprehension, the element level, the percept level, the concept level, the subject level, and the domain level. The intensional units that make up these levels emerge and evolve in an iterative comprehension process that is active at each level. The iterations of this process comprise the four phases of lower level unit organization, unit integration, upper level unit organization, and unit validation. We demonstrate integrative levels of program comprehension using the object-oriented testing framework jUnit as a case study.",1095-1350;2375-5369,978-0-7695-3429,10.1109/WCRE.2008.57,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656404,Intensional Program Comprehension;Integrative Levels,Organizations;Maintenance engineering;Psychology;Humans;Aggregates;Assembly;Graphics,knowledge acquisition;software engineering,program comprehension;integrative levels;knowledge integration;iterative comprehension process;object-oriented testing framework,,4,19,,,,,IEEE,IEEE Conferences
A Comment Analysis Approach for Program Comprehension,J. L. Freitas; D. da Cruz; P. R. Henriques,NA; NA; NA,2012 35th Annual IEEE Software Engineering Workshop,,2012,,,11,20,"Comments are interspersed by the Programmer among code lines, at software development phase, with two main purposes: to help himself during the development phase; to help other programmers later on, during the maintenance phase. The former are memos to help him remembering to do something; they are not useful for those willing to understand code. The latter are explanations about the ideas he has in mind when he wrote the code; they can be a relevant aid for others and should be taken into consideration as a first step in program comprehension. Comments are scattered all over the source code, sometimes wrapping a block of code (placed at the beginning or at its end), other times complementing a single statement. If comments are inserted to help in understanding the programmer ideas, they will contain for sure concepts associated with problem domain In this paper we discuss an approach to locate a relevant code chunk (one where the programmer should focus the attention for software maintenance), using information retrieval techniques to locate problem domain concepts within comments. In our approach, comments are isolated marking their type (inline, block or javadoc comment) and keeping their context (code lines to which they are associated). Picking up concepts from the ontology that describes the problem, it is possible to find all the comments that contain that concept (similar words) and rate them. Reading comments from the retrieved list, the programmer can select those that seem to him meaningful and dive directly into the associated chunk. In the paper, we also survey Comment Analysis techniques and describe an environment, Darius, that aims at automatizing the approach proposed. Moreover, Darius provides functionality to study comments frequency in the source files of a given project, to support the discussion weather it is worthwhile or not to apply this program comprehension step.",1550-6215;1550-6215,978-1-4673-5574-2978-0-7695-4947,10.1109/SEW.2012.8,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6479798,program comprehension;comment analysis;concept location;problem domain;program domain,Portable document format;Semantics;Standards;Software maintenance;Natural languages;Data mining,information retrieval;ontologies (artificial intelligence);software maintenance,comment analysis approach;software development phase;code lines;source code;code chunk;software maintenance;information retrieval techniques;problem domain concepts;block comment;javadoc comment;inline comment;ontology;Darius;source files;discussion weather;program comprehension step,,1,34,,,,,IEEE,IEEE Conferences
Finding the right needles in hay helping program comprehension of large software systems,I. Şora,"Department of Computer and Software Engineering, University Politehnica of Timisoara, Romania",2015 International Conference on Evaluation of Novel Approaches to Software Engineering (ENASE),,2015,,,129,140,"Maintenance of complex software systems can be done by software engineers only after they understand well the existing code. Program comprehension is supported by documentation - either developer documentation or reverse engineered. What is most often missing is a short document providing the new user with useful information to start with - an executive summary. In this work we propose a tool to automatically extract such a summary, by identifying the most important classes of a system. Our approach relies on techniques of static analysis of dependencies and graph-based ranking. Experiments on a set of real systems show good results.",,978-989-758-143,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7320345,Reverse Engineering;Program Comprehension;Recommender System;Key Classes,Software systems;Documentation;Software algorithms;Libraries;Software engineering;Reverse engineering,graph theory;reverse engineering;software maintenance,helping program comprehension;large-software systems;complex software system maintenance;static dependency analysis;graph-based ranking,,,17,,,,,IEEE,IEEE Conferences
An Approach for Detecting Execution Phases of a System for the Purpose of Program Comprehension,H. Pirzadeh; A. Agarwal; A. Hamou-Lhadj,NA; NA; NA,"2010 Eighth ACIS International Conference on Software Engineering Research, Management and Applications",,2010,,,207,214,"Understanding the behavioural aspects of a software system is an important activity in many software engineering activities including program comprehension and reverse engineering. The behaviour of software is typically represented in the form of execution traces. Traces, however, tend to be considerably large which makes analyzing their content a complex task. There is a need for trace simplification techniques that can help software engineers make sense of the content of a trace despite the trace being massive. In this paper, we present a novel algorithm that aims to simplify the analysis of a large trace by detecting the execution phases that compose it. An example of a phase could be an initialization phase, a specific computation, etc. Our algorithm processes a trace generated from running the program under study and divides it into phases that can be later used by software engineers to understand where and why a particular computation appears. We also show the effectiveness of our approach through a case study.",,978-1-4244-7337-3978-1-4244-7336-6978-0-7695-4075,10.1109/SERA.2010.34,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5489832,Program comprehension;dynamic analysis;trace analysis;trace phase detection,Phase detection;Software maintenance;Software engineering;Reverse engineering;Algorithm design and analysis;Software algorithms;Runtime;Information analysis;Conference management;Engineering management,program diagnostics;reverse engineering;software engineering,execution phases detection;program comprehension;behavioural aspects;software engineering activities;reverse engineering;execution traces;trace simplification techniques,,15,14,,,,,IEEE,IEEE Conferences
Applying Webmining techniques to execution traces to support the program comprehension process,A. Zaidman; T. Calders; S. Demeyer; J. Paredaens,"Dept. of Math. & Comput. Sci., Antwerp Univ., Belgium; Dept. of Math. & Comput. Sci., Antwerp Univ., Belgium; Dept. of Math. & Comput. Sci., Antwerp Univ., Belgium; Dept. of Math. & Comput. Sci., Antwerp Univ., Belgium",Ninth European Conference on Software Maintenance and Reengineering,,2005,,,134,142,"Well-designed object-oriented programs typically consist of a few key classes that work tightly together to provide the bulk of the functionality. As such, these key classes are excellent starting points for the program comprehension process. We propose a technique that uses Webmining principles on execution traces to discover these important and tightly interacting classes. Based on two medium-scale case studies - Apache Ant and Jakarta JMeter - and detailed architectural information from its developers, we show that our heuristic does in fact find a sizeable number of the classes deemed important by the developers.",1534-5351,0-7695-2304,10.1109/CSMR.2005.12,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1402122,Reverse engineering;dynamic analysis;web-mining;program comprehension,Object oriented modeling;Programming profession;Reverse engineering;Software performance;Cognitive science;Software maintenance;Cognition;Application software;Object oriented databases;Mathematical model,reverse engineering;object-oriented programming;Internet;data mining;software maintenance;program diagnostics,Webmining techniques;program comprehension process;object-oriented program;execution traces;reverse engineering;dynamic analysis,,30,29,,,,,IEEE,IEEE Conferences
Structure transition graphs: An ECG for program comprehension?,S. E. Sim; S. Ratanotayanon; L. Cotran,"Dept. of Informatics, University of California, Irvine, USA; Dept. of Informatics, University of California, Irvine, USA; Dept. of Informatics, University of California, Irvine, USA",2009 IEEE 17th International Conference on Program Comprehension,,2009,,,303,304,"This paper presents an idea of using a structure traversal graph (STG) to characterize whether program comprehension is progressing smoothly. Inspired by electrocardiograms that are used to measure heart rhythms, STGs are an attempt to depict the rhythm of program navigation. STGs are created by abstracting navigation between files to the level of a conceptual architecture graph. We analyzed the navigation patterns of fifteen developers performing a modification task in the laboratory and found that the STG was a good organizing principle for program comprehension behavior.",1092-8138,978-1-4244-3998-0978-1-4244-3997,10.1109/ICPC.2009.5090069,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090069,,Electrocardiography;Navigation;Heart;Rhythm;Informatics;Organizing;Java;XML;Computer languages;Service oriented architecture,electrocardiography;graph theory;medical computing,structure transition graphs;program comprehension behavior;electrocardiograms;heart rhythms;program navigation;conceptual architecture graph,,1,2,,,,,IEEE,IEEE Conferences
Improving program comprehension by enhancing program constructs: An analysis of the Umple language,A. Forward; T. C. Lethbridge; D. Brestovansky,"School of Information Technology and Engineering (SITE), University of Ottawa, Canada; School of Information Technology and Engineering (SITE), University of Ottawa, Canada; School of Information Technology and Engineering (SITE), University of Ottawa, Canada",2009 IEEE 17th International Conference on Program Comprehension,,2009,,,311,312,"Umple is a set of extensions to object-oriented languages that provides a concrete syntax for UML abstractions like associations. We argue that Umple will help increase program comprehension by allowing developers to describe a system at a more abstract level, and by reducing the volume of code.",1092-8138,978-1-4244-3998-0978-1-4244-3997,10.1109/ICPC.2009.5090073,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090073,,Object oriented modeling;Unified modeling language;Computer languages;Investments;Information analysis;Information technology;Concrete;Risk analysis;Object oriented programming;Application software,object-oriented languages;programming languages;Unified Modeling Language,program comprehension;program constructs;language analysis;object-oriented languages;UML abstractions,,8,8,,,,,IEEE,IEEE Conferences
Hidden dependencies in program comprehension and change propagation,Zhifeng Yu; V. Rajlich,"Dept. of Comput. Sci., Wayne State Univ., Detroit, MI, USA; NA",Proceedings 9th International Workshop on Program Comprehension. IWPC 2001,,2001,,,293,299,"Large software systems are difficult to understand and maintain. Program dependency analysis plays a key role in both understanding and maintenance. This paper discusses hidden dependencies among software components that make both understanding and maintenance hard. A hidden dependency is a relationship between two seemingly independent components, and it is caused by the data flow in a third software component. The paper uses abstract system dependency graphs to define hidden dependencies. It discusses the impact of hidden dependencies on the process of change propagation and also discusses an algorithm that warns about the possible presence of hidden dependencies.",1092-8138,0-7695-1131,10.1109/WPC.2001.921739,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921739,,Software maintenance;Computer science;Software systems;Independent component analysis;Object oriented modeling;Programming profession;Variable speed drives;Java;Collaborative work;Protocols,reverse engineering;software maintenance;graphs;subroutines;data flow analysis,hidden dependencies;program comprehension;software change propagation;large software systems;program dependency analysis;program understanding;software maintenance;software components;independent components;data flow;abstract system dependency graphs;warning algorithm,,15,25,,,,,IEEE,IEEE Conferences
A Case-Based Reasoning Method for Processing Model Recognition and Reuse in Program Comprehension,J. Qian; H. Chen; Y. Ding; F. Qi,"College of Computer Engineering, Univ. of Shanghai for Science & Technology, Shanghai, China, 200093. linghaijian@gmail.com; College of Computer Science and Technology, Zhejiang University, Hangzhou, China, 310027. solaris@cs.zju.edu.cn; College of Computer Engineering, Univ. of Shanghai for Science & Technology, Shanghai, China, 200093; College of Computer Science and Technology, Zhejiang University, Hangzhou, China, 310027",2006 International Conference on Computational Intelligence and Security,,2006,1,,113,116,"Applying cased-based reasoning (CBR) method in program understanding provides a practical route towards more powerful software engineering technology. A CBR approach to the recognition of model component is presented, and the whole reasoning process of the recognition is presented, including a case representation method and a matching algorithm. A prototype system named process model component recognition & reuse (PMCRR) is developed to implement model transformation and reconstruction. At last, an example is illustrated to check the efficiency of CBR method",,1-4244-0604-81-4244-0605,10.1109/ICCIAS.2006.294101,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4072054,,Information systems;Educational institutions;Power system modeling;Power engineering computing;Power engineering and energy;Software prototyping;Prototypes;Computer science;Software engineering;Data mining,case-based reasoning;object-oriented programming;reverse engineering;software reusability,case-based reasoning;program reuse;program comprehension;program understanding;software engineering;process model component recognition;model transformation;model reconstruction,,,7,,,,,IEEE,IEEE Conferences
Working session: Tools for program comprehension: building a comprehender's workbench [Session intro.],K. B. Gallagher,Loyola College in Maryland,Proceedings IWPC 2000. 8th International Workshop on Program Comprehension,,2000,,,255,255,"Comprehension, the primordial task, hasn't changed much in 40 years. Whether the comprehension task is global (architectural) or atomic (single statement effect), the approach is the same. We run it. We read it. We grep (search) it. An electronic search on the criteria ""comprehension and tools"" yielded no results. So while there is programmer's workbench, a maintainer's workbench, and a tester’s workbench, the comprehender’s workbench is evidently barren. While borrowing tools from other engineers gives a toe-hold, the question still arises: ""What tools belong in a comprehender’s workbench, per se?"" This workshop session will try to answer this question.",1092-8138,0-7695-0656,10.1109/WPC.2000.852500,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852500,,Educational institutions;Computer science;Testing;Software maintenance;Buildings;Maintenance engineering;File systems;Libraries;Biographies;NIST,,,,,,,,,,IEEE,IEEE Conferences
Recursion Removal/Introduction by Formal Transformation: An Aid to Program Development and Program Comprehension,M. P. Ward; K. H. Bennett,NA; NA,The Computer Journal,,1999,42,8,650,673,"The transformation of a recursive program to an iterative equivalent is a fundamental operation in computer science. In the reverse direction, the task of reverse engineering (analysing a given program in order to determine its specification) can be greatly ameliorated if the program can be re-expressed in a suitable recursive form. However, the existing recursion removal transformations, such as the techniques discussed by Knuth [1] and Bird [2], can only be applied in the reverse direction if the source program happens to match the structure produced by a particular recursion removal operation. In this paper we describe a much more powerful recursion removal and introduction operation which describes its source and target in the form of an action system (a collection of labels and calls to labels). A simple, mechanical restructuring operation can be applied to a great many iterative programs, which will put them in a suitable form for recursion introduction. Our transformation generates strictly more iterative versions than the standard methods, including those of Knuth and Bird [1, 2]. With the aid of this theorem we prove a (somewhat counterintuitive) result for programs that contain sequences of two or more recursive calls: under a reasonable commutativity condition, ‘depth-first’ execution is more general than ‘breadth-first’ execution. In ‘depth-first’ execution, the execution of each recursive call is completed, including all sub-calls, before execution of the next call is started. In ‘breadth-first’ execution, each recursive call in the sequence is partially executed but any sub-calls are temporarily postponed. This result means that any breadth-first program can be reimplemented as a corresponding depth-first program, but the converse does not hold. We also treat the case of ‘random-first’ execution, where the execution order is implementation dependent. For the more restricted domain of tree searching we show that a ‘breadth-first’ search is the most general form. We also give two examples of recursion introduction as an aid to formal reverse engineering.",0010-4620;1460-2067,,10.1093/comjnl/42.8.650,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8129741,,,,,,2,,,,,,OUP,OUP Journals
A structured demonstration of five program comprehension tools: lessons learnt,S. E. Sim; M. Storey; A. Winter,"Dept. of Comput. Sci., Toronto Univ., Toronto, Ont., Canada; NA; NA",Proceedings Seventh Working Conference on Reverse Engineering,,2000,,,210,212,"The purpose of the article is to report on a structured demonstration for comparing program comprehension tools. Five teams of program comprehension tool designers applied their tools to a set of maintenance tasks on a common subject system. By applying a variety of reverse engineering techniques to a predefined set of tasks, the tools can be compared using a common playing field. A secondary topic of discussion will address the development of ""guinea pig"" systems and how to use them in a structured demonstration for evaluating software tools.",1095-1350,0-7695-0881,10.1109/WCRE.2000.891471,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=891471,,Software tools;Conferences;Computer science;Reverse engineering;Educational institutions;Computer industry;Industrial relations;Software systems;Data mining;Software architecture,reverse engineering;software maintenance;software tools;software performance evaluation;software selection,structured demonstration;program comprehension tool designers;maintenance tasks;common subject system;reverse engineering techniques;common playing field;guinea pig systems;software tool evaluation,,8,3,,,,,IEEE,IEEE Conferences
Software visualization for object-oriented program comprehension,M. J. Pacione,"Dept. of Comput. & Inf. Sci., Strathclyde Univ., UK",Proceedings. 26th International Conference on Software Engineering,,2004,,,63,65,"Software visualisation is the process of modelling software systems for comprehension. The comprehension of software systems both during and after development is a crucial component of the software process. The complex interactions inherent in the object-oriented paradigm make visualisation a particularly appropriate comprehension technique, and the large volume of information typically generated during visualisation necessitates tool support. In order to address the disadvantages with current visualisation techniques, an approach is proposed that integrates abstraction, structural and behavioural perspectives, and statically and dynamically extracted information. The aim of this research is to improve the effectiveness of visualisation techniques for large-scale software understanding based on the use of abstraction. interrelated facets and the integration of statically and dynamically extracted information.",0270-5257,0-7695-2163,10.1109/ICSE.2004.1317423,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1317423,,Visualization;Software systems;Data mining;Software tools;Reverse engineering;Large-scale systems;Object oriented modeling;Large scale integration;Software performance;Computer architecture,object-oriented programming;program visualisation;software engineering,software visualization;software modelling;software processes;object-oriented software;object-oriented program;information extraction,,7,8,,,,,IEEE,IEEE Conferences
IMMV: An interactive multi-matrix visualization for program comprehension,A. Abuthawabeh; D. Zeckzer,"TU Kaiserslautern, Germany; TU Kaiserslautern, Germany",2013 First IEEE Working Conference on Software Visualization (VISSOFT),,2013,,,1,4,"Many visualization techniques are used by software engineers to understand and to analyze the static structure of software systems, with the static structure being extracted from the source code. However, the need for scalable visualizations, which take into account the increasing number of code entities (classes and interfaces) and different types of code couplings (relations between them) in software systems, is still not sufficiently fulfilled. In this paper, we extend the design of an existing multi-matrix visualization approach to represent the static structure of software systems in a scalable way. First, we extended the data model and the algorithms. Second, we added more visualization and interaction elements. Finally, we incorporated the folding (collapsing) and the unfolding (expanding) of the package hierarchy, which have quadratic time complexity and quadratic space complexity in the number of nodes. This extended approach can be applied to support program comprehension and to analyze the static structure of software systems.",,978-1-4799-1457,10.1109/VISSOFT.2013.6650549,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6650549,,Visualization;Software systems;Couplings;Algorithm design and analysis;Color;Complexity theory,computational complexity;data visualisation;matrix algebra;program diagnostics,IMMV;interactive multimatrix visualization;program comprehension;visualization techniques;software engineers;source code;scalable visualizations;code entities;code couplings;static software systems structure;interaction elements;visualization elements;package hierarchy;quadratic time complexity;quadratic space complexity,,4,13,,,,,IEEE,IEEE Conferences
Artifact Driven Communication to Improve Program Comprehension,J. Kubelka,NA,2017 IEEE/ACM 39th International Conference on Software Engineering Companion (ICSE-C),,2017,,,457,460,"Developer communication is an important factor during program comprehension. Live programming environments encourage developers to comprehend applications through manipulation of running instances-liveness. Such application exploration is interrupted whenever programmers need to communicate an issue with dislocated co-workers. Describing the issue becomes challenging as programmers use text based communication mediums, e.g., emails or chats. The issues are magnified during bug day events, where developers around the world meet together in order to improve a project. Communication and coordination need to be increased, but the infrastructure stays the same. We target the research gap by introducing the COLLABORATIVE PLAYGROUND, a tool that exposes liveness into developer communication during programming change tasks and integrates coordination needs during bug day events. We will evaluate our approach by deploying the COLLABORATIVE PLAYGROUND during a series of Bug Day events for Pharo, one of the most active live programming platforms in existence.",,978-1-5386-1589-8978-1-5386-1590,10.1109/ICSE-C.2017.47,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7965383,Collaborative Programming;Live Programming Environment;Qualitative Study,Computer bugs;Collaboration;Tools;Programming;Libraries;Measurement;Electronic mail,groupware;program debugging,program comprehension;running instance manipulation;text based communication mediums;bug day events;collaborative playground;liveness;developer communication;programming change tasks;coordination needs integration;Pharo;live programming platforms;artifact driven communication,,,13,,,,,IEEE,IEEE Conferences
VPLs and novice program comprehension: how do different languages compare?,J. Good,"Human Commun. Res. Centre, Edinburgh Univ., UK",Proceedings 1999 IEEE Symposium on Visual Languages,,1999,,,262,269,"This paper reports on an experiment which compared small control and data flow visual programming languages (VPLs). The study used a combination of the match-mismatch conjecture and the information types approach in order to investigate the effect of language style on comprehension. Results showed that the control flow VPL is associated with faster task performance, regardless of the match between language and task. However, accuracy scores showed some evidence of a match-mismatch effect. These results were supported by program summary data, which showed that the data flow VPL was associated with abstract, functional accounts of the program, while the control flow language led to low-level, procedural descriptions. This suggests that specific properties of VPLs lead to differences in program comprehension.",1049-2615,0-7695-0216,10.1109/VL.1999.795912,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=795912,,Computer languages,visual languages;parallel languages,VPLs;program comprehension;data flow visual programming languages;match-mismatch conjecture;information types approach;program summary data,,4,15,,,,,IEEE,IEEE Conferences
Program COmprehension through Dynamic Analysis,A. Zaidman; O. Greevy; A. Hamou-Lhadj,"Delft Univ. of Technology, The Netherlands; University of Antwerp, Belgium; Univ. of Bern, Switzerland; University of Ottawa, Canada",2006 13th Working Conference on Reverse Engineering,,2006,,,315,315,"Software maintenance and evolution can be made easier with program comprehension techniques. The aim of this workshop is to gather together researchers working in the area of program comprehension with an emphasis on dynamic analysis. We are interested in investigating how dynamic analysis techniques are or can be used to enable better comprehension of a software system. The objective is to find common case studies, compare existing techniques, and find possible symbioses for existing solutions. Building upon the previous edition of the workshop, PCODA 2005, we aim to set up a forum for exchanging experiences, discussing solutions, and exploring new ideas.",1095-1350;2375-5369,0-7695-2719,10.1109/WCRE.2006.45,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4024010,,Information analysis;Software maintenance;Software systems;Information technology;Documentation;Maintenance engineering;Runtime;Programming profession;Reverse engineering,,,,,2,,,,,IEEE,IEEE Conferences
Concept Location and Program Comprehension in Service-Oriented Software,O. Panchenko,"Hasso Plattner Institute for Software Systems Engineering, Mailbox 900460, D-14440 Potsdam, oleksandr.panchenko@hpi.uni-potsdam.de",2007 IEEE International Conference on Software Maintenance,,2007,,,513,514,The maintenance process of service-oriented software might be different from the maintenance of software built using established technologies. This research aims at an investigation of existing maintenance methods for concept location and program comprehension and their applicability to new service-oriented environments as well as development of new appropriate methods. This paper outlines the goals and shortly discusses how these can be achieved.,1063-6773,978-1-4244-1255-6978-1-4244-1256,10.1109/ICSM.2007.4362676,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362676,,Software maintenance;Acceleration;Service oriented architecture;Computer architecture;Semiconductor optical amplifiers;Object oriented modeling;Iterative methods;Costs;Software design;Software systems,reverse engineering;software maintenance,concept location;program comprehension;service-oriented software;maintenance process,,5,12,,,,,IEEE,IEEE Conferences
15 Years of Program Comprehension,S. Tilley,Florida Institute of Technology,15th IEEE International Conference on Program Comprehension (ICPC '07),,2007,,,279,280,"This paper looks back at fifteen years of program comprehension (WPC, IWPC, ICPC), gathering key themes and important issues that have been discussed. Since the traditional gift for a 15<sup>th</sup> anniversary is crystal, the workshop also strives to peer into the future and outline some of the coming challenges in the field for the next few years.",1092-8138,0-7695-2860,10.1109/ICPC.2007.1,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268263,,Conferences;Software engineering;Software maintenance;Application software;Particle measurements;Engineering profession;History;Time factors;IEEE Computer Society Press,reverse engineering;software maintenance,program comprehension;program understanding;software engineering;software maintenance,,,3,,,,,IEEE,IEEE Conferences
JRipples: a tool for program comprehension during incremental change,J. Buckner; J. Buchta; M. Petrenko; V. Rajlich,"Dept. of Comput. Sci., Wayne State Univ., Detroit, MI, USA; Dept. of Comput. Sci., Wayne State Univ., Detroit, MI, USA; Dept. of Comput. Sci., Wayne State Univ., Detroit, MI, USA; Dept. of Comput. Sci., Wayne State Univ., Detroit, MI, USA",13th International Workshop on Program Comprehension (IWPC'05),,2005,,,149,152,"Incremental software change adds new functionality to software. It is the foundation of software evolution, maintenance, iterative development, agile development, and other software processes. Highly interactive tool JRipples provides the programmer with the organizational support that makes the incremental change process easier and more systematic. JRipples supports impact analysis and change propagation, the two most difficult activities of the incremental change.",1092-8138,0-7695-2254,10.1109/WPC.2005.22,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421025,,Programming profession;Software maintenance;Databases;Software tools;Java;Displays;Computer science;Software engineering;Humans;Error analysis,software tools;software maintenance,JRipples tool;program comprehension;incremental change process;software evolution;software maintenance;iterative development;agile development,,40,24,,,,,IEEE,IEEE Conferences
Comprehending Studies on Program Comprehension,I. Schröter; J. Krüger; J. Siegmund; T. Leich,NA; NA; NA; NA,2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC),,2017,,,308,311,"Program comprehension is an important aspect of developing and maintaining software, as programmers spend most of their time comprehending source code. Thus, it is the focus of many studies and experiments to evaluate approaches and techniques that aim to improve program comprehension. As the amount of corresponding work increases, the question arises how researchers address program comprehension. To answer this question, we conducted a literature review of papers published at the International Conference on Program Comprehension, the major venue for research on program comprehension. In this article, we i) present preliminary results of the literature review and ii) derive further research directions. The results indicate the necessity for a more detailed analysis of program comprehension and empirical research.",,978-1-5386-0535-6978-1-5386-0536,10.1109/ICPC.2017.9,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961527,Systematic Review;Study Comprehension;Empirical Research,Terminology;Bibliographies;Documentation;Software;Guidelines;Context;Testing,software maintenance;source code (software),source code;program comprehension;software maintenance;software development,,,22,,,,,IEEE,IEEE Conferences
Workshop on Program Comprehension through Dynamic Analysis (PCODA07),A. Hamou-Lhadj; A. Zaidman; O. Greevy,NA; NA; NA,14th Working Conference on Reverse Engineering (WCRE 2007),,2007,,,298,298,"Software maintenance and evolution can be made easier if program comprehension techniques are used. Understanding a software system would typically necessitate a combination of static and dynamic analysis techniques. The aim of this workshop is to gather together researchers working in the area of program comprehension with an emphasis on dynamic analysis. We are interested in investigating how dynamic analysis techniques are used or can be used to enable better comprehension of a software system. The objective is to find common case studies, compare existing techniques, and find possible symbioses for existing solutions. Building upon the two previous editions of the workshop, we aim to set up a forum for exchanging experiences, discussing solutions, and exploring new ideas.",1095-1350;2375-5369,0-7695-3034-6978-0-7695-3034,10.1109/WCRE.2007.53,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4400183,,,computer science education;program diagnostics;software maintenance,program comprehension;dynamic analysis;software maintenance;software evolution;software system;static analysis,,1,4,,,,,IEEE,IEEE Conferences
Workshop on Program Comprehension through Dynamic Analysis (PCODA10),A. Hamou-Lhadj; D. Rothlisberger; A. Zaidman; O. Greevy,NA; NA; NA; NA,2010 17th Working Conference on Reverse Engineering,,2010,,,279,280,"Applying program comprehension techniques may render software maintenance and evolution easier. Understanding a software system typically requires a combination of static and dynamic analysis techniques. The aim of this workshop is to bring together researchers and practitioners working in the area of program comprehension with an emphasis on dynamic analysis. We are interested in investigating how dynamic analysis techniques are used or can be used to enable better comprehension of a software system. The objective is to compare existing techniques, and to identify common case studies and possible symbioses for existing solutions. Building upon four previous editions of the workshop, we aim to set up a forum for exchanging experiences, discussing solutions, and exploring new ideas.",2375-5369;1095-1350,978-1-4244-8911,10.1109/WCRE.2010.40,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5645500,,Conferences;Performance analysis;Reverse engineering;IEEE Computer Society;Software systems;Software maintenance;Special issues and sections,,,,,8,,,,,IEEE,IEEE Conferences
Towards standard for experiments in program comprehension,V. Rajlich; G. S. Cowan,"Dept. of Comput. Sci., Wayne State Univ., Detroit, MI, USA; NA",Proceedings Fifth International Workshop on Program Comprehension. IWPC'97,,1997,,,160,161,"Program comprehension can make a unique contribution to the field of software engineering because it is feasible to validate its claims with inexpensive experiments. To fully realize this unique position, program comprehension researchers need to develop standards that will guide them in designing experiments and allow them to judge the strength of an experiment in supporting a claim. To begin the discussion leading to such standards, we propose that program comprehension experiments always measure and interpret the following dependent variables: accuracy, accurate response time, and inaccurate response time.",1092-8138,0-8186-7993,10.1109/WPC.1997.601284,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601284,,Software engineering;Delay;Costs;Time measurement;Programming profession;Standards development;Software systems;Computer science;Measurement standards;Humans,reverse engineering;software standards;software metrics,program comprehension;software engineering;software standards;dependent variables;accurate response time;inaccurate response time;reverse engineering,,10,5,,,,,IEEE,IEEE Conferences
From Program Comprehension to People Comprehension,A. Begel,NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,190,191,Large-scale software engineering requires many teams to collaborate together to create software products. The problems these teams suffer trying to coordinate their joint work can be addressed through tools inspired by social networking. Social networking tools help people to more easily discover and more efficiently maintain relationships than is feasible using one-to-one or face-to-face interactions. Applying these ideas to the software domain requires new kinds and combinations of software program and process analyses that overcome intrinsic limitations in the accuracy of the underlying data sources and the ambiguity inherent in human relationships.,1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.42,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521747,software process;human aspects,Collaborative software;Humans;Software engineering;Collaborative work;Social network services;Computer bugs;Software testing;Data engineering;Data mining;USA Councils,social aspects of automation;social networking (online);software engineering,program comprehension;people comprehension;social networking tools;software program;software products;human aspects,,1,9,,,,,IEEE,IEEE Conferences
CodeCrawler - an information visualization tool for program comprehension,M. Lanza; S. Ducasse; H. Gall; M. Pinzger,"Fac. of Informatics, Lugano Univ., Switzerland; NA; NA; NA","Proceedings. 27th International Conference on Software Engineering, 2005. ICSE 2005.",,2005,,,672,673,"CodeCrawler is a language independent, interactive, information visualization tool. It is mainly targeted at visualizing object-oriented software, and has been successfully validated in several industrial case studies over the past few years. CC adheres to lightweight principles: it implements and visualizes polymetric views, visualizations of software enriched with information such as software metrics and other source code semantics. CC is built on top of Moose, an extensible language independent reengineering environment that implements the FAMIX metamodel. In its last implementation, CC has become a general-purpose information visualization tool.",0270-5257;1558-1225,1-59593-963,10.1109/ICSE.2005.1553647,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1553647,,Visualization;Informatics;Computer industry;Software metrics;Reverse engineering;Software tools;Data mining;Information analysis;Object oriented modeling;Java,program visualisation;reverse engineering,CodeCrawler;information visualization tool;program comprehension;object-oriented software;software visualization;Moose;extensible language independent reengineering environment;FAMIX metamodel,,10,6,,,,,IEEE,IEEE Conferences
"SFAC, a tool for program comprehension by specialization",S. Blazy; P. Facon,"CEDRIC IIE, Evry, France; CEDRIC IIE, Evry, France",Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94,,1994,,,162,167,"This paper describes a tool for facilitating the comprehension of general programs using automatic specialization. The goal of this approach was to assist in the maintenance of old programs, which have become very complex due to numerous extensions. This paper explains why this approach was chosen, how the tool's architecture was set up, and how the correctness of the specialization has been proved. Then, it discusses the results obtained by using this tool, and the future evolutions.<<ETX>>",1092-8138,0-8186-5647,10.1109/WPC.1994.341266,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341266,,Input variables;Geometry;Switches;Software maintenance;Application software;Computer applications;Natural languages;Optimizing compilers;Program processors;Solid modeling,reverse engineering;software tools;program diagnostics,program comprehension;specialization;SFAC;software tool;automatic specialization;program maintenance,,6,14,,,,,IEEE,IEEE Conferences
Experiences in teaching software evolution and program comprehension,A. van Deursen; J. -. Favre; R. Koschke; J. Rilling,"Delft Univ. of Technol., Netherlands; NA; NA; NA","11th IEEE International Workshop on Program Comprehension, 2003.",,2003,,,283,284,"A large amount of research is devoted to software evolution and program understanding, but these topics are often neglected in software engineering curricula. The CCSE initiative from IEEE/ACM proposes guidelines for the future. At the ICSM'02 conference, a panel was held to establish what should be taught in the future. This working session focuses on what is being taught and what will be taught in the near future. The goals include (1) to share experiences in teaching software evolution and program understanding, (2) to establish the state of the practice and (3) to identify future directions.",1092-8138,0-7695-1883,10.1109/WPC.2003.1199214,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199214,,Education;Software engineering;Software tools;Guidelines;Software maintenance;Computer industry;Reverse engineering;Seminars;Conferences;Computer architecture,teaching;reverse engineering;computer science education,teaching;software evolution;program comprehension;software engineering curricula;CCSE initiative;IEEE/ACM;ICSM'02 conference;program understanding;future directions,,3,4,,,,,IEEE,IEEE Conferences
Scalability solutions for program comprehension through dynamic analysis,A. Zaidman,"Dept. of Math. & Comput. Sci., Antwerp Univ., Belgium",Conference on Software Maintenance and Reengineering (CSMR'06),,2006,,,4 pp.,330,"Dynamic analysis has long been a subject of study in the context of (compiler) optimization, program comprehension, test coverage, etc. Ever-since, the scale of the event trace has been an important issue. This scalability issue finds its limits on the computational front, where time and/or space complexity of algorithms become too large to be handled by a computer, but also on the cognitive front, where the results presented to the user become too large to be easily understood. This research focuses on delivering a number of program comprehension solutions that help software engineers to focus on the software system during their initial program exploration and comprehension phases. The key concepts we use in our techniques are ""frequency of execution"" and runtime ""coupling"". To validate our techniques we used a number of open-source software systems, as well as an industrial legacy application",1534-5351,0-7695-2536,10.1109/CSMR.2006.46,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1602389,,Scalability;Open source software;Software systems;Program processors;Optimizing compilers;Testing;Frequency;Runtime;Computer industry;Application software,reverse engineering;software maintenance;system monitoring,program comprehension;dynamic analysis;event trace;time complexity;space complexity;software engineering;program exploration;open-source software systems;industrial legacy application,,12,13,,,,,IEEE,IEEE Conferences
Improving program comprehension by answering questions (keynote),B. A. Myers,"Human Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA",2013 21st International Conference on Program Comprehension (ICPC),,2013,,,1,2,"My Natural Programming Project is working on making software development easier to learn, more effective, and less error prone. An important focus over the last few years has been to discover what are the hard-to-answer questions that developers ask while they are trying to comprehend their programs, and then to develop tools to help answer those questions. For example, when studying programmers working on everyday bugs, we found that they continuously ask “Why” and “Why Not” questions as they try to comprehend what happened. We developed the “Whyline” debugging tool, which allows programmers to directly ask these questions of their programs and get a visualization of the answers. In a small lab study, Whyline increased productivity by a factor of about two. We studied professional programmers trying to understand unfamiliar code and identified over 100 questions they identified as hard-to-answer. In particular, we saw that programmers frequently had specific questions about the feasible execution paths, so we developed a new visualization tool to directly present this information. When trying to use unfamiliar APIs, such as the Java SDK and the SAP eSOA APIs, we discovered some common patterns that make programmers up to 10 times slower in finding and understanding how to use the appropriate methods, so we developed new tools to assist them. This talk will provide an overview of our studies and resulting tools that address program comprehension issues.",1092-8138,978-1-4673-3092,10.1109/ICPC.2013.6613827,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613827,Natural Programming;Debugging;Application Programming Interfaces (APIs);Integrated development environments (IDEs);Documentation;Reverse Engineering;Programming Environments,Visualization;Programming;Educational institutions;User interfaces;Usability;Documentation;Software engineering,computer science education;program debugging;program visualisation;project management;reverse engineering,program comprehension;question answering;My Natural Programming Project;software development learning;hard-to-answer questions;tool development;Whyline debugging tool;program visualization;productivity;professional programmer;execution paths;visualization tool;API,,,15,,,,,IEEE,IEEE Conferences
A program visualization tool for program comprehension,M. Ohki; Y. Hosaka,"Nippon Inst. of Technol., Japan; Nippon Inst. of Technol., Japan","IEEE Symposium on Human Centric Computing Languages and Environments, 2003. Proceedings. 2003",,2003,,,263,265,"At the beginning stage of programming education, comprehending program logics plays a more important role than capturing knowledge of a specific program language. In this paper, the authors describe an outline of a visualization tool that animates the actions of a program by adding simple annotations to the variables defined in a program, and show several ideas to improve the usability of this tool. The authors also discuss the effectiveness of program visualization.",,0-7803-8225,10.1109/HCC.2003.1260243,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1260243,,Visualization;Programming profession;Animation;Logic testing;Educational programs;Sorting;Arithmetic;Shape control;Programmable logic arrays;Educational technology,program visualisation;computer animation;reverse engineering;computer science education,program visualization tool;program comprehension;programming education;program logic;software tool;program action animation;program variable annotation,,1,3,,,,,IEEE,IEEE Conferences
gccXfront: exploiting gcc as a front end for program comprehension tools via XML/XSLT,M. Hennessy; B. A. Malloy; J. F. Power,"Comput. Sci. Dept, Nat. Univ. of Ireland, Maynooth, Ireland; NA; NA","11th IEEE International Workshop on Program Comprehension, 2003.",,2003,,,298,299,"Parsing programming languages is an essential component of the front end of most program comprehension tools. Languages such as C++ can be difficult to parse and so it can prove useful to re-use existing front ends such as those from the GNU compiler collection, gcc. We have modified gcc to provide syntactic tags in XML format around the source code which can greatly enhance our comprehension of the program structure. Further, by using XML transformation stylesheets, the XML outputted by our modified gcc can be translated into a more readable format. Our tool, gccXfront leverages the power and portability of the gcc suite, since any C, C++, Objective C or Java program can be processed using gcc. Our tool can thus act as a bridge between gcc and other program comprehension tools that accept XML formatted input.",1092-8138,0-7695-1883,10.1109/WPC.2003.1199222,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199222,,XML;Java;Computer science;Computer languages;Graphical user interfaces;Bridges;Style sheet languages;Humans;Navigation;Visualization,XML;reverse engineering;software tools;C++ language;program compilers;computational linguistics;software portability;Java,gccXfront;front end;program comprehension tools;XML/XSLT;programming language parsing;C++ languages;GNU compiler collection;syntactic tags;XML transformation stylesheets;portability;C program;Objective C program;Java program,,2,5,,,,,IEEE,IEEE Conferences
Industrial Program Comprehension Challenge 2011: Archeology and Anthropology of Embedded Control Systems,A. Begel; J. Quante,NA; NA,2011 IEEE 19th International Conference on Program Comprehension,,2011,,,227,229,"The Industrial Program Comprehension Challenge is a two-year-old track of the International Conference on Program Comprehension that provides a venue for researchers and industrial practitioners to communicate about new research directions that can help address real world problems. This year, 2011, a scenario-based challenge was created to inspire researchers to apply the best ""archaeological"" techniques for understanding the complexity of industrial software, and foster appreciation for the delicate ""anthropological"" scenario which drives the behavior of the software engineers, management, and customers. Participants had two months to work on the challenge and submit write-ups of their solutions. Acceptable submissions were exhibited as posters, while the best solutions were presented during the Industrial Challenge conference session. This new challenge format gives researchers the opportunity to present their novel techniques, tools and ideas to the community.",1092-8138;1092-8138,978-1-61284-308-7978-0-7695-4398,10.1109/ICPC.2011.50,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970193,,Software;Leg;Legged locomotion;Computer bugs;Electronic mail;Companies,embedded systems;production engineering computing;software engineering,archeology;anthropology;embedded control systems;Industrial Program Comprehension Challenge;industrial software,,3,1,,,,,IEEE,IEEE Conferences
A Visualization Tool for 3D Graphics Program Comprehension and Debugging,S. Podila; Y. Zhu,NA; NA,2016 IEEE Working Conference on Software Visualization (VISSOFT),,2016,,,111,115,"Real-time 3D graphics programs are based on a 3D pipeline structure. In a 3D pipeline, data is loaded, prepared, transferred from CPU to GPU, and then processed on GPU to create images. Regular debuggers and special graphics debuggers primarily focus on displaying data but do not show how data is transferred from CPU to GPU. If there is an error in data transfer, programmers usually need to locate the error by reading the source code, which many of our students find difficult. We have developed a tool to visualize data flow between CPU and GPU in a 3D pipeline. The visualization helps students understand 3D graphics programs, especially some of the implicit data connections in 3D graphics APIs. It also helps students quickly locate bugs related to data transfer in a 3D pipeline. We demonstrate our tool with an example that shows how a subtle error can be quickly detected in our visualization.",,978-1-5090-3850-3978-1-5090-3851,10.1109/VISSOFT.2016.23,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780167,software visualization;software comprehension;debugging;3D graphics program,Three-dimensional displays;Pipelines;Graphics processing units;Data visualization;Debugging;Engines;Data transfer,application program interfaces;graphics processing units;microprocessor chips;pipeline processing;program debugging;program visualisation,3D graphic API;data flow visualization;GPU;CPU;3D pipeline structure;3D graphic program debugging;3D graphic program comprehension;visualization tool,,,13,,,,,IEEE,IEEE Conferences
A Synergistic Approach to Program Comprehension,B. L. Vinz; L. H. Etzkorn,University of Alabama in Huntsville; NA,14th IEEE International Conference on Program Comprehension (ICPC'06),,2006,,,69,73,Program comprehension involves the process of extracting properties from a program in order to achieve a better understanding of the software system. The most common approaches are code-based with focus primarily on the program code. More attention needs to be given to information encoded in comments and identifiers and the valuable clues they may provide. This paper describes a technique that combines a code-based program understanding approach with a comment understanding approach. The goal is to match the comments and identifiers to the code in order to obtain a comprehensive understanding of the software under analysis. The method has application to software development and maintenance. It can also be used as an instructional tool for software students,1092-8138,0-7695-2601,10.1109/ICPC.2006.7,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631106,,Programming;Software maintenance;Software tools;Computer science;Data mining;Software systems;Application software;Scattering;Education;Inference algorithms,program diagnostics;reverse engineering;software maintenance,program comprehension;software system development;code-based program understanding approach;comment understanding approach;program identifiers;software maintenance;instructional tool,,4,7,,,,,IEEE,IEEE Conferences
Layered Program Auralization: Using Music to Increase Runtime Program Comprehension and Debugging Effectiveness,A. Stefik; K. Fitz; R. Alexander,Washington State University; NA; NA,14th IEEE International Conference on Program Comprehension (ICPC'06),,2006,,,89,93,"Layered program auralization uses music for debugging computer code. Layers of musical structure represent the state and behavior of a computer program while it is running, taking advantage of metaphorical relationships between musical structure and programming constructs. This paper makes three contributions to the debugging and program auralization literature. We use cadences, recognizable patterns of chords that usually dictate an ending, to metaphorically represent nesting depth and hierarchical control structures. Auralizations, in our system, use more than one perceptual mapping at a time. Further, we decompose our auralizations into units, which we call layers. This decomposition is similar to using classes in object oriented programming. We see debugging as a time consuming, difficult task, and present a solution where music is played to the programmer during program execution. Our goal is to increase debugging effectiveness and to improve a programmer's comprehension of the runtime behavior of computer programs",1092-8138,0-7695-2601,10.1109/ICPC.2006.33,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631110,Fault detection;music;sonified debugging;testing;layered program auralization.,Multiple signal classification;Runtime;Debugging;Programming profession;Pattern recognition;Testing;Recycling;Computer science;Object oriented programming;Fault detection,music;program debugging;system monitoring,layered program auralization;music;runtime program comprehension;computer code debugging;metaphorical relationship;programming construct;cadence;recognizable chord pattern;hierarchical control structure;object oriented programming;program execution;fault detection,,1,13,,,,,IEEE,IEEE Conferences
Program comprehension as a learning process,V. Rajich,"Dept. of Comput. Sci., Wayne State Univ., Detroit, MI, USA",Proceedings First IEEE International Conference on Cognitive Informatics,,2002,,,343,347,"The paper describes the process of program comprehension from the point of view of constructivist theory of learning. According to this view, program comprehension starts with existing knowledge and continues through processes of assimilation and adaptation. Assimilation means that the facts encountered in the program are either added to the knowledge or rejected. Adaptation means that the existing knowledge is reorganized in order to absorb new facts. These processes are illustrated by a case study where the knowledge of the program is represented by UML class diagrams.",,0-7695-1724,10.1109/COGINF.2002.1039316,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1039316,,Programming profession;Software maintenance;Computer science;Unified modeling language;Software engineering;Documentation;Data visualization;Insurance;Companies;Pattern recognition,reverse engineering;software engineering;specification languages,program comprehension;constructivist learning theory;assimilation;adaptation;UML class diagrams,,2,16,,,,,IEEE,IEEE Conferences
Workshop on Program Comprehension through Dynamic Analysis (PCODA ‘05),O. Greevy; A. Hamou-Lhadj; A. Zaidman,University of Bern; NA; NA,12th Working Conference on Reverse Engineering (WCRE'05),,2005,,,232,232,Software maintenance and evolution can be made easier if program comprehension techniques are used. Understanding a software system would typically necessitate a combination of static and dynamic analysis techniques. The aim of this workshop is to gather researchers working in the area of program comprehension with an emphasis on dynamic analysis. We are interested in investigating how dynamic analysis techniques are used or can be used to enable better comprehension of a software system.,1095-1350;2375-5369,0-7695-2474,10.1109/WCRE.2005.35,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1566163,,,,,,2,2,,,,,IEEE,IEEE Conferences
Constructivism and program comprehension strategies,C. Exton,"Limerick Univ., Ireland",Proceedings 10th International Workshop on Program Comprehension,,2002,,,281,284,"Program comprehension strategies and learning theories are difficult topics in themselves, and the combination of both can provide some interesting observations. Constructivism differs from the traditional learning theories which suggest knowledge exists as something independent of the individual in several ways. One major premise of constructivism is that we actively construct our knowledge rather than simply absorbing it through repeated practice or predefined steps. Constructivism asserts that there is no knowledge independent of that constructed by the learner, and its construction is a unique experience for each individual. This paper provides an overview of existing program comprehension strategies and contrasts them in relation to the learning theory of constructivism.",1092-8138,0-7695-1495,10.1109/WPC.2002.1021349,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021349,,Programming profession;Educational institutions;Conferences;Cultural differences,reverse engineering;software engineering;learning (artificial intelligence),program comprehension strategies;learning theories;constructivism;knowledge construction,,5,7,,,,,IEEE,IEEE Conferences
Working session: program comprehension strategies for Web service and service-oriented architectures,L. O'Brien; D. Smith,"Software Eng. Inst., Carnegie Mellon Univ., Pittsburgh, PA, USA; Software Eng. Inst., Carnegie Mellon Univ., Pittsburgh, PA, USA","Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.",,2004,,,260,261,"The availability of the Web has made it possible to provide new life to legacy systems as Web services components within a service-oriented architecture. Web services are self-contained, modular applications that can be described, published, located, and invoked over a network, generally, the World Wide Web. The service-oriented architecture describes three roles: service provider, service requester and service broker; and three basic operations: publish, find and bind. A network component can play any or all of these roles. Web services focus on the integration and infrastructure complexities of B2B by leveraging the benefits of Web service technologies, Internet standards and common infrastructures. While the migration to Web services has the potential of providing significant value to legacy systems and components, a number of critical program comprehension issues need to be addressed. These include understanding the legacy systems and components in enough detail to make decisions on the types of changes that need to be made for using them within the new service-oriented architecture, understanding the legacy and target architectures, and analyzing the specific Web service technologies that will be required and how to incorporate the legacy components as services. This working session will discuss approaches for addressing these issues. Based on the results of the session, a working model will be developed that lists current approaches, their strengths and weaknesses, as well as current open issues.",1092-8138,0-7695-2149,10.1109/WPC.2004.1311071,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311071,,Web services;Service oriented architecture;Conferences;Computer architecture;Software engineering;Decision making;Computer aided software engineering;Availability;Application software;Web sites,reverse engineering;software maintenance;Internet;software prototyping;software architecture;electronic commerce;object-oriented programming,program comprehension;Web service;service-oriented architecture;legacy system;Web services component;World Wide Web;network component;Internet;legacy component,,1,,,,,,IEEE,IEEE Conferences
An Empirical Study of Blindness and Program Comprehension,A. Armaly,NA,2016 IEEE/ACM 38th International Conference on Software Engineering Companion (ICSE-C),,2016,,,683,685,"Blind programmers typically use a screen reader when reading code whereas sighted programmers are able to skim the code with their eyes. This difference has the potential to impact the generalizability of software engineering studies and approaches. We present a summary of a paper which will soon be under review at TSE that investigates how code comprehension of blind programmers differs from that of sighted programmers. Put briefly, we found no statistically-significant differences between the areas of code that the blind programmers found to be important and the areas of code that the sighted programmers found to be important.",,978-1-4503-4205-6978-1-5090-2245,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7883372,,Software engineering;Conferences;Computer languages;Programming;Measurement;Software maintenance;Blindness,computer aided instruction;handicapped aids;software engineering,software engineering studies;reading code;screen reader;blind programmers;blindness;program comprehension,,,17,,,,,IEEE,IEEE Conferences
Lost comments support program comprehension,T. Omori,"Department of Computer Science, Ritsumeikan University, Kusatsu, Shiga, Japan","2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER)",,2017,,,567,568,"Source code comments are valuable to keep developers' explanations of code fragments. Proper comments help code readers understand the source code quickly and precisely. However, developers sometimes delete valuable comments since they do not know about the readers' knowledge and think the written comments are redundant. This paper describes a study of lost comments based on edit operation histories of source code. The experimental result shows that developers sometimes delete comments although their associated code fragments are not changed. Lost comments contain valuable descriptions that can be utilized as new data sources to support program comprehension.",,978-1-5090-5501-2978-1-5090-5502,10.1109/SANER.2017.7884680,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7884680,,History;Software;Encoding;Syntactics;Computer science;Writing;Data mining,software engineering;source code (software),lost comments support program comprehension;source code comments;code fragments explanation;software developers;edit operation histories,,,4,,,,,IEEE,IEEE Conferences
A study on assisting in Prolog program comprehension by using stepwise execution and stepwise comparison,Y. Deguchi; M. Nakamura; S. Otsuki,"Graduate Sch. of Inf. Sci., Hiroshima City Univ., Japan; Graduate Sch. of Inf. Sci., Hiroshima City Univ., Japan; Graduate Sch. of Inf. Sci., Hiroshima City Univ., Japan","International Conference on Computers in Education, 2002. Proceedings.",,2002,,,106,110 vol.1,"Reading a program, learners must understand syntax, semantics, and usage, which are characteristics of each individual programming language. Moreover, they must acquire typical writing art through understanding various good programs. In order to obtain good programming methods, learners must also know the execution flow of programs, which is difficult to explain statically. In this paper, as a learning environment for Prolog programs, an animation tree is proposed, which allows learners to interactively manipulate program execution back and forth in a stepwise manner. The effect of the animation tree in the problem solving process and the contents of finding through comparison of two programs with the same structure are investigated.",,0-7695-1509,10.1109/CIE.2002.1185876,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1185876,,Computer languages;Animation;Problem-solving;Cognitive science;Magnetic heads;Writing;Art;Programming profession;Buildings;Computer science education,computer science education;computer animation;PROLOG;programming language semantics;flowcharting,Prolog program;syntax;semantics;usage;programming language;writing art;programming methods;program execution flow;animation tree;learning environment;stepwise execution;stepwise comparison;Prolog program comprehension,,,,,,,,IEEE,IEEE Conferences
"Managing a multi-file, multi-language software repository for program comprehension tools: a generic approach",M. Kamp,"Inst. of Software Technol., Koblenz Univ., Germany",Proceedings. 6th International Workshop on Program Comprehension. IWPC'98 (Cat. No.98TB100242),,1998,,,64,71,"Software repositories that provide a basis for software comprehension or reengineering tools usually have to represent a huge number of documents of different types bound into a web of many kinds of relationships. The flexibility and the structural properties of a software repository are crucial for its use. This paper presents a repository approach that allows to set up, fill and update a software repository where the documents are represented as a highly integrated structure. The repository schema is described by a user defined, object based conceptual model. The integration of new documents into the existing repository is described by declarative rules. The repository was implemented as part of the GUPRO project.",1092-8138,0-8186-8560,10.1109/WPC.1998.693287,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=693287,,Software tools;Electrical capacitance tomography;Software systems;Databases;Visualization;Technology management;Hip;Data mining;Computer languages;Operating systems,software libraries;software reusability;reverse engineering;software tools;systems re-engineering;object-oriented programming,multi-file multi-language software repository;program comprehension tools;reengineering tools;documents;repository schema;object based conceptual model;declarative rules;GUPRO project,,6,17,,,,,IEEE,IEEE Conferences
A brief summary of cognitive patterns for program comprehension,A. Murray; T. C. Lethbridge,"SITE, Ottawa Univ., Ont., Canada; SITE, Ottawa Univ., Ont., Canada",11th Working Conference on Reverse Engineering,,2004,,,304,305,"A cognitive pattern is a solution to a recurring mental problem. We focus on those relevant to program comprehension. We expand one pattern, Temporal Details, which is also a pattern language since it decomposes into sub-patterns. Tool designers can use cognitive patterns to grasp how tool users may think.",1095-1350,0-7695-2243,10.1109/WCRE.2004.5,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1374334,,Navigation;Humans;Software systems;Cultural differences;Reverse engineering;Software tools;Vocabulary;Object oriented modeling;Unified modeling language;Time factors,reverse engineering;software tools;object-oriented programming,cognitive patterns;program comprehension;mental problem;temporal details;pattern language;tool designer;software tool,,2,,,,,,IEEE,IEEE Conferences
Supporting program comprehension with program summarization,Y. Liu; X. Sun; X. Liu; Y. Li,"School of Information Engineering, Yangzhou University, China; School of Information Engineering, Yangzhou University, China; School of Information Engineering, Yangzhou University, China; School of Information Engineering, Yangzhou University, China",2014 IEEE/ACIS 13th International Conference on Computer and Information Science (ICIS),,2014,,,363,368,"A large amount of software maintenance effort is spent on program comprehension. How to accurately and quickly get the functional features in a program becomes a hot issue in program comprehension. Some studies in this area are focused on extracting the topics by analyzing linguistic information in the source code based on the textual mining techniques. However, the extracted topics are usually composed of some standalone words and difficult to understand. In this paper, we attempt to solve this problem based on a novel program summarization technique. First, we propose to use latent semantic indexing and clustering to group source artifacts with similar vocabulary to analyze the composition of each package in the program. Then, some topics composed of a vector of independent words can be extracted based on latent semantic indexing. Finally, we employ Minipar, a nature language parser, to help generate the summaries. The summaries can effectively organize the words from the topics in the form of the predefined sentence based on some rules. With such form of summaries, developers can understand what the features the program has and their corresponding source artifacts.",,978-1-4799-4860,10.1109/ICIS.2014.6912159,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6912159,,Pragmatics;Semantics;Large scale integration;Matrix decomposition;Indexing;Software systems,data mining;grammars;indexing;pattern clustering;software maintenance;source code (software);text analysis;vocabulary,program comprehension;software maintenance effort;functional features;topic extraction;linguistic information analysis;source code;textual mining techniques;program summarization technique;latent semantic indexing;program summarization technique;latent semantic clustering;source artifacts;independent word vector extraction;Minipar;language parser,,2,20,,,,,IEEE,IEEE Conferences
Working session: Using eye-tracking to understand program comprehension,Y. Gueheneuc; H. Kagdi; J. I. Maletic,"Ptidej Team - DGIGL, École Polytechnique de Montréal, Quebec, Canada; Department of Computer Science, Missouri University of Science and Technology, Rolla, 65401, USA; Department of Computer Science, Kent State University, Ohio 44242, USA",2009 IEEE 17th International Conference on Program Comprehension,,2009,,,278,279,"The working session focuses on the use of eye-tracking technology to assess, understand, and evaluate tools and techniques for program comprehension. An introduction to the technology and tools of eye-tracking will be presented. A discussion of how these tools augment existing evaluation mechanism in the context of program comprehension will follow. Research directions and open problems will be a main topic.",1092-8138,978-1-4244-3998-0978-1-4244-3997,10.1109/ICPC.2009.5090057,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090057,,Humans;Computer science;Software engineering;Unified modeling language;Tracking;Physiology;Time measurement;Cameras;Psychology;Cognitive science,reverse engineering;software tools,program comprehension understanding;working session;eye-tracking technology;program tools,,3,9,,,,,IEEE,IEEE Conferences
Tree-matching object concept assignment to support program comprehension,Chen Hua; Qian Jianfei; Chen Qi; Yu Ruizhao,NA; NA; NA; NA,"Second IEEE International Conference on Computational Cybernetics, 2004. ICCC 2004.",,2004,,,249,251,"This paper outlines a method for assisting program comprehension by addressing the concept assignment problem. The method, termed tree-matching object concept assignment, uses information gathered from program execution to assign plausible object concept to source code. The candidate concepts are selected from knowledge base. An evaluation of prototype system has shown that the method can accurately recognize object concepts in a range of real-world programs",,0-7803-8588,10.1109/ICCCYB.2004.1437719,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1437719,,Software maintenance;Costs;Educational institutions;Computer science;Software systems;Software engineering;Prototypes;Typesetting;Desktop publishing;Application software,program diagnostics;reverse engineering;software maintenance,tree-matching object concept assignment;program comprehension;desktop publishing format;software maintenance,,,6,,,,,IEEE,IEEE Conferences
Working Session: Program Comprehension and Migration Strategies for Web Service and Service-Oriented Architectures,D. Smith; L. O'Brien; K. Kontogiannis,"Software Engineering Institute, USA; NA; NA",14th IEEE International Conference on Program Comprehension (ICPC'06),,2006,,,235,240,"The migration to Web services has the potential of providing significant value to keeping legacy systems and components operational in a networked environment, a number of critical issues still need to be addressed. These issues can be classified in three categories; a) program comprehension and analysis issues; b) legacy system migration issues and; c) technology and standards issues. This paper discusses and debates approaches for addressing these issues. The paper's objective is twofold. First, is to explore the current state of the art in methods, tools and technologies that can assist in carrying out the required work and to identify a taxonomy of current approaches as well as, their strengths and weaknesses. The second objective is to identify open issues and research opportunities in the area of migrating legacy systems in Web enabled environments",1092-8138,0-7695-2601,10.1109/ICPC.2006.52,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631126,,Web services;Service oriented architecture;Computer architecture;Object oriented modeling;Software engineering;Web and internet services;Taxonomy;Application software;Middleware;Decision making,Internet;reverse engineering;software architecture,program comprehension;Web service;service-oriented architecture;legacy system;legacy system migration;taxonomy,,,6,,,,,IEEE,IEEE Conferences
Building a research infrastructure for program comprehension observations,S. Lang; A. Von Mayrhauser,"Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA; NA",Proceedings Fifth International Workshop on Program Comprehension. IWPC'97,,1997,,,165,169,"Detailed program comprehension studies are expensive. Today, most of those studies are difficult to aggregate, as analysis methods for the data differ widely between researchers. As part of an effort to build a research infrastructure, a uniform, systematic analysis method for analyzing think-aloud protocols is proposed. This method is shown to be compatible with other analysis methods and extensible. It provides the possibility of aggregating results from experiments and leveraging results through such aggregation.",1092-8138,0-8186-7993,10.1109/WPC.1997.601287,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601287,,Protocols;Encoding;Computer science;Gratings;Programming profession;Software maintenance;Software tools;Guidelines;Documentation;Size control,reverse engineering,research infrastructure;program comprehension observations;program comprehension studies;systematic analysis method;think-aloud protocols;results aggregation,,1,12,,,,,IEEE,IEEE Conferences
An Empirical Study on the Impact of C++ Lambdas and Programmer Experience,P. M. Uesbeck; A. Stefik; S. Hanenberg; J. Pedersen; P. Daleiden,NA; NA; NA; NA; NA,2016 IEEE/ACM 38th International Conference on Software Engineering (ICSE),,2016,,,760,771,"Lambdas have seen increasing use in mainstream programming languages, notably in Java 8 and C++ 11. While the technical aspects of lambdas are known, we conducted the first randomized controlled trial on the human factors impact of C++ 11 lambdas compared to iterators. Because there has been recent debate on having students or professionals in experiments, we recruited undergraduates across the academic pipeline and professional programmers to evaluate these findings in a broader context. Results afford some doubt that lambdas benefit developers and show evidence that students are negatively impacted in regard to how quickly they can write correct programs to a test specification and whether they can complete a task. Analysis from log data shows that participants spent more time with compiler errors, and have more errors, when using lambdas as compared to iterators, suggesting difficulty with the syntax chosen for C++. Finally, experienced users were more likely to complete tasks, with or without lambdas, and could do so more quickly, with experience as a factor explaining 45.7% of the variance in our sample in regard to completion time.",1558-1225,978-1-4503-3900-1978-1-5090-2071,10.1145/2884781.2884849,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886954,Lambda Expressions;Human Factors;C++11,C++ languages;Java;Syntactics;Context;Algorithm design and analysis;Libraries,C++ language;formal specification,C++ lambda;programmer experience;mainstream programming languages;Java 8 languages;C++ 11 languages;test specification,,8,59,,,,,IEEE,IEEE Conferences
Source code comprehension analysis in software maintenance,N. A. Al-Saiyd,"Computer Science Department, Faculty of Information Technology Applied Science Private University, Amman-Jordan",2017 2nd International Conference on Computer and Communication Systems (ICCCS),,2017,,,1,5,"Source code comprehension is considered as an essential part of the software maintenance process. It is considered as one of the most critical and time-consuming task during software maintenance process. The difficulties of source code comprehension is analyzed. A static Bottom-up code comprehension model is used. The code is partitioned into functional-based blocks and their data and control dependencies that preserve the functionality of the program are analyzed. The data-flow and control-flow graphs reflects the dependencies and assist in refactoring process. The proposed strategy helps in improving the readability of the program code, increase maintainer productivity, and reducing the time and effort of code comprehension. It helps maintainers to locate the required lines of code that constitute the functional area that the maintainers are searching for in their maintenance work.",,978-1-5386-0539-4978-1-5386-0538-7978-1-5386-0537-0978-1-5386-0540,10.1109/CCOMS.2017.8075175,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8075175,source code comprehension;code comprehension;models;refactoring;effort estimation;source line of code (SLOC),Maintenance engineering;Computer languages;Software maintenance;Documentation;Software systems,data flow graphs;software maintenance;source code (software),source code comprehension analysis;software maintenance process;functional-based blocks;control dependencies;control-flow graphs;refactoring process;program code;maintenance work;data-flow graph;static bottom-up code comprehension model;code partitioning,,,18,,,,,IEEE,IEEE Conferences
"""Automatically Assessing Code Understandability"" Reanalyzed: Combined Metrics Matter",A. Trockman; K. Cates; M. Mozina; T. Nguyen; C. Kästner; B. Vasilescu,NA; NA; NA; NA; NA; NA,2018 IEEE/ACM 15th International Conference on Mining Software Repositories (MSR),,2018,,,314,318,"Previous research shows that developers spend most of their time understanding code. Despite the importance of code understandability for maintenance-related activities, an objective measure of it remains an elusive goal. Recently, Scalabrino et al. reported on an experiment with 46 Java developers designed to evaluate metrics for code understandability. The authors collected and analyzed data on more than a hundred features describing the code snippets, the developers' experience, and the developers' performance on a quiz designed to assess understanding. They concluded that none of the metrics considered can individually capture understandability. Expecting that understandability is better captured by a combination of multiple features, we present a reanalysis of the data from the Scalabrino et al. study, in which we use different statistical modeling techniques. Our models suggest that some computed features of code, such as those arising from syntactic structure and documentation, have a small but significant correlation with understandability. Further, we construct a binary classifier of understandability based on various interpretable code features, which has a small amount of discriminating power. Our encouraging results, based on a small data set, suggest that a useful metric of understandability could feasibly be created, but more data is needed.",2574-3864;2574-3848,978-1-4503-5716-6978-1-5386-6171,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8595214,code understandability;metric;reanalysis;statistical modeling;readability;classification;replication;program comprehension,Measurement;Java;Documentation;Principal component analysis;Data models;Computational modeling;Predictive models,Java;software maintenance;software metrics;statistical analysis,code snippets;interpretable code features;Java developers;metrics matter combination;assessing code understandability;statistical modeling techniques;syntactic structure;syntactic documentation;binary classifier,,,22,,,,,IEEE,IEEE Conferences
Program readability: procedures versus comments,T. Tenny,"Dept. of Comput. Sci., Texas Christian Univ., Fort Worth, TX, USA",IEEE Transactions on Software Engineering,,1988,14,9,1271,1279,"A 3*2 factorial experiment was performed to compare the effects of procedure format (none, internal, or external) with those of comments (absent or present) on the readability of a PL/1 program. The readability of six editions of the program, each having a different combination of these factors, was inferred from the accuracy with which students could answer questions about the program after reading it. Both extremes in readability occurred in the program editions having no procedures: without comments the procedureless program was the least readable and with comments it was the most readable.<<ETX>>",0098-5589;1939-3520;2326-3881,,10.1109/32.6171,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6171,,Testing;Programming profession;Software engineering;Proposals;Costs;Computer science,PL/1;programming,procedures;comments;factorial experiment;procedure format;PL/1 program;readability,,52,13,,,,,IEEE,IEEE Journals
Enhancing program readability and comprehensibility with tools for program visualization,R. Baecker,"Dept. of Comput. Sci., Toronto Univ., Ont., Canada",Proceedings. [1989] 11th International Conference on Software Engineering,,1988,,,356,366,"To make computer programs for comprehensible, the presentation of program source text, program documentation, and program execution needs to be enhanced. A number of techniques and tools developed to achieve these ends are described. One of these is a design for the effective presentation of source text in the C programming language using high-quality digital typography; a processor which implements the design is also given. Some experimental evidence is summarized to demonstrate that the resulting source text presentation is significantly more readable and comprehensible than the presentation conventionally used today. Brief descriptions are given of two other techniques, the development of a system of structured program documentation incorporating both text and graphics and the portrayal of program execution with colored computer animation.<<ETX>>",,0-89791-258,10.1109/ICSE.1988.93716,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=93716,,Visualization;Computer graphics;Animation;Computer interfaces;Software engineering;Programming profession;Computer languages;Writing;Computer aided software engineering;Computer science,software tools;system documentation,software tools;program readability;comprehensibility;program visualization;computer programs;program source text;program documentation;program execution;C programming language;high-quality digital typography;structured program documentation;graphics;program execution;colored computer animation,,8,66,,,,,IEEE,IEEE Conferences
Program factors as predictors of program readability,G. E. DeYoung; G. R. Kampen,St. Louis University; NA,"COMPSAC 79. Proceedings. Computer Software and The IEEE Computer Society's Third International Applications Conference, 1979.",,1979,,,668,673,"In comparison with such objective aspects of program quality as efficiency and correctness, readability is elusive and hard-to-measure. Since it is surely an important factor in the cost of maintaining a program over its lifetime, the usefulness of an accurate and inexpensive measure of readability is obvious. In an attempt to find such a measure, a set of 30 Algol 68 programs written by students in an upper-level course was graded by hand for readability and the results compared with a set of program parameters extracted by a SNOBOL program. Correlation and multiple regression techniques were used to test hypotheses suggested in the literature on program quality, and to find a combination of parameters with maximum predictive value. A set of three variables was found to be effective in predicting readability.",,,10.1109/CMPSAC.1979.762579,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=762579,,Psychology;Costs;Testing;Programming profession;Guidelines;Maintenance;Area measurement;Software measurement;Program processors;Feedback,,,,,14,,,,,IEEE,IEEE Conferences
Novice Code Understanding Strategies during a Software Maintenance Assignment,C. Szabo,NA,2015 IEEE/ACM 37th IEEE International Conference on Software Engineering,,2015,2,,276,284,"Existing efforts on teaching software maintenance have focussed on constructing adequate codebases that students with limited knowledge could maintain, with little focus on the learning outcomes of such exercises and of the approaches that students employ while performing maintenance. An analysis of the code understanding strategies employed by novice students as they perform software maintenance exercises is fundamental for the effective teaching of software maintenance. In this paper, we analyze the strategies employed by second year students in a maintenance exercise over a large codebase. We analyze student reflections on their code understanding, maintenance process and the use of tools. We show that students are generally capable of working with large codebases. Our study also finds that the majority of students follow a systematic approach to code understanding, but that their approach can be significantly improved through the use of tools and a better understanding of reverse engineering approaches.",0270-5257;1558-1225,978-1-4799-1934,10.1109/ICSE.2015.341,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202973,software maintenance;software engineering;cognitive models,Software maintenance;Maintenance engineering;Software engineering;Education;Testing;Systematics,computer science education;reverse engineering;software maintenance,novice code understanding strategies;software maintenance assignment;adequate codebases;learning outcomes;novice students;software maintenance exercises;second year students;reverse engineering approaches,,1,20,,,,,IEEE,IEEE Conferences
Reusing Program Investigation Knowledge for Code Understanding,M. P. Robillard; P. Manggala,NA; NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,202,211,"Software maintenance tasks typically involve an important amount of program investigation effort on the part of software developers. To what extent can we benefit from prior program investigation activities to decrease this effort? To investigate this question, we studied the revision history of two systems to determine how knowledge derived from prior investigation activities could have been reused to support other change tasks. Our initial investigation used a tool, ConcernDetector, that can recommend sets of program elements associated with a high-level concern when elements in the set overlap with elements currently being modified. We discovered that simple overlap-based techniques for retrieving prior investigation knowledge have important limitations, and that effective reuse of prior program investigation knowledge requires analyses that can partially infer the nature and intent of a task.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.10,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556132,Program Investigation;Concerns;Software Navigation;Knowledge Reuse,Software maintenance;History;Documentation;Computer science;Software systems;Computer bugs;Joining processes;Open source software;Context modeling,software maintenance,program investigation knowledge;code understanding;software maintenance;software developers;ConcernDetector;high-level concern;overlap-based techniques,,4,22,,,,,IEEE,IEEE Conferences
From code understanding needs to reverse engineering tool capabilities,A. von Mayrhauser; A. M. Vans,"Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA; NA",Proceedings of 6th International Workshop on Computer-Aided Software Engineering,,1993,,,230,239,"A major portion of the software maintenance effort is spent on the reverse engineering activity of understanding existing software. If one can learn more about how programmers understand code successfully, one can build better tools to support the understanding process. This contributes to higher quality and improved efficiency of maintenance tasks. An integrated code comprehension model and experiences with it in an industrial setting are presented. Audio-taped, think-aloud reports were used to investigate how well the integrated code comprehension model works during industrial maintenance activities that range from code fixes to enhancements, code leverage, and reuse. The tapes were analyzed for information needs during maintenance activities, and tool capabilities were derived accordingly. The results are presented and discussed.",1066-1387,0-8186-3480,10.1109/CASE.1993.634824,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=634824,,Programming profession;Cognition;Switches;Computer science;Software maintenance;Reverse engineering;Information analysis;Computer industry;Electrical equipment industry;Large-scale systems,reverse engineering,audio-taped think-aloud reports;code enhancements;code reuse;understanding needs;reverse engineering tool capabilities;software maintenance;quality;efficiency;integrated code comprehension model;industrial maintenance activities;code fixes;code leverage;information needs,,24,22,,,,,IEEE,IEEE Conferences
Code understanding through program transformation for reusable component identification,Hongj Yang; P. Luker; W. C. Chu,"Dept. of Comput. Sci., De Montfort Univ., Leicester, UK; NA; NA",Proceedings Fifth International Workshop on Program Comprehension. IWPC'97,,1997,,,148,157,"Code understanding is the most essential step in all post delivery software activities such as software maintenance and reuse. In the Reverse-engineering Reuse Redevelopment Assistant (R/sup 3/ A), a tool aimed at providing a comprehensive approach for all post delivery software activities, code understanding has been addressed by reverse engineering through program transformation. The paper proposes a method to deal with this problem and discusses in detail how program transformation techniques, program comprehension techniques and the role of human knowledge are integrated into R/sup 3/ A, i.e., how they are used during reverse engineering to recognise reusable components, and how they are used by semantic interface analysis to represent formally reusable components. The experiments conducted strongly suggest the proposed method is a practical approach to software reuse.",1092-8138,0-8186-7993,10.1109/WPC.1997.601283,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601283,,Software maintenance;Reverse engineering;Information resources;Software tools;Humans;Computer science;Recycling;Costs;Hardware;Software testing,reverse engineering;software maintenance;software reusability;software tools;formal specification,code understanding;program transformation;reusable component identification;post delivery software activities;software maintenance;Reverse-engineering Reuse Redevelopment Assistant;R/sup 3/ A;reverse engineering;program comprehension techniques;human knowledge;reusable components;semantic interface analysis;formally reusable components;software reuse,,3,20,,,,,IEEE,IEEE Conferences
Improving code readability models with textual features,S. Scalabrino; M. Linares-Vásquez; D. Poshyvanyk; R. Oliveto,"University of Molise, Pesche (IS), Italy; The College of William and Mary, Williamsburg, Virginia, USA; The College of William and Mary, Williamsburg, Virginia, USA; University of Molise, Pesche (IS), Italy",2016 IEEE 24th International Conference on Program Comprehension (ICPC),,2016,,,1,10,"Code reading is one of the most frequent activities in software maintenance; before implementing changes, it is necessary to fully understand source code often written by other developers. Thus, readability is a crucial aspect of source code that may significantly influence program comprehension effort. In general, models used to estimate software readability take into account only structural aspects of source code, e.g., line length and a number of comments. However, source code is a particular form of text; therefore, a code readability model should not ignore the textual aspects of source code encapsulated in identifiers and comments. In this paper, we propose a set of textual features aimed at measuring code readability. We evaluated the proposed textual features on 600 code snippets manually evaluated (in terms of readability) by 5K+ people. The results demonstrate that the proposed features complement classic structural features when predicting code readability judgments. Consequently, a code readability model based on a richer set of features, including the ones proposed in this paper, achieves a significantly higher accuracy as compared to all of the state-of-the-art readability models.",,978-1-5090-1428,10.1109/ICPC.2016.7503707,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7503707,,Feature extraction;Syntactics;Visualization;Computational modeling;Semantics;Software quality,software maintenance;source code (software);text analysis,code readability models;textual features;software maintenance;source code;program comprehension effort;software readability;line length;code snippets,,15,46,,,,,IEEE,IEEE Conferences
Improving Source Code Readability: Theory and Practice,S. Fakhoury; D. Roy; A. Hassan; V. Arnaoudova,Washinton State University; Washington State University; Infosapex Limited; Washington State University,2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC),,2019,,,2,12,"There are several widely accepted metrics to measure code quality that are currently being used in both research and practice to detect code smells and to find opportunities for code improvement. Although these metrics have been proposed as a proxy of code quality, recent research suggests that more often than not, state-of-the-art code quality metrics do not successfully capture quality improvements in the source code as perceived by developers. More specifically, results show that there may be inconsistencies between, on the one hand, the results from metrics for cohesion, coupling, complexity, and readability, and, on the other hand, the interpretation of these metrics in practice. As code improvement tools rely on these metrics, there is a clear need to identify and resolve the aforementioned inconsistencies. This will allow for the creation of tools that are more aligned with developers' perception of quality, and can more effectively help source code improvement efforts. In this study, we investigate 548 instances of source code readability improvements, as explicitly stated by internal developers in practice, from 63 engineered software projects. We show that current readability models fail to capture readability improvements. We also show that tools to calculate additional metrics, to detect refactorings, and to detect style problems are able to capture characteristics that are specific to readability changes and thus should be considered by future readability models.",2643-7171;2643-7147,978-1-7281-1519-1978-1-7281-1520,10.1109/ICPC.2019.00014,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813254,Readability;Code Quality metrics;Developers perception,,,,,,34,,,,,IEEE,IEEE Conferences
"Code Readability Testing, an Empirical Study",T. Sedano,NA,2016 IEEE 29th International Conference on Software Engineering Education and Training (CSEET),,2016,,,111,117,"Context: One of the factors that leads to improved code maintainability is its readability. When code is difficult to read, it is difficult for subsequent developers to understand its flow and its side effects. They are likely to introduce new bugs while trying to fix old bugs or adding new features. But how do software developers know they have written readable code? Objective: This paper presents a new technique, Code Readability Testing, to determine whether code is readable and evaluates whether the technique increases programmers' ability to write readable code. Method: The researcher conducted a field study using 21 software engineering master students and followed the Code Readability Testing with each student in four separate sessions evaluating different ""production ready"" software. After the observations, a questionnaire evaluated the programmer's perspective. Results: By following Code Readability Testing, half of the programmers writing ""unreadable"" code started writing ""readable"" code after four sessions. Programmers writing ""readable"" code also improved their ability to write readable code. The study reveals that the most frequent suggestions for increasing code readability are improving variable names, improving method names, creating new methods in order to reduce code duplication, simplifying if conditions and structures, and simplifying loop conditions. The programmers report that readability testing is worth their time. They observe increases in their ability to write readable code. When programmers experience a reader struggling to understand their code, they become motivated to write readable code. Conclusion: This paper defines code readability, demonstrates that Code Readability Testing improves programmers' ability to write readable code, and identifies frequent fixes needed to improve code readability.",2377-570X,978-1-5090-0765-3978-1-5090-0764,10.1109/CSEET.2016.36,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7474473,,Testing;Software;Programming profession;Writing;Software engineering;Computers,computer science education;program control structures;software maintenance,code readability testing;code maintainability;readable code;code duplication reduction;loop conditions;software engineering master students,,3,30,,,,,IEEE,IEEE Conferences
Automatically Assessing Code Understandability,S. Scalabrino; G. Bavota; C. Vendome; M. Linares-V?squez; D. Poshyvanyk; R. Oliveto,"Biosciences and Territory, Universita degli Studi del Molise, 18960 Pesche, IS Italy (e-mail: simone.scalabrino@unimol.it); Faculty of Informatics, Universita della Svizzera Italiana, 27216 Lugano, Lugano Switzerland 6904 (e-mail: gabriele.bavota@usi.ch); Computer Science and Software Engineering, Miami University, 6403 Oxford, Ohio United States (e-mail: cgvendome@email.wm.edu); Systems Engineering and Computing, Universidad de los Andes, 27991 Bogota, Bogota Colombia (e-mail: m.linaresv@uniandes.edu.co); Computer Science Department, College of William and Mary, 8604 Williamsburg, Virginia United States (e-mail: denys@cs.wm.edu); Biosciences and Territory, Universita degli Studi del Molise, 18960 Pesche, IS Italy (e-mail: rocco.oliveto@unimol.it)",IEEE Transactions on Software Engineering,,2019,PP,99,1,1,"Understanding software is an inherent requirement for many maintenance and evolution tasks. Without a thorough understanding of the code, developers would not be able to fix bugs or add new features timely. Measuring code understandability might be useful to guide developers in writing better code, and could also help in estimating the effort required to modify code components. Unfortunately, there are no metrics designed to assess the understandability of code snippets. In this work, we perform an extensive evaluation of 121 existing as well as new code-related, documentation-related, and developer-related metrics. We try to (i) correlate each metric with understandability and (ii) build models combining metrics to assess understandability. To do this, we use 444 human evaluations from 63 developers and we obtained a bold negative result: none of the 121 experimented metrics is able to capture code understandability, not even the ones assumed to assess quality attributes apparently related, such as code readability and complexity. While we observed some improvements while combining metrics in models, their effectiveness is still far from making them suitable for practical applications. Finally, we conducted interviews with five professional developers to understand the factors that influence their ability to understand code snippets, aiming at identifying possible new metrics.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2019.2901468,Schweizerischer Nationalfonds zur Förderung der Wissenschaftlichen Forschung; ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8651396,Software metrics;Code understandability;Empirical study;Negative result,Complexity theory;Software;Computer bugs;Readability metrics;Software measurement;Indexes,,,,,,,,,,IEEE,IEEE Early Access Articles
Recognizing Sorting Algorithms with the C4.5 Decision Tree Classifier,A. Taherkhani,NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,72,75,"We present a method for automatic algorithm recognition, which consists of two phases. First, the target algorithms are converted into characteristic vectors, which are computed based on static analysis of program code including various statistics of language constructs and analysis of Roles of Variables. In the second phase, the algorithms are classified based on these vectors using the C4.5 decision tree classifier. We have developed a prototype and successfully applied the method to sorting algorithms. Evaluated with leave-one-out technique, the accuracy of the constructed decision tree classifier is 97.1%.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.11,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521763,Algorithm recognition;program comprehension;program understanding;roles of variables;C4.5 algorithm,Sorting;Decision trees;Classification tree analysis;Algorithm design and analysis;Statistical analysis;Computer science;Prototypes;Computational complexity;Computer languages;Programming profession,decision trees;pattern classification;sorting;statistical analysis,sorting algorithms;algorithm recognition;C4.5 decision tree classifier;language constructs statistics;program code analysis;roles-of-variables analysis;leave-one-out technique,,4,23,,,,,IEEE,IEEE Conferences
"An Exploratory Study of How Developers Seek, Relate, and Collect Relevant Information during Software Maintenance Tasks",A. J. Ko; B. A. Myers; M. J. Coblenz; H. H. Aung,"Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, 5000 Forbes Ave., Pittsburgh, PA 15213; Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, 5000 Forbes Ave., Pittsburgh, PA 15213; mcoblenz@andrew.cmu.edu; hhaung@gmail.com",IEEE Transactions on Software Engineering,,2006,32,12,971,987,"Much of software developers' time is spent understanding unfamiliar code. To better understand how developers gain this understanding and how software development environments might be involved, a study was performed in which developers were given an unfamiliar program and asked to work on two debugging tasks and three enhancement tasks for 70 minutes. The study found that developers interleaved three activities. They began by searching for relevant code both manually and using search tools; however, they based their searches on limited and misrepresentative cues in the code, environment, and executing program, often leading to failed searches. When developers found relevant code, they followed its incoming and outgoing dependencies, often returning to it and navigating its other dependencies; while doing so, however, Eclipse's navigational tools caused significant overhead. Developers collected code and other information that they believed would be necessary to edit, duplicate, or otherwise refer to later by encoding it in the interactive state of Eclipse's package explorer, file tabs, and scroll bars. However, developers lost track of relevant code as these interfaces were used for other tasks, and developers were forced to find it again. These issues caused developers to spend, on average, 35 percent of their time performing the mechanics of navigation within and between source files. These observations suggest a new model of program understanding grounded in theories of information foraging and suggest ideas for tools that help developers seek, relate, and collect information in a more effective and explicit manner",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2006.116,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4016573,Program investigation;program understanding;program comprehension;empirical software engineering;information foraging;information scent.,Software maintenance;Programming;Navigation;Software engineering;Software tools;Performance gain;Debugging;Encoding;Packaging;Bars,program debugging;software maintenance,software maintenance tasks;software development environment;debugging task;search tool;Eclipse package explorer;file tabs;scroll bars;source files;program understanding;information foraging,,241,51,,,,,IEEE,IEEE Journals
Behavioural validation of software engineering artefacts,G. de Caso,"Universidad de Buenos Aires, Buenos Aires, Argentina",2010 ACM/IEEE 32nd International Conference on Software Engineering,,2010,2,,505,506,"Software engineering artefacts that define behaviour tend to be of a fragmented nature in order to facilitate their construction, modification, and modular reasoning (e.g. modular code, pre/post-conditions specifications). However, fragmentation makes the validation of global behaviour difficult. Typically synthesis techniques that yield global representations of large or infinite states are used in combination with simulation or partial explorations, techniques which necessarily lose the global view of system behaviour. I am working on the development of abstraction-for-validation techniques that automatically produce finite state abstractions that are sufficiently small to support validating the emergent behaviour of a fragmented description ""at a glance"".",1558-1225;0270-5257,978-1-60558-719,10.1145/1810295.1810453,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6062270,behaviour models;code understanding;contract conformance,Contracts;Software engineering;Analytical models;Software;Cognitive science;Protocols;Complexity theory,,,,,10,,,,,IEEE,IEEE Conferences
Behavioural validation of software engineering artefacts,G. de Caso,"Universidad de Buenos Aires, Buenos Aires, Argentina",2010 ACM/IEEE 32nd International Conference on Software Engineering,,2010,2,,335,336,"Software engineering artefacts that define behaviour tend to be of a fragmented nature in order to facilitate their construction, modification, and modular reasoning (e.g. modular code, pre/post-conditions specifications). However, fragmentation makes the validation of global behaviour difficult. Typically synthesis techniques that yield global representations of large and potentially infinite states are used in combination with simulation, animation or partial explorations, techniques which necesarily loose the global view of system behaviour. I aim to develop abstraction-for-validation techniques that automatically produce finite state abstractions that are sufficiently small to support validating the emergent behaviour of a fragmented description ""at a glance"".",1558-1225;0270-5257,978-1-60558-719,10.1145/1810295.1810380,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6062202,behaviour models;code understanding;contract conformance,Contracts;Software engineering;Analytical models;Software;Cognitive science;Complexity theory;Approximation methods,approximation theory;software engineering,software engineering artefact;behavioural validation;abstraction-for-validation technique;finite state abstraction;finite state approximation,,,8,,,,,IEEE,IEEE Conferences
Reordering Program Statements for Improving Readability,Y. Sasaki; Y. Higo; S. Kusumoto,NA; NA; NA,2013 17th European Conference on Software Maintenance and Reengineering,,2013,,,361,364,"In order to understand source code, humans sometimes execute the program in their mind. When they illustrate the program execution in their mind, it is necessary to memorize what values all the variables are along with the execution. If there are many variables in the program, it is hard to their memorization. However, it is possible to ease to memorize them by shortening the distance between the definition of a variable and its reference if they are separated in the source code. This paper proposes a technique reordering statements in a module by considering how far the definition of a variable is from its references. We applied the proposed technique to a Java OSS and collected human evaluations for the reordered methods. As a result, we could confirm that the reordered methods had better readability than their originals. Moreover, we obtained some knowledge of human consideration about the order of statements.",1534-5351,978-0-7695-4948-4978-1-4673-5833,10.1109/CSMR.2013.50,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6498489,source code readability;source code analysis;software tool;arranging program statements,Java;Correlation;Software maintenance;Educational institutions;Software metrics;Europe,Java;public domain software;software maintenance,program statement reordering;program execution;program memorization;Java OSS;open-source software;software maintainance;source code readability,,2,7,,,,,IEEE,IEEE Conferences
Theory and practice of middle-out programming to support program understanding,K. H. Bennett; M. P. Ward,"Dept. of Comput. Sci., Durham Univ., UK; Dept. of Comput. Sci., Durham Univ., UK",Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94,,1994,,,168,175,"Theories of top-down and bottom-up program comprehension have existed for several years, but it has been recognised that understanding rarely happens in practice in such a well-ordered way. The paper describes recent work and results at Durham on what is termed middle-out programming. The objective is to avoid the problems of top-down and bottom-up approaches, by designing a very high level language specific to the application domain. Domain knowledge is captured in the design of this language, which retains a strong formal basis. This paper takes the view that software engineering will become strongly application domain based, and that knowledge representation of the domain will be a crucial factor in supporting program comprehension. An example of using this approach in the design of a large software system is presented.<<ETX>>",1092-8138,0-8186-5647,10.1109/WPC.1994.341267,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341267,,Computer science;Software engineering;Large-scale systems;Application software;Software systems;High level languages;Knowledge representation;Domain specific languages;Formal languages;Concurrent engineering,programming;reverse engineering;high level languages,middle-out programming;program understanding;top-down program comprehension;bottom-up program comprehension;very high level language;domain knowledge;software engineering;knowledge representation;program comprehension;large software system design,,4,19,,,,,IEEE,IEEE Conferences
On the role of program understanding in re-engineering tasks,A. Von Mayrhauser; A. M. Vaus,"Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA; Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA",1996 IEEE Aerospace Applications Conference. Proceedings,,1996,2,,253,267 vol.2,"This paper reports on a software understanding experiment during re-engineering of large-scale software. Participants were professional software maintenance engineers. The paper explains the general understanding process, the information needs of these software engineers during their tasks, and the tool capabilities that would help them to be more productive.",,0-7803-3196,10.1109/AERO.1996.495930,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=495930,,Programming profession;Object oriented modeling;Large scale integration;Computer science;Application software;Large-scale systems;Software maintenance;Software tools;Filters;Software performance,systems re-engineering;software maintenance;reverse engineering,program understanding;re-engineering tasks;professional software maintenance engineers;information needs;tool capabilities;comprehension model,,5,24,,,,,IEEE,IEEE Conferences
Program understanding as constraint satisfaction,S. Woods; Qiang Yang,"Dept. of Comput. Sci., Waterloo Univ., Ont., Canada; Dept. of Comput. Sci., Waterloo Univ., Ont., Canada",Proceedings of 2nd Working Conference on Reverse Engineering,,1995,,,314,323,"The process of understanding a source code in a high-level programming language involves complex computation. Given a piece of legacy code and a library of program plan templates, understanding the code corresponds to building mappings from parts of the source code to particular program plans. These mappings could be used to assist an expert in reverse engineering legacy code, to facilitate software reuse, or to assist in the translation of the source into another programming language. In this paper, we present a model of program understanding using constraint satisfaction. Within this model, we intelligently compose a partial global picture of the source program code by transforming knowledge about the problem domain and the program itself into sets of constraints. We then systematically study different search algorithms and empirically evaluate their performance. One advantage of the constraint satisfaction model is its generality; many previous attempts in program understanding could now be cast under the same spectrum of heuristics, and thus be readily compared. Another advantage is the improvement in search efficiency using various heuristic techniques in constraint satisfaction.",,0-8186-711-,10.1109/WCRE.1995.514719,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=514719,,Computer languages;Humans;Libraries;Computer science;Intelligent agent;Software engineering;Debugging;Logic programming;Costs;Artificial intelligence,reverse engineering;constraint handling;search problems;heuristic programming;software libraries;software reusability,program understanding;constraint satisfaction;source code understanding;high-level programming language;complex computation;legacy code;program plan template library;mappings;software reuse;program translation;partial global picture;problem domain knowledge transformation;search algorithms;performance evaluation;heuristic techniques;search efficiency,,2,20,,,,,IEEE,IEEE Conferences
A toolset for program understanding,P. E. Livadas; S. D. Alden,"Comput. & Inf. Sci., Florida Univ., Gainesville, FL, USA; Comput. & Inf. Sci., Florida Univ., Gainesville, FL, USA",[1993] IEEE Second Workshop on Program Comprehension,,1993,,,110,118,"Program understanding is associated with the hierarchy of abstractions and interpretations that are deduced from the code. Program understanding requires the identification and study of the numerous complex interrelationships that are induced by the data flow, calling, and functional dependencies that exist in the software. Therefore, an environment is needed in order aid the programmer in understanding software. The authors have previously discussed both an internal program representation and an environment that conforms to the requirements stated. The toolset is referred to as Ghinsu and it supports a number of tasks over a program written in a subset of ANSI C such as slicing, dicing, and ripple analysis. They present some background on the problems associated with program understanding and show how the Ghinsu toolset can aid the programmer in understanding software.<<ETX>>",1092-8138,0-8186-4042,10.1109/WPC.1993.263900,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263900,,Software maintenance;Costs;Programming profession;Intellectual property;Control systems;Software tools;Life estimation;Lifetime estimation;Computer aided instruction;Military computing,software maintenance;software tools,program understanding;data flow;calling;functional dependencies;understanding software;internal program representation;ANSI C;slicing;dicing;ripple analysis,,6,19,,,,,IEEE,IEEE Conferences
Jan - Java animation for program understanding,K. -. Lohr; A. Vratislavsky,"Freie Univ. Berlin, Germany; NA","IEEE Symposium on Human Centric Computing Languages and Environments, 2003. Proceedings. 2003",,2003,,,67,75,"Jan is a system for animated execution of Java programs. Its application area is program understanding rather than debugging. To this end, the animation can be customized, both by annotating the code with visualization directives and by interactively adapting the visual appearance to the user's personal taste. Object diagrams and sequence diagrams are supported. Scalability is achieved by recognizing object composition: object aggregates are displayed in a nested fashion; mechanisms for collapsing and exploding aggregates are provided. Jan has been applied to itself producing an animation of its visualization back-end.",,0-7803-8225,10.1109/HCC.2003.1260205,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1260205,,Java;Animation;Aggregates;Unified modeling language;Debugging;Scalability;Instruments;Data visualization;Displays;Collaboration,Java;reverse engineering;computer animation;program visualisation;diagrams;object-oriented programming,Jan;Java animation;program understanding;animated Java program execution;object diagrams;sequence diagrams;object composition;object aggregates;program visualization,,3,17,,,,,IEEE,IEEE Conferences
A graphics-based system that supports the program understanding process,B. R. Rimes,"Dept. of Comput. Sci., Univ. of Southern Mississippi, Hattiesburg, MS, USA",Systems Integration '90. Proceedings of the First International Conference on Systems Integration,,1990,,,117,124,"A visual system called PEEC (program execution environment configuration) that is designed to support the program understanding process through the use of the program's flow model represented in three-dimensional space is described. PEEC augments the control model by localizing source code and displaying identifiers based on their scope definition. The building blocks, tiers, used to construct a graphical model of the program's execution flow are defined. The format of the flow model in three-dimensional space is also defined. The tiers and the three-dimensional configuration of these tiers form the basis for the graphical representation of the program's execution environment. Examples of the flow model are provided that demonstrate the user's options as he/she browses the flow model.<<ETX>>",,0-8186-9027,10.1109/ICSI.1990.138671,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=138671,,Programming profession;Computer science;Visual system;Graphics;Three dimensional displays;Control systems,computer graphics;configuration management;programming environments;visual programming,graphics-based system;program understanding process;visual system;PEEC;program execution environment configuration;flow model;three-dimensional space;control model;source code;identifiers;scope definition;building blocks;tiers;graphical model;execution flow;three-dimensional configuration,,,9,,,,,IEEE,IEEE Conferences
Lackwit: A Program Understanding Tool Based on Type Inference,R. O'Callahan; D. Jackson,"School of Computer Science, Carnegie Mellon University; NA",Proceedings of the (19th) International Conference on Software Engineering,,1997,,,338,348,,0270-5257,0-89791-914,10.1145/253228.253351,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=610284,,Computer science;Data structures;Prototypes;Inference algorithms,"restructuring, abstraction, C, representation",,,23,17,,,,,IEEE,IEEE Conferences
The relationship of slicing and debugging to program understanding,M. A. Francel; S. Rugaber,"Dept. of Math. & Comput. Sci., Citadel Coll., Charleston, SC, USA; NA",Proceedings Seventh International Workshop on Program Comprehension,,1999,,,106,113,"The paper describes a study that explores the relationship between program slicing and code understanding gained while debugging. The study consisted of an experiment that compared the program understanding abilities of two classes of debuggers: those who slice while debugging and those who do not. For debugging purposes, a slice can be thought of as a minimal subprogram of the original code that contains the program faults. Those who only examine statements within a slice for correctness are considered slicers; all others are considered non-slicers. Using accuracy of reconstruction as a measure of understanding, it was determined that slicers have a better understanding of the code after debugging.",1092-8138,0-7695-0180,10.1109/WPC.1999.777749,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=777749,,Debugging;Terminology;Mathematics;Computer science;Educational institutions;Fault diagnosis;IEEE standard glossaries,reverse engineering;program slicing;program debugging,program understanding;debugging;program slicing;code understanding;minimal subprogram;program faults,,3,9,,,,,IEEE,IEEE Conferences
Model-based tools to record program understanding,E. J. Younger; K. H. Bennett,"Sch. of Eng. & Comput. Sci., Durham Univ., UK; Sch. of Eng. & Comput. Sci., Durham Univ., UK",[1993] IEEE Second Workshop on Program Comprehension,,1993,,,87,95,Tools to record the knowledge gained by maintainers engaged in understanding an existing program are described. These tools are based on a model of the comprehension process and of reverse engineering as a whole. They form a part of an integrated reverse engineering toolset based around a central repository. Using these tools new documentation for an existing software system may be built up incrementally by successive maintainers who work on the system.<<ETX>>,1092-8138,0-8186-4042,10.1109/WPC.1993.263902,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263902,,Documentation;Application software;Software maintenance;Reverse engineering;Maintenance engineering;Knowledge engineering;Computer science;Software systems;Software quality;Software tools,software maintenance;software tools;system documentation,maintenance;program understanding;comprehension process;reverse engineering;central repository;documentation,,11,24,,,,,IEEE,IEEE Conferences
Augmenting abstract syntax trees for program understanding,C. A. Welty,"Dept. of Comput. Sci., Vassar Coll., Poughkeepsie, NY, USA",Proceedings 12th IEEE International Conference Automated Software Engineering,,1997,,,126,133,"Program understanding efforts by individual maintainers are dominated by a process known as discovery, which is characterized by low-level searches through the source code and documentation to obtain information that is important to the maintenance task. Discovery is complicated by the delocalization of information in the source code, and can consume from 40-60% of a maintainer's time. This paper presents an ontology for representing code-level knowledge based on abstract syntax trees, that was developed in the context of studying maintenance problems in a small software company. The ontology enables the utilization of automated reasoning to counter delocalization, and thus to speed up discovery.",,0-8186-7961,10.1109/ASE.1997.632832,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=632832,,Software maintenance;Laboratories;Ontologies;Software systems;Computer industry;Industrial training;Educational institutions;Computer science;Documentation;Counting circuits,reverse engineering;software maintenance;trees (mathematics);knowledge representation;inference mechanisms;computer aided software engineering,abstract syntax trees;program understanding;software maintenance;discovery;low-level searches;source code;documentation;information delocalization;code-level knowledge representation;automated reasoning;software information systems,,15,23,,,,,IEEE,IEEE Conferences
Assessment of support for program understanding,Eun Man Choi; A. von Mayrhauser,"Dept. of Comput. Sci., Illinois Inst. of Technol., Chicago, IL, USA; NA",[1992] Proceedings of the Second Symposium on Assessment of Quality Software Development Tools,,1992,,,102,111,"Discusses tools for program understanding during the software maintenance phase. The program understanding is crucial to successful maintenance, but it is still poorly supported by analysis-oriented tools. In the light of cognitive studies for program understanding, the authors assess the existing tools for program understanding, and suggest an approach which facilitates the understanding of complex code during maintenance via the chunking process. During this process programmers recognize the abstract function or meaning of groups of statements and then piece together these chunks to form even larger chunks until the entire code is understood and mapped out. Chunking support can be effective as part of a maintenance toolkit. It lets maintenance personnel control code abstraction and ask many semantic questions about chunks and their relationship to other parts of the code.<<ETX>>",,0-8186-2620,10.1109/AQSDT.1992.205843,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=205843,,Software maintenance;Programming profession;Computer science;Pattern recognition;Personnel;Software testing;Application software;Computer architecture;Productivity;Character recognition,human factors;software maintenance;software tools,software tools;program understanding;software maintenance;cognitive studies;chunking process;personnel;code abstraction,,1,31,,,,,IEEE,IEEE Conferences
JACKAL: a hierarchical approach to program understanding,A. A. Reeves; J. D. Schlesinger,"IDA/Center for Comput. Sci., USA; NA",Proceedings of the Fourth Working Conference on Reverse Engineering,,1997,,,84,93,"We present a tool, JACKAL, that represents both a program and cliches in an abstract language (AL) expressly developed for the purpose of facilitating the cliche matching task at a very high level rather than using abstract syntax trees. We then apply various matching algorithms to the AL representation. The language and two algorithms are presented.",,0-8186-8162,10.1109/WCRE.1997.624579,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=624579,,Vegetation mapping;Libraries;Data structures;Pattern recognition;Size control;Lab-on-a-chip;Programming profession;Performance analysis;Reverse engineering;Pattern matching,reverse engineering;pattern matching;software libraries;formal languages,JACKAL;hierarchical approach;program understanding;cliches;abstract language;cliche matching task;high level;matching algorithms;AL representation,,5,16,,,,,IEEE,IEEE Conferences
Program understanding: Challenge for the 1990s,T. A. Corbi,"IBM Data Systems Division, P.O. Box 390, Poughkeepsie, New York 12602, USA",IBM Systems Journal,,1989,28,2,294,306,"In the Program Understanding Project at IBM's Research Division, work began in late 1986 on tools which could help programmers in two key areas: static analysis (reading the code) and dynamic analysis (running the code). The work is reported in the companion papers by Cleveland and by Pazel in this issue. The history and background which motivated and which led to the start of this research on tools to assist programmers in understanding existing program code is reported here.",0018-8670,,10.1147/sj.282.0294,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5387570,,,,,,111,,,,,,IBM,IBM Journals
Towards Trace Based Model Synthesis for Program Understanding and Test Automation,T. Kanstren,VTT Technical Research Centre of Finland,International Conference on Software Engineering Advances (ICSEA 2007),,2007,,,46,46,"Effective maintenance and evolution of complex, software intensive systems requires understanding how the system works and having tests available to verify the effects of changes. Understanding complex systems is difficult, and testability of these systems is often low due to design constraints, system complexity and long- term evolution. Thus understanding the system and adding new tests is difficult. Yet, especially in these cases, the understanding and tests are important to verify the system correctness over long-term evolution. This paper discusses synthesizing models from system traces and using these models to facilitate program understanding and test automation. Basing the models on execution traces allows generation of automated tests even for low testability systems. Generating and visualizing abstracted models facilitates program understanding, which helps in system maintenance.",,0-7695-2937-2978-0-7695-2937,10.1109/ICSEA.2007.80,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4299927,,Automatic testing;Automation;System testing;Instruments;Software testing;Software maintenance;Software systems;Visualization;Real time systems;Control systems,program diagnostics;program testing,program understanding;test automation;trace based model synthesis;software intensive system,,1,26,,,,,IEEE,IEEE Conferences
Improving program understanding by unfolding layers of interacting patterns,R. R. Klosch; R. T. Mittermeir,"Dept. of Inf. & Comput. Sci., California Univ., Irvine, CA, USA; NA",WPC '96. 4th Workshop on Program Comprehension,,1996,,,208,217,"Reverse engineering of legacy systems is a cumbersome task. Some of its aspects can be automated reasonably well, others are better not touched or require the intervention of a human expert. In an attempt to improve our rearchitecturing methodology, COREM, we found that various patterns, software developers use or have to use when developing systems, can serve to support the program understanding part of the reverse engineering process. We depart from the widely accepted hypothesis that software developed by experts is not a mere sequence of relatively primitive statements, but rather the result of a set of interacting, time and situation specific problem, design, and language patterns. To support these considerations, the paper shows how different language paradigms influence the actual code even with a simple problem. The extension of these ideas to interacting high level design patterns is motivated.",1092-8138,0-8186-7283,10.1109/WPC.1996.501135,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501135,,Reverse engineering;Application software;Programming profession;Software systems;Computer science;Informatics;Humans;Error analysis;Image analysis;Information analysis,reverse engineering;software reusability;automatic programming;software tools,program understanding;reverse engineering;legacy systems;rearchitecturing methodology;COREM;reverse engineering process;situation specific problem;language patterns;language paradigms;interacting high level design patterns,,1,31,,,,,IEEE,IEEE Conferences
A program understanding support environment,L. Cleveland,"IBM Research Division, T. J. Watson Research Center, P.O. Box 704, Yorktown Heights, New York 10598, USA",IBM Systems Journal,,1989,28,2,324,344,"Software maintenance represents the largest cost element in the life of a software system, and the process of understanding the software system utilizes 50 percent of the time spent on software maintenance. Thus there is a need for tools to aid the program understanding task. The tool described in this paper—program UNderstanding Support environment (PUNS)—provides the needed environment. Here the program understanding task is supported with multiple views of the program and a simple strategy for moving between views and exploring a particular view in depth. PUNS consists of a repository component that loads and manages a repository of information about the program to be understood and a user interface component that presents the information in the repository, utilizing graphics to emphasize the relationships and allowing the user to move among the pieces of information quickly and easily.",0018-8670,,10.1147/sj.282.0324,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5387572,,,,,,14,,,,,,IBM,IBM Journals
Applying the signature concept to plan-based program understanding,Y. Limpiyakorn; I. Burnstein,"Dept. of Comput. Eng., Chulalongkorn Univ., Bangkok, Thailand; NA","International Conference on Software Maintenance, 2003. ICSM 2003. Proceedings.",,2003,,,325,334,"Program understanding tools that are able to process large legacy systems are needed to support software engineers with maintenance tasks. One type of tool, a plan-based program understander, recognizes concepts in the code by comparing the target code against a library of programming plans. For a large plan library, an exhaustive search for a matching plan during concept recognition is not effective. This drawback limits the practical scalability of these types of tools. We propose a signature-based approach to prune the plan library. A signature in this work is a set of high level attributes derived from code features suggested by studies on human program comprehension. A SIGMA prototype is implemented to embody the proposed approach. Program plan retrieval with SIGMA (signature matching agent) shows promising results in removing irrelevant plans from consideration prior to attempting the later computational concept recognition process. It appears that the signature approach to plan retrieval may be able to facilitate the scaling up of plan-based understanders so that they can better support maintenance tasks on large legacy systems.",1063-6773,0-7695-1905,10.1109/ICSM.2003.1235438,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1235438,,Software maintenance,reverse engineering;software maintenance;software tools;software libraries;pattern matching,plan-based program understanding;program understanding tools;legacy systems;software engineering support;software maintenance tasks;plan library;signature-based approach;human program comprehension;SIGMA prototype;signature matching agent;program plan retrieval;computational concept recognition,,1,19,,,,,IEEE,IEEE Conferences
Using a concept lattice of decomposition slices for program understanding and impact analysis,P. Tonella,"Centro per la Ricerca Sci. e Tecnologica, Trento, Italy",IEEE Transactions on Software Engineering,,2003,29,6,495,509,"The decomposition slice graph and concept lattice are two program representations used to abstract the details of code into a higher-level view of the program. The decomposition slice graph partitions the program into computations performed on different variables and shows the dependence relation between computations, holding when a computation needs another computation as a building block. The concept lattice groups program entities which share common attributes and organizes such groupings into a hierarchy of concepts, which are related through generalizations/specializations. This paper investigates the relationship existing between these two program representations. The main result of this paper is a novel program representation, called concept lattice of decomposition slices, which is shown to be an extension of the decomposition slice graph, and is obtained by means of concept analysis, with additional nodes associated with weak interferences between computations, i.e., shared statements which are not decomposition slices. The concept lattice of decomposition slices can be used to support software maintenance by providing relevant information about the computations performed by a program and the related dependences/interferences, as well as by representing a natural data structure on which to conduct impact analysis. Preliminary results on small to medium size code support the applicability of this method at the intraprocedural level or when investigating the dependences among small groups of procedures.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2003.1205178,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1205178,,Lattices;Interference;Software maintenance;Data structures;Performance analysis;Information analysis;Application software,reverse engineering;program slicing;software maintenance,program representations;program understanding;impact analysis;concept lattice;decomposition slice graph;dependence relation;common attributes;generalizations;specializations;weak interferences;shared statements;software maintenance;data structure;intraprocedural level,,96,38,,,,,IEEE,IEEE Journals
Automated assistance to program understanding,Eun Man Choi; A. von Mayrhauser,"Dept. of Comput. Eng., Dongguk Univ., Seoul, South Korea; NA",Proceedings of TENCON'94 - 1994 IEEE Region 10's 9th Annual International Conference on: 'Frontiers of Computer Technology',,1994,,,1002,1007 vol.2,"Software maintenance requires the understanding of existing code, determining whether to make changes, assessing the impact of modifications, rebuilding code after alterations, and regression testing to validate changes. Program understanding is a bottleneck phase when the code to be maintained is invisible which means difficult to get needed information. This paper suggests a method for supporting program understanding by bottom-up driven and code-oriented view. The toolset includes abstraction mechanism, restructuring capability, ripple effect analysis, chunking guidance, and reuse. It lets the maintenance programmer understand the program effectively, refer to other people's understanding, analyze the effect of changes, and reusable program segments.<<ETX>>",,0-7803-1862,10.1109/TENCON.1994.369160,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=369160,,Programming profession;Cognitive science;Guidelines;Character recognition,reverse engineering;software maintenance;program debugging;programming environments;software tools;software reusability,program understanding;software maintenance;code rebuilding;regression testing;bottom-up driven;code-oriented view;toolset;abstraction mechanism;restructuring capability;ripple effect analysis;chunking guidance;software reuse;maintenance programmer;program segments,,1,13,,,,,IEEE,IEEE Conferences
A cognitive approach to program understanding,K. Bertels; P. Vanneste; C. De Backer,"Namur Univ., Belgium; NA; NA",[1993] Proceedings Working Conference on Reverse Engineering,,1993,,,1,7,"A method of program understanding is presented, based on a cognitive model of programming knowledge, and incorporating the basic concepts, structures, and strategies used by human expert programmers. The approach involves the generation of a high-level description of the program with, as main advantages, the use of abstraction and robustness with respect to conceptual errors. The use of abstraction permits the transcending of any syntactical variation and allows focusing on the semantics. This also potentially allows the analysis of larger programs. The method can cope with erroneous code, and can generate a precise description of the bug(s) involved. The method is useful for integration in a tutoring system for programming.<<ETX>>",,0-8186-3780,10.1109/WCRE.1993.287784,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=287784,,Flow graphs;Programming profession;Humans;Robustness;Computer bugs;Libraries;Testing;Usability;Calculus;Error correction,program debugging;program diagnostics;systems analysis,program description generation;program analysis;program debugging;program tutoring;program understanding;cognitive model;programming knowledge;human expert programmers;high-level description;conceptual errors;syntactical variation;semantics;erroneous code;tutoring system,,1,12,,,,,IEEE,IEEE Conferences
Simplicity: a key engineering concept for program understanding,Yang Li; Hongji Yang,"Dept. of Comput. Sci., De Monfort Univ., Leicester, UK; NA",Proceedings 9th International Workshop on Program Comprehension. IWPC 2001,,2001,,,98,107,"One of the most significant problems for existing program comprehension methods is its scalability. We introduce a new technique to make the scalability possible. In particular, we advocate the concept of ""simplicity"" for program understanding. We first propose a simplified semantic network as domain knowledge representation; we then introduce a linear and domain-oriented program partitioning method which can partition a huge program into self-contained program modules so that the recovery of domain knowledge can be carried out within smaller program space. We also introduce a set of rules for recovering domain knowledge from C code followed by a theoretical analysis on these algorithms. A case study on programming style based program partitioning method is given. Finally, comparisons with other work are made and a conclusion is drawn.",1092-8138,0-7695-1131,10.1109/WPC.2001.921718,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921718,,Software systems;Documentation;Programming profession;Humans;Computational complexity;Scalability;Linear programming;Couplings;Knowledge engineering;Computer science,reverse engineering;semantic networks;program slicing;C language,program understanding;program comprehension;scalability;simplicity;semantic network;domain knowledge representation;program partitioning;domain knowledge recovery;C code;case study;programming style,,1,25,,,,,IEEE,IEEE Conferences
Applying plan recognition algorithms to program understanding,A. Quilici; Qiang Yang; S. Woods,"Dept. of Electr. Eng., Hawaii Univ., Honolulu, HI, USA; NA; NA",Proceedings of the 11th Knowledge-Based Software Engineering Conference,,1996,,,96,103,"Program understanding is often viewed as the task of extracting plans and design goals from program source. As such, it is natural to try to apply standard AI plan recognition techniques to the program understanding problem. Yet program understanding researchers have quietly, but consistently, avoided the use of these plan recognition algorithms. This paper shows that treating program understanding as plan recognition is too simplistic and that traditional AI search algorithms for plan recognition are not suitable. In particular, we show that: the program understanding task differs significantly from the typical general plan recognition task along several key dimensions; the program understanding task has particular properties that make it particularly amenable to constraint satisfaction techniques; and augmenting AI plan recognition algorithms with these techniques can lead to effective solutions for the program understanding problem.",1068-3062,0-8186-7681,10.1109/KBSE.1996.552827,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=552827,,Artificial intelligence;Computer science;Libraries;Algorithm design and analysis;Reverse engineering;Computer applications;Uncertainty,reverse engineering,plan recognition algorithms;program understanding;software design;artificial intelligence;search algorithms;constraint satisfaction,,3,25,,,,,IEEE,IEEE Conferences
Function-theoretic principles of program understanding,M. G. Pleszkoch; P. A. Hausler; A. R. Hevner; R. C. Linger,"IBM Corp., Baltimore, MD, USA; IBM Corp., Baltimore, MD, USA; NA; NA",Twenty-Third Annual Hawaii International Conference on System Sciences,,1990,2,,74,81 vol.2,"The authors propose a comprehensive methodology for automated program abstraction of computer programs. The theoretical foundations that support program abstraction are functional abstraction, data analysis, program slicing, and pattern matching. The theory of functional abstraction is applied to an example program. The localization of data scope is described as a step to facilitate the abstraction process. Techniques are presented for automatically abstracting the functions of both nonlooping and looping control structures.<<ETX>>",,,10.1109/HICSS.1990.205177,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=205177,,Software maintenance;Documentation;Business;Software performance;Libraries;Debugging;Educational institutions;Data analysis;Large-scale systems;Automation,data structures;program processors;programming theory;software tools,program understanding;automated program abstraction;functional abstraction;data analysis;program slicing;pattern matching;data scope;nonlooping;looping control structures,,11,17,,,,,IEEE,IEEE Conferences
A cooperative program understanding environment,A. Quilici; D. N. Chin,"Dept. of Electr. Eng., Hawaii Univ., Honolulu, HI, USA; Dept. of Electr. Eng., Hawaii Univ., Honolulu, HI, USA",Proceedings KBSE '94. Ninth Knowledge-Based Software Engineering Conference,,1994,,,125,132,The large size and high-percentage of domain-specific code in most legacy systems makes it unlikely that automated understanding tools will be able to completely understand them. Yet automated tools can clearly recognize portions of the design. That suggests exploring environments in which programmer and system work together to understand legacy software. This paper describes such an environment that supports programmer and system cooperating to extract an object-oriented design from legacy software systems. It combines an automated program understanding component that recognizes standard implementations of domain independent plans with with a structured notebook that the programmer uses to link object-oriented design primitives to arbitrary source code fragments. This jointly extracted information is used to support conceptual queries about the program's code and design.<<ETX>>,1068-3062,0-8186-6380,10.1109/KBSE.1994.342670,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=342670,,Programming profession;Data mining;Computer architecture;Code standards;Software tools;Pattern recognition;Libraries;Computer science;Software prototyping;Software design,program diagnostics;software tools;object-oriented programming;knowledge based systems;software maintenance,cooperative program understanding environment;domain-specific code;legacy systems;automated understanding tools;object-oriented design;domain independent plans;structured notebook;source code fragments,,3,20,,,,,IEEE,IEEE Conferences
Temporal event analysis and program understanding,W. E. Howden; G. M. Shi,"SERL, Hawaii Univ., Honolulu, HI, USA; SERL, Hawaii Univ., Honolulu, HI, USA",Proceedings Nineteenth Annual International Computer Software and Applications Conference (COMPSAC'95),,1995,,,4,11,"A temporal event analysis approach to program understanding is described. Program understanding is viewed as a sequence of episodes in which the programmer concludes that an informal event occurs that corresponds to some part of the code. This can be viewed as accepting that the code is an adequate definition of the meaning of the informal event. Often, such a definition is contingent upon working hypotheses that describe other informal program properties that should be verified in order to confirm the validity of the understanding process. Verification of working hypotheses may depend on the formulation of additional definitions or working hypotheses. The understanding process can be assisted through the use of a documentation language for describing events and hypotheses, and a hypothesis verification tool. The paper describes a temporal event language in which hypotheses are formulated in terms of expected event sequences. A hypothesis verification tool was built, and experimentation was carried out on a set of programs. The tool was found to be very useful in understanding the detailed, control oriented aspects of a program. Program faults were discovered in every program that was analyzed, indicating that it facilitates a deep level of understanding.",0730-3157,0-8186-7119,10.1109/CMPSAC.1995.524751,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=524751,,Programming profession;Documentation;Reverse engineering;IEEE Policy and Procedures,reverse engineering;program verification;system documentation;temporal logic,temporal event analysis approach;program understanding;informal event;working hypotheses;documentation language;hypothesis verification tool;temporal event language;expected event sequences;control oriented aspects;program faults,,,15,,,,,IEEE,IEEE Conferences
Program understanding during software adaptation tasks,A. von Mayrhauser; A. M. Vans,"Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA; NA",Proceedings. International Conference on Software Maintenance (Cat. No. 98CB36272),,1998,,,316,325,"This paper reports on a software understanding study during adaptation of large-scale software by software maintenance professionals. The paper explains the general understanding process, the information needs of these software engineers during their tasks, and the tool capabilities that would help them to be more productive. We also contrast programmer behavior during adaptation with that during other maintenance activities like corrective maintenance and enhancement.",1063-6773,0-8186-8779,10.1109/ICSM.1998.738523,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=738523,,Programming profession;Large-scale systems;Computer science;Operating systems;Software systems;Databases;Application software;Software tools;Documentation;Computer industry,reverse engineering;software maintenance,program understanding;software adaptation tasks;large-scale software;software maintenance;corrective maintenance,,4,22,,,,,IEEE,IEEE Conferences
A user interface for an environment to support program understanding,L. Cleveland,"IBM Thomas J. Watson Res. Center, Yorktown Heights, NY, USA","Proceedings. Conference on Software Maintenance, 1988.",,1988,,,86,91,"A static analysis of the program to be understood can yield much valuable information. However, to be of value to the programmer involved in an understanding task, the presentation of the static analysis data must not complicate, nor distract from, the task of understanding the program. An appropriate technique for presenting such static analysis data to the programmer engaged in the understanding task is described. This user interface assumes a multiple-window environment and supports an intelligent cursor. The techniques described integrate the presentation of the various types of static analysis data yielding an interface that does not distract the programmer as he or she attempts to understand the program.<>",,0-8186-0879,10.1109/ICSM.1988.10145,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=10145,,User interfaces;Programming profession;Data analysis;Software maintenance;Costs;Information analysis;Flow graphs;Couplings;Vehicles;Informatics,multiprogramming;program verification;programming environments;software tools;user interfaces,program verification;software tools;user interface;program understanding;static analysis;multiple-window environment;intelligent cursor,,10,,,,,,IEEE,IEEE Conferences
Graph services for program understanding tools,P. Brown; D. W. Stafford,"IBM Sterling Forest, Suffern, NY, USA; IBM Sterling Forest, Suffern, NY, USA",[1992] Proceedings of the Second Symposium on Assessment of Quality Software Development Tools,,1992,,,238,251,"Many types of problems are more easily understood when represented with graphs. This paper presents an organization of graph theoretical functions for use by an application program. The paper covers a unified set of generalized routines and data structures for graph reductions, path analysis, and data flow problems. Some suggestions for user interfaces are provided. Examples of problems in which these functions might be used are program understanding, software testing, software design, scheduling, and network management.<<ETX>>",,0-8186-2620,10.1109/AQSDT.1992.205859,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=205859,,Application software;Data structures;Data analysis;Flow graphs;User interfaces;Software testing;Scheduling;Graphics;Graph theory;Information analysis,computer graphics;data structures;graphical user interfaces;program testing;software engineering,program understanding tools;graph theoretical functions;application program;generalized routines;data structures;graph reductions;path analysis;data flow problems;user interfaces;software testing;software design;scheduling;network management,,,8,,,,,IEEE,IEEE Conferences
An automatic assistant for program understanding,V. Gafni,"MBT, Israel Aircraft Ind., Yehud, Israel",[1988] Proceedings. The Third Israel Conference on Computer Systems and Software Engineering,,1988,,,79,85,"The paper explores the problem of understanding imperative programs. It points out the role of the procedural nature of knowledge representation as the main reason for difficulties in understanding this type of program. The paper suggests a generic process for reasoning about the knowledge embodied in an imperative program as a way to confront this problem. It proceeds with a concrete implementation of the process and a tool that has been constructed accordingly, thus demonstrating its practical usefulness. The goal of this work is to show a possible direction in automating the software development process rather than presenting a definite solution.<<ETX>>",,0-8186-0884,10.1109/ICCSSE.1988.72245,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=72245,,Software systems;Computer languages;Application software;Object oriented programming;Aircraft;Aerospace industry;Knowledge representation;Concrete;Natural languages;Humans,inference mechanisms;knowledge based systems;knowledge representation;software tools,automatic assistant;program understanding;imperative programs;procedural nature;knowledge representation;reasoning;software development process,,,10,,,,,IEEE,IEEE Conferences
Effects of decomposition techniques on knowledge-based program understanding,S. K. Abd-El-Hafiz,NA,1997 Proceedings International Conference on Software Maintenance,,1997,,,21,30,"This paper studies the effects of two different program decomposition techniques on knowledge-based program understanding. The first technique generates events which encapsulate program parts that are interdependent with respect to data flow. The second technique is program slicing. Both techniques are briefly described and the resulting slices and events are compared. An understanding of a program is formed by matching its events or slices against previously designed knowledge base plans. In order to have a detailed insight into the design and utilization of the knowledge base, we perform a two-phase case study. The first phase uses the decomposition results of a set of 65 loops to construct two different knowledge bases; one for recognizing loop events and the other for recognizing loop slices. This phase of the case study demonstrates the different design decisions made during the construction of the two knowledge bases. The second phase of the case study utilizes the previously designed plans in analyzing a set of 92 loops extracted from five randomly selected programs. Finally, the results of comparing the two decomposition techniques are summarized",1063-6773,0-8186-8013,10.1109/ICSM.1997.624227,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5726931,,,data flow analysis;knowledge based systems;program control structures;reverse engineering;software maintenance,case study;data flow;design decisions;knowledge base plans;knowledge-based program understanding;program decomposition techniques;program loop events;program loop slices;program parts;program slicing,,,35,,,,,IEEE,IEEE Conferences
PUMP: a program understanding tool for MODSIM programs,A. S. Bhullar; L. G. Birta,"Sch. of Inf. Technol. & Eng., Ottawa Univ., Ont., Canada; NA",Proceedings 33rd Annual Simulation Symposium (SS 2000),,2000,,,121,130,"Automated program understanding tools have the potential to make important contributions to reducing the very substantial costs of program maintenance. We formulate a particular approach to program understanding within the context of the object-oriented simulation language, MODSIM. The software tool that has been developed is called PUMP (Program Understanding of MODSIM Programs). The input to this tool is the syntactically correct MODSIM program code for a simulation project which typically is distributed over several files. The main presentation of information about the program is via a user interface that is organized along hierarchical lines that correspond to the organizational structure of MODSIM programs. The hierarchical approach permits examination of program features in increasing levels of detail. The main thrust of the analysis is to identify entity types (e.g., objects, methods, variables) used in the program together with their interrelationships. The key design aspects of PUMP are outlined in the paper and an overview of the user interface is presented. Emphasis is given to the mechanisms specifically developed for handling the object-oriented features of MODSIM.",1080-241X,0-7695-0598,10.1109/SIMSYM.2000.844908,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=844908,,Software maintenance;Software systems;Application software;Costs;Programming profession;Documentation;Information technology;Electrical capacitance tomography;Software engineering;Object oriented programming,reverse engineering;digital simulation;software maintenance;object-oriented languages;simulation languages;software tools;user interfaces,PUMP tool;program understanding tool;MODSIM programs;program maintenance;costs;object-oriented simulation language;software tool;user interface,,,8,,,,,IEEE,IEEE Conferences
Program understanding needs during corrective maintenance of large scale software,A. von Mayrhauser; A. M. Vans,"Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA; NA",Proceedings Twenty-First Annual International Computer Software and Applications Conference (COMPSAC'97),,1997,,,630,637,"We report on a software understanding field study during corrective maintenance of large-scale software by professional software maintenance engineers. We explain the general understanding process, the information needs of these software engineers during their tasks, and the tool capabilities that would help them to be more productive.",0730-3157,0-8186-8105,10.1109/CMPSAC.1997.625084,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=625084,,Large-scale systems;Software maintenance;Programming profession;Software tools;Switches;Documentation;Computer science;Software testing;Software algorithms;Cognition,reverse engineering;software maintenance;human resource management;software tools,program understanding needs;corrective maintenance;large scale software;software understanding field study;professional software maintenance engineers;information needs;software tool;productivity,,7,16,,,,,IEEE,IEEE Conferences
Using latent semantic analysis to identify similarities in source code to support program understanding,J. I. Maletic; A. Marcus,"Div. of Comput. Sci., Memphis Univ., Memphis, TN, USA; NA",Proceedings 12th IEEE Internationals Conference on Tools with Artificial Intelligence. ICTAI 2000,,2000,,,46,53,"The paper describes the results of applying Latent Semantic Analysis (LSA), an advanced information retrieval method, to program source code and associated documentation. Latent semantic analysis is a corpus based statistical method for inducing and representing aspects of the meanings of words and passages (of natural language) reflective in their usage. This methodology is assessed for application to the domain of software components (i.e., source code and its accompanying documentation). Here LSA is used as the basis to cluster software components. This clustering is used to assist in the understanding of a nontrivial software system, namely a version of Mosaic. Applying latent semantic analysis to the domain of source code and internal documentation for the support of program understanding is a new application of this method and a departure from the normal application domain of natural language.",1082-3409,0-7695-0909,10.1109/TAI.2000.889845,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=889845,,Documentation;Information retrieval;Software systems;Information analysis;Natural languages;Application software;Statistical analysis;Computer science;Computer architecture;Software maintenance,reverse engineering;information retrieval;natural languages;computational linguistics;system documentation;statistical analysis,latent semantic analysis;source code similarities;program understanding;information retrieval method;source code;corpus based statistical method;natural language;software components;LSA;software component clustering;nontrivial software system;Mosaic;internal documentation,,37,21,,,,,IEEE,IEEE Conferences
Influence of domain-specific notation to program understanding,T. Kosar; M. Mernik; M. Črepinšek; P. R. Henriques; D. da Cruz; M. J. Varanda Pereira; N. Oliveira,"University of Maribor, Faculty of Electrical Engineering and Computer Science, Smetanova 17, 2000, Slovenia; University of Maribor, Faculty of Electrical Engineering and Computer Science, Smetanova 17, 2000, Slovenia; University of Maribor, Faculty of Electrical Engineering and Computer Science, Smetanova 17, 2000, Slovenia; University of Minho - Department of Computer Science, Campus de Gualtar, 4715-057, Braga, Portugal; University of Minho - Department of Computer Science, Campus de Gualtar, 4715-057, Braga, Portugal; Polytechnic Institute of Bragança, Campus de Sta. Apolónia, Apartado 134 - 5301-857, Portugal; University of Minho - Department of Computer Science, Campus de Gualtar, 4715-057, Braga, Portugal",2009 International Multiconference on Computer Science and Information Technology,,2009,,,675,682,"Application libraries are the most commonly used implementation approach to solve problems in general-purpose languages. Their competitors are domain-specific languages, which can provide notation close to the problem domain. We carried out an empirical study on comparing domain-specific languages and application libraries regarding program understanding. In this paper, one case study is presented. Over 3000 lines of code were studied and more than 86 pages long questionnaires were answered by end-users, answering questions on learning, perceiving and evolving programs written in domain-specific language as well as general-purpose language using application library. In this paper, we present comparison results on end-users' correctness and consumed time. For domain-specific language and application library same problem domain has been used-a well-known open source graph description language, DOT.",2157-5525,978-1-4244-5314,10.1109/IMCSIT.2009.5352767,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5352767,,DSL;Domain specific languages;Libraries;Computer science;Productivity;Information technology;Cognitive science;Programming environments;Skeleton;Software engineering,program diagnostics;programming languages;specification languages,domain specific notation;program understanding;application libraries;general purpose languages;domain specific languages;learning;open source graph description language,,2,17,,,,,IEEE,IEEE Conferences
Program understanding as constraint satisfaction,S. Woods; Qiang Yang,"Dept. of Comput. Sci., Waterloo Univ., Ont., Canada; Dept. of Comput. Sci., Waterloo Univ., Ont., Canada",Proceedings Seventh International Workshop on Computer-Aided Software Engineering,,1995,,,318,327,"The process of understanding a source code in a high-level programming language involves complex computation. Given a piece of legacy code and a library of program plan templates, understanding the code corresponds to building mappings from parts of the source code to particular program plans. These mappings could be used to assist an expert in reverse engineering legacy code, to facilitate software reuse, or to assist in the translation of the source into another programming language. In this paper we present a model of program understanding using constraint satisfaction. Within this model we intelligently compose a partial global picture of the source program code by transforming knowledge about the problem domain and the program itself into sets of constraints. We then systematically study different search algorithms and empirically evaluate their performance. One advantage of the constraint satisfaction model is its generality; many previous attempts in program understanding could now be cast under the same spectrum of heuristics, and thus be readily compared. Another advantage is the improvement in search efficiency using various heuristic techniques in constraint satisfaction.<<ETX>>",,0-8186-7078,10.1109/CASE.1995.465302,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=465302,,Humans;Libraries;Computer science;Intelligent agent;Software engineering;Computer languages;Debugging;Logic programming;Costs;Artificial intelligence,reverse engineering;constraint handling;high level languages;software libraries;search problems;heuristic programming,program understanding;constraint satisfaction;high-level programming language;legacy code;program plan templates;reverse engineering;software reuse;programming language translation;search algorithms;performance evaluation;heuristics;search efficiency;heuristic techniques,,7,20,,,,,IEEE,IEEE Conferences
How do program understanding tools affect how programmers understand programs?,M. -. D. Storey; K. Wong; H. A. Muller,"Sch. of Comput. Sci., Simon Fraser Univ., Burnaby, BC, Canada; NA; NA",Proceedings of the Fourth Working Conference on Reverse Engineering,,1997,,,12,21,"We explore the question of whether program understanding tools enhance or change the way that programmers understand programs. The strategies that programmers use to comprehend programs vary widely. Program understanding tools should enhance or ease the programmer's preferred strategies, rather than impose a fixed strategy that may not always be suitable. We present observations from a user study that compares three tools for browsing program source code and exploring software structures. In this study, 30 participants used these tools to solve several high level program understanding tasks. These tasks required a broad range of comprehension strategies. We describe how these tools supported or hindered the diverse comprehension strategies used.",,0-8186-8162,10.1109/WCRE.1997.624572,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=624572,,Programming profession;Switches;Software tools;Software maintenance;Reverse engineering;Displays;Visualization;Computer science;Software systems;Animation,reverse engineering;software maintenance;software tools;human factors,program understanding tools;programmers;user study;program source code browsing;software structures;high level program understanding tasks;diverse comprehension strategies,,53,19,,,,,IEEE,IEEE Conferences
Feature-driven program understanding using concept analysis of execution traces,T. Eisenbarth; R. Koschke; D. Simon,"Stuttgart Univ., Germany; NA; NA",Proceedings 9th International Workshop on Program Comprehension. IWPC 2001,,2001,,,300,309,"The first task of a programmer who wants to understand how a certain feature is implemented is to localize the implementation of the feature in the code. If the implementations of a set of related features are to be understood, a programmer is interested in their commonalities and variabilities. For large and badly documented programs, localizing features in code and identifying the commonalities and variabilities of components and features can be difficult and time-consuming. It is useful to derive this information automatically. The feature-component correspondence describes which components are needed to implement a set of features and what are the respective commonalities and variabilities of those features and components. This paper describes a new technique to derive the feature-component correspondence utilizing dynamic information and concept analysis. The method is simple to apply, cost-effective, largely language-independent, and can yield results quickly.",1092-8138,0-7695-1131,10.1109/WPC.2001.921740,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921740,,Programming profession;Information analysis;Information resources;Documentation;Software architecture,reverse engineering;program diagnostics;subroutines,feature-driven program understanding;concept analysis;program execution traces;code feature implementation localization;feature commonalities;feature variabilities;large programs;badly documented programs;software components;automatic information derivation;feature-component correspondence;dynamic information;application simplicity;cost-effectiveness;language-independent method,,22,16,,,,,IEEE,IEEE Conferences
Program understanding and maintenance with the CANTO environment,G. Antoniol; R. Fiutem; G. Lutteri; P. Tonella; S. Zanfei; E. Merlo,NA; NA; NA; NA; NA; NA,1997 Proceedings International Conference on Software Maintenance,,1997,,,72,81,"During maintenance activities, the availability of integrated conceptual views that present software at different levels of abstraction, from software architecture to control and data flow relations at code level, is fundamental to understand and modify legacy systems. This paper presents CANTO (Code and Architecture Analysis Tool), a comprehensive program understanding and maintenance environment which integrates fine grained information with architectural views extracted from source code, giving the user control of what is being computed by analyses. The capabilities and usefulness of CANTO are illustrated with reference to a real understanding and maintenance task",1063-6773,0-8186-8013,10.1109/ICSM.1997.624233,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5726937,,,data flow analysis;program control structures;reverse engineering;software maintenance;software tools,CANTO;Code and Architecture Analysis Tool;abstraction levels;architectural views;data flow relations;fine grained information;integrated conceptual views;legacy systems;program control;program understanding;software architecture;software maintenance;source code,,29,15,,,,,IEEE,IEEE Conferences
On inserting program understanding technology into the software change process,K. Wong,"Dept. of Comput. Sci., Victoria Univ., BC, Canada",WPC '96. 4th Workshop on Program Comprehension,,1996,,,90,99,"Program understanding technologies can be applied effectively in the analysis phase of a software change process. The analysis phase naturally follows a goal driven metaprocess. Described are issues involved with inserting program understanding technology into existing practice and into such a metaprocess. The implied processes of program understanding and reverse engineering tools play an important role. These issues pose major problems for the acceptance of redocumentation tools such as Rigi, an evolvable reverse engineering tool. An example using Rigi and its analysis methodology for change impact analysis is considered.",1092-8138,0-8186-7283,10.1109/WPC.1996.501124,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501124,,Software quality;Reverse engineering;Costs;Software systems;Computer science;Software development management;Computer industry;Programming;Customer satisfaction;Matched filters,reverse engineering;management of change;system documentation;software tools,program understanding technology;software change process;analysis phase;goal driven metaprocess;reverse engineering tools;redocumentation tools;evolvable reverse engineering tool;change impact analysis,,2,20,,,,,IEEE,IEEE Conferences
Building program understanding tools using visitor combinators,A. van Deursen; J. Visser,"CWI, Amsterdam, Netherlands; CWI, Amsterdam, Netherlands",Proceedings 10th International Workshop on Program Comprehension,,2002,,,137,146,"Program understanding tools manipulate program representations, such as abstract syntax trees, control-flow graphs or data-flow graphs. This paper deals with the use of visitor combinators to conduct such manipulations. Visitor combinators are an extension of the well-known visitor design pattern. They are small, reusable classes that carry out specific visiting steps. They can be composed in different constellations to build more complex visitors. We evaluate the expressiveness, reusability, ease of development and applicability of visitor combinators to the construction of program understanding tools. To that end, we conduct a case study in the use of visitor combinators for control-flow analysis and visualization as used in a commercial Cobol program understanding tool.",1092-8138,0-7695-1495,10.1109/WPC.2002.1021335,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021335,,Tree graphs;Visualization;Concrete;Testing;Pattern analysis;Software design;Flow graphs;Solid modeling;Context modeling;Design engineering,reverse engineering;software tools;object-oriented methods;program diagnostics;software reusability;computer aided software engineering;flow graphs;COBOL,Cobol program understanding tool;visitor combinators;program representations manipulation;abstract syntax trees;control-flow graphs;data-flow graphs;visitor design pattern;reusable classes;visiting steps;constellations;expressiveness;reusability;ease of development;tool construction applicability;case study;control-flow analysis;software visualization;program analysis;program comprehension,,1,16,,,,,IEEE,IEEE Conferences
Binary-level lightweight data integration to develop program understanding tools for embedded software in C,K. Gondow; T. Suzuki; H. Kawashima,"Tokyo Inst. of Technol., Japan; NA; NA",11th Asia-Pacific Software Engineering Conference,,2004,,,336,345,"In embedded software development, the programming language C and inline assembly code are traditionally widely used. However, tools for C program-understanding, e.g., cross-referencers or call graph extractors, are not mature still today. In this paper, we introduce a novel technique for developing program-understanding tools, based on binary-level lightweight data integration. To verify this idea, we first propose a new markup language for DWARF2 debugging information, and then, using the technique, we experimentally developed two cross-referencers (called dxref and rxref) and a call graph extractor (called bscg) for C. Our preliminary evaluation shows that the technique enabled us to efficiently develop practical and flexible tools.",1530-1362,0-7695-2245,10.1109/APSEC.2004.36,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1371936,,Embedded software;Software engineering,data integrity;C language;reverse engineering;embedded systems;software tools,binary-level lightweight data integration;program understanding tool;embedded software;C;embedded software development;programming language;inline assembly code;cross-referencer;call graph extractor;markup language;DWARF2 debugging information,,1,32,,,,,IEEE,IEEE Conferences
Evolving Ispell: a case study of program understanding for reuse,L. Aversano; G. Canfora; A. De Lucia; S. Stefanucci,"Dept. of Eng., Univ. of Sannio, Benevento, Italy; Dept. of Eng., Univ. of Sannio, Benevento, Italy; Dept. of Eng., Univ. of Sannio, Benevento, Italy; Dept. of Eng., Univ. of Sannio, Benevento, Italy",Proceedings 10th International Workshop on Program Comprehension,,2002,,,197,206,"Text processing has proven helpful in a number of software engineering tasks. We discuss how a morphological analyser for the Italian language, and its associated linguistic resources, have been developed by reusing and evolving an existing system, Ispell, which is an open-source spell-checker. The need to develop such an analyser derives from the need to improve the traceability link recovery process described by G. Antoniol et al. (2000, 2002). This paper shows how the program understanding exercise was useful to develop a system in a specialized application domain in which we had a very limited background knowledge.",1092-8138,0-7695-1495,10.1109/WPC.2002.1021341,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021341,,Computer aided software engineering;Information retrieval;Text processing;Data mining;Software engineering;Software maintenance;Programming profession;Indexing;Application software;Stress,spelling aids;reverse engineering;software reusability;linguistics;public domain software;computer aided analysis;text analysis,Ispell system evolution;case study;program understanding;software reuse;text processing;software engineering;morphological analyser;Italian language;linguistic resources;open-source spell-checker;traceability link recovery process;specialized application domain;limited background knowledge,,,32,,,,,IEEE,IEEE Conferences
The program understanding problem: analysis and a heuristic approach,S. Woods; Qiang Yang,"Dept. of Comput. Sci., Waterloo Univ., Ont., Canada; NA",Proceedings of IEEE 18th International Conference on Software Engineering,,1996,,,6,15,"Program understanding is the process of making sense of a complex source code. This process has been considered as computationally difficult and conceptually complex. So far no formal complexity results have been presented, and conceptual models differ from one researcher to the next. We formally prove that program understanding is NP hard. Furthermore, we show that even a much simpler subproblem remains NP hard. However we do not despair by this result, but rather offer an attractive problem solving model for the program understanding problem. Our model is built on a framework for solving constraint satisfaction problems, or CSPs, which are known to have interesting heuristic solutions. Specifically, we can represent and heuristically address previous and new heuristic approaches to the program understanding problem with both existing and specially designed constraint propagation and search algorithms.",0270-5257,0-8186-7247,10.1109/ICSE.1996.493397,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=493397,,Libraries;Computer science;Problem-solving;Algorithm design and analysis;Computer languages;Artificial intelligence,reverse engineering;computational complexity;constraint handling;search problems,program understanding problem;heuristic approach;complex source code;formal complexity results;conceptual models;NP hard;problem solving model;constraint satisfaction problems;CSPs;heuristic solutions;constraint propagation;search algorithms,,13,19,,,,,IEEE,IEEE Conferences
Evaluation of a knowledge-based approach to program understanding,S. K. Abd-El-Hafiz,"Fac. of Eng., Cairo Univ., Giza, Egypt",Proceedings of WCRE '96: 4rd Working Conference on Reverse Engineering,,1996,,,259,268,"Paper reprinted from ICSM '96. This paper evaluates a knowledge-based program understanding approach that generates first order predicate logic annotations of loops. An initial and partial evaluation of this approach was performed on an existing program of reasonable size. Plans in the knowledge base were designed by performing an analysis of the existing program. As a result the previous study did not demonstrate that the knowledge base generated for a given program is generally usable beyond that program. In this study, an extensive evaluation of the analysis approach is performed. Plans developed during the initial evaluation stage are used to analyze a set of 92 loops in five randomly selected Pascal programs. Results concerning the analyzed loops and utilization of the existing plans are given and discussed. These results generally show a good usability of the knowledge base beyond the original program.",,0-8186-7674,10.1109/WCRE.1996.558931,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=558931,,Performance analysis;Performance evaluation;Automation;Logic programming;Usability;Mathematics;Design methodology;Testing,knowledge based systems,knowledge-based approach;program understanding;first order predicate logic annotations;program loops;plans;Pascal programs;system usability,,,23,,,,,IEEE,IEEE Conferences
A prototype system for static and dynamic program understanding,D. P. Olshefski; A. Cole,"IBM T.J. Watson Res. Center, Yorktown Heights, NY, USA; IBM T.J. Watson Res. Center, Yorktown Heights, NY, USA",[1993] Proceedings Working Conference on Reverse Engineering,,1993,,,93,106,"A tool called PUNDIT (Program Understanding Investigation Tool) is described. It is a prototype intended to serve as a vehicle for exploring and testing ideas in the area of program understanding; it combines static analysis information with information collected at runtime. The architecture of PUNDIT is described, together with its two main components (the C source analyzer and a graphical user interface). Several of the views provided by the tool are explained, including a high-level structure chart, a dynamic call graph, a control flow graph animated during program execution, a type definition window, and others. By integrating static and dynamic information, the tool provides a more comprehensive understanding of a program as the first step to reengineering or maintaining the application that can be obtained by static analysis alone.<<ETX>>",,0-8186-3780,10.1109/WCRE.1993.287775,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=287775,,Prototypes;Information analysis;Vehicle dynamics;Runtime;User interfaces;Vehicles;Testing;Flow graphs;Maintenance engineering;Humans,graphical user interfaces;program diagnostics;software maintenance;software tools,software tool;program testing;runtime information;software reengineering;software maintenance;prototype system;PUNDIT;Program Understanding Investigation Tool;static analysis information;C source analyzer;graphical user interface;high-level structure chart;dynamic call graph;control flow graph;program execution;type definition window,,1,13,,,,,IEEE,IEEE Conferences
Evaluation of a knowledge-based approach to program understanding,S. K. Abd-El-Hafiz,"Dept. of Eng. Math., Cairo Univ., Giza, Egypt",1996 Proceedings of International Conference on Software Maintenance,,1996,,,275,284,"The paper evaluates a recently presented knowledge-based program understanding approach that generates first order predicate logic annotations of loops. An initial and partial evaluation of this approach was performed on an existing program of reasonable size. Plans in the knowledge base were designed by performing an analysis of the existing program. As a result, the previous study did not demonstrate that the knowledge base generated for a given program is generally usable beyond that program. An extensive evaluation of the analysis approach is performed. Plans developed during the initial evaluation stage are used to analyze a set of 92 loops in five randomly selected Pascal programs. Results concerning the analyzed loops and utilization of the existing plans are given and discussed. These results generally show a good usability of the knowledge base beyond the original program.",1063-6773,0-8186-7677,10.1109/ICSM.1996.565017,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=565017,,Reverse engineering,reverse engineering,knowledge-based program understanding evaluation;first order predicate logic loop annotation;partial evaluation;plans;program analysis;initial evaluation;Pascal programs;usability,,1,23,,,,,IEEE,IEEE Conferences
Evaluating process clusters to support automatic program understanding,T. Kunz,"Dept. of Comput. Sci., Waterloo Univ., Ont., Canada",WPC '96. 4th Workshop on Program Comprehension,,1996,,,198,207,"Evaluating the design of a distributed application is difficult but provides useful information for program development and maintenance. In distributed debugging, for example, processes are often grouped together and treated as one entity to reduce the debugging complexity. We previously identified multiple approaches to automatic process clustering and prototypical tools implementing these approaches have been developed. The process clusters derived with these tools have been evaluated by comparing them to the author's understanding of the application design. This paper discusses a quantitative measure for process cluster evaluation. The measure uses information derived by a static source analysis as well as information about interprocess communication during the application execution. Experiments show that the resulting quantitative evaluation conforms with a human evaluation of the same clusters.",1092-8138,0-8186-7283,10.1109/WPC.1996.501134,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501134,,Debugging;Software maintenance;Humans;Computer science;Application software;Prototypes;Information analysis;Distributed computing;Parallel processing;Message passing,reverse engineering;software maintenance;distributed processing;program debugging;program diagnostics;software tools,process cluster evaluation;automatic program understanding;distributed application;software design;program development;software maintenance;distributed debugging;prototypical tools;software tools;application design;static source analysis;interprocess communication;application execution;quantitative evaluation,,8,17,,,,,IEEE,IEEE Conferences
Points to analysis for program understanding,P. Tonella; G. Antoniol; R. Fiutem; E. Merlo,"IRST, Trento, Italy; NA; NA; NA",Proceedings Fifth International Workshop on Program Comprehension. IWPC'97,,1997,,,90,99,"Real world programs (in languages like C) heavily make use of pointers. Program understanding activities are thus made more difficult, since pointers affect the memory locations that are referenced in a statement, and also the functions called by a statement, when function pointers are used. The programmer needs to build a mental model of the memory use and of the pointers to its locations, in order to comprehend the functionalities of the system. This paper presents an efficient flow insensitive context insensitive points-to analysis algorithm capable of dealing with the features of the C code. It is extremely promising with regard to scalability, because of the low complexity. The results are valuable by themselves, as their graphical display represents the points to links between locations. They are also integrated with other program understanding techniques like, e.g., call graph construction, slicing, plan recognition and architectural recovery.",1092-8138,0-8186-7993,10.1109/WPC.1997.601271,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601271,,Programming profession;Algorithm design and analysis;Testing;Cognitive science;Scalability;Displays;Computer languages;Data mining;Maintenance engineering;Data engineering,reverse engineering;C language;program control structures,points to analysis;program understanding;C language;pointers;memory locations;function calls;function pointers;mental model;flow insensitive;context insensitive;scalability;graphical display;call graph;program slicing;plan recognition;architectural recovery,,4,16,,,,,IEEE,IEEE Conferences
The concept assignment problem in program understanding,T. J. Biggerstaff; B. G. Mitbander; D. Webster,"Microsoft Res., Redmond, WA, USA; NA; NA",[1993] Proceedings Working Conference on Reverse Engineering,,1993,,,27,43,The problem of discovering individual human oriented concepts and assigning them to their implementation-oriented counterparts for a given program is the concept assignment problem. It is argued that the solution to this problem requires methods that have a strong plausible reasoning component. These ideas are illustrated through recovery system called DESIRE. DESIRE is evaluated based on its use on real-world problems over the years.<<ETX>>,,0-8186-3780,10.1109/WCRE.1993.287781,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=287781,,Humans;Pattern recognition;Microelectronics;Reverse engineering;Vocabulary;Automatic control;Communication system control;Context;Maintenance engineering;Assembly,program diagnostics;software engineering;systems analysis,concept assignment problem;program understanding;human oriented concepts;implementation-oriented counterparts;plausible reasoning;recovery system;DESIRE,,11,18,,,,,IEEE,IEEE Conferences
A case study of domain-based program understanding,R. Clayton; S. Rugaber; L. Taylor; L. Wills,"Coll. of Comput., Georgia Inst. of Technol., Atlanta, GA, USA; NA; NA; NA",Proceedings Fifth International Workshop on Program Comprehension. IWPC'97,,1997,,,102,110,"Program understanding relates a computer program to the goals and requirements it is designed to accomplish. Understanding techniques that rely only on source code analysis are limited in their ability to derive this relationship. Application-domain analysis is another source of information that can aid program understanding by guiding the source analysis and providing structure to its results. This paper describes the application of a domain based program understanding process, Synchronized Refinement, to the problem of reverse engineering the Mosaic World Wide Web browser software. It discusses the domain analysis undertaken, the corresponding source code analysis we plan to perform, and the strengths and limitations of available automated tools.",1092-8138,0-8186-7993,10.1109/WPC.1997.601273,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601273,,Computer aided software engineering;Application software;Reverse engineering;Information analysis;Strontium;Software systems;Web sites;Performance analysis;Software tools;Documentation,reverse engineering;Internet;online front-ends;software tools;systems re-engineering,case study;domain-based program understanding;system requirements;source code analysis;application-domain analysis;Synchronized Refinement;reverse engineering;Mosaic World Wide Web browser;domain analysis;software tools;reengineering,,7,20,,,,,IEEE,IEEE Conferences
A use-case driven method of architecture recovery for program understanding and reuse reengineering,D. Bojic; D. Velasevic,"Fac. of Electr. Eng., Belgrade Univ., Serbia; NA",Proceedings of the Fourth European Conference on Software Maintenance and Reengineering,,2000,,,23,31,"This work focuses on architectural recovery for program understanding and reuse reengineering of legacy object-oriented systems. The proposed method is based on dynamic analysis of the system for the selected test cases that cover relevant use cases. The theory of formal concept analysis is applied to decompose the logical hierarchy of subsystems, so that parts of the system which implement similar functionality are grouped together.",,0-7695-0546,10.1109/CSMR.2000.827302,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=827302,,Unified modeling language;Software systems;Computer architecture;Clustering algorithms;System testing;Software architecture;Communication system control;Access protocols;Documentation;Technology planning,software architecture;reverse engineering;system recovery;software reusability;systems re-engineering;object-oriented programming;object-oriented methods,use-case driven method;software architecture recovery;program understanding;reuse reengineering;legacy object-oriented systems;dynamic systems analysis;formal concept analysis;logical hierarchy decomposition;subsystems;functionality,,17,38,,,,,IEEE,IEEE Conferences
The concept assignment problem in program understanding,T. J. Biggerstaff; B. G. Mitbander; D. Webster,NA; NA; NA,Proceedings of 1993 15th International Conference on Software Engineering,,1993,,,482,498,"Concept assignment is a process of recognizing concepts within a computer program and building up an understanding of the program by relating the recognized concepts to portions of the program, its operational context and to one another. The problem of discovering individual human oriented concepts and assigning them to their implementation oriented counterparts for a given program is the concept assignment problem. The authors argue that the solution to this problem requires methods that have a strong plausible reasoning component. They illustrate these ideas through example scenarios using an existing design recovery system called DESIRE. DESIRE is evaluated based on its usage on real-world problems over the years.<<ETX>>",0270-5257,0-8186-3700,10.1109/ICSE.1993.346017,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=346017,,Humans;Pattern recognition;Context;Microelectronics;Reverse engineering;Vocabulary;Automatic control;Communication system control;Maintenance engineering;Assembly,software tools;program diagnostics;software maintenance,concept assignment problem;program understanding;human oriented concepts;implementation oriented counterparts;plausible reasoning;design recovery system;DESIRE,,88,19,,,,,IEEE,IEEE Conferences
Folding: an approach to enable program understanding of preprocessed languages,B. Kullbach; V. Riediger,"Inst. for Software Technol., Univ. of Koblenz-Landau, Koblenz, Germany; NA",Proceedings Eighth Working Conference on Reverse Engineering,,2001,,,3,12,"Since the early days of programming, preprocessors have been used to increase the expressiveness of programming languages. As a prominent example, the C Preprocessor cpp even allows low level configuration management through conditional compilation. But preprocessors significantly complicate the task of program understanding because ""what the user sees is not what the compiler gets"". There is a need for bridging the gap between preprocessor input and preprocessor output. The authors propose the use of folding for explicitly representing preprocessor replacements within a program understanding environment. The approach presented has been implemented as part of the GUPRO program understanding workbench. The user is enabled to individually choose the level of detail from the programmer's view to the compiler's view on the source code.",1095-1350,0-7695-1303,10.1109/WCRE.2001.957805,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=957805,,Reverse engineering;Program processors;Data preprocessing;Computer languages;Databases;Lattices;Visualization;Bidirectional control,reverse engineering;program processors;configuration management;C language,Folding;program understanding;preprocessed languages;programming language expressiveness;C Preprocessor;cpp;low level configuration management;conditional compilation;preprocessor input;preprocessor output;preprocessor replacements;program understanding environment;GUPRO program understanding workbench;source code;compiler view,,15,14,,,,,IEEE,IEEE Conferences
A documentation-related approach to object-oriented program understanding,L. H. Etzkorn; C. G. Davis,"Alabama Univ., Huntsville, AL, USA; Alabama Univ., Huntsville, AL, USA",Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94,,1994,,,39,45,"Object-oriented code is considered to be inherently more reusable than functional decomposition code; however, object-oriented code can suffer from a program understanding standpoint since good object-oriented style seems to require a large number of small methods. Hence code for a particular task may be scattered widely. Thus good semantics based tools are necessary. This paper describes an approach to object-oriented code understanding that focuses largely on informal linguistic aspects of code, such as comments and identifiers.<<ETX>>",1092-8138,0-8186-5647,10.1109/WPC.1994.341247,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341247,,Scattering;Formal specifications;Flow graphs;Software engineering;Encapsulation;Object oriented programming;Object oriented modeling;Software maintenance;Qualifications;Tree graphs,reverse engineering;object-oriented programming;software reusability;system documentation,object-oriented program understanding;documentation;reusable;semantics based tools;linguistic aspects;comments;identifiers,,7,14,,,,,IEEE,IEEE Conferences
Data-centered program understanding,Joiner; Tsai; Chen; Subramanian; Sun; Gandamaneni,"Dept. of Comput. Sci., Minnesota Univ., Minneapolis, MN, USA; Dept. of Comput. Sci., Minnesota Univ., Minneapolis, MN, USA; Dept. of Comput. Sci., Minnesota Univ., Minneapolis, MN, USA; Dept. of Comput. Sci., Minnesota Univ., Minneapolis, MN, USA; Dept. of Comput. Sci., Minnesota Univ., Minneapolis, MN, USA; Dept. of Comput. Sci., Minnesota Univ., Minneapolis, MN, USA",Proceedings 1994 International Conference on Software Maintenance,,1994,,,272,281,"Software maintainers use a variety of techniques and representations for understanding programs. Most of these representations first focus on the control structure of a program such as call graphs, control flow graphs and paths. We propose a new approach for program understanding that is data-centered-it first focuses on data and data relationships. We have experimented on both small and large Cobol programs from industry to determine if our methods are useful for program understanding and software maintenance. We have developed DPUTE (Data-centered Program Understanding Tool Environment) that is currently being evaluated and enhanced by our industrial partners.<<ETX>>",,0-8186-6330,10.1109/ICSM.1994.336767,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=336767,,Software maintenance;Software fault diagnosis;Software tools;Software development environments,software maintenance;program diagnostics;software tools;programming environments,Data-centered Program Understanding Tool Environment;software maintenance;program control structure;call graphs;control flow graphs;control paths;data relationships;Cobol programs;DPUTE,,26,28,,,,,IEEE,IEEE Conferences
A little knowledge can go a long way towards program understanding,J. Sayyad-Shirabad; T. C. Lethbridge; S. Lyon,"Dept. of Comput. Sci., Ottawa Univ., Ont., Canada; NA; NA",Proceedings Fifth International Workshop on Program Comprehension. IWPC'97,,1997,,,111,117,"Large, complex software systems are hard to learn and navigate. In an ideal environment, documentation can help in this process. However the latter is usually out of date and hard to use. Others have proposed using large knowledge bases to model software systems, however these are very, extensive to build and may be as unmaintainable as the code. We propose instead to use a highly circumscribed, small, conceptual knowledge base, whose purpose is to help the apprentice navigate a software system, and facilitate search within the code. We present our vision, and some initial experiments which involve building such a knowledge base in a semiautomated way.",1092-8138,0-8186-7993,10.1109/WPC.1997.601275,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601275,,Documentation;Software systems;Maintenance engineering;Cognitive science;Navigation;Computer science;Application software;Knowledge acquisition;Design methodology;Computer industry,reverse engineering;knowledge based systems;utility programs,program understanding;large complex software systems;ideal environment;documentation;software system modelling;small conceptual knowledge base;apprentice;knowledge engineering,,12,8,,,,,IEEE,IEEE Conferences
Metarule-guided association rule mining for program understanding,O. Maqbool; H. A. Babri; A. Karim; M. Sarwar,"Lahore Univ. of Manage. Sci., Pakistan; NA; NA; NA",IEE Proceedings - Software,,2005,152,6,281,296,"Software systems are expected to change over their lifetime in order to remain useful. Understanding a software system that has undergone changes is often difficult owing to the unavailability of up-to-date documentation. Under these circumstances, source code is the only reliable means of information regarding the system. In the paper, association rule mining is applied to the problem of software understanding i.e. given the source files of a software system, association rule mining is used to gain an insight into the software. To make association rule mining more effective, constraints are placed on the mining process in the form of metarules. Metarule-guided mining is carried out to find associations which can be used to identify recurring problems within software systems. Metarules are related to re-engineering patterns which present solutions to these problems. Association rule mining is applied to five legacy systems and results presented show how extracted association rules can be helpful in analysing the structure of a software system and modifications to improve the structure are suggested. A comparison of the results obtained for the five systems also reveals legacy system characteristics, which can lead to understanding the nature of open source legacy software and its evolution.",1462-5970,,10.1049/ip-sen:20050012,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1577581,,,data mining;reverse engineering;systems re-engineering;software prototyping;public domain software;software maintenance,metarule-guided association rule mining;program understanding;software system understanding;source code;re-engineering patterns;open source software;legacy system;software evolution,,4,,,,,,IET,IET Journals
Investigating reverse engineering technologies for the CAS program understanding project,E. Buss; R. De Mori; W. M. Gentleman; J. Henshaw; H. Johnson; K. Kontogiannis; E. Merlo; H. A. Muller; J. Mylopoulos; S. Paul; A. Prakash; M. Stanley; S. R. Tilley; J. Troster; K. Wong,"IBM Software Solutions Division, Toronto Laboratory, IBM Canada Ltd., 895 Don Mills Road, North York, Ontario M3C 1W3, Canada; McGill university, School of Computer Science, 3480 University Street, Room 318, Montréal, Québec H3A 2A7, Canada; Institute for Information Technology, National Research Council Canada, Montreal Road, Building M-50, Ottawa, Ontario K1A 0R6, Canada; IBM Software Solutions Division, Toronto Laboratory, IBM Canada Ltd., 895 Don Mills Road, North York, Ontario M3C 1W3, Canada; Institute for Information Technology, National Research Council Canada, Montreal Road, Building M-50, Ottawa, Ontario K1A 0R6, Canada; McGill university, School of Computer Science, 3480 University Street, Room 318, Montréal, Québec H3A 2A7, Canada; Departement de Genie Electrique, École Polytechnique, C.P. 6079, Succ. Centre Ville, Montréal, Québec H3C 3A7, Canada; Department of Computer Science, University of Victoria, P.O. Box 3055, BC V8W 3P6, Canada; Department of Electrical and Computer Engineering, University of Toronto, 6 King's College Road, Ontario M5S 1A4, Canada; Software Systems Research Laboratory, Department of EECS, University of Michigan, Ann Arbor, 48109, USA; Software Systems Research Laboratory, Department of EECS, University of Michigan, Ann Arbor, 48109, USA; Department of Electrical and Computer Engineering, University of Toronto, 6 King's College Road, Ontario M5S 1A4, Canada; Department of Computer Science, University of Victoria, P.O. Box 3055, BC V8W 3P6, Canada; IBM Software Solutions Division, Toronto Laboratory, IBM Canada Ltd., 895 Don Mills Road, North York, Ontario M3C 1W3, Canada; Department of Computer Science, University of Victoria, P.O. Box 3055, BC V8W 3P6, Canada",IBM Systems Journal,,1994,33,3,477,500,"Corporations face mounting maintenance and re-engineering costs for large legacy systems. Evolving over several years, these systems embody substantial corporate knowledge, including requirements, design decisions, and business rules. Such knowledge is difficult to recover after many years of operation, evolution, and personnel change. To address the problem of program understanding, software engineers are spending an ever-growing amount of effort on reverse engineering technologies. This paper describes the scope and results of an ongoing research project on program understanding undertaken by the IBM Toronto Software Solutions Laboratory Centre for Advanced Studies (CAS). The project involves a team from CAS and five research groups working cooperatively on complementary reverse engineering approaches. All the groups are using the source code of SQL/DS™ (a multimillion-line relational database system) as the reference legacy system. Also discussed is an approach adopted to integrate the various tools under a single reverse engineering environment.",0018-8670,,10.1147/sj.333.0477,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5387326,,,,,,23,,,,,,IBM,IBM Journals
The interleaving problem in program understanding,S. Rugaber; K. Stirewalt; L. M. Wills,"Coll. of Comput., Georgia Inst. of Technol., Atlanta, GA, USA; Coll. of Comput., Georgia Inst. of Technol., Atlanta, GA, USA; Coll. of Comput., Georgia Inst. of Technol., Atlanta, GA, USA",Proceedings of 2nd Working Conference on Reverse Engineering,,1995,,,166,175,"One of the factors that can make a program difficult to understand is that code responsible for accomplishing more than one purpose may be woven together in a single section. We call this interleaving, and it may arise either intentionally-for example, in optimizing a program, a programmer may use some intermediate result for several purposes-or unintentionally, due to patches, quick fixes, or other hasty maintenance practices. To understand this phenomenon, we have looked at a variety of interleaving instances in actual programs and have distilled characteristic features. If the characterization proves to be robust then it will enable the design of tools for detection of interleavings and the extraction of the individual strands of computation.",,0-8186-711-,10.1109/WCRE.1995.514705,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=514705,,Interleaved codes;Programming,reverse engineering;software maintenance;software tools,interleaving problem;program understanding;program optimization;software maintenance;computation;reverse engineering,,28,29,,,,,IEEE,IEEE Conferences
Using an artificial intelligence approach to build an automated program understanding/fault localization tool,I. Burnstein; R. Saner; Y. Limpiyakorn,"Dept. of Comput. Sci., Illinois Inst. of Technol., Chicago, IL, USA; NA; NA",Proceedings 11th International Conference on Tools with Artificial Intelligence,,1999,,,69,76,"Artificial intelligence techniques and architectures have played a large role in the design of a blackboard-based program understanding/fault localization tool we have been developing. We focus on a system knowledge source called the plan processor which will have artificial intelligence support for two of its major tasks. One task is to retrieve a set of program plans from a plan library using indices called signatures. To make this retrieval task more effective we propose using a genetic algorithm. We also describe a fuzzy reasoning component which supports the plan processor with a second task; ranking the retrieved plans in order of similarity to the target code. The most similar plan is then used for the complex plan/code matching required for automated program understanding. Our approach may eliminate the need for exhaustive plan library searches, and could lead to automated program understanders that scale up for use on software systems from a variety of problem domains.",1082-3409,0-7695-0456,10.1109/TAI.1999.809768,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=809768,,Artificial intelligence;Computer architecture;Software systems;Computer science;Genetic algorithms;Software libraries;Software maintenance;Software tools;Knowledge engineering;Programming profession,blackboard architecture;reverse engineering;program debugging;planning (artificial intelligence);genetic algorithms;fuzzy logic;inference mechanisms;uncertainty handling,artificial intelligence;program understanding;fault localization tool;blackboard-based tool;system knowledge source;plan processor;plan library;genetic algorithm;fuzzy reasoning,,1,18,,,,,IEEE,IEEE Conferences
Towards a framework for program understanding,S. R. Tilley; S. Paul; D. B. Smith,"Software Eng. Inst., Carnegie Mellon Univ., Pittsburgh, PA, USA; NA; NA",WPC '96. 4th Workshop on Program Comprehension,,1996,,,19,28,The paper describes an initial conceptual framework for the classification of reverse engineering tools and techniques that aid program understanding. It is based on a description of the canonical activities that are characteristic of the reverse engineering process. A descriptive model is presented that categorizes important support mechanism features based on a hierarchy of attributes.,1092-8138,0-8186-7283,10.1109/WPC.1996.501117,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501117,,Reverse engineering;Software engineering;Software maintenance;Programming profession;Cognition;Relational databases,reverse engineering;computer aided software engineering;cognitive systems,program understanding framework;reverse engineering tools;canonical activities;descriptive model;support mechanism features;attribute hierarchy,,39,23,,,,,IEEE,IEEE Conferences
Toward a constraint-satisfaction framework for evaluating program-understanding algorithms,A. Quilici; S. Woods,"Dept. of Electr. Eng., Hawaii Univ., Honolulu, HI, USA; NA",WPC '96. 4th Workshop on Program Comprehension,,1996,,,55,64,"Different program understanding algorithms often use different representational frameworks and take advantage of numerous heuristic tricks. This situation makes it difficult to compare these approaches and their performance. The paper addresses this problem by proposing constraint satisfaction as a general framework for describing program understanding algorithms, demonstrating how to transform a relatively complex existing program understanding algorithm into an instance of a constraint satisfaction problem, and showing how this facilitates better understanding of its performance.",1092-8138,0-8186-7283,10.1109/WPC.1996.501121,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501121,,Libraries;Performance analysis;Algorithm design and analysis;Indexing;Computer science;Distributed computing;Scalability;Heuristic algorithms;Decoding,reverse engineering;heuristic programming;constraint handling;constraint theory,constraint satisfaction framework;program understanding algorithm evaluation;representational frameworks;heuristic tricks,,6,21,,,,,IEEE,IEEE Conferences
PUI: a tool to support program understanding,Pui-Shan Chan; M. Munro,"Visualization Res. Group, Durham Univ., UK; NA",Proceedings Fifth International Workshop on Program Comprehension. IWPC'97,,1997,,,192,198,"Static analysis tools are useful in extracting information from programs. Maintainers are more likely to be overloaded with information extracted from these analysis tools as programs grow in size. This paper outlines some of the theories and strategies of program comprehension and describes how the various strategies can be realised by a simple browsing tool, PUI (Program Understanding Implement), which allows maintainers to understand the relationships between program elements. The tool is based on a matrix of program relations designed to reflect the multi-dimensional nature of programs. This work is centred on the C programming language.",1092-8138,0-8186-7993,10.1109/WPC.1997.601293,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601293,,Information analysis;Data mining;Computer languages;Switches;Visualization;Software maintenance;DH-HEMTs;Documentation;Information resources;Control systems,software tools;reverse engineering;program diagnostics;software maintenance;C language;computer aided software engineering,PUI;Program Understanding Implement;static analysis tool;program information extraction;software maintenance;program comprehension;browsing tool;program element relationships;program relations matrix;multi-dimensional programs;C programming language,,3,14,,,,,IEEE,IEEE Conferences
Integrated hypertext and program understanding tools,P. Brown,"IBM Enterprise Systems Division, Sterling Forest, P.O. Box 700, Suffern, New York 10901, USA",IBM Systems Journal,,1991,30,3,363,392,"This paper describes some concepts and issues related to software tools integration. Questions regarding data integration and functional integration between tools are identified and discussed. Some techniques for handling large volumes of data are briefly described. A prototype tool is described in which hypertext links are automatically created between program analysis data and hypertext documentation. With this tool, end users can freely move between source code views and related documentation. A common annotation feature lets software developers and information developers share information and synchronize maintenance activities in a single tools environment.",0018-8670,,10.1147/sj.303.0363,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5387485,,,,,,9,,,,,,IBM,IBM Journals
An Eye-Tracking Study of Java Programmers and Application to Source Code Summarization,P. Rodeghero; C. Liu; P. W. McBurney; C. McMillan,"Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN",IEEE Transactions on Software Engineering,,2015,41,11,1038,1054,"Source Code Summarization is an emerging technology for automatically generating brief descriptions of code. Current summarization techniques work by selecting a subset of the statements and keywords from the code, and then including information from those statements and keywords in the summary. The quality of the summary depends heavily on the process of selecting the subset: a high-quality selection would contain the same statements and keywords that a programmer would choose. Unfortunately, little evidence exists about the statements and keywords that programmers view as important when they summarize source code. In this paper, we present an eye-tracking study of 10 professional Java programmers in which the programmers read Java methods and wrote English summaries of those methods. We apply the findings to build a novel summarization tool. Then, we evaluate this tool. Finally, we further analyze the programmers' method summaries to explore specific keyword usage and provide evidence to support the development of source code summarization systems.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2015.2442238,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7118751,Source code summaries;program comprehension;Source code summaries;program comprehension,Java;Software;Documentation;Navigation;XML;Software engineering,Java;program compilers;source code (software),eye-tracking study;Java programmer;source code summarization;code generation,,9,75,,,,,IEEE,IEEE Journals
Automatic Source Code Summarization of Context for Java Methods,P. W. McBurney; C. McMillan,"College of Computer Science and Engineering, University Notre Dame, Notre Dame, IN; Computer Science, University of Notre Dame, South Bend, VA",IEEE Transactions on Software Engineering,,2016,42,2,103,119,"Source code summarization is the task of creating readable summaries that describe the functionality of software. Source code summarization is a critical component of documentation generation, for example as Javadocs formed from short paragraphs attached to each method in a Java program. At present, a majority of source code summarization is manual, in that the paragraphs are written by human experts. However, new automated technologies are becoming feasible. These automated techniques have been shown to be effective in select situations, though a key weakness is that they do not explain the source code's context. That is, they can describe the behavior of a Java method, but not why the method exists or what role it plays in the software. In this paper, we propose a source code summarization technique that writes English descriptions of Java methods by analyzing how those methods are invoked. We then performed two user studies to evaluate our approach. First, we compared our generated summaries to summaries written manually by experts. Then, we compared our summaries to summaries written by a state-of-the-art automatic summarization tool. We found that while our approach does not reach the quality of human-written summaries, we do improve over the state-of-the-art summarization tool in several dimensions by a statistically-significant margin.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2015.2465386,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181703,Source code summarization;automatic documentation;program comprehension;Source code summarization;automatic documentation;program comprehension,Context;Documentation;Java;Natural languages;Software;Generators;XML,Java;object-oriented methods,source code summarization technique;Java methods;software functionality;documentation generation;Javadocs;Java program;user studies;automatic summarization tool;human-written summaries,,18,51,,,,,IEEE,IEEE Journals
Entity based source code summarization (EBSCS),Chitti babu K; Kavitha C.; SankarRam N,"Dept. of. CSE, RMKCET, Chennai, India; Dept. of. CSE, RMKCET, Chennai, India; Dept. of. CSE, RMKCET, Chennai, India",2016 3rd International Conference on Advanced Computing and Communication Systems (ICACCS),,2016,1,,1,5,"In the software evolution process a developer must analyze the source code in order to understand the entities in it. In general this analysis is done manually which takes lots of time and is a tedious task. The other option is to use automated source code summarization techniques. Existing techniques does not provide the required summary and most of them are complex. Source code summarization is the task of creating readable summaries that describe the functionality of software. Source code summarization is a critical component of documentation generation. In this paper we propose a novel summarization technique called EBSCS which is based on the entities like packages, classes, methods control statements and comments in the source code. In this technique description is generated for the entities and the comment lines are used to generate summary for the source code.",,978-1-4673-9206-8978-1-4673-9207,10.1109/ICACCS.2016.7586385,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7586385,Source code entities;Source code summarization;Textual clues;source code comprehension,Documentation;Semantics;Communication systems;Software maintenance;Generators;Conferences,software engineering;source code (software);system documentation,entity based source code summarization;EBSCS;software evolution;software functionality;documentation generation,,,14,,,,,IEEE,IEEE Conferences
IDE-independent program comprehension tools via source file overwriting,M. Sulír; J. Porubän; O. Zoricák,"Department of Computers and Informatics, Faculty of Electrical Engineering and Informatics, Technical University of Košice Letná 9, 042 00 Košice, Slovakia; Department of Computers and Informatics, Faculty of Electrical Engineering and Informatics, Technical University of Košice Letná 9, 042 00 Košice, Slovakia; Department of Computers and Informatics, Faculty of Electrical Engineering and Informatics, Technical University of Košice Letná 9, 042 00 Košice, Slovakia",2017 IEEE 14th International Scientific Conference on Informatics,,2017,,,372,376,"Traditionally, we have two possibilities to design tools for program comprehension and analysis. The first option is to create a standalone program, independent of any source code editor. This way, the act of source code editing is separated from the act of viewing the code analysis results. The second option is to create a plugin for a specific IDE (integrated development environment) - in this case, a separate version must be created for each IDE. We propose an approach where information about source code elements is written directly into source files as annotations or special comments. Before committing to a version control system, the annotations are removed from the source code to avoid code pollution. We briefly evaluate the approach and delineate its limitations.",,978-1-5386-0889-0978-1-5386-0888-3978-1-5386-0890,10.1109/INFORMATICS.2017.8327277,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8327277,,Tools;Metadata;Java;Control systems;Measurement;Informatics;Computers,configuration management;programming environments;software tools;source code (software),IDE-independent program comprehension tools;design tools;standalone program;source code editor;source code editing;code analysis results;integrated development environment;source file overwriting;version control system,,1,18,,,,,IEEE,IEEE Conferences
Enabling program comprehension through a visual object-focused development environment,F. Olivero; M. Lanza; M. D'Ambros; R. Robbes,"REVEAL @ Faculty of Informatics - University of Lugano, Switzerland; REVEAL @ Faculty of Informatics - University of Lugano, Switzerland; REVEAL @ Faculty of Informatics - University of Lugano, Switzerland; PLEIAD@DCC - University of Chile, Chile",2011 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC),,2011,,,127,134,"Integrated development environments (IDEs) include many tools that provide the means to construct programs. Coincidentally, the very same IDEs are a primary vehicle for program comprehension. We claim that IDEs may be an impediment for program comprehension because they treat software elements as text, which may be counterproductive in the context of program understanding-where abstracting from the source text to the level of structural entities and relationships is the key. We are currently building Gaucho, a visual object-focused environment that allows developers to write programs by creating and manipulating lightweight and intuitive depictions of object-oriented constructs. The research question we investigate here is how such an environment compares with traditional IDEs when it comes to performing program comprehension tasks. To answer our question, we conducted a preliminary controlled experiment with eight subjects, comparing Gaucho against a traditional IDE. We found that Gaucho outperforms the IDE regarding the correctness of the tasks, while it is slower with respect to the completion time. Our preliminary results suggest that alternative-visual-IDEs may be superior to traditional IDEs as program comprehension aids.",1943-6106;1943-6092;1943-6092,978-1-4577-1247-0978-1-4577-1246-3978-1-4577-1244,10.1109/VLHCC.2011.6070389,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6070389,,Shape;Navigation;Visualization;Software;Programming;Object oriented modeling;Layout,object-oriented methods;software maintenance,program comprehension;visual object-focused development environment;integrated development environment;program understanding context;Gaucho environment;object-oriented constructs,,4,25,,,,,IEEE,IEEE Conferences
Effort estimation for program comprehension,P. Fiore; F. Lanubile; G. Visaggio,"Basica spa, Bari, Italy; NA; NA",WPC '96. 4th Workshop on Program Comprehension,,1996,,,78,87,"The study presents an experience of deriving an econometric model for software comprehension; this process is necessary for the renovation of existing software systems. The model uses data on the process and products. The aim of the econometric model is to minimize the risks when forecasting the budget and time needed to carry out the project. After having obtained the basic model, the correction factors which could reduce the risk or error of the forecast are considered. In particular, one factor, the suitability of the tool for the processes, requires such marked correction that the basic model is divided into two, one for each type of process (automatic or semiautomatic). All the models have the code lines of the existing program as independent variables; the model for semiautomatic processes uses the number of modules to be extracted as a regulator of the risk of forecasting error.",1092-8138,0-8186-7283,10.1109/WPC.1996.501123,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501123,,Predictive models;Economic forecasting;Econometrics;Reverse engineering;Error correction;Electronic mail;Software systems;Regulators;Investments;Humans,reverse engineering;software reusability;economic cybernetics;software management;project management,effort estimation;program comprehension;econometric model;software comprehension;software systems renovation;correction factors;marked correction;code lines;independent variables;semiautomatic processes;forecasting error risk,,3,21,,,,,IEEE,IEEE Conferences
DOCKET: program comprehension-in-the-large,P. J. Layzell; R. Champion; M. J. Freeman,"Dept. of Comput., Univ. of Manchester, Inst. of Sci. & Technol., UK; Dept. of Comput., Univ. of Manchester, Inst. of Sci. & Technol., UK; Dept. of Comput., Univ. of Manchester, Inst. of Sci. & Technol., UK",[1993] IEEE Second Workshop on Program Comprehension,,1993,,,140,148,"With the growing awareness of the importance of software maintenance, has come a re-evaluation of software maintenance tools. Such tools range from source code analysers to semi-intelligent tools which seek to reconstruct systems designs and specification documents from source code. However, it is clear that relying solely upon source code as the basis for reverse engineering has many problems. This paper proposes the need for program comprehension-in-the-large and describes the work of the Esprit DOCKET project which seeks to provide such a support capability. The DOCKET project has developed a prototype environment to support the development of a system model linking user-oriented, business aspects of a system, to operational code using a variety of knowledge source inputs: code, documents and user expertise. The aim is to provide a coherent model to form the basis for system and program understanding and to support the software change and evolution process.<<ETX>>",1092-8138,0-8186-4042,10.1109/WPC.1993.263897,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263897,,Software maintenance;Documentation;Humans;Reverse engineering;Software engineering;Computer industry;Software tools;Software systems;Software prototyping;Prototypes,software maintenance;software tools,DOCKET;program comprehension-in-the-large;software maintenance;maintenance tools;source code analysers;semi-intelligent tools;specification documents;business aspects;operational code;knowledge source;program understanding;software change;evolution process,,8,6,,,,,IEEE,IEEE Conferences
Detecting and comparing brain activity in short program comprehension using EEG,M. K. -. Yeh; D. Gopstein; Y. Yan; Y. Zhuang,"College of Information Sciences and Technology, Penn State University, Brandywine; Department of Computer Science and Engineering, New York University; College of Education, Penn State University, University Park; Department of Computer Science, University of Colorado, Colorado Sprints",2017 IEEE Frontiers in Education Conference (FIE),,2017,,,1,5,"Program comprehension is a common task in software development. Programmers perform program comprehension at different stages of the software development life cycle. Detecting when a programmer experiences problems or confusion can be difficult. Self-reported data may be useful, but not reliable. More importantly, it is hard to use the self-reported feedback in real time. In this study, we use an inexpensive, non-invasive EEG device to record 8 subjects' brain activity in short program comprehension. Subjects were presented either confusing or non-confusing C/C++ code snippets. Paired sample t-tests are used to compare the average magnitude in alpha and theta frequency bands. The results show that the differences in the average magnitude in both bands are significant comparing confusing and non-confusing questions. We then use ANOVA to detect whether such difference also presented in the same type of questions. We found that there is no significant difference across questions of the same difficulty level. Our outcome, however, shows alpha and theta band powers both increased when subjects are under the heavy cognitive workload. Other research studies reported a negative correlation between (upper) alpha and theta band powers.",,978-1-5090-5920-1978-1-5090-5919-5978-1-5090-4920,10.1109/FIE.2017.8190486,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8190486,computer programming;electroencephalograph;EEG,Electroencephalography;Brain;Software;Electrodes;Real-time systems;Performance evaluation,electroencephalography;medical signal processing,EEG device;program comprehension;C/C++ code snippets;ANOVA;brain activity;software development life cycle,,,20,,,,,IEEE,IEEE Conferences
Building Usage Contexts During Program Comprehension,C. Parnin; C. Gorg,Georgia Institute of Technology; NA,14th IEEE International Conference on Program Comprehension (ICPC'06),,2006,,,13,22,"Software developers often work on multiple simultaneous projects. Even when only a single project is underway, everyday distractions interrupt the development effort. Consequently, developers spend significant effort pursuing recovery of their context. By context, we focus on the classes and methods within the code that are relevant to a specific bug being fixed or enhancement made. Context is reified by a program in terms of a set of presentations (windows a containing source code, command executions, and data files); however, it is not enough to save the latest context. Even when working on a single task, programmers flip between contexts as they extend their understanding, and when they decide on a change, they may have to visit several contexts in order to address all possible ripple effects. Consequently, we would like to record a history of contexts and be able to retrieve them as demanded by the current task. We introduce a novel technique to obtain a context, consisting of a set of methods relevant for the current task, from a programmer's interactions with an IDE. Using this context, we demonstrate how to improve the ability of a programmer to recover the mental state associated with tasks and to facilitate the exploration of software through recommendation systems",1092-8138,0-7695-2601,10.1109/ICPC.2006.14,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631101,,Programming profession;Educational institutions;History;Software systems;Energy resolution;Organizing;Context modeling,human factors;project management;reverse engineering;software engineering,program usage context;program comprehension;software project development;program bug;programmer interaction;IDE;recommendation system,,31,18,,,,,IEEE,IEEE Conferences
Automated chunking to support program comprehension,I. Burnstein; K. Roberson,"Dept. of Comput. Sci., Illinois Inst. of Technol., Chicago, IL, USA; NA",Proceedings Fifth International Workshop on Program Comprehension. IWPC'97,,1997,,,40,49,"We report on a program comprehension support tool called the Chunker. It partitions code into abstractions called candidate chunks using data dependency analysis and a set of heuristics. The candidate chunks can be mapped to programming and problem domain concepts by a software engineer and are useful for building mental models during comprehension. We describe the implementation of the Chunker, performance issues, and plans for tool enhancement.",1092-8138,0-8186-7993,10.1109/WPC.1997.601262,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601262,,Cognitive science;Data analysis;Software tools;Data visualization;Displays;Computer science;Software performance;Buildings;Computer languages;Assembly,reverse engineering;software tools;user modelling;software performance evaluation,automated chunking;program comprehension support tool;Chunker;code partitioning;abstractions;candidate chunks;data dependency analysis;heuristics;programming;mental models;software performance,,7,12,,,,,IEEE,IEEE Conferences
Scalable interfaces to support program comprehension,W. Citrin; C. Santiago; B. Zorn,"Dept. of Electr. & Comput. Eng., Colorado Univ., Boulder, CO, USA; NA; NA",WPC '96. 4th Workshop on Program Comprehension,,1996,,,123,132,"Studies of how programmers understand code suggest that programmers approach the understanding task in both bottom-up and top-town ways, depending on the context. We present a tool, VIPR, that provides a unified visual representation of both high-level and low-level constructs and a smooth transition between the two levels through smoothly animated zooming and focus and context ('fisheyeing') techniques. VlPR is currently being used to visualize Tcl programs, but the technique is generally applicable to programs written in any imperative programming language.",1092-8138,0-8186-7283,10.1109/WPC.1996.501127,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501127,,Programming profession;Visualization;Animation;Microstructure;Computer languages;Programming environments;User interfaces;Computer science,reverse engineering;program diagnostics;software tools;visual programming;data visualisation;graphical user interfaces,scalable interfaces;program comprehension;programmers;program understanding;bottom-up;top-town;VIPR;software tool;visual representation;zooming;animation;fisheye;program visualization;Tcl programs;imperative programming language;programming environment;graphical user interface,,5,17,,,,,IEEE,IEEE Conferences
Program comprehension experiences with GXL; comprehension for comprehension,C. Knight; M. Munro,"Dept. of Comput. Sci., Durham Univ., UK; Dept. of Comput. Sci., Durham Univ., UK",Proceedings 10th International Workshop on Program Comprehension,,2002,,,147,156,"Tools are vital to support the various activities that form the many tasks that are part of the program comprehension process. In order for these tools to be used and useful, it is necessary that they support the activities of the user. This support must complement the work methods and activities of the user and not hinder them. Whilst features of good tools have been identified, tool builders do not always adhere to them. It is important to consider whether needs have changed, and if those desirable properties need augmenting or revising. From experience of maintaining and enhancing an existing program comprehension tool for the purposes of participating in a re-engineering activity, many lessons on tool support have been learned. Various program comprehension strategies are introduced in this paper. The use of GXL (Graph eXchange Language) and involvement in the SORTIE project are presented with reference to the tool being adapted and used. Details of the changes made are given to illustrate the support desired. These all feed into the final section of the paper that discusses the sort of support that tools should provide, current tool deficiencies and some of the ways in which these could be addressed.",1092-8138,0-7695-1495,10.1109/WPC.2002.1021336,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021336,,Software tools;Software maintenance;Visualization;Computer science;Programming profession;Feeds;Conferences,reverse engineering;software tools;visual languages;electronic data interchange;program visualisation,program comprehension;GXL;Graph Exchange Language;user work methods;user activities;reengineering activity;SORTIE project;tool deficiencies,,2,22,,,,,IEEE,IEEE Conferences
Reading the documentation of invoked API functions in program comprehension,U. Dekel; J. D. Herbsleb,"Institute for Software Research, School of Computer Science, Carnegie Mellon University, 5000 Forbes Avenue, Pittsburgh, PA 15213 USA; Institute for Software Research, School of Computer Science, Carnegie Mellon University, 5000 Forbes Avenue, Pittsburgh, PA 15213 USA",2009 IEEE 17th International Conference on Program Comprehension,,2009,,,168,177,"Comprehending an unfamiliar code fragment requires an awareness of explicit usage directives that may be present in the documentation of some invoked functions. Since it is not practical for developers to thoroughly investigate every call, directives may be missed and errors may occur. We previously reported on a tool called eMoose, which highlights calls to methods with associated directives, and on a controlled comparative lab study in which eMoose users were more successful at fixing bugs in given code fragments. In this paper we attempt to shed light on the factors behind these differences with a detailed analysis of videos from the study. We argue that information foraging theory may explain the subjects' reading choices and the impact of our tool. We also suggest ways to structure documentation to increase the prospects of knowledge acquisition.",1092-8138,978-1-4244-3998-0978-1-4244-3997,10.1109/ICPC.2009.5090040,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090040,,Documentation;Java;Functional programming;Computer science;Computer bugs;Videos;Knowledge acquisition;Software maintenance;Collaborative software;Application software,application program interfaces;knowledge acquisition;program debugging;software maintenance,application programming interfaces;software maintenance;program comprehension;information foraging theory;knowledge acquisition,,7,13,,,,,IEEE,IEEE Conferences
MOOSE - a task-driven program comprehension environment,J. Rilling; A. Seffah,"Dept. of Comput. Sci., Concordia Univ., Montreal, Que., Canada; NA",25th Annual International Computer Software and Applications Conference. COMPSAC 2001,,2001,,,77,84,"Many tools have been developed to derive abstract representations from existing source code. Yet, most of these tools provide only little help in providing an encompassing picture of the system under examination. Graphical visualization techniques derived from reverse engineered source code have long been recognized for their impact on improving the comprehensibility of software systems and their source code. In this paper, we present a task-oriented approach to software comprehension by introducing our MOOSE (Montreal Object-Oriented Slicing Environment) environment that provides a task-driven wizard approach that supports a cognitive comprehension model combined with reverse engineering techniques, algorithmic and visualization support. We close our discussion with a brief overview of typical software comprehension tasks and how the MOOSE environment will benefit users during these comprehension tasks.",0730-3157,0-7695-1372,10.1109/CMPSAC.2001.960601,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=960601,,Reverse engineering;Object oriented modeling;Software maintenance;Software systems;Computer science;Design methodology;Data visualization;Pattern matching;Pattern recognition;Software quality,reverse engineering;program slicing;program visualisation;programming environments;object-oriented methods,MOOSE;task-driven program comprehension environment;abstract representations;source code;graphical visualization;reverse engineered source code;task-oriented approach;Montreal Object-Oriented Slicing Environment;task-driven wizard;cognitive comprehension model;reverse engineering techniques,,2,31,,,,,IEEE,IEEE Conferences
Using conceptual roles of data for enhanced program comprehension,Yunbo Deng; S. Kothari,"Dept. of Electr. & Comput. Eng., Iowa State Univ., Ames, IA, USA; Dept. of Electr. & Comput. Eng., Iowa State Univ., Ames, IA, USA","Ninth Working Conference on Reverse Engineering, 2002. Proceedings.",,2002,,,119,127,"Without proper background, it is often very difficult for human beings to understand a legacy code. Domain knowledge is valuable to guide domain experts to efficiently comprehend and reengineer domain applications. In the comprehension process, what domain experts normally do is associate domain concepts in the human mind with their representations in the actual code. This paper is addressed as an effort to recover the representations of domain-specific concepts in an application and show the usefulness of such recovery in program comprehension. We describe two important aspects of this research: data-centered program analysis to recover the conceptual roles of data in a program; deriving a ""program skeleton"" aided by the conceptual roles to present an abstraction to capture the program behavior and the relationship between kernel variables in a program. We are developing a software engineering environment, named ""SeeCORE"", which incorporates these two approaches. SeeCORE can be customized for different domains by appropriately user-defined domain-specific rules. We have used a class of scientific applications as a domain to demonstrate our approach.",1095-1350,0-7695-1799,10.1109/WCRE.2002.1173070,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1173070,,Reverse engineering,reverse engineering;program diagnostics;programming environments,legacy code;domain knowledge;program comprehension;data-centered program analysis;program skeleton;program behavior;software engineering environment;SeeCORE;user-defined domain-specific rules,,,16,,,,,IEEE,IEEE Conferences
A structured demonstration of program comprehension tools,S. E. Sim; M. A. D. Storey,"Dept. of Comput. Sci., Toronto Univ., Ont., Canada; NA",Proceedings Seventh Working Conference on Reverse Engineering,,2000,,,184,193,"This paper describes a structured tool demonstration, a hybrid evaluation technique that combines elements from experiments, case studies and technology demonstrations. Developers of program understanding tools were invited to bring their tools to a common location to participate in a scenario with a common subject system. Working simultaneously the tool teams were given reverse engineering tasks and maintenance tasks to complete on an unfamiliar subject system. Observers were assigned to each team to find out how useful the observed program comprehension tool would be in an industrial setting. The demonstration was followed by a workshop panel where the development teams and the observers presented their results and findings from this experience.",1095-1350,0-7695-0881,10.1109/WCRE.2000.891465,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=891465,,Reverse engineering;Software systems;Software tools;Computer science;Educational institutions;Technology transfer;Scalability;Nominations and elections;Visualization;Operating systems,reverse engineering;software maintenance;software tools,program comprehension tools;structured tool demonstration;hybrid evaluation technique;experiments;case studies;technology demonstrations;program understanding;reverse engineering;software maintenance,,12,24,,,,,IEEE,IEEE Conferences
Maintenance of embedded systems: Supporting program comprehension using dynamic analysis,J. Trümper; S. Voigt; J. Döllner,"Hasso-Plattner-Institute - University of Potsdam, Germany; Hasso-Plattner-Institute - University of Potsdam, Germany; Hasso-Plattner-Institute - University of Potsdam, Germany",2012 Second International Workshop on Software Engineering for Embedded Systems (SEES),,2012,,,58,64,"Maintenance of embedded software systems is faced with multiple challenges, including the exploration and analysis of the actual system's runtime behavior. As a fundamental technique, tracing can be used to capture data about runtime behavior as a whole, and represents one of the few methods to observe and record data about embedded systems within their production environments. In this paper we present a software-based, function-boundary tracing approach for embedded software systems. It uses static binary instrumentation, which implies only lightweight memory and performance overheads. To further reduce these overheads, instrumentation can be configured per trace, i.e., activated only for a specified group of functions without having to recompile the system. The technique can be characterized by its robust implementation and its versatile usage. It is complemented by a visualization framework that allows for analysis and exploration of a system's runtime behavior, e.g., to examine thread interaction. To show the technique's applicability, we conclude with a case study that has been applied to an industrial embedded software system.",,978-1-4673-1853-2978-1-4673-1852,10.1109/SEES.2012.6225492,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6225492,,Instruments;Runtime;Embedded systems;Libraries;Hardware,embedded systems;software maintenance,embedded system maintenance;program comprehension support;dynamic analysis;embedded software systems;fundamental technique;production environments;static binary instrumentation;lightweight memory,,4,36,,,,,IEEE,IEEE Conferences
Assessing the contribution of the individual alpha frequency (IAF) in an EEG-based study of program comprehension,I. Crk; T. Kluthe,"Department of Computer Science, Southern Illinois University Edwardsville, Edwardsville, IL 62026, USA; Department of Computer Science, Southern Illinois University Edwardsville, Edwardsville, IL 62026, USA",2016 38th Annual International Conference of the IEEE Engineering in Medicine and Biology Society (EMBC),,2016,,,4601,4604,"Empirical studies of programming language learnability and usability have thus far depended on indirect measures of human cognitive performance, attempting to capture what is at its essence a purely cognitive exercise through various indicators of comprehension, such as the time spent working out the meaning of code and producing acceptable solutions. We present evidence of the relative contribution of experience and the individual alpha frequency (IAF) to achieving correct performance during program comprehension tasks, specifically that more experience and higher IAF are both associated with an increased likelihood of correct task performance, with experience playing the greater part.",1558-4615;1557-170X,978-1-4577-0220-4978-1-4577-0219,10.1109/EMBC.2016.7591752,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7591752,,Electroencephalography;Atmospheric measurements;Particle measurements;Timing;Programming;Frequency conversion,cognition;electroencephalography;human computer interaction,individual alpha frequency;EEG-based study;program comprehension tasks;programming language learnability;programming language usability;human cognitive performance;empirical study;human-computer interaction,Alpha Rhythm;Comprehension;Electroencephalography;Humans;Logistic Models;Reproducibility of Results;Task Performance and Analysis;Time Factors,1,22,,,,,IEEE,IEEE Conferences
How Webmining and Coupling Metrics Improve Early Program Comprehension,A. Zaidman; Bart Du Bois; S. Demeyer,"University of Antwerp, Belgium; NA; NA",14th IEEE International Conference on Program Comprehension (ICPC'06),,2006,,,74,78,"During initial program comprehension, software engineers could benefit from knowing the most need-to-be-understood classes in the system under study in order to kick-start their software reconnaissance. Previously we have used Webmining techniques on runtime trace data to identify these important classes. Here, we reprise this Webmining technique and make a thorough comparison of its effectiveness when collecting static information of the software system under study. Apache Ant and Jakarta JMeter, two medium-scale open source Java software systems, serve as case studies. From publicly available developers notes we conclude that the Webmining technique in combination with dynamic analysis provides the best results with a level of recall of 90% when comparing with the developers' opinion",1092-8138,0-7695-2601,10.1109/ICPC.2006.26,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631107,,Software systems;Runtime;Open source software;Information analysis;Reconnaissance;Java;Large-scale systems;Leg;Availability;Scalability,data mining;Internet;Java;public domain software;reverse engineering;software maintenance;software metrics;system monitoring,Webmining;coupling metrics;program comprehension;software engineering;software reconnaissance;runtime trace data;Apache Ant;Jakarta JMeter;open source Java software system;dynamic analysis,,9,7,,,,,IEEE,IEEE Conferences
An Empirical Study on the Usage of SQL Execution Traces for Program Comprehension,N. Noughi; S. Hanenberg; A. Cleve,NA; NA; NA,"2017 IEEE International Conference on Software Quality, Reliability and Security Companion (QRS-C)",,2017,,,47,54,"Several studies have investigated dynamic analysis in the context of software maintenance and evolution, and most of them confirmed the positive impact of such analysis on program comprehension tasks. In this paper, we focus on the understanding of the database access behavior of a program, which has become an important (yet largely ignored) aspect of program comprehension. We empirically assess how developers/students are (not) able to understand interactions between the database and the application program. To this end, we used DAViS, a tool for Dynamic Analysis and Visualization of SQL execution traces. We present a controlled experiment that quantitatively evaluates to what extent DAViS can influence program comprehension in terms of duration and correctness of the tasks. The results of the study indicate that DAViS does reduce the response time and increases the correctness (with a large effect size), which means that we found a strong indicator that the chosen approach is truly able to help developers.",,978-1-5386-2072-4978-1-5386-2073,10.1109/QRS-C.2017.17,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8004293,,Databases;Structured Query Language;Tools;Time factors;Performance analysis;Time measurement;Software,data visualisation;software maintenance;SQL,SQL execution traces;dynamic analysis;software maintenance;software evolution;program comprehension tasks;database access behavior;database;application program;DAViS;dynamic visualization,,,25,,,,,IEEE,IEEE Conferences
Program comprehension for the purpose of testing,H. M. Sneed,"ANECON GmbH, Vienna, Austria","Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.",,2004,,,162,171,"In this paper, program comprehension techniques are examined within the context of testing. First, the tasks of a tester are identified, then the information requirements of a tester to fulfill these tasks. Comprehension is viewed as a knowledge acquisition process. The knowledge needed depends on the level at which one is testing. For system testing, other knowledge is required than for unit and integration testing. In light of the scope of testing, the paper concludes that it is the tester who needs the broadest knowledge about a software system. Having established the information requirements of testing, a set of tools are presented which help to satisfy these requirements and their practical application discussed.",1092-8138,0-7695-2149,10.1109/WPC.2004.1311058,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311058,,Software testing;System testing;Costs;Databases;Software systems;Application software;Documentation;Programming profession;Knowledge acquisition;Software tools,program testing;formal specification;knowledge acquisition,program comprehension;knowledge acquisition;system testing;information requirements;integration testing;software system;software comprehension;testing requirements,,4,21,,,,,IEEE,IEEE Conferences
Refining existing theories of program comprehension during maintenance for concurrent software,S. D. Fleming; E. Kraemer; R. E. K. Stirewalt; L. K. Dillon; S. Xie,NA; NA; NA; NA; NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,23,32,"While the sources of complexity in the initial design and verification of multi-threaded software systems are well-documented, less is known of the issues specific to the maintenance of these systems. The literature contains a number of observational studies of programmers performing maintenance, conducted in the context of sequential software and designed to investigate the factors and behaviors that lead to success. To help fill the gap in knowledge in the area of concurrent software maintenance, we conducted a study that refines the findings of two prior studies, those of Littman et al. and of Vessey, to address issues and obstacles that arise in the understanding of concurrent software. We validated these refinements by observing programmers performing corrective maintenance on a small but complex multi-threaded server program.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.40,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556114,,Software maintenance;Programming profession;Concurrent computing;Cognitive science;Software systems;Interleaved codes;Design engineering,concurrent engineering;software maintenance,refining existing theories;program comprehension;concurrent software maintenance;initial design;multithreaded software systems,,,20,,,,,IEEE,IEEE Conferences
Early field experience with the Software Reconnaissance technique for program comprehension,N. Wilde; C. Casey,"Univ. of West Florida, Pensacola, FL, USA; NA",Proceedings of WCRE '96: 4rd Working Conference on Reverse Engineering,,1996,,,270,276,"Paper reprinted from ICSM '96. Software Reconnaissance is a dynamic analysis technique to help programmers locate code that they need to understand, fix, or enhance in an unfamiliar system. The technique was originally motivated by comments by industrial maintainers about the need for better ways of locating software features in large systems. It was then prototyped in a university setting and an initial tool called RECON was developed. This paper describes four case studies applying Reconnaissance to three different industrial programs of moderate site. Reconnaissance seems to be effective in finding ""places to start looking"" for maintainers of unfamiliar code. It can also be used to recover a traceability relation between program features and program code that may help identify design patterns. The case studies are the initial phase of an ongoing technology transfer project of the Software Engineering Research Center, to make Software Reconnaissance into a usable industrial technique.",,0-8186-7674,10.1109/WCRE.1996.558934,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=558934,,Reconnaissance;Software maintenance;Computer industry;Technology transfer;Programming profession;Software engineering;Industrial relations;Communication system software;Switches;Testing,reverse engineering,Software Reconnaissance technique;program comprehension;dynamic analysis technique;program enhancement;unfamiliar system;software maintenance;RECON tool;traceability relation;design patterns;technology transfer project;Software Engineering Research Center;industrial technique,,6,15,,,,,IEEE,IEEE Conferences
Program Comprehension through Software Habitability,R. Wettel; M. Lanza,"University of Lugano, Switzerland; University of Lugano, Switzerland",15th IEEE International Conference on Program Comprehension (ICPC '07),,2007,,,231,240,"The comprehensive understanding of a large software system is a daunting task because of the sheer size and complexity that such systems exhibit. In this context software visualization is a widely used approach, since well-conceived visual representations allow one to spot patterns. The large majority of visualizations use 2D representations, because they are easier to construct, navigate, and interact with. 3D representations usually exploit the 3rd dimension as an additional means to encode quantitative values, which is dismissed by many as a too small benefit in the light of the added complexity in terms of navigation and interaction. We argue that a well-constructed, interactive, and easily navigable 3D visualization can greatly help in program comprehension tasks by supporting habitability. Habitability transmits to a developer the notion that a software system is a physical space with strong orientation points. This can give developers the feeling of being ""at home"" in a system. We propose a 3D visualization of software systems hinging on the city metaphor. It is useful for program comprehension because it leads to clarity about the overall structure of a system. We apply our visualization technique on two large systems and discuss its benefits and drawbacks.",1092-8138,0-7695-2860,10.1109/ICPC.2007.30,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268257,,Visualization;Software systems;Cities and towns;Writing;Navigation;Informatics;Reverse engineering;Cognitive science;Humans;Programming profession,program visualisation;reverse engineering,program comprehension;software habitability;software visualization;visual representation;3D representation;metaphor;UML,,40,22,,,,,IEEE,IEEE Conferences
Program comprehension support for knowledge-based parallelization,S. Andel; B. di Martino; J. Hulman; H. P. Zima,"Inst. for Software Technol. & Parallel Syst., Wien Univ., Austria; Inst. for Software Technol. & Parallel Syst., Wien Univ., Austria; Inst. for Software Technol. & Parallel Syst., Wien Univ., Austria; Inst. for Software Technol. & Parallel Syst., Wien Univ., Austria",Proceedings of 4th Euromicro Workshop on Parallel and Distributed Processing,,1996,,,455,461,"Current compilation systems for distributed memory computers have to integrate new techniques to support the highly complex task of producing efficient programs for parallel systems. Two techniques, program comprehension and expert systems, although developed outside the scope of parallelization domain, are extremely useful to improve the quality of the parallel code generated and to make the parallelization process more convenient and automatic. We describe a parallelization environment consisting of three main components: Vienna Fortran Compilation System (VFCS), a tool for recognition of Parallelizable Algorithmic Patterns (PAP Recognizer), and a knowledge based parallelization support tool (Expert Adviser). After these main components are introduced, the paper focuses on integration issues of PAP Recognizer and Expert Adviser within the framework of VFCS. We outline the salient features of a new parallelization environment. The design of the XPA knowledge base for recognized program concepts (patterns) as presented, and the methodology of knowledge acquisition for program patterns is outlined.",,0-8186-7376,10.1109/EMPDP.1996.500619,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=500619,,Pattern recognition;Performance analysis;Program processors;Pattern analysis;Message passing;Time measurement;Computer science;Concurrent computing;Distributed computing;Knowledge acquisition,parallel programming;distributed memory systems;programming environments;computer aided software engineering;expert systems;Vienna development method;knowledge acquisition,program comprehension support;knowledge based parallelization;compilation systems;distributed memory computers;expert systems;parallel code quality;parallelization environment;Vienna Fortran Compilation System;Parallelizable Algorithmic Patterns;PAP Recognizer;knowledge based parallelization support tool;Expert Adviser;XPA knowledge base;knowledge acquisition;program patterns,,2,20,,,,,IEEE,IEEE Conferences
Program comprehension by visualization in contexts,Rui Yin; R. K. Keller,"Dept. d'Inf. et de Recherche Oper., Montreal Univ., Que., Canada; NA","International Conference on Software Maintenance, 2002. Proceedings.",,2002,,,332,341,"To make program comprehension more effective, the analyst needs high-level information about the software under investigation, in particular information at the structure and the design levels. Visualization in contexts allows the analyst to investigate software in terms of various contexts at different levels of abstraction and to form a variety of mental models of the software at hand. Moreover, the analyst can mentally integrate disparate mental models by cross-referencing. In this paper, the visualization in contexts strategy is introduced. Then, the Context Viewer, a prototype tool supporting the strategy within the SPOOL reverse engineering environment, is detailed. Three usage scenarios illustrate the approach. The scenarios, complemented by an informal evaluation and comparison, suggest the usefulness of the tool and the underlying strategy.",1063-6773,0-7695-1819,10.1109/ICSM.2002.1167789,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1167789,,Object oriented modeling;Cognitive science;Information analysis;Software systems;Reverse engineering;Councils;Data visualization;Software prototyping;Prototypes;Collaborative tools,reverse engineering;program visualisation;software tools,program comprehension;high-level information;software;visualization in contexts;abstraction;mental models;cross-referencing;Context Viewer tool;SPOOL reverse engineering environment,,,31,,,,,IEEE,IEEE Conferences
Layered explanations of software: a methodology for program comprehension,V. Rajlich; J. Doran; R. T. S. Gudla,"Wayne State Univ., Detroit, MI, USA; Wayne State Univ., Detroit, MI, USA; Wayne State Univ., Detroit, MI, USA",Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94,,1994,,,46,52,"In dealing with the legacy systems, one often encounters poorly documented and heavily maintained software. Lack of understandability of these systems complicates the task of software maintenance, making it time consuming and limiting the possibilities of the evolution of the system. We present a methodology that helps the programmers to understand programs. Our approach is compatible with the ""top-down theory"" of software understanding, where the programmer creates a chain of hypotheses and subsidiary hypotheses, concerning the properties of the code. Then he/she looks for evidence (beacons) in the code. Our approach shortens the process of hypotheses creation and verification, and allows recording of successful hypotheses for the future maintenance. All information needed for understanding is recorded in layers of annotations. An experiment was conducted to investigate how the proposed methodology helps in program understanding. A tool supporting the methodology, is presented.<<ETX>>",1092-8138,0-8186-5647,10.1109/WPC.1994.341248,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341248,,Programming profession;Software maintenance;Software tools;Computer science;Software engineering;Terminology;Cognitive science;Data structures,software maintenance;reverse engineering,legacy systems;software maintenance;program comprehension;layered explanations;understandability;hypotheses,,26,11,,,,,IEEE,IEEE Conferences
The role of concepts in program comprehension,V. Rajlich; N. Wilde,"Dept. of Comput. Sci., Wayne State Univ., Detroit, MI, USA; NA",Proceedings 10th International Workshop on Program Comprehension,,2002,,,271,278,"The paper presents an overview of the role of concepts in program comprehension. It discusses concept location, in which the implementation of a specific concept is located in the code. This process is very common and precedes a large proportion of code changes. The paper also discusses the process of learning about the domain from the code, which is a prerequisite of code reengineering. The paper notes the similarities and overlaps between program comprehension and human learning.",1092-8138,0-7695-1495,10.1109/WPC.2002.1021348,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021348,,Programming profession;Humans;Software maintenance;Computer science;Documentation;Visualization;Conferences;Software engineering;Credit cards,reverse engineering;software maintenance;systems re-engineering,program comprehension;concept location;code changes;code reengineering;human learning;concepts,,84,28,,,,,IEEE,IEEE Conferences
An empirical study on program comprehension task classification of novices,N. Saroni; S. A. Aljunid; S. M. Shuhidan; A. Shargabi,"Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia","2015 IEEE Conference on e-Learning, e-Management and e-Services (IC3e)",,2015,,,15,20,"Program comprehension is difficult to novices. Tasks have substantial effect on program comprehension. This work is part of larger study aims at identifying tasks that can improve novices' program comprehension. In one of our previous studies, fourteen tasks were identified to be feasibly effective in improving novices' program comprehension. These tasks were also classified into cognitive categories using revised Bloom taxonomy. This particular study is to validate the classification of these tasks. An online survey was conducted to a number of programming instructors as well as developers. The respondents were asked to place each of the fourteen identified tasks into one of the six cognitive categories of revised Bloom taxonomy. The findings showed that most of the respondents agreed with our classification. In future, we plan to replicate this study with more respondents and also to conduct controlled experiments to investigate the effect of the classified tasks on novices.",,978-1-4673-9437-6978-1-4673-9436,10.1109/IC3e.2015.7403479,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7403479,program comprehensoin;novices;revised Bloom Taxonomy;task,Taxonomy;Programming profession;Debugging;Conferences;Electronic learning;Documentation,educational courses;programming,program comprehension task classification;novices;cognitive categories;revised Bloom taxonomy;programming instructors;programming course,,,26,,,,,IEEE,IEEE Conferences
Delocalized Plans and Program Comprehension,S. Letovsky; E. Soloway,Yale University; NA,IEEE Software,,1986,3,3,41,49,A maintainer's understanding can go awry when it is based on purely local clues. How can we spell out the intentions behind a piece of code?,0740-7459;1937-4194,,10.1109/MS.1986.233414,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1695544,,Programming profession;Documentation;Binary trees;Algorithm design and analysis;Error analysis;Sorting;Merging;Scattering;Failure analysis;Text recognition,,,,127,17,,,,,IEEE,IEEE Magazines
"Tactile programming: a unified manipulation paradigm supporting program comprehension, composition and sharing",A. Repenning; J. Ambach,"Dept. of Comput. Sci., Colorado Univ., Boulder, CO, USA; NA",Proceedings 1996 IEEE Symposium on Visual Languages,,1996,,,102,109,"Although visual programming techniques have been used to lower the threshold of programming for end users, they are not sufficient for creating end user programming environments that are both easy to use and powerful. To achieve this, an environment must support the definition of programs that are not just static representations of behavior, but are instead dynamic collections of program objects which can be applied in a number of contexts rather than just a program editor. We describe an approach to end user programming called tactile programming which extends visual techniques with a unified program manipulation paradigm that makes programs easy to comprehend, compose and, most importantly, share over the World Wide Web. Tactile programming's inherent ability to support the social context in which programming takes place along with its ability to ease program comprehension and composition is what differentiates this approach from others. In the context of the Agentsheets programming substrate, we have created an instance of a tactile programming environment called Visual AgenTalk which is used to create interactive simulations.",1049-2615,0-8186-7508,10.1109/VL.1996.545275,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=545275,,Programming profession;Programming environments;Computational modeling;Computer science;Web sites;Context modeling;Computer languages;Collaboration,visual programming;programming environments,visual programming;tactile programming;end user programming environments;program manipulation paradigm;social context;program comprehension;Agentsheets programming substrate;Visual AgenTalk;interactive simulations,,27,24,,,,,IEEE,IEEE Conferences
Early field experience with the Software Reconnaissance technique for program comprehension,Wilde; Casey,"Univ. of West Florida, Pensacola, FL, USA; NA",1996 Proceedings of International Conference on Software Maintenance,,1996,,,312,318,"Software Reconnaissance is a dynamic analysis technique to help programmers locate code that they need to understand, fix, or enhance in an unfamiliar system. The technique was originally motivated by comments by industrial maintainers about the need for better ways of locating software features in large systems. It was then prototyped in a university setting and an initial tool called RECON was developed. The paper describes four case studies applying Reconnaissance to three different industrial programs of moderate size. Reconnaissance seems to be effective in finding ""places to start looking"" for maintainers of unfamiliar code. It can also be used to recover a traceability relation between program features and program code that may help identify design patterns. The case studies are the initial phase of an ongoing technology transfer project of the Software Engineering Research Center, to make Software Reconnaissance into a usable industrial technique.",1063-6773,0-8186-7677,10.1109/ICSM.1996.565034,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=565034,,Reverse engineering,reverse engineering,Software Reconnaissance technique;program comprehension;dynamic analysis technique;programmers;code location;industrial maintainers;software feature location;large systems;RECON tool;industrial programs;traceability relation;program features;program code;design patterns,,20,15,,,,,IEEE,IEEE Conferences
PFN: A novel program feature network for program comprehension,X. Liu; X. Sun; B. Li; J. Zhu,"School of Information Engineering, Yangzhou University, China; School of Information Engineering, Yangzhou University, China; School of Information Engineering, Yangzhou University, China; School of Information Engineering, Yangzhou University, China",2014 IEEE/ACIS 13th International Conference on Computer and Information Science (ICIS),,2014,,,349,354,"Program comprehension is one of the most frequently performed activities during software maintenance and evolution. In order to facilitate program comprehension, a variety of graphical models have been proposed in software engineering community to construct relationships between program elements. These graphical models are mostly used for understanding the system based on structural syntax dependencies between program elements. However, these graphical models fail to extract the functional or semantic features of the system. Thus, developers still cannot effectively identify the functional part in source code fit for their needs. This paper tries to fill this gap, and proposes a novel representation, program feature network (PFN), to identify the semantic features of the program at class level. PFN is generated based on the relational topic model, a hierarchical probabilistic model of networks. Based on PFN, the semantic features and the links between pairs of two classes in the program can be clearly shown. In addition, PFN can predict the possible links between the newly change request in existing program feature network rather than reconstructing the representation from the start.",,978-1-4799-4860,10.1109/ICIS.2014.6912158,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6912158,,Object oriented modeling;Semantics;Graphical models;Syntactics;Graphics;Software systems,network theory (graphs);probability;program testing;software maintenance,software evolution;hierarchical probabilistic model;PFN;relational topic model;class level;program semantic features;program elements;software engineering community;software maintenance;program comprehension;program feature network,,2,23,,,,,IEEE,IEEE Conferences
A role for chunking and fuzzy reasoning in a program comprehension and debugging tool,I. Burnstein; K. Roberson; F. Saner; A. Mirza; A. Tubaishat,"Dept. of Comput. Sci., Illinois Inst. of Technol., Chicago, IL, USA; NA; NA; NA; NA",Proceedings Ninth IEEE International Conference on Tools with Artificial Intelligence,,1997,,,102,109,"We are applying artificial intelligence techniques to develop a tool called BUG-DOCTOR that assists software engineers with program comprehension and debugging. In this paper we describe two of BUG-DOCTOR's knowledge sources, the Chunker and the Plan Processor. The Chunker identifies candidate chunks in the target code using program analysis techniques and a set of heuristics. Candidate chunks map to higher level concepts, and have a signature which captures their major identifying characteristics. The Plan Processor uses a signature to retrieve a set of program plans from a Plan Library with features that are similar to those of the candidate chunk. Its fuzzy reasoner then ranks the retrieved plans. The plan chosen as most similar to the candidate chunk is used for program comprehension and debugging tasks that follow. We believe that this approach could lead to more scalable tools for program comprehension and debugging.",1082-3409,0-8186-8203,10.1109/TAI.1997.632243,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=632243,,Fuzzy reasoning;Libraries;Programming profession;Fault diagnosis;Target recognition;Computer science;Software debugging;Software tools;Artificial intelligence;Fuzzy systems,program debugging;inference mechanisms;artificial intelligence;fuzzy logic;knowledge based systems,fuzzy reasoning;program comprehension;debugging tool;artificial intelligence;BUG-DOCTOR;software engineers;knowledge sources;Chunker;Plan Processor;program analysis techniques;heuristics;Plan Library,,7,14,,,,,IEEE,IEEE Conferences
Supporting program comprehension using semantic and structural information,J. I. Maletic; A. Marcus,"Dept. of Math. Sci., Memphis Univ., TN, USA; Dept. of Math. Sci., Memphis Univ., TN, USA",Proceedings of the 23rd International Conference on Software Engineering. ICSE 2001,,2001,,,103,112,"Focuses on investigating the combined use of semantic and structural information of programs to support the comprehension tasks involved in the maintenance and reengineering of software systems. ""Semantic information"" refers to the domain-specific issues (both the problem and the development domains) of a software system. The other dimension, structural information, refers to issues such as the actual syntactic structure of the program, along with the control and data flow that it represents. An advanced information retrieval method, latent semantic indexing, is used to define a semantic similarity measure between software components. Components within a software system are then clustered together using this similarity measure. Simple structural information (i.e. the file organization) of the software system is then used to assess the semantic cohesion of the clusters and files with respect to each other. The measures are formally defined for general application. A set of experiments is presented which demonstrates how these measures can assist in the understanding of a nontrivial software system, namely a version of NCSA Mosaic.",0270-5257,0-7695-1050,10.1109/ICSE.2001.919085,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=919085,,Information retrieval;Software systems;Data mining;Indexing;Software measurement;Documentation;Natural languages;Computer science;Application software;Computer languages,reverse engineering;program control structures;software maintenance;systems re-engineering;software metrics;online front-ends;data flow analysis;information retrieval;indexing,program comprehension;semantic information;structural information;software systems maintenance;software systems reengineering;domain-specific issues;problem domain;software development domain;syntactic program structure;control flow;data flow;information retrieval method;latent semantic indexing;semantic similarity measure;software component clustering;file organization;semantic cohesion;NCSA Mosaic,,89,49,,,,,IEEE,IEEE Conferences
Program comprehension through multiple simultaneous views: a session with VinEd,J. Sajaniemi,"Dept. of Comput. Sci., Joensun Univ., Finland",Proceedings IWPC 2000. 8th International Workshop on Program Comprehension,,2000,,,99,108,"Program comprehension is a hard cognitive task that can be promoted by the use of views, i.e., automatically created concrete representations of a program revealing different aspects of its structure and behavior. VinEd is a view-based editor that allows users to add their own views to the system. The paper analyzes the VinEd approach by presenting a scenario of a session where VinEd is used in a comprehension task. The scenario is analyzed from a cognitive point of view. The VinEd approach is also evaluated using two requirement lists proposed for software exploration tools.",1092-8138,0-7695-0656,10.1109/WPC.2000.852484,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852484,,Programming profession;Concrete;Cognitive science;Transformers;Computer languages;Computer science;Software maintenance;Application software;Navigation;Writing,reverse engineering;configuration management;cognitive systems;text editing,program comprehension;multiple simultaneous views;VinEd;hard cognitive task;automatically created concrete representations;view-based editor;comprehension task;cognitive viewpoint;requirement lists;software exploration tools,,3,21,,,,,IEEE,IEEE Conferences
Towards automated code parallelization through program comprehension,B. D. Martino; G. Iannello,"Dipartimento di Inf. e Sistemistica, Naples Univ., Italy; Dipartimento di Inf. e Sistemistica, Naples Univ., Italy",Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94,,1994,,,108,115,"Currently available parallelizing tools are biased in favor of a particular parallel execution model for generating the output parallel program. This obviously limits the generality of these tools, since programs may be parallelized according to different programming paradigms. In this paper we propose a novel approach to automated code parallelization that tries to overcome these limitations. This approach consists in recognizing first the paradigm that as best suited to a given program to be parallelized, and then applying paradigm-specific transformation to generate the final parallel code. We argue that the recognition phase can be fully automated using techniques developed in the framework of automated program understanding. With the help of a case study, we discuss how this new approach could be implemented and propose the basic structure of a paradigm-oriented parallelizer.<<ETX>>",1092-8138,0-8186-5647,10.1109/WPC.1994.341258,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341258,,Parallel programming;Pattern recognition;Concurrent computing;Parallel processing;Automatic control;Skeleton;Performance analysis,reverse engineering;parallel programming;automatic programming,automated code parallelization;program comprehension;paradigm-oriented parallelizer;parallel program;automated program understanding,,6,12,,,,,IEEE,IEEE Conferences
Relational views for program comprehension,T. Jones; W. Allison; D. Carrington,"Dept. of Comput. Sci., Queensland Univ., Brisbane, Qld., Australia; Dept. of Comput. Sci., Queensland Univ., Brisbane, Qld., Australia; Dept. of Comput. Sci., Queensland Univ., Brisbane, Qld., Australia",Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94,,1994,,,136,144,"In this paper we describe UQ*, an integrated development environment that is currently under construction at the University of Queensland. Its architecture supports the definition of multiple documents and multiple document types, and allows the relationships that are implicit within the set of documents to be represented explicitly. We identify two techniques that aid program comprehension which require knowledge about the relationships that exist in and between documents. They are program dependency analysis and literate programming. Two simple examples are presented to illustrate the flexible definition of relations within such an architecture and the use of relations for presentation of and navigation through, various views of a program and its related documentation. These examples highlight the application of such an approach to program dependency analysis and literate programming.<<ETX>>",1092-8138,0-8186-5647,10.1109/WPC.1994.341262,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341262,,Documentation;Testing;Programming profession;Debugging;Computer science;Computer architecture;Navigation;Application software;Software maintenance;Software systems,reverse engineering;programming environments,UQ*;integrated development environment;program comprehension;relational views;program dependency analysis;literate programming,,1,35,,,,,IEEE,IEEE Conferences
Understanding the complexity embedded in large routine call traces with a focus on program comprehension tasks,A. Hamou-Lhadj; T. C. Lethbridge,"Concordia University, Canada; University of Ottawa, Canada",IET Software,,2010,4,2,161,177,"The analysis of execution traces has been shown to be useful in many software maintenance activities that require a certain understanding of the systems' behaviour. Traces, however, are extremely large, hence are difficult for humans to analyse without effective tools. These tools usually support some sort of trace abstraction techniques that can help users understand the essence of a trace despite the trace being massive. Designing such tools requires a good understanding of the amount of complexity embedded in traces. Trace complexity has traditionally been measured using the file size or the number of lines in the trace. In this study, the authors argue that such metrics provide limited indication of the complexity of a trace. The authors address this issue by presenting a catalogue of metrics for assessing the various facets of traces of routine calls, with the ultimate objective being to facilitate the development of tools for the exploration of lengthy traces. The authors show the effectiveness of our metrics by applying them to 35 traces generated from four software systems.",1751-8806;1751-8814,,10.1049/iet-sen.2009.0031,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5440856,,,computational complexity;embedded systems;software maintenance;software metrics,complexity embedded understanding;large routine call traces;program comprehension tasks;software maintenance;software systems,,3,,,,,,IET,IET Journals
Expressiveness and effectiveness of program comprehension: Thoughts on future research directions,J. I. Maletic; H. Kagdi,"Department of Computer Science, Kent State University, Ohio 44242, USA; Department of Computer Science, Missouri University of Science and Technology, Rolla 65409, USA",2008 Frontiers of Software Maintenance,,2008,,,31,37,"A number of research challenges in the area of program comprehension are presented. The expressiveness and effectiveness of program comprehension are discussed, and research directions are organized along these two axes. Both fundament research issues are raised along with new applications for program comprehension methods. The work advocates the investigation of better measures, further empirical studies, and controlled experiments to assess the effectiveness of program comprehension techniques.",,978-1-4244-2654-6978-1-4244-2655,10.1109/FOSM.2008.4659246,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4659246,,Libraries;Software;Programming;Software engineering;Humans;Tracking;Software systems,program visualisation;reverse engineering;software maintenance;software prototyping,program comprehension expressiveness;program comprehension effectiveness;software evolution;software change;program visualization;software maintenance,,7,29,,,,,IEEE,IEEE Conferences
An ontology toolkit for problem domain concept location in program comprehension,N. R. Carvalho,"Department of Informatics, University of Minho, Campus de Gualtar - 4710-057 Braga, Portugal",2013 35th International Conference on Software Engineering (ICSE),,2013,,,1415,1418,"Programmers are able to understand source code because they are able to relate program elements (e.g. modules, objects, or functions), with the real world concepts these elements are addressing. The main goal of this work is to enhance current program comprehension by systematically creating bidirectional mappings between domain concepts and source code. To achieve this, semantic bridges are required between natural language terms used in the problem domain and program elements written using formal programming languages. These bridges are created by an inference engine over a multi-ontology environment, including an ontological representation of the program, the problem domain, and the real world effects program execution produces. These ontologies are populated with data collected from both domains, and enriched using available Natural Language Processing and Information Retrieval techniques.",0270-5257;1558-1225,978-1-4673-3076-3978-1-4673-3073,10.1109/ICSE.2013.6606731,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6606731,,Ontologies;Conferences;Engines;Software maintenance;Natural languages;Data mining,formal languages;inference mechanisms;information retrieval;natural language processing;ontologies (artificial intelligence);programming languages;reverse engineering,ontology toolkit;problem domain concept location;program comprehension;source code;bidirectional mapping;semantic bridges;natural language terms;program elements;formal programming languages;inference engine;multiontology environment;ontological representation;program execution;natural language processing;information retrieval techniques,,3,27,,,,,IEEE,IEEE Conferences
An empirical study of amorphous slicing as a program comprehension support tool,D. Binkley; M. Harman; L. R. Raszewski; C. Smith,"Loyola Coll., Baltimore, MD, USA; NA; NA; NA",Proceedings IWPC 2000. 8th International Workshop on Program Comprehension,,2000,,,161,170,"Amorphous program slicing relaxes the syntactic constraint of traditional slicing and can therefore produce considerably smaller slices. This simplification power can be used to answer questions a software engineer might have about a program by first augmenting the program to make the question explicit and then slicing out an answer. One benefit of this technique is that the answer is in the form of a program and thus, in a language that the software engineer understands well. To test the usefulness of amorphous slicing in answering such questions, the question of array access safety is considered. A safety slice (an amorphous slice of an augmented program) is used to guide a software engineer to potential array bounds violations. A series of experiments was conducted to determine whether the safety slice was an effective aid to an engineer. 76 subjects participated in the controlled experiments. For experiments involving novice programmers, the null hypothesis could not be rejected, and so it was not possible to conclude that amorphous slicing assisted such programmers. However for more experienced groups, the experimental subjects (who were able to consult amorphous slices) significantly outperformed the control group. The study lends empirical support to the assertion that amorphous slicing assists program comprehension.",1092-8138,0-7695-0656,10.1109/WPC.2000.852490,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852490,,Amorphous materials;Educational institutions;Safety;Testing;Humans;Power engineering and energy;Programming profession;Councils;Debugging;Logic,program slicing;reverse engineering;software engineering;safety;arrays,amorphous program slicing;program comprehension support tool;syntactic constraint;simplification;software engineering questions;program augmentation;array access safety;safety slice;array bounds violations;novice programmers;empirical validation,,14,14,,,,,IEEE,IEEE Conferences
Comparing graph-based program comprehension tools to relational database-based tools,C. Lange; H. M. Sneed; A. Winter,"Inst. for Software Technol., Koblenz-Landau Univ., Germany; NA; NA",Proceedings 9th International Workshop on Program Comprehension. IWPC 2001,,2001,,,209,218,"In this paper we compare the experiences of applying the graph-based GUPRO approach to experiences in applying ANAUSoftSpec-an approach based on relational databases. We present the results of a case study in which GUPRO has been applied to a multi-language software system for stock trading (GEOS). Comparing the results of the case study, with experiences of applying ANAL/SoftSpec to GEOS we show that the graph-oriented approach enables an efficient way of source code analysis and program understanding.",1092-8138,0-7695-1131,10.1109/WPC.2001.921732,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921732,,Relational databases;Software tools;Software systems;Reverse engineering;Industrial relations;Application software;Usability;Programming profession;Embedded system;Layout,relational databases;reverse engineering;software maintenance;query processing,graph-based program comprehension tools;relational database-based tools;graph-based GUPRO approach;ANAUSoftSpec;multi-language software system;stock trading;graph-oriented approach;source code analysis;program understanding,,5,29,,,,,IEEE,IEEE Conferences
Enhancing program comprehension with recovered state models,S. S. Some; T. C. Lethbridge,"Sch. of Inf. Technol. & Eng., Ottawa, Ont., Canada; Sch. of Inf. Technol. & Eng., Ottawa, Ont., Canada",Proceedings 10th International Workshop on Program Comprehension,,2002,,,85,93,"State transition machines are high-level behavior descriptions often used as modeling tools for the design and implementation of a large class of software systems. Some of the state transition machine implementation approaches are such that the static structure of the resulting code closely matches that of the original state transition machines. Therefore, having a representation of the original state transition machines is likely to improve the corresponding code understandability. We present an approach supported by a prototype tool, to extract state transition machines by static analysis of source code. An objective of this work is to enhance program comprehension with visual representations of the behavior of the programs being analyzed.",1092-8138,0-7695-1495,10.1109/WPC.2002.1021325,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021325,,Object oriented modeling;Software systems;Software maintenance;Data mining;Information technology;Design engineering;Software prototyping;Prototypes;Software tools;Navigation,reverse engineering;program visualisation;program diagnostics;graph theory,program comprehension;recovered state models;state transition machines;high-level behavior descriptions;modeling tools;software systems;static structure;code understandability;static analysis;source code;visual representations,,7,16,,,,,IEEE,IEEE Conferences
Program comprehension risks and opportunities in extreme programming,A. van Deursen,"CWI, Amsterdam, Netherlands",Proceedings Eighth Working Conference on Reverse Engineering,,2001,,,176,185,"Investigates the relationship between reverse engineering and program comprehension on the one hand, and the software process on the other. To understand this relationship, we select one particular existing software process, extreme programming (XP), and study the role played in it by program comprehension and reverse engineering. To that end, we analyze five key XP practices in depth: pair programming, unit testing, refactoring, evolutionary design and collaborative planning. The contributions of this paper are: (1) the identification of promising research areas in the field of program comprehension; (2) the identification of new application perspectives for reverse engineering technology; (3) a critical analysis of XP resulting in research questions that could help resolve some of the uncertainties surrounding XP; and (4) a discussion of the role that comprehension and reverse engineering can play in software process design.",1095-1350,0-7695-1303,10.1109/WCRE.2001.957822,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=957822,,Reverse engineering;Software testing;System testing;Genetic programming;Costs;Software systems;World Wide Web;Collaboration;Application software;Uncertainty,programming;reverse engineering;program testing;software prototyping,program comprehension;reverse engineering;software process;extreme programming;risks;pair programming;unit testing;refactoring;evolutionary design;collaborative planning;application perspectives identification;uncertainties;collaborative work,,18,36,,,,,IEEE,IEEE Conferences
Program comprehension in multi-language systems,B. Kullbach; A. Winter; P. Dahm; J. Ebert,"Inst. for Software Technol., Koblenz-Landau Univ., Germany; NA; NA; NA",Proceedings Fifth Working Conference on Reverse Engineering (Cat. No.98TB100261),,1998,,,135,143,"This paper presents an approach to program comprehension in multi-language systems. Such systems are characterized by a high amount of source codes in various languages for programming, database definition and job control. Coping with those systems requires the references crossing the language boundaries to be analyzed. Using the EER/GRAL approach to graph-based conceptual modeling, models representing relevant aspects of single language are built and integrated into a common conceptual model. Since conceptual modeling focusses on specific problems, the integrated model presented here is especially tailored to multi-language aspects. Software systems are parsed and represented according to this conceptual model and queried by using a powerful graph query mechanism. This allows multi-language cross references to be easily retrieved. The multi-language conceptual model and the query facilities have been developed in cooperation with the maintenance programmers at an insurance company within the GUPRO project.",,0-8186-8967,10.1109/WCRE.1998.723183,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=723183,,Power system modeling;Software systems;Software maintenance;Relational databases;Database languages;Insurance;Software performance;Programming;Data structures;Image databases,software maintenance;systems re-engineering;query languages,program comprehension;multi-language systems;source codes;database definition;job control;graph-based conceptual modeling;common conceptual model;integrated model;graph query mechanism;multilanguage conceptual model;GUPRO project,,24,45,,,,,IEEE,IEEE Conferences
Program comprehension during software maintenance and evolution,A. Von Mayrhauser; A. M. Vans,"Colorado State Univ., Fort Collins, CO, USA; Colorado State Univ., Fort Collins, CO, USA",Computer,,1995,28,8,44,55,"Code cognition models examine how programmers understand program code. The authors survey the current knowledge in this area by comparing six program comprehension models: the Letovsky (1986) model; the Shneiderman and Mayer (1979) model; the Brooks (1983) model; Soloway, Adelson and Ehrlich's (1988) top-down model; Pennington's (1987) bottom-up model; and the integrated metamodel of von Mayrhauser and Vans (1994). While these general models can foster a complete understanding of a piece of code, they may not always apply to specialized tasks that more efficiently employ strategies geared toward partial understanding. We identify open questions, particularly considering the maintenance and evolution of large-scale code. These questions relate to the scalability of existing experimental results with small programs, the validity and credibility of results based on experimental procedures, and the challenges of data availability.<<ETX>>",0018-9162;1558-0814,,10.1109/2.402076,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=402076,,Software maintenance;Cognition;Cognitive science;Programming profession;Application software;Computer architecture;Documentation;Large-scale systems;Scalability;Round robin,software maintenance;reverse engineering;human factors;large-scale systems,program comprehension models;software maintenance;software evolution;code cognition models;program code understanding;integrated metamodel;top-down model;bottom-up model;specialized tasks;partial understanding;large-scale code;scalability;data availability;experimental procedures,,230,12,,,,,IEEE,IEEE Magazines
Using run-time data for program comprehension,T. Gschwind; J. Oberleitner; M. Pinzger,"Distributed Syst. Group, Tech. Univ. Wien, Austria; Distributed Syst. Group, Tech. Univ. Wien, Austria; Distributed Syst. Group, Tech. Univ. Wien, Austria","11th IEEE International Workshop on Program Comprehension, 2003.",,2003,,,245,250,"Traditional approaches for program comprehension use static program analysis or dynamic program analysis in the form of execution traces. Our approach, however, makes use of runtime-data such as parameter and object values. Compared to traditional program comprehension techniques, this approach enables fundamentally new ways of program analysis which we have not seen so far. Reflection analysis which allows engineers to understand programs making use of reflective (dynamic) method invocations is one such analysis. Another is object tracing which allows engineers to trace and track the use of a given instance of a class within the program to be understood. In this paper we present these techniques along with a case study to which we have applied them.",1092-8138,0-7695-1883,10.1109/WPC.2003.1199208,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199208,,Runtime;Application software;Performance analysis;Collaborative software;Data analysis;Instruments;Algorithm design and analysis;Information analysis;Europe;Reflection,reverse engineering;program diagnostics,run-time data;program comprehension;static program analysis;dynamic program analysis;reflection analysis;programs understanding;object tracing,,5,16,,,,,IEEE,IEEE Conferences
Using background colors to support program comprehension in software product lines,J. Feigenspan; M. Schulze; M. Papendieck; C. Kästner; R. Dachselt; V. Köppen; M. Frisch,"University of Magdeburg, Germany; University of Magdeburg, Germany; University of Magdeburg, Germany; Philipps University Marburg, Germany; University of Magdeburg, Germany; University of Magdeburg, Germany; University of Magdeburg, Germany",15th Annual Conference on Evaluation & Assessment in Software Engineering (EASE 2011),,2011,,,66,75,"Background: Software product line engineering provides an effective mechanism to implement variable software. However, the usage of preprocessors, which is typical in industry, is heavily criticized, because it often leads to obfuscated code. Using background colors to support comprehensibility has shown effective, however, scalability to large software product lines (SPLs) is questionable. Aim: Our goal is to implement and evaluate scalable usage of background colors for industrial-sized SPLs. Method: We designed and implemented scalable concepts in a tool called FeatureCommander. To evaluate its effectiveness, we conducted a controlled experiment with a large real-world SPL with over 160,000 lines of code and 340 features. We used a within-subjects design with treatments colors and no colors. We compared correctness and response time of tasks for both treatments. Results: For certain kinds of tasks, background colors improve program comprehension. Furthermore, subjects generally favor background colors. Conclusion: We show that background colors can improve program comprehension in large SPLs. Based on these encouraging results, we will continue our work improving program comprehension in large SPLs.",,978-1-84919-509,10.1049/ic.2011.0008,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6083163,,,data flow analysis;reverse engineering;software engineering,background colors;program comprehension;software product line engineering;preprocessors;obfuscated code;FeatureCommander,,10,,,,,,IET,IET Conferences
Source animation as a means of program comprehension for object-oriented systems,H. M. Sneed,"Arget, Germany",Proceedings IWPC 2000. 8th International Workshop on Program Comprehension,,2000,,,179,187,"Object oriented systems are particularly difficult to comprehend because of the distribution of functionality and polymorphism which limits the effectiveness of conventional static analysis methods. The paper proposes a dynamic analysis approach using animation to simulate the use cases in a financial application system. The objective is to offer maintenance programmers a means of familiarizing themselves with complex C++ code while at the same time validating the correctness of the code. For this purpose, control flow slicing and concept lattices are used.",1092-8138,0-7695-0656,10.1109/WPC.2000.852492,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852492,,Animation;Dynamic programming;Object oriented modeling;Lattices;Runtime;Object oriented programming;Analytical models;Programming profession;Delay;Assembly,object-oriented programming;reverse engineering;program visualisation;computer animation;financial data processing;software maintenance;C++ language;program verification,source animation;program comprehension;object oriented systems;polymorphism;conventional static analysis methods;dynamic analysis approach;use case simulation;financial application system;maintenance programmers;complex C++ code;correctness validation;control flow slicing;concept lattices,,2,24,,,,,IEEE,IEEE Conferences
A workbench for program comprehension during software maintenance,G. Canfora; L. Mancini; M. Tortorella,"Dipartimento di Ingegneria dell'Inf. ed Ingegneria Elettrica, Salerno Univ., Italy; NA; NA",WPC '96. 4th Workshop on Program Comprehension,,1996,,,30,39,"The paper describes the research carried out into the process of program comprehension during software maintenance within the EUREKA project REM (Reverse Engineering and Maintenance). Tools to aid maintenance programmers to achieve and document an overall interpretation of the system being maintained, as well as a deep understanding of the fine details of the source code, are presented. The cognition model assumed exploits both the top down and the bottom up approaches: program comprehension is intended as an iterative process of guessing, constructing hypotheses and verifying them This process is supported by providing maintenance programmers with a flexible system for querying source code and testing hypotheses against the evidence in the code. Several facilities generate new documents at the design and specification level, thus allowing maintenance programmers to record the knowledge gained for future use.",1092-8138,0-8186-7283,10.1109/WPC.1996.501118,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501118,,Software maintenance;Programming profession;Documentation;Reverse engineering;Costs;Proposals;Switches;Cognition;Iterative methods;System testing,reverse engineering;software maintenance;software tools;cognitive systems,program comprehension;software maintenance;EUREKA project REM;maintenance programmers;source code;cognition model;bottom up approaches;iterative process;specification level,,11,22,,,,,IEEE,IEEE Conferences
Integrating Runtime Values with Source Code to Facilitate Program Comprehension,M. Sulír,NA,2018 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2018,,,743,748,"An inherently abstract nature of source code makes programs difficult to understand. In our research, we designed three techniques utilizing concrete values of variables and other expressions during program execution. RuntimeSearch is a debugger extension searching for a given string in all expressions at runtime. DynamiDoc generates documentation sentences containing examples of arguments, return values and state changes. RuntimeSamp augments source code lines in the IDE (integrated development environment) with sample variable values. In this post-doctoral article, we briefly describe these three approaches and related motivational studies, surveys and evaluations. We also reflect on the PhD study, providing advice for current students. Finally, short-term and long-term future work is described.",2576-3148;1063-6773,978-1-5386-7870-1978-1-5386-7871,10.1109/ICSME.2018.00093,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530096,integrated development environment;documentation;debugging;dynamic analysis;variables,Documentation;Tools;Runtime;Debugging;Task analysis;Graphical user interfaces;Collaboration,Java;program compilers;program debugging;program diagnostics;programming environments;reverse engineering;software maintenance;software tools,documentation sentences;IDE;integrated development environment;program execution;debugger extension;program comprehension;string;runtimesamp augments source code lines;runtimesearch;DynamiDoc;abstract nature,,,35,,,,,IEEE,IEEE Conferences
Bridging program comprehension tools by design navigation,Robitaille; Schauer; Keller,"Dept. d'Inf. et de Recherche Oper., Montreal Univ., Que., Canada; NA; NA",Proceedings 2000 International Conference on Software Maintenance,,2000,,,22,32,"Source code investigation is one of the most time-consuming activities during software maintenance and evolution, yet currently-available tool support suffers from several shortcomings. Browsing is typically limited to low-level elements, investigation is only supported as a one-way activity, and tools provide little help in getting an encompassing picture of the system under examination. In our research, we have developed tool support for design navigation that addresses these shortcomings. A design browser allows for flexible browsing of a system's design-level representation and for information exchange with a suite of program comprehension tools. The browser is complemented with a retriever supporting full-text and structural searching. In this paper, we detail these tools and their integration into a reverse engineering environment, present three case studies and put them into perspective.",1063-6773,0-7695-0753,10.1109/ICSM.2000.882972,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=882972,,Reverse engineering,reverse engineering;full-text databases;online front-ends;software maintenance;computer aided software engineering;software tools,program comprehension tools;design navigation;source code investigation;software maintenance;software evolution;design browser;retriever;low-level elements;one-way activity;flexible browsing;system design-level representation;information exchange;full-text searching;structural searching;reverse engineering environment;case studies,,13,29,,,,,IEEE,IEEE Conferences
The role of testing and dynamic analysis in program comprehension supports,P. Benedusi; V. Benvenuto; L. Tomacelli,"CRIAI, Portici, Italy; CRIAI, Portici, Italy; CRIAI, Portici, Italy",[1993] IEEE Second Workshop on Program Comprehension,,1993,,,149,158,"Test cases. amd the human activities involved in testing and error analysis play a peculiar and considerable role in the comprehension of a software product and process. This subject was systematically explored in the context of the Esprit DOCKET Project designing and experimenting second-generation reverse engineering processes which combine multiple knowledge sources. This paper describes the approach, and the architecture which have been designed for the capitalisation of the knowledge products of both existing software life cycle activities and proposed knowledge-elicitation oriented testing strategies.<<ETX>>",1092-8138,0-8186-4042,10.1109/WPC.1993.263896,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263896,,Software testing;Life testing;Reverse engineering;Software debugging;Error analysis;Software performance;Humans;Animation;Flow graphs;Microscopy,knowledge acquisition;program testing;software maintenance;software tools,testing;dynamic analysis;program comprehension;error analysis;software product;DOCKET;reverse engineering;knowledge sources;software life cycle;knowledge-elicitation,,,37,,,,,IEEE,IEEE Conferences
Aiding program comprehension by static and dynamic feature analysis,T. Eisenbarth; R. Koschke; D. Simon,"Stuttgart Univ., Germany; NA; NA",Proceedings IEEE International Conference on Software Maintenance. ICSM 2001,,2001,,,602,611,"Understanding a system's implementation without prior knowledge is a hard task for reengineers in general. However, some degree of automatic aid is possible. The authors present a technique for building a mapping between the system's externally visible behavior and the relevant parts of the source code. The technique combines dynamic and static analyses to rapidly focus on the system's parts urgently required for a goal-directed process of program understanding.",1063-6773,0-7695-1189,10.1109/ICSM.2001.972777,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=972777,,Documentation;Reverse engineering;Terminology;Computer languages;Information analysis,reverse engineering;systems re-engineering;program diagnostics;software maintenance,program comprehension;static/dynamic feature analysis;system implementation understanding;prior knowledge;reengineers;automatic aid;externally visible behavior;source code;dynamic analyses;static analyses;goal-directed process;program understanding,,63,22,,,,,IEEE,IEEE Conferences
Trace visualization for program comprehension: A controlled experiment,B. Cornelissen; A. Zaidman; A. van Deursen; B. van Rompaey,"Delft University of Technology, The Netherlands; Delft University of Technology, The Netherlands; Delft University of Technology, The Netherlands; University of Antwerp, Belgium",2009 IEEE 17th International Conference on Program Comprehension,,2009,,,100,109,"Understanding software through dynamic analysis has been a popular activity in the past decades. One of the most common approaches in this respect is execution trace analysis: among our own efforts in this context is EXTRAVIS, a tool for the visualization of large traces. Similar to other trace visualization techniques, our tool has been validated through anecdotal evidence, but should also be quantitatively evaluated to assess its usefulness for program comprehension. This paper reports on a first controlled experiment concerning trace visualization for program comprehension. We designed eight typical tasks aimed at gaining an understanding of a representative subject system, and measured how a control group (using the Eclipse IDE) and an experimental group (using both Eclipse and EXTRAVIS) performed in terms of correctness and time spent. The results are statistically significant in both regards, showing a 21% decrease in time and a 43% increase in correctness for the latter group.",1092-8138,978-1-4244-3998-0978-1-4244-3997,10.1109/ICPC.2009.5090033,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090033,,Software maintenance;Time measurement;Performance evaluation;Scalability;Gain measurement;Control systems;Programming;Documentation;Data visualization;Design for experiments,program diagnostics;program visualisation;programming environments;reverse engineering,trace visualization;program comprehension;software understanding;dynamic analysis;execution trace analysis;EXTRAVIS tool;Eclipse IDE,,17,22,,,,,IEEE,IEEE Conferences
Sonification design guidelines to enhance program comprehension,K. Hussein; E. Tilevich; I. I. Bukvic; SooBeen Kim,"Department of Computer Science, Virginia Tech, Blacksburg, 24061, USA; Department of Computer Science, Virginia Tech, Blacksburg, 24061, USA; Department of Music, Virginia Tech, Blacksburg, 24061, USA; Wellesley College, MA 02481, USA",2009 IEEE 17th International Conference on Program Comprehension,,2009,,,120,129,"Faced with the challenges of understanding the source code of a program, software developers are assisted by a wealth of software visualization research. This work explores how visualization can be supplemented by sonification as a cognitive tool for code comprehension. By engaging the programmer's auditory senses, sonification can improve the utility of program comprehension tools. This paper reports on our experiences of creating and evaluating a program comprehension prototype tool that employs sonification to assist program understanding by rendering sonic cues. Our empirical evaluation of the efficacy of information sonification indicates that this cognitive aid can effectively complement visualization when trying to understand an unfamiliar code base. Based on our experiences, we then propose a set of guidelines for the design of a new generation of tools that increase their information utility by combining visualization and sonification.",1092-8138,978-1-4244-3998-0978-1-4244-3997,10.1109/ICPC.2009.5090035,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090035,,Guidelines;Visualization;Software maintenance;Software systems;Programming;Auditory displays;Computer science;Educational institutions;Software prototyping;Prototypes,program visualisation;source coding,sonification design guidelines;program source code;software developers;software visualization;cognitive tool;code comprehension;auditory senses;program comprehension tools,,6,56,,,,,IEEE,IEEE Conferences
An empirical investigation of the influence of a type of side effects on program comprehension,J. J. Dolado; M. Harman; M. C. Otero; L. Hu,"Dept. of Comput. Languages & Syst., Univ. of the Basque Country, San Sebastian, Spain; NA; NA; NA",IEEE Transactions on Software Engineering,,2003,29,7,665,670,"This paper reports the results of a study on the impact of a type of side effect (SE) upon program comprehension. We applied a crossover design on different tests involving fragments of C code that include increment and decrement operators. Each test had an SE version and a side-effect-free counterpart. The variables measured in the treatments were the number of correct answers and the time spent in answering. The results show that the side-effect operators considered significantly reduce performance in comprehension-related tasks, providing empirical justification for the belief that side effects are harmful.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2003.1214329,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1214329,,Testing;Programming profession;Time measurement;Impedance;Computer languages;Humans;Algorithm design and analysis;Software maintenance,program testing;software engineering,side-effect-free programs;program comprehension;LinSERT algorithm;crossover design;program tests;side-effect operators,,17,22,,,,,IEEE,IEEE Journals
InfoSound: an audio aid to program comprehension,D. H. Sonnenwald; B. Gopinath; G. O. Haberman; W. M. Keese; J. S. Myers,"Bellcore, Red Bank, NJ, USA; Bellcore, Red Bank, NJ, USA; Bellcore, Red Bank, NJ, USA; Bellcore, Red Bank, NJ, USA; Bellcore, Red Bank, NJ, USA",Twenty-Third Annual Hawaii International Conference on System Sciences,,1990,2,,541,546 vol.2,"The authors have explored ways to enhance users' comprehension of complex applications using music and special sound effects to present application program events that are difficult to visually detect. A prototype system, InfoSound, allows developers to create and store musical sequences and special sound effects, to associate stored musical sequences and sound effects to application events, and to have real-time, continuous auditory control of sounds during application execution. InfoSound has been used to create auditory interfaces for two applications: a telephone network service simulation and a parallel computation simulation. The auditory interfaces in these applications helped users detect rapid, multiple event sequences that were difficult to visually detect using text and graphical interfaces. The paper describes the architecture of InfoSound, use of the system, and lessons the authors have learnt.<<ETX>>",,,10.1109/HICSS.1990.205229,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=205229,,Event detection;Computational modeling;Music;Prototypes;Real time systems;Control systems;Telephony;Computer interfaces;Computer networks;Concurrent computing,digital simulation;electronic music;parallel processing;software tools;telephone networks;user interfaces,user comprehension;earcons;music;special sound effects;application program events;prototype system;InfoSound;musical sequences;application events;continuous auditory control;auditory interfaces;telephone network service simulation;parallel computation simulation;multiple event sequences,,16,16,,,,,IEEE,IEEE Conferences
Metrics to identify where object-oriented program comprehension benefits from the runtime structure,M. Abi-Antoun; R. Vanciu; N. Ammar,"Department of Computer Science, Wayne State University, USA; Department of Computer Science, Wayne State University, USA; Department of Computer Science, Wayne State University, USA",2013 4th International Workshop on Emerging Trends in Software Metrics (WETSoM),,2013,,,42,48,"To evolve object-oriented code, developers often need to understand both the code structure in terms of classes and packages, as well as the runtime structure in terms of abstractions of objects. Recent empirical studies have shown that for some code modifications tasks, developers do benefit from having access to information about the runtime structure. However, there is no good sense of when object-oriented program comprehension clearly depends on information about the runtime structure. We propose using metrics to identify cases in object-oriented program comprehension that benefit from information about the runtime structure. The metrics relate properties observed on a statically extracted hierarchical object graph to the type structures declared in the code and highlight key differences between the runtime structure and the code structure.",2327-0969;2327-0950,978-1-4673-6331,10.1109/WETSoM.2013.6619335,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6619335,object-oriented runtime structure;metrics,Runtime;Measurement;Abstracts;Context;Concrete;Object recognition;Bismuth,object-oriented programming;software maintenance;software metrics,object-oriented program comprehension;runtime structure;object-oriented code;metrics;statically extracted hierarchical object graph;code structure;software maintenance,,1,22,,,,,IEEE,IEEE Conferences
On evaluating the layout of UML class diagrams for program comprehension,D. Sun; K. Wong,"Dept. of Comput. Sci., Alberta Univ., Edmonton, Alta., Canada; Dept. of Comput. Sci., Alberta Univ., Edmonton, Alta., Canada",13th International Workshop on Program Comprehension (IWPC'05),,2005,,,317,326,"UML class diagrams are helpful for understanding the structure of a software system. Algorithms and tools have been developed to generate UML class diagrams automatically for program understanding purposes. However, many tools often ignore perceptual factors in the layout of these diagrams. Therefore, users still have to spend much time and effort rearranging boxes and lines to make the diagram understandable. This paper presents key criteria and guidelines for the effective layout of UML class diagrams from the perspective of perceptual theories. Two UML tools have been analyzed and evaluated to illustrate how the criteria can be applied to improve the readability of class diagrams.",1092-8138,0-7695-2254,10.1109/WPC.2005.26,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421047,UML class diagrams;perceptual theory;aesthetics;graph layout;UML modeling tools,Unified modeling language;Software systems;Layout;Guidelines;Visualization;Sun;Reverse engineering;Documentation;Knowledge engineering;Large-scale systems,Unified Modeling Language;program visualisation;reverse engineering;diagrams;software tools,software system understanding;UML class diagram layout;perceptual theory;program comprehension;graph layout;Unified Modeling Language;program visualisation;software tools,,10,33,,,,,IEEE,IEEE Conferences
From program comprehension to tool requirements for an industrial environment,A. von Mayrhauser; A. M. Vans,"Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA; Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA",[1993] IEEE Second Workshop on Program Comprehension,,1993,,,78,86,"A major portion of the maintenance effort is spent understanding existing software. The authors present an integrated code comprehension model and experiences with it in an industrial setting. They use audio-taped, think-aloud reports to investigate how well this integrated code comprehension model works during industrial maintenance activities ranging from code fixes to enhancements, code leverage, and reuse. They analyze the tapes for information needs during maintenance activities and derive tool capabilities accordingly.<<ETX>>",1092-8138,0-8186-4042,10.1109/WPC.1993.263903,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263903,,Cognition;Programming profession;Switches;Computer industry;Computer science;Software maintenance;Large-scale systems;Software tools;Information analysis;Electrical equipment industry,software maintenance;software tools,program comprehension;tool requirements;industrial environment;maintenance effort;code comprehension model;think-aloud reports;industrial maintenance activities;code fixes;enhancements;code leverage;reuse;information needs;tool capabilities,,43,22,,,,,IEEE,IEEE Conferences
A contribution to program comprehension by program analysis: application to numerical programs,Y. Ait-Ameur,"ENSMA-LISA, Futuroscope, France",Proceedings 12th IEEE International Conference Automated Software Engineering,,1997,,,134,141,"This paper deals with non-functional aspects of software. It presents an approach towards the integration of methods in order to handle properties of numerical programs. We develop a program analysis technique which allows us to formalise, evaluate and check non-functional properties of programs. These property evaluations are used in two main areas. The first one is related to program design to choose data representations and to perform program transformations. The second is related to reverse engineering, and particularly to software reuse and maintenance. As example, a functional language with numerical type only is considered, and the accuracy of the numerical computations is the considered non-functional property.",,0-8186-7961,10.1109/ASE.1997.632833,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=632833,,Application software;Software maintenance;Program processors;Operating systems;Reverse engineering;Commutation;Equations;Data security;Data structures,reverse engineering;program diagnostics;numerical analysis;software maintenance;software reusability;functional languages;data structures,program comprehension;program analysis;numerical programs;nonfunctional property evaluation;program design;data representations;program transformations;reverse engineering;software reuse;software maintenance;functional language;numerical type;numerical computational accuracy,,1,13,,,,,IEEE,IEEE Conferences
Interprocedural analysis for program comprehension by specialization,S. Blazy; P. Facon,"CEDRIC IIE, Evry, France; NA",WPC '96. 4th Workshop on Program Comprehension,,1996,,,133,141,"We report on an approach for program comprehension during large-scale maintenance of Fortran application programs. We have adapted partial evaluation (or specialization of programs given specific values for their input data) techniques for program comprehension. We focus on the automatic interprocedural analysis and we describe how we have specified, implemented in a tool, and used that analysis to improve program comprehension. The difficulty of that analysis is due to the lack of well defined interprocedural mechanisms and the complexity of visibility rules in Fortran.",1092-8138,0-8186-7283,10.1109/WPC.1996.501128,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501128,,Large-scale systems;Solid modeling;Power generation;Software maintenance;Formal specifications;Input variables;Displays;Cognition;Fluid flow;Geometry,reverse engineering;software maintenance;FORTRAN;partial evaluation (compilers);program compilers;software tools;program diagnostics,interprocedural analysis;program comprehension;specialization;software maintenance;Fortran;application programs;partial evaluation;software tool;visibility rules,,,14,,,,,IEEE,IEEE Conferences
An exploratory study of code and document interactions during task-directed program comprehension,P. Parkin,"Sch. of Inf. Syst., New South Wales Univ., Sydney, NSW, Australia",2004 Australian Software Engineering Conference. Proceedings.,,2004,,,221,230,"This exploratory study investigates the program comprehension strategies employed during enhancement and corrective maintenance from the perspective of the programmer activities of examining both program and task documentation and analysing and potentially modifying program code. Twenty-nine experienced C programmers independently undertook one of two maintenance tasks on the same C program and their various activities were recorded. Analysis and comparisons of activity durations were conducted at various points during the maintenance task as well as at the level of the complete task. The results show that contrary to previous research in this area, programmers implementing a correction utilized program documentation and header information significantly more than programmers undertaking an enhancement. Within their projects, this comparative additional usage occurred predominantly in the second quarter of the project suggesting more pronounced domain modeling than enhancers. Enhancers themselves made much more specific use of task documentation than did corrective programmers, seemingly to map out extensions and adjustments to their program models and, finally, to verify the code modifications made.",,0-7695-2089,10.1109/ASWEC.2004.1290475,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1290475,,Programming profession;Documentation;Australia;Information analysis;Software maintenance;Management information systems;Technology management;Navigation;Educational programs;Software engineering,formal verification;reverse engineering;system documentation;software maintenance;C language,task directed program comprehension;program documentation;task documentation;C program;program code verification,,2,23,,,,,IEEE,IEEE Conferences
Two program comprehension tools for automatic parallelization,B. Di Martino; C. W. Kessler,"Fac. of Eng., Second Univ. of Naples, Italy; NA",IEEE Concurrency,,2000,8,1,37,47,"The authors compare two program-comprehension systems targeted to support automatic parallelization: PARAMAT (PARAllelization by pattern MATching) and the PAP (Parallelizable Algorithmic Patterns) Recognizer. The authors illuminate the main differences of each method, discussing the tradeoff between the speed of the first and the generality of the second.",1092-3063;1558-0849,,10.1109/4434.824311,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=824311,,Runtime;Microwave integrated circuits;Parallel algorithms;Automatic control;Linear algebra;Partial differential equations;Algorithm design and analysis;Pattern recognition;Libraries;Program processors,reverse engineering;parallelising compilers;software tools;pattern matching;software performance evaluation,program comprehension tools;automatic parallelization;PARAMAT;pattern matching;PAP Recognizer;parallelizable algorithmic patterns;generality;execution speed,,15,18,,,,,IEEE,IEEE Magazines
Presenting micro-theories of program comprehension in pattern form,A. Murray; T. C. Lethbridge,"Ottawa Univ., Ont., Canada; Ottawa Univ., Ont., Canada",13th International Workshop on Program Comprehension (IWPC'05),,2005,,,45,54,"We present the notion of cognitive patterns, and provide several examples. A cognitive pattern is the written record of a solution to a recurring cognitive problem typically employed by experienced practitioners. We focus on those relevant to program comprehension, which we have developed through studying the literature and conducting field studies. Collectively the set of patterns constitute a rich theory of program comprehension, which is why we call each one a micro-theory. We expand on one pattern, temporal details, which is also a 'pattern language since it breaks down into sub-patterns'. A key use of cognitive patterns is to suggest useful features for tool designers to implement.",1092-8138,0-7695-2254,10.1109/WPC.2005.28,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421014,,Software maintenance;Software engineering;Software tools;Problem-solving;Software debugging;Software systems;Documentation;Cognitive science;Conferences,reverse engineering;object-oriented programming;software tools,program comprehension micro-theories;cognitive pattern notion;temporal details pattern language;software tools,,,40,,,,,IEEE,IEEE Conferences
Impact of the visitor pattern on program comprehension and maintenance,S. Jeanmart; Y. Gueheneuc; H. Sahraoui; N. Habra,"PReCISE Research Center, University of Namur, Namur, Belgium; Ptidej Team, DGIGL, École Polytechnique de Montreal, Quebec, Canada; GEODES, DIRO, University of Montreal, Quebec, Canada; PReCISE Research Center, University of Namur, Namur, Belgium",2009 3rd International Symposium on Empirical Software Engineering and Measurement,,2009,,,69,78,"In the software engineering literature, many works claim that the use of design patterns improves the comprehensibility of programs and, more generally, their maintainability. Yet, little work attempted to study the impact of design patterns on the developers' tasks of program comprehension and modification. We design and perform an experiment to collect data on the impact of the visitor pattern on comprehension and modification tasks with class diagrams. We use an eye-tracker to register saccades and fixations, the latter representing the focus of the developers' attention. Collected data show that the visitor pattern plays a role in maintenance tasks: class diagrams with its canonical representation requires less efforts from developers.",1949-3770;1949-3789,978-1-4244-4842-5978-1-4244-4841,10.1109/ESEM.2009.5316015,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5316015,,Unified modeling language;Software engineering;Software measurement;Level measurement;Electronic mail;Pattern analysis;Visualization;Performance evaluation;Standards development;Design for experiments,object-oriented programming;reverse engineering;software maintenance,visitor pattern;program comprehension;program maintenance;software engineering literature;design patterns,,28,28,,,,,IEEE,IEEE Conferences
Conceptual interpretation of SQL execution traces for program comprehension,N. Noughi; A. Cleve,"University of Namur, Belgium; University of Namur, Belgium",2015 IEEE 6th International Workshop on Program Comprehension through Dynamic Analysis (PCODA),,2015,,,19,24,"Modern data-intensive software systems manipulate an increasing amount of heterogeneous data usually stored in a database. Maintaining such systems became a crucial and complex task, which is especially true due to the lack of sufficient documentation. In this context, program comprehension became a primary and an important step in this task. Unfortunately, the highly dynamic nature of interactions between a system and its database makes it hard to analyze these interactions with static analysis techniques. To this end, we propose a novel approach that combines dynamic analysis techniques and visualization to ease understanding data-intensive systems, by focusing on their database manipulation behavior. The approach consists of defining the conceptual interpretation of SQL execution traces in terms of a domain-specific, platform-independent model.",,978-1-4673-6917,10.1109/PCODA.2015.7067179,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7067179,,Visualization;Databases;Cities and towns;Natural languages;Context;Software systems;Abstracts,data visualisation;distributed databases;program diagnostics;SQL,conceptual interpretation;SQL execution traces;program comprehension;data-intensive software systems;heterogeneous data;static analysis techniques;dynamic analysis techniques;data visualization;database manipulation behavior;domain-specific model;platform-independent model,,2,12,,,,,IEEE,IEEE Conferences
Program comprehension through the identification of abstract data types,A. Cimitile; M. Tortorella; M. Munro,"Dipartimento di Inf. e Sistemistica, Naples Univ., Italy; Dipartimento di Inf. e Sistemistica, Naples Univ., Italy; NA",Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94,,1994,,,12,19,"The paper presents the results of experiments carried out on identifying abstract data types in existing code by an improved algorithm described in previous work (G. Canfora et al., 1994). It presents a brief description of the improved algorithm and then describes the results of the experiments. It addresses issues in program comprehension from the perspective of software reuse.<<ETX>>",1092-8138,0-8186-5647,10.1109/WPC.1994.341243,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341243,,Software engineering;Software systems;Software testing;System testing;Debugging;Software maintenance;Tree graphs,abstract data types;data structures;object-oriented programming;software reusability;software maintenance,program comprehension;abstract data type identification;software reuse,,15,11,,,,,IEEE,IEEE Conferences
Query Technologies and Applications for Program Comprehension (QTAPC 2008),M. Verbaere; M. W. Godfrey; T. Girba,NA; NA; NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,285,288,"Industrial software systems are large and complex, both in terms of the software entities and their relationships. Consequently, understanding how a software system works requires the ability to pose queries over the design-level entities of the system. Traditionally, this task has been supported by simple tools (e.g., grep) combined with the programmer's intuition and experience. Recently, however, specialized code query technologies have matured to the point where they can be used in industrial situations, providing more intelligent, timely, and efficient responses to developer queries. This working session aims to explore the state of the art in code query technologies, and discover new ways in which these technologies may be useful in program comprehension. The session brings together researchers and practitioners. We survey existing techniques and applications, trying to understand the strengths and weaknesses of the various approaches, and sketch out new frontiers that hold promise.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.27,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556146,,Application software;Software engineering;Computer bugs;Software systems;Visualization;Quality assurance;Monitoring;Computer industry;Industrial relations;Software quality,program visualisation;query processing;software quality,program comprehension;industrial software systems;software entities;code query technology,,3,32,,,,,IEEE,IEEE Conferences
Program comprehension for Web services,N. Gold; K. Bennett,"Dept. of Comput., UMIST, Manchester, UK; NA","Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.",,2004,,,151,160,"Web services provide programmatic interaction between organisations within large heterogeneous distributed systems. Using recent experiences of constructing and enhancing a data integration system for the health domain, based on Web services, we draw conclusions about new problems for program comprehension. These derive from the fundamentally dynamic and distributed nature of the environment. We suggest several key research topics for program comprehension, arguing that these are crucial if software constructed from Web services is to be supportable over a long period. Finally, we briefly summarise some wider conclusions about understanding Web services at the application domain level.",1092-8138,0-7695-2149,10.1109/WPC.2004.1311057,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311057,,Web services;Software maintenance;Application software;Software debugging;Software prototyping;Gold;Distributed computing;Computer science;Cost function;Computer bugs,software maintenance;Internet;data integrity;reverse engineering,program comprehension;Web services;distributed systems;data integration;software maintenance;service-based software,,8,19,,,,,IEEE,IEEE Conferences
Brain activity measurement during program comprehension with NIRS,Y. Ikutani; H. Uwano,"Department of Information Engineering Nara National College of Technology Japan, Nara, Yamatokoriyama; Department of Information Engineering Nara National College of Technology Japan, Nara, Yamatokoriyama","15th IEEE/ACIS International Conference on Software Engineering, Artificial Intelligence, Networking and Parallel/Distributed Computing (SNPD)",,2014,,,1,6,"Near infrared spectroscopy (NIRS) has been used as a low cost, noninvasive method to measure brain activity. In this paper, we experiment to measure the effects of variables and controls in a source code to the brain activity in program comprehension. The measurement results are evaluated after noise reduction and normalization to statistical analysis. As the result of the experiment, significant differences in brain activity were observed at a task that requires memorizing variables to understand a code snippet. On the other hand, no significant differences between different levels of mental arithmetic tasks were observed. We conclude that the frontal pole reflects workload to short-term memory caused by variables without affected from calculation.",,978-1-4799-5604,10.1109/SNPD.2014.6888727,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6888727,,Brain;Atmospheric measurements;Particle measurements;Noise;Blood;Noise reduction;Statistical analysis,blood;blood flow measurement;brain;infrared spectra;medical signal processing;neurophysiology;signal denoising;statistical analysis,brain activity measurement;program comprehension;near infrared spectroscopy;noninvasive method;source code;noise reduction;normalization;statistical analysis;mental arithmetic tasks;short-term memory;frontal pole;code snippet,,7,10,,,,,IEEE,IEEE Conferences
Using feature modeling for program comprehension and software architecture recovery,I. Pashov; M. Riebisch,"Tech. Univ. Ilmenau, Germany; Tech. Univ. Ilmenau, Germany","Proceedings. 11th IEEE International Conference and Workshop on the Engineering of Computer-Based Systems, 2004.",,2004,,,406,417,"The available evidence in a legacy software system, which can help in its understanding and recovery of its architecture are not always sufficient. Very often the system's documentation is poor and outdated. One may argue that the most reliable resource of information is the system's source code. Nevertheless a significant knowledge about the problem domain is required in order to facilitate the extraction of the system's useful architectural information. In this approach feature modeling is introduced as an additional step in a system's architectural recovery process. Feature modeling structures the system's functionality and supports reverse engineering by detecting the relations between source code elements and requirements. Tracing these relations may lead to a better understanding of the program's behavior and the recovery of various architectural elements. In this way, by providing a mapping between source code and features, the system's feature model supports program comprehension and architectural recovery. The approach is developed as first part of a migration methodology towards a component-based architecture of legacy systems. Recovered information about features and architecture is collected in a repository to enable a refactoring as next step. The approach is currently applied in a large project for reengineering of an industrial image processing system.",,0-7695-2125,10.1109/ECBS.2004.1316725,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1316725,,Software architecture;Reverse engineering;Computer architecture;Software systems;Documentation;Data mining;Image processing;Companies;Image reconstruction;Information resources,systems re-engineering;software architecture;software prototyping;software maintenance;reverse engineering;formal verification;object-oriented programming,legacy software system;software architecture recovery;feature modeling;reverse engineering;program comprehension;component-based architecture;software refactoring;industrial image processing system,,11,29,,,,,IEEE,IEEE Conferences
Criteria for program comprehension derived from software complexity metrics,H. Zuse,"Tech. Univ., Berlin, Germany",[1993] IEEE Second Workshop on Program Comprehension,,1993,,,8,16,Program comprehension is close related to program complexity. In order to analyze program complexity much effort has been spent to measure the complexity of programs. For this reason hundreds of software complexity measures have been proposed. Criteria/conditions for program comprehension from software complexity measures are derived. It is also shown that using measurement theoretic numerical conditions from software complexity measures can be translated back to empirical conditions. That means the term comprehension can be described by empirical axioms. This approach makes it easier to talk about the term program comprehension.<<ETX>>,1092-8138,0-8186-4042,10.1109/WPC.1993.263911,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263911,,Software measurement;Humans;Software design;Internet;Computer architecture;Programming profession,software engineering;software metrics,program comprehension;software complexity metrics;program complexity;measurement theoretic numerical conditions,,4,18,,,,,IEEE,IEEE Conferences
Data mining source code to facilitate program comprehension: experiments on clustering data retrieved from C++ programs,Y. Kanellopoulos; C. Tjortjis,"Dept. of Comput., UMIST, Manchester, UK; Dept. of Comput., UMIST, Manchester, UK","Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.",,2004,,,214,223,"This paper presents ongoing work on using data mining to discover knowledge about software systems thus facilitating program comprehension. We discuss how this work fits in the context of tool supported maintenance and comprehension and report on applying a new methodology on C++ programs. The overall framework can provide practical insights and guide the maintainer through the specifics of systems, assuming little familiarity with these. The contribution of this work is two-fold: it provides a model and associated method to extract data from C++ source code which is subsequently to be mined, and evaluates a proposed framework for clustering such data to obtain useful knowledge. The methodology is evaluated on three open source applications, results are assessed and conclusions are presented. This paper concludes with directions for future work.",1092-8138,0-7695-2149,10.1109/WPC.2004.1311063,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311063,,Data mining;Information retrieval;Software maintenance;Software systems;Object oriented modeling;Application software;Data models;Documentation;Character recognition;Computer languages,data mining;C++ language;reverse engineering;software maintenance;public domain software,data mining;program comprehension;data clustering;C++ programs;tool supported maintenance;data extraction;C++ source code;open source applications,,6,20,,,,,IEEE,IEEE Conferences
Inference-based and expectation-based processing in program comprehension,M. P. O'Brien; J. Buckley,"Dept. of Inf. Technol., Limerick Inst. of Technol., Ireland; NA",Proceedings 9th International Workshop on Program Comprehension. IWPC 2001,,2001,,,71,78,"This paper formally distinguishes between two variants of top-down comprehension (as originally described by Brooks (1983) and Soloway (1984)). The first is inference-based comprehension, where the programmer derives meaning from cliched implementations in the code. The second is expectation-based comprehension, where the programmer has pre-generated expectations of the code's meaning. The paper describes the distinguishing features of the two variants, and uses these characteristics as the basis for an empirical study. This study establishes their existence, and identifies their relationship with programmers' domain and coding standards familiarity.",1092-8138,0-7695-1131,10.1109/WPC.2001.921715,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921715,,Programming profession;Costs;Documentation;Information technology;Bridges;Data mining;Performance evaluation;Cognitive science,reverse engineering,program comprehension;top-down comprehension;inference-based comprehension;expectation-based comprehension;coding standards,,11,16,,,,,IEEE,IEEE Conferences
Facilitating program comprehension by mining association rules from source code,C. Tjortjis; L. Sinos; P. Layzell,"Dept. of Comput., Univ. of Manchester Inst. of Sci. & Technol., UK; Dept. of Comput., Univ. of Manchester Inst. of Sci. & Technol., UK; Dept. of Comput., Univ. of Manchester Inst. of Sci. & Technol., UK","11th IEEE International Workshop on Program Comprehension, 2003.",,2003,,,125,132,"Program comprehension is an important part of software maintenance, especially when program structure is complex and documentation is unavailable or outdated. Data mining can produce structural views of source code thus facilitating legacy systems understanding. This paper presents a method for mining association rules from code aiming at capturing program structure and achieving better system understanding. A tool was implemented to assess this method. It inputs data extracted from code and derives association rules. Rules are then processed to abstract programs into groups containing interrelated entities. Entities are grouped together if their attributes participate in common rules. The abstraction is performed at the function level, in contrast to other approaches, that work at the program level. The method was evaluated using real, working programs. Programs are fed into a code analyser which produces the input needed for the mining tool. Results show that the method facilitates program comprehension by only using source code where domain knowledge and reliable documentation are not available or reliable.",1092-8138,0-7695-1883,10.1109/WPC.2003.1199196,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199196,,Data mining;Association rules;Software maintenance;Documentation;Performance analysis;Algorithm design and analysis;Spatial databases;Software performance;Guidelines;Software tools,reverse engineering;data mining;software maintenance,program comprehension;association rule mining;source code;software maintenance;data mining;structural views;legacy systems understanding;program structure;system understanding;interrelated entities;function level,,15,25,,,,,IEEE,IEEE Conferences
Understanding Lolita: program comprehension in functional languages,J. E. Hazan; S. A. Jarvis; R. G. Morgan; R. Garigliano,"Durham Univ., UK; Durham Univ., UK; Durham Univ., UK; Durham Univ., UK",[1993] IEEE Second Workshop on Program Comprehension,,1993,,,26,34,"Traditional arguments concerning the comprehensibility of functional programs have been illustrated with trivial examples. The authors present the real-life example of a large system for natural language processing which has been programmed entirely in a lazy functional language. This system is undergoing constant change as new features are added to different areas. They present a series of case studies which illustrate various aspects of the maintenance task, including reuse of existing parts of the system and the integration of the new features. They explain how the choice of a functional language for programming the system has aided in the comprehension of the system by new programmers and how this in turn has led to the simplification of the maintenance task. They describe the ease with which new features have been integrated into the system and relate this to the careful design of abstractions within a functional programming framework.<<ETX>>",1092-8138,0-8186-4042,10.1109/WPC.1993.263909,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263909,,Functional programming;Programming profession;Artificial intelligence;Natural language processing;Memory management;Councils;Large-scale systems;Ink;Trademarks,functional programming;software maintenance,Lolita;program comprehension;functional languages;functional programs;natural language processing;lazy functional language;maintenance task;reuse;comprehension,,,13,,,,,IEEE,IEEE Conferences
Backward conditioning: a new program specialisation technique and its application to program comprehension,C. Fox; M. Harman; R. Hierons; S. Danicic,"King's Coll., London Univ., UK; NA; NA; NA",Proceedings 9th International Workshop on Program Comprehension. IWPC 2001,,2001,,,89,97,"This paper introduces backward conditioning. Like forward conditioning (used in conditioned slicing), backward conditioning consists of specialising a program with respect to a condition inserted into the program. However, whereas forward conditioning deletes statements which are not executed when the initial state satisfies the condition, backward conditioning deletes statements which cannot cause execution to enter a state which satisfies the condition. The relationship between backward and forward conditioning is reminiscent of the relationship between backward and forward slicing. Forward conditioning addresses program comprehension questions of the form 'what happens if the program starts in a state satisfying condition c?', whereas backward conditioning addresses questions of the form 'what parts of the program could potentially lead to the program arriving in a state satisfying condition c?' The paper illustrates the use of backward conditioning as a program comprehension assistant and presents an algorithm for constructing backward conditioned programs.",1092-8138,0-7695-1131,10.1109/WPC.2001.921717,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921717,,Educational institutions;Programming profession;Temperature,reverse engineering;program slicing,program specialisation;program comprehension;backward conditioning;forward conditioning;conditioned slicing,,11,19,,,,,IEEE,IEEE Conferences
Easing program comprehension by sharing navigation data,R. DeLine; M. Czerwinski; G. Robertson,"Microsoft Res., Microsoft Corp., Redmond, WA, USA; Microsoft Res., Microsoft Corp., Redmond, WA, USA; Microsoft Res., Microsoft Corp., Redmond, WA, USA",2005 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC'05),,2005,,,241,248,"Large software projects often require a programmer to make changes to unfamiliar source code. This paper describes a set of tools, called Team Tracks, designed to ease program comprehension by showing the source code navigation patterns of fellow development team members. One technique shows a list of related items, given that the user is viewing a given method or class. Another technique shows the favorite classes, by showing a class hierarchy view that hides less frequently visited classes, methods, and members. Two user studies, a laboratory study and a field study, were run to evaluate the effectiveness of these techniques. The results of the two studies demonstrate that sharing navigation data can improve program comprehension and is subjectively preferred by users.",1943-6092;1943-6106,0-7695-2443,10.1109/VLHCC.2005.32,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1509509,,Navigation;Costs;Data visualization;Usability;Documentation;Instruments;Programming profession;Fellows;Laboratories;Unified modeling language,program visualisation;reverse engineering,program comprehension;navigation data sharing;software project;software programming;Team Tracks;source code navigation pattern;class hierarchy,,50,13,,,,,IEEE,IEEE Conferences
A Concern Visualization Approach for Improving MATLAB and Octave Program Comprehension,I. D. M. Lessa; G. D. F. Carneiro; M. P. Monteiro; F. B. e. Abreu,NA; NA; NA; NA,2015 29th Brazilian Symposium on Software Engineering,,2015,,,130,139,"The literature has pointed out the need for focusing efforts to better support comprehension of MATLAB and Octave programs. Despite being largely used in the industry and academia in the engineering domain, programs and routines written in those languages still require efforts to propose approaches and tools for its understanding. Considering the use of crosscutting concerns (CCCs) to support the comprehension of object-oriented programs, there is room of its use in the context of MATLAB and Octave programs. The literature has purpose and examples in this direction. Considering this scenario, we propose the use of visualization enriched with CCCs representation to support the comprehension of such programs. This paper discusses the use of a multiple view interactive environment called OctMiner in the context of two case studies to characterize how collected information relating to crosscutting concerns can foster the comprehension of MATLAB and GNU/Octave programs. As a result of the conducted case studies, we propose strategies based on OctMiner and tailored to support different comprehension activities of programs written in MATLAB and Octave.",,978-1-4673-9272,10.1109/SBES.2015.19,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7328017,MATLAB/Octave;software comprehension;crosscutting concerns;software visualization,MATLAB;Visualization;Scattering;Context;XML;Image color analysis,data visualisation;mathematics computing;program diagnostics,concern visualization approach;MATLAB;Octave program comprehension;engineering domain;crosscutting concerns;CCC;OctMiner;multiple view interactive environment;GNU-Octave programs,,,19,,,,,IEEE,IEEE Conferences
Designing your Next Empirical Study on Program Comprehension,M. Di Penta; R. E. K. Stirewalt; E. Kraemer,"University of Sannio, Via Traiano 82100 Benevento, Italy; Michigan State University, East Lansing, MI; University of Georgia, Athens, GA",15th IEEE International Conference on Program Comprehension (ICPC '07),,2007,,,281,285,"The field of program comprehension is characterized by both the continuing development of new tools and techniques and the adaptation of existing techniques to address program comprehension needs for new software development and maintenance scenarios. The adoption of these techniques and tools in industry requires proper experimentation to assess the advantages and disadvantages of each technique or tool and to let the practitioners choose the most suitable approach for a specific problem. The objective of this working session is to encourage researchers and practitioners working in the area of program comprehension to join forces to design and carry out studies related to program comprehension, including observational studies, controlled experiments, case studies, surveys, and contests, and to develop standards for describing and carrying out such studies in a way that facilitates replication of data and aggregation of the results of related studies.",1092-8138,0-7695-2860,10.1109/ICPC.2007.17,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268264,,Software maintenance;Computer science;Software tools;Programming;Force control;Standards development;Software engineering;Documentation;Collaboration;Best practices,design;software engineering,program comprehension;software development;software maintenance;data replication,,15,25,,,,,IEEE,IEEE Conferences
Evaluating software maintenance support tools for their support of program comprehension,A. Von Mayrhauser; S. Lang,"Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA; NA",1998 IEEE Aerospace Conference Proceedings (Cat. No.98TH8339),,1998,4,,173,187 vol.4,"New tools that purport to help programmers understand software during maintenance and evolution are appearing on the market with increasing frequency. Just how good are they at supporting software comprehension is frequently only ""demonstrated"" by anecdote or hearsay. This paper reports on an analysis infrastructure for formally performing such evaluation, and on an application of the evaluation instrument to an existing tool, Lemma.",1095-323X,0-7803-4311,10.1109/AERO.1998.682191,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=682191,,Software maintenance;Programming profession;Computer science;Software tools;Frequency;Performance analysis;Performance evaluation;Application software;Instruments;Cognition,software maintenance;software tools;software performance evaluation,software maintenance support tools;program comprehension;programmers;maintenance;evolution;software comprehension;analysis infrastructure;Lemma,,2,23,,,,,IEEE,IEEE Conferences
Using Sex Differences to Link Spatial Cognition and Program Comprehension,M. Fisher; A. Cox; L. Zhao,"Department of Psychology, Saint Mary’s University, Halifax, Nova Scotia, Canada; Faculty of Computer Science, Dalhousie University, Halifax, Nova Scotia, Canada; Faculty of Computer Science, Dalhousie University, Halifax, Nova Scotia, Canada",2006 22nd IEEE International Conference on Software Maintenance,,2006,,,289,298,"Spatial cognition and program development have both been examined using contrasting models. We suggest that sex-based differences in one's perception of risk is the key to relating these models. Specifically, the survey map approach to navigation and the top-down development/comprehension strategy use similar and related high risk cognitive skills that males show a preference towards. Conversely, the route-based approach to navigation and the bottom-up development/comprehension strategy use similar and related low risk cognitive skills that women show a preference towards. On the assumption that programmers are consistent in their risk-taking behaviours, we believe that they, as much as possible, tend to use the same strategy when performing program development and comprehension. In an experimental setting, we compare programmer's performance on spatial cognition and program comprehension tasks. The correlations that we found suggest that programmers use equivalently risky strategies for program comprehension and spatial cognition. Thus, there is evidence that similar cognitive skills are used for spatial cognition and program comprehension/development, and that the similarities are a consequence of sex-based differences in risk-taking behaviour",1063-6773,0-7695-2354,10.1109/ICSM.2006.72,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4021352,,Cognition;Navigation;Programming profession;Software maintenance;Computer science;Psychology;Application software;Software systems;Cognitive science;Flow graphs,cognition;gender issues;programming;reverse engineering,sex differences;spatial cognition;program comprehension;program development;risk-taking behaviour,,14,36,,,,,IEEE,IEEE Conferences
Individual differences in program comprehension strategies in unfamiliar programming systems,A. J. Ko; B. Uttl,"Sch. of Comput. Sci., Carnegie Mellon Univ., Pittsburgh, PA, USA; NA","11th IEEE International Workshop on Program Comprehension, 2003.",,2003,,,175,184,"This study examines the effect of individual differences on the program comprehension strategies of users working with an unfamiliar programming system. Participants of varying programming expertise were given a battery of psychological tests, a brief introduction to a statistical programming environment, and a 20-minute debugging task. Our data show three distinct comprehension strategies that were related to programming experience, but individuals with stronger domain knowledge for specific bugs tended to succeed.",1092-8138,0-7695-1883,10.1109/WPC.2003.1199201,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199201,,Programming profession;Debugging;Psychology;Computer bugs;Predictive models;Documentation;Computer science;Educational institutions;Art;Batteries,reverse engineering;program debugging;human factors;programming environments,program comprehension strategies;unfamiliar programming systems;individual differences;programming expertise;psychological tests;statistical programming environment;program understanding;debugging task;programming experience,,9,16,,,,,IEEE,IEEE Conferences
From system comprehension to program comprehension,C. Tjortjis; N. Gold; P. Layzell; K. Bennett,"Comput. Dept., Univ. of Manchester Inst. of Sci. & Technol., UK; Comput. Dept., Univ. of Manchester Inst. of Sci. & Technol., UK; Comput. Dept., Univ. of Manchester Inst. of Sci. & Technol., UK; NA",Proceedings 26th Annual International Computer Software and Applications,,2002,,,427,432,"Program and system comprehension are vital parts of the software maintenance process. We discuss the need for both perspectives and describe two methods that may be integrated to provide a smooth transition in understanding from the system level to the program level. Results from a qualitative survey of expert industrial software maintainers, their information needs and requirements when comprehending software are initially presented. We then review existing software tools which facilitate system level and program comprehension. Two successful methods from the fields of data mining and concept assignment are discussed, each addressing some of these requirements. We also describe how these methods can be coupled to produce a broader software comprehension method which partly satisfies all the requirements. Future directions including the closer integration of the techniques are also identified.",0730-3157,0-7695-1727,10.1109/CMPSAC.2002.1045039,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1045039,,Software maintenance;Software quality;Software tools;Computer industry;Acceleration;Gold;Computer science;Data mining;Costs;Guidelines,software maintenance;software tools;data mining,system comprehension;program comprehension;software maintenance;software tools;data mining;concept assignment,,4,28,,,,,IEEE,IEEE Conferences
Facilitating program comprehension via generic components for state machines,J. Weidl; R. R. Klosch; G. Trausmuth; H. Gall,"Dept. of Distribution Syst., Tech. Univ. Vienna, Austria; NA; NA; NA",Proceedings Fifth International Workshop on Program Comprehension. IWPC'97,,1997,,,118,127,"Various applications use state transition mechanisms as a major building block. As an example, finite state machines (FSMs) and their graphical counterpart-state transition diagram-are heavily used e.g. for the specification of various kinds of protocols such as network protocols (e.g. TCP/IP), protocols for infrared data transmission, etc. Many embedded systems, such as telephone switching systems and television control, are directly based on state machines. Introducing generic components for state machines can raise the source code abstraction level from ""hard coded"" control flow decisions such as ""switch/case"" and ""if"" to a more flexible implementation model of control flow. The paper shows that it is possible to use statecharts and their advanced mechanisms from specification to implementation of reactive systems. By explicitly modeling states and state transitions the source code is described at a higher abstraction level and thereby top down program comprehension is facilitated. We define a set of specific design patterns to abstract state machine source code from low level implementation to a more abstract level. Furthermore, we introduce a certain degree of genericity and thus flexibility without major losses in efficiency during the design and implementation of generic components.",1092-8138,0-8186-7993,10.1109/WPC.1997.601277,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601277,,Switches;Protocols;Embedded system;Documentation;Europe;Automata;TCPIP;Data communication;Telephony;TV,reverse engineering;finite state machines;formal specification;real-time systems;visual programming,program comprehension;generic components;state machines;state transition mechanisms;finite state machines;graphical counterpart;state transition diagram;specification;network protocols;television control;embedded systems;telephone switching systems;source code abstraction level;flexible implementation model;control flow;statecharts;reactive systems;higher abstraction level;top down program comprehension;abstract state machine source code,,1,15,,,,,IEEE,IEEE Conferences
Collective Code Bookmarks for Program Comprehension,A. Guzzi; L. Hattori; M. Lanza; M. Pinzger; A. v. Deursen,NA; NA; NA; NA; NA,2011 IEEE 19th International Conference on Program Comprehension,,2011,,,101,110,"The program comprehension research community has been developing useful tools and techniques to support developers in the time-consuming activity of understanding software artifacts. However, the majority of the tools do not bring collective benefit to the team: After gaining the necessary understanding of an artifact (e.g., using a technique based on visualization, feature localization, architecture reconstruction, etc.), developers seldom document what they have learned, thus not sharing their knowledge. We argue that code bookmarking can be effectively used to document a developer's findings, to retrieve this valuable knowledge later on, and to share the findings with other team members. We present a tool, called Pollicino, for collective code bookmarking. To gather requirements for our bookmarking tool, we conducted an online survey and interviewed professional software engineers about their current usage and needs of code bookmarks. We describe our approach and the tool we implemented. To assess the tool's effectiveness, adequacy, and usability, we present an exploratory pre-experimental user study we have performed with 11 participants.",1092-8138;1092-8138,978-1-61284-308-7978-0-7695-4398,10.1109/ICPC.2011.19,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970168,,Usability;Interviews;XML;Navigation;Documentation;Particle measurements,reverse engineering;software tools;system documentation,program comprehension;software artifact understanding;developer findings documentation;Pollicino;collective code bookmarking,,10,17,,,,,IEEE,IEEE Conferences
Applying program comprehension techniques to karel robot programs,N. Oliveira; P. R. Henriques; D. da Cruz; M. J. Varanda Pereira; M. Mernik; T. Kosar; M. Črepinšek,"University of Minho - Department of Computer Science, Campus de Gualtar, 4715-057, Braga, Portugal; University of Minho - Department of Computer Science, Campus de Gualtar, 4715-057, Braga, Portugal; University of Minho - Department of Computer Science, Campus de Gualtar, 4715-057, Braga, Portugal; Polytechnic Institute of Braganca, Campus de Sta. Apolonia, Apartado 134 - 5301-857, Portugal; University of Maribor, Faculty of Electrical Engineering and Computer Science, Smetanova 17, 2000, Slovenia; University of Maribor, Faculty of Electrical Engineering and Computer Science, Smetanova 17, 2000, Slovenia; University of Maribor, Faculty of Electrical Engineering and Computer Science, Smetanova 17, 2000, Slovenia",2009 International Multiconference on Computer Science and Information Technology,,2009,,,699,706,"In the context of program understanding, a challenge research topic1 is to learn how techniques and tools for the comprehension of General-Purpose Languages (GPLs) can be used or adjusted to the understanding of Domain-Specific Languages (DSLs). Being DSLs tailored for the description of problems within a specific domain, it becomes easier to improve these tools with specific visualizations (at a higher abstraction level, closer to the problem level) in order to understand the DSLs programs. In this paper, comprehension techniques will be applied to Karel language. This will allow us to explore the creation of problem domain visualizations for this language and to combine both problem and program domains in order to reach a full understanding of Karel programs.",2157-5525,978-1-4244-5314,10.1109/IMCSIT.2009.5352762,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5352762,,Robots;DSL;Visualization;Computer science;Data mining;Domain specific languages;Digital signal processing;Information technology;Vocabulary;Natural languages,program visualisation;reverse engineering;robot programming,program comprehension techniques;Karel robot programs;program understanding;general-purpose languages;domain-specific languages;Karel language;problem domain visualizations,,1,22,,,,,IEEE,IEEE Conferences
FEPSS: a flexible and extensible program comprehension support system,Tao Lin; L. O'Brien,"Math. & Inf. Sci., CSIRO, Canberra, ACT, Australia; NA",Proceedings Fifth Working Conference on Reverse Engineering (Cat. No.98TB100261),,1998,,,40,49,"This paper describes the architecture of an ongoing developed Flexible and Extensible Program comprehension Support System (FEPSS). Program comprehension is a process for supporting users to understand a software system and is required for forward, reverse engineering, and re-engineering. In a program comprehension process some artifacts such as control-flow graphs and data-flow graphs need to be generated to help users in understanding and some artifacts such as design rationale and testing cases also need to be recorded for further re-engineering. It is impossible to predict all the types of artifacts to be supported in a program comprehension process as at least no one makes a re-engineering plan when designing a new software system. Therefore a program comprehension system should support a great flexibility and extensibility in artifact modelling. The approach which FEPSS takes is to provide a support system where the users can add new artifacts even at run time. FEPSS uses a relational object model to link the artifacts in order to integrate various activities in a program comprehension process as a whole. To help users to understand the artifacts and their relationships FEPSS uses 3D visualization to display artifacts. As the number of the artifacts for a software system can be very large FEPSS provides a navigation tool for users to control what artifacts to display. Based on these mechanisms, FEPSS can support users to analyze, model, and explore the artifacts through pictures.",,0-8186-8967,10.1109/WCRE.1998.723174,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=723174,,Data models;Data visualization;Computer architecture;Software systems;Three dimensional displays;Two dimensional displays;Navigation;Reverse engineering;Software maintenance;Information analysis,reverse engineering;software tools;systems re-engineering;data visualisation;data flow graphs,FEPSS;flexible extensible program comprehension system;program understanding;forward engineering;reverse engineering;re-engineering;control-flow graphs;data-flow graphs;design rationale;testing cases;artifact modelling;run time;relational object model;3D visualization;navigation tool,,,24,,,,,IEEE,IEEE Conferences
Enriching program comprehension for software reuse,E. Burd; M. Munro,"Centre for Software Maintenance, Durham Univ., UK; NA",Proceedings Fifth International Workshop on Program Comprehension. IWPC'97,,1997,,,130,137,"The paper describes the process of code scavenging for reuse. In particular we consider enriching program comprehension for the identification and integration of reuse components by information abstraction and the use of graphical representations. The requirements of good reuse candidates are described, and then a description of a process of identifying and preparing for their reengineering into reuse units is given, In particular we describe two main activities: the identification of units; and the definition of the units user interface. Initially, the identification of reusable units applies some of the methods from RE/sup 2/ but is extended with the use of graph simplification procedures. The identification process is based on the calling structure of the code. Secondly, data analysis is performed on the identified reuse candidates. The data analysis process provides an indication of the potential use of the component and the effect required to make the candidate reusable. The paper provides examples and results from a number of case studies which have been used to evaluate this work. Our work relies heavily on there being communication between technical and non-technical staff. We achieve this through the use of graphical representation and thus results are displayed graphically where applicable.",1092-8138,0-8186-7993,10.1109/WPC.1997.601279,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601279,,Software reusability;Software maintenance;Data analysis;Costs;Software quality;User interfaces;Productivity;Programming;Software design;Software performance,software reusability;reverse engineering;systems re-engineering;visual programming,program comprehension;software reuse;code scavenging;reuse components;information abstraction;graphical representations;reuse candidates;reengineering;reuse units;units user interface;unit identification;RE/sup 2/;graph simplification procedures;calling structure;data analysis;graphical representation,,9,12,,,,,IEEE,IEEE Conferences
"Does the ""Refactor to Understand"" reverse engineering pattern improve program comprehension?",B. Du Bois; S. Demeyer; J. Verelst,"Lab. on ReEng., Antwerpen Univ., Belgium; Lab. on ReEng., Antwerpen Univ., Belgium; NA",Ninth European Conference on Software Maintenance and Reengineering,,2005,,,334,343,"Program comprehension is a fundamental requirement for all but the most trivial maintenance activities. Previous research has demonstrated key principles for improving comprehension. Among others, these consist of the introduction of beacons as indexes into knowledge, and the chunking of low-level structures into higher-level abstractions. These principles are naturally reflected in the reverse engineering pattern Refactor to Understand, which uses incremental renaming and extracting of program elements as the means to decipher cryptic code. In this paper, we discuss a controlled experiment to explore differences in program comprehension between the application of Refactor to Understand and the traditional Read to Understand pattern. Our results support added value of Refactor to Understand regarding specific aspects of program comprehension and specific types of source code. These findings illustrate the need for further experiments to provide clear guidelines on the application of refactorings for improving program comprehension.",1534-5351,0-7695-2304,10.1109/CSMR.2005.25,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1402151,,Reverse engineering;Management information systems;Guidelines;Pattern analysis;Computer science;Time factors;Delay;Software maintenance;Software testing;System testing,reverse engineering;software maintenance;software process improvement,Refactor to Understand reverse engineering pattern;program comprehension improvement;incremental renaming;program element extraction;Read to Understand pattern;source code,,10,22,,,,,IEEE,IEEE Conferences
Intensions are a key to program comprehension,V. Rajlich,"Department of Computer Science, Wayne State University, Detroit, MI USA 48202",2009 IEEE 17th International Conference on Program Comprehension,,2009,,,1,9,"The classical comprehension theories study relations between extensions, intensions, and names. Originally developed in linguistics and mathematics, these theories are applicable to program comprehension as well. While extensions are present in the program, the intensions are usually missing, and evolution and maintenance programmers have to recover them as the program cannot be successfully comprehended and changed without them.",1092-8138,978-1-4244-3998-0978-1-4244-3997,10.1109/ICPC.2009.5090022,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090022,,Mathematics;Programming profession;Hardware;Computer science;Visualization;Humans;Cities and towns;Marketing and sales;Credit cards;Software engineering,computational linguistics;reverse engineering;software maintenance;software metrics,program comprehension effort;program intension;software evolution;software maintenance;linguistics;software development;program extension,,10,27,,,,,IEEE,IEEE Conferences
Moral dominance relations for program comprehension,S. C. Shaw; M. Goldstein; M. Munro; E. Burd,NA; NA; NA; NA,IEEE Transactions on Software Engineering,,2003,29,9,851,863,"Dominance trees have been used as a means for reengineering legacy systems into potential reuse candidates. The dominance relation suggests the reuse candidates which are identified by strongly directly dominated subtrees. We review the approach and illustrate how the dominance tree may fail to show the relationship between the strongly direct dominated procedures and the directly dominated procedures. We introduce a relation of generalized conditional independence which strengthens the argument for the adoption of the potential reuse candidates suggested by the dominance tree and explains their relationship with the directly dominated vertices. This leads to an improved dominance tree, the moral dominance tree, which helps aid program comprehension available from the tree. The generalized conditional independence relation also identifies potential reuse candidates that are missed by the dominance relation.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2003.1232289,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1232289,,Ethics;Tree graphs;Software maintenance;Databases;Graphical models;Reverse engineering;Testing;Companies;Software performance;Documentation,tree data structures;reverse engineering;software reusability;systems re-engineering,moral dominance relations;program comprehension;dominance trees;legacy systems reengineering;reuse candidates;strongly directly dominated subtrees;directly dominated vertices;generalized conditional independence relation,,7,29,,,,,IEEE,IEEE Journals
Search Based Software Engineering for Program Comprehension,M. Harman,"King's College London, UK",15th IEEE International Conference on Program Comprehension (ICPC '07),,2007,,,3,13,"Search based software engineering (SBSE) is an approach to software engineering in which search based optimization algorithms are used to identify optimal or near optimal solutions and to yield insight. SBSE techniques can cater for multiple, possibly competing objectives and/or constraints and applications where the potential solution space is large and complex. Such situations are common in software engineering, leading to an increasing interest in SBSE. This paper provides a brief overview of SBSE, explaining some of the ways in which it has already been applied to program-comprehension related activities. The paper also outlines some possible future applications of and challenges for the further application of SBSE to program comprehension.",1092-8138,0-7695-2860,10.1109/ICPC.2007.35,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268235,,Software engineering;Application software;Software testing;Biomedical engineering;Software algorithms;Educational institutions;Cost function;Automatic testing;Optimizing compilers;Quality assessment,optimisation;software engineering,program comprehension;search based software engineering;optimization algorithms,,23,82,,,,,IEEE,IEEE Conferences
User Perspectives on a Visual Aid to Program Comprehension,A. Cox; M. Fisher; J. Muzzerall,"Faculty of Computer Science, Dalhousie University, Halifax, Nova Scotia, Canada. amcox@cs.dal.ca; NA; NA",3rd IEEE International Workshop on Visualizing Software for Understanding and Analysis,,2005,,,1,6,"In an experiment to investigate the utility of variable dependency diagrams, the unsolicited comments of the participants provide important insights into the characteristics of effective visualisations. The data obtained during the experiment provides support for these insights and suggests that to be effective, visualisations must unify the information they provide with the needs of programmers. As well, programmers require training in the use of specific visualisations since, during maintenance tasks, their need to focus on the task causes them to avoid the distraction of learning new, unfamiliar tools. When maintenance requires source code manipulation, visualisations must be capable of directly linking information to the code, as programmers are often incapable or unwilling to identify relationships between the visualisation and the code",,0-7803-9540,10.1109/VISSOF.2005.1684308,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1684308,,Programming profession;Computer science;Psychology;Data visualization;Joining processes;Functional programming;Documentation,program visualisation;software maintenance,program comprehension visual aid;variable dependency diagrams;program visualisation;software maintenance;source code manipulation,,2,12,,,,,IEEE,IEEE Conferences
View definitions for language-independent multiple-view program comprehension and editing,J. Sajaniemi,"Dept. of Comput. Sci., Joensuu Univ., Finland",Proceedings First International Workshop on Visualizing Software for Understanding and Analysis,,2002,,,3,12,"View-based editing provides a technique to integrate program analysis tools into the comprehension and editing process. The programmer may study the result of an analysis in a separate view window and make changes in the output, and the system will propagate the changes back to the original program. In this paper, we will study how view-based editors and editable views can be made technically realizable and cognitively usable. The most important technical aspects are data flow considerations, the frequency of transformations, and the treatment of failures. For users, the most significant properties are understandability in the users' framework, avoidance of unexpected changes or side effects, and the smoothness of successive cycles.",,0-7695-1662,10.1109/VISSOF.2002.1019789,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1019789,,Programming profession;Transformers;Natural languages;Concrete;Computer science;Frequency;Debugging;Text analysis;Conferences;Java,reverse engineering;software engineering;text editing,language-independent multiple-view program comprehension;language-independent multiple-view program editing;view definitions;view-based editing;program analysis tools;editable views;data flow;understandability;user framework,,,22,,,,,IEEE,IEEE Conferences
Program comprehension in generative programming: a history of grand challenges,D. Batory,"Dept. of Comput. Sci., Texas Univ. at Austin, TX, USA","Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.",,2004,,,2,11,"The communities of generative programming (GP) and program comprehension (PC) look at similar problems: GP derives a program from a specification, PC derives a specification from a program. A basic difference between the two is GP's use of specific knowledge representations and mental models that are essential for program synthesis. In this paper, the author presents a historical review of the grand challenges, results, and outlook for GP as they pertain to PC.",1092-8138,0-7695-2149,10.1109/WPC.2004.1311042,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311042,,History;Conferences,reverse engineering;automatic programming;formal specification;knowledge representation,program comprehension;generative programming;program specification;knowledge representations;mental models;program synthesis,,1,22,,,,,IEEE,IEEE Conferences
A cognitive model for program comprehension,Shaochun Xu,"Dept. of Comput. Sci., Laurentian Univ., Ont., Canada","Third ACIS Int'l Conference on Software Engineering Research, Management and Applications (SERA'05)",,2005,,,392,398,"This paper proposes a cognitive model to classify the level of cognition and cognitive activities in program comprehension. This model is composed of input, cognitive process and output, among which the cognitive process includes four activities (absorption, denial, reorganization and expulsion) at six Bloom learning levels. Compared with the existing models, our learning model is more complete and more detailed. It not only describes cognitive activities in detail, but can also be applied in most of the cases. Our model can also reveal the differences between experts and novices in program comprehension. It provides some useful insights on how to build a tool to aid program comprehension. We also find that the so-called traditional program comprehension process involves activities not only at comprehension level of the Bloom's taxonomy, but at higher levels as well. A case study is conducted to validate this learning model.",,0-7695-2297,10.1109/SERA.2005.2,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1563188,,Programming profession;Software maintenance;Computer science;Educational institutions;Cognition;Absorption;Taxonomy;Brain modeling;Software engineering;Conference management,reverse engineering;software maintenance;cognition,cognitive model;program comprehension;Bloom learning level;software maintenance;program understanding;Bloom taxonomy,,,29,,,,,IEEE,IEEE Conferences
Program comprehension techniques improve software inspections: a case study,S. Rifkin; L. Deimel,"Master Syst. Inc., McLean, VA, USA; NA",Proceedings IWPC 2000. 8th International Workshop on Program Comprehension,,2000,,,131,138,"Software inspections are widely regarded as a cost-effective mechanism for removing defects in software, though performing them does not always reduce the number of customer-discovered defects. We present a case study in which an attempt was made to reduce such defects through inspection training that introduced program comprehension ideas. The training was designed to address the problem of understanding the artifact being reviewed, as well as other perceived deficiencies of the inspection process itself. Measures, both formal and informal, suggest that explicit training in program understanding may improve inspection effectiveness.",1092-8138,0-7695-0656,10.1109/WPC.2000.852487,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852487,,Inspection;Computer aided software engineering;Software performance;Costs;Programming;Software maintenance;Software measurement;Software testing;Data privacy,reverse engineering;inspection;program debugging;program diagnostics;training;computer science education,program comprehension techniques;software inspections;case study;cost-effective mechanism;software defect removal;customer-discovered defects;training;perceived deficiencies;formal measures;informal measures;program understanding;effectiveness;formal technical reviews;peer reviews,,3,14,,,,,IEEE,IEEE Conferences
Reducing Program Comprehension Effort in Evolving Software by Recognizing Feature Implementation Convergence,J. Kothari; T. Denton; A. Shokoufandeh; S. Mancoridis,Drexel University; Drexel University; Drexel University; Drexel University,15th IEEE International Conference on Program Comprehension (ICPC '07),,2007,,,17,26,"The implementations of software features evolve as an application matures. We define a measure of feature implementation overlap that determines how similar features are in their execution by examining their call graphs. We consider how this measure changes over time, and evaluate the hypothesis that over time and subsequent versions of a software application, the implementations of semantically similar features converge. As the features of an application converge in their implementation, we are able to more effectively determine groups of semantically similar features and to reduce the cost of program comprehension by selecting few key features that give an overview of the system. We present a case study analyzing the features of the Jext, Firefox, and Gaim software systems to support our hypothesis.",1092-8138,0-7695-2860,10.1109/ICPC.2007.33,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268237,,Convergence;Application software;Software systems;Costs;Computer science;Educational institutions;Software measurement;Time measurement;Maintenance engineering;Text processing,configuration management;feature extraction;reverse engineering;software cost estimation;software maintenance;software metrics;software prototyping,program comprehension effort reduction;software evolution;software feature implementation convergence;call graph;software version;software refactoring,,7,12,,,,,IEEE,IEEE Conferences
Supporting program comprehension in large preprocessor-based software product lines,J. Feigenspan; M. Schulze; M. Papendieck; C. Kastner; R. Dachselt; V. Koppen; M. Frisch; G. Saake,"School of Computer Science, University of Magdeburg, Germany; School of Computer Science, University of Magdeburg, Germany; School of Computer Science, University of Magdeburg, Germany; School of Mathematic and Computer Science, Philipps University Marburg, Germany; School of Computer Science, University of Magdeburg, Germany; School of Computer Science, University of Magdeburg, Germany; School of Computer Science, University of Magdeburg, Germany; School of Computer Science, University of Magdeburg, Germany",IET Software,,2012,6,6,488,501,"Software product line (SPL) engineering provides an effective mechanism to implement variable software. However, using preprocessors to realise variability, which is typical in industry, is heavily criticised, because it often leads to obfuscated code. Using background colours to highlight code annotated with preprocessor statements to support comprehensibility has proved to be effective, however, scalability to large SPLs is questionable. The authors' aim is to implement and evaluate scalable usage of background colours for industrial-sized SPLs. They designed and implemented scalable concepts in a tool called FeatureCommander. To evaluate its effectiveness, the authors conducted a controlled experiment with a large real-world SPL with over 99'000 lines of code and 340 features. They used a within-subjects design with treatment colours and no colours. They compared correctness and response time of tasks for both treatments. For certain kinds of tasks, background colours improve program comprehension. Furthermore, the subjects generally favour background colours compared with no background colours. In addition, the subjects who worked with background colours had to use the search functions less frequently. The authors show that background colours can improve program comprehension in large SPLs. Based on these encouraging results, they continue their work on improving program comprehension in large SPLs.",1751-8806;1751-8814,,10.1049/iet-sen.2011.0172,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6353334,,,reverse engineering;software engineering,program comprehension support;preprocessor-based software product lines;SPL engineering;variable software implementation;background colours;code annotation;industrial-sized SPL;FeatureCommander tool;within-subjects design;treatment colours;no colours,,1,,,,,,IET,IET Journals
An application of fuzzy reasoning to support automated program comprehension,I. Burnstein; F. Saner,"Dept. of Comput. Sci., Illinois Inst. of Technol., Chicago, IL, USA; NA",Proceedings Seventh International Workshop on Program Comprehension,,1999,,,66,73,"We are developing a knowledge based program understanding/fault localization system called BUGDOCTOR. We describe a system knowledge source called the Plan Processor that retrieves a set of program plans from a plan library using indices called signatures. We propose use of a fuzzy reasoning component to support the Plan Processor with the task of ranking the retrieved plans in order of similarity to the target code. The most similar plan can then be used for the complex plan/code matching required for automated program understanding. Our approach to plan processing may eliminate the need for exhaustive plan library searches, and could lead to automated program understanders that scale up for use on large software systems.",1092-8138,0-7695-0180,10.1109/WPC.1999.777745,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=777745,,Fuzzy reasoning;Software libraries;Software systems;Software tools;Artificial intelligence;Debugging;Application software;Computer science;Software maintenance;Knowledge engineering,automatic programming;reverse engineering;uncertainty handling;inference mechanisms;fuzzy set theory,fuzzy reasoning;automated program comprehension;knowledge based program understanding;fault localization system;BUGDOCTOR;system knowledge source;Plan Processor;plan library;program plan retrieval;signatures;fuzzy reasoning component;target code;similar plan;complex plan/code matching;automated program understanding;large software systems,,1,17,,,,,IEEE,IEEE Conferences
Queue-based cost evaluation of mental simulation process in program comprehension,M. Nakamura; A. Monden; T. Itoh; K. Matsumoto; Y. Kanzaki; H. Satoh,"Graduate Sch. of Inf. Sci., Nara Inst. of Sci. & Technol., Japan; Graduate Sch. of Inf. Sci., Nara Inst. of Sci. & Technol., Japan; NA; NA; NA; NA",Proceedings. 5th International Workshop on Enterprise Networking and Computing in Healthcare Industry (IEEE Cat. No.03EX717),,2003,,,351,360,"We present a method to estimate the cost of mental (hand) simulation of programs. In mental simulation, human short term memory is extensively used to recall and memorize values of variables. When the simulation reaches a variable reference, the simulation can be performed easily if the value is still remembered. However, if not, we have to backtrack the simulation until the value is obtained, which is time consuming. Taking the above observation into consideration, we first present a model, called virtual mental simulation model (VMSM), which exploits a queue representing short term memory. The VMSM takes one of the abstract processes recall or backtrack, depending on whether the variable is currently stored in the queue or not. Then, applying cost functions to the VMSM, we derive four dynamic metrics reflecting the cost of mental simulation. In our empirical study, the proposed VMSM metrics reveal that the backtrack process for nonconstant variables gives a significant impact on the cost of mental simulation. Since the proposed method can be fully automated, it can provide a practical means to estimate the cost of mental simulation, which can be also used as a program comprehension measure.",1530-1435,0-7695-1987,10.1109/METRIC.2003.1232480,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1232480,,Computational modeling;Humans;Computer simulation;Cost function;Computer hacking;Information science;Programming profession;Debugging;Computer crime;Protection,reverse engineering;software metrics;backtracking,program comprehension;mental program simulation;queue-based cost evaluation;virtual mental simulation model;human short-term memory;dynamic metrics;recall process;backtrack process,,5,15,,,,,IEEE,IEEE Conferences
CheckDep: A Tool for Tracking Software Dependencies,D. Beyer; A. Fararooy,NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,42,43,"Many software developers use a syntactical `diff' in order to performa quick review before committing changes to the repository. Others are notified of the change by e-mail (containing diffs or change logs), and they review the received information to determine if their work is affected. We lift this simple process from the code level to the more abstract level of dependencies: a software developer can use CheckDep to inspect introduced and removed dependencies before committing new versions, and other developers receive summaries of the changed dependencies via e-mail. We find the tool useful in our software-development activities and now make the tool publicly available.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.51,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521774,Dependency Analysis;Software Structure;Refactoring;Program Understanding,Software tools;Visualization;Software performance;Feedback;Uniform resource locators;Concrete;Cement industry;Computer industry;Industrial control;Licenses,software engineering;software tools,CheckDep tool;software dependency tracking;e-mail;code level;software development,,2,2,,,,,IEEE,IEEE Conferences
A Simple and Effective Measure for Complex Low-Level Dependencies,D. Beyer; A. Fararooy,NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,80,83,"The measure dep-degree is a simple indicator for structural problems and complex dependencies on code-level. We model low-level dependencies between program operations as use-def graph, which is generated from reaching definitions of variables. The more dependencies a program operation has, the more different program states have to be considered and the more difficult it is to understand the operation. Dep-degree is simple to compute and interpret, flexible and scalable in its application, and independently complementing other indicators. Preliminary experiments suggest that the measure dep-degree, which simply counts the number of dependency edges in the use-def graph, is a good indicator for readability and understandablity.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.49,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521761,Software Measure;Dependency Analysis;Refactoring;Program Understanding,Software measurement;Lab-on-a-chip;Size measurement;Length measurement;Application software;Software systems;Frequency;Stability;Guidelines;Program processors,software metrics,low-level dependency measurement;dep-degree measurement;readability indicator;understandablity indicator,,5,22,,,,,IEEE,IEEE Conferences
A visualization tool for Data Structures course,Jauhar Ali,"College of Engineering and Computer Science, Abu Dhabi University, UAE",2009 2nd IEEE International Conference on Computer Science and Information Technology,,2009,,,212,216,"Data structures is a core course in almost all computer science programs. Textbooks and courses on data structures these days are programming-languages-based with those based on object-oriented programming (OOP) in dominance. In many cases, they base their pedagogy on software design patterns. However, because of heavy reliance on abstraction, they place greater demands on learners. In this study, we design and implement a visualization tool that makes it easier for students to understand object-oriented data structures.",,978-1-4244-4519-6978-1-4244-4520,10.1109/ICCSIT.2009.5234389,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5234389,visualization;data structures;program understanding;technology in education,Data visualization;Data structures;Object oriented programming;Computer science;Programming profession;Object oriented modeling;Data mining;Educational institutions;Data engineering;Software design,computer science education;data structures;data visualisation;educational courses;object-oriented programming,visualization tool;data structures course;computer science programs;programming-languages;object-oriented programming;software design patterns;object-oriented data structures,,,22,,,,,IEEE,IEEE Conferences
Towards Developing a Meta-model for Comprehending Software Adaptability,M. Amoui; S. Li; E. A. Oliveira Jr.; L. Tahvildari,NA; NA; NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,56,57,"To modernize legacy software into adaptable software, a program understanding procedure is needed to study software for identifying the mechanisms that support adaptability. Though the procedure can benefit from modeling techniques, current software meta-models do not fully support particular aspects of software adaptability. The goal of this research is to develop a meta-model, which facilitate comprehending applications for adaptability by annotating a set of pre-determined adaptability factors in software models. To this end, we investigate application-level sensing and effecting mechanisms, identify the core adaptability factors, and propose a meta-model for adaptability.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.50,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521769,program understanding;adaptability;meta-model,Object oriented modeling;Application software;Runtime;Switches;Turning;Time of arrival estimation;Mechanical factors;Flow graphs;Reflection;Computational modeling,adaptive systems;software reliability,software adaptability;software meta model;program understanding procedure,,,5,,,,,IEEE,IEEE Conferences
DepDigger: A Tool for Detecting Complex Low-Level Dependencies,D. Beyer; A. Fararooy,NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,40,41,"We present a tool that identifies complex data-flow dependencies on code-level, based on the measure dep-degree. Low-level dependencies between program operations are modeled by the use-def graph, which is generated from reaching definitions of variables. The tool annotates program operations with their dep-degree values, such that 'difficult' program operations are easy to locate. We hope that this tool helps detecting and preventing code degeneration, which is often a challenge in today's software projects, due to the high refactoring and restructuring frequency.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.52,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521777,Dependency Analysis;Software Structure;Refactoring;Program Understanding,Software tools;Tree graphs;Software maintenance;Lab-on-a-chip;Frequency measurement;Software measurement;Java;Licenses;Program processors;Optimizing compilers,data flow analysis;software tools,DepDigger tool;complex low-Level dependencies;complex data-flow dependencies;code-level;use-def graph;program operation annotation;dep-degree values;code degeneration prevention;software projects,,3,1,,,,,IEEE,IEEE Conferences
A New Standard of Choosing Slicing Criterion,Q. Zhang; Y. Su,NA; NA,2009 WRI World Congress on Software Engineering,,2009,3,,307,310,"In the development of software reverse engineering, program understanding is one of the most important steps. With the brief introductions of several program slicing technologies and their advantages and disadvantages, a new standard, used to choose slicing criterion, is proposed in this paper. By comparison with other methods, the experiment shows that the program slicing which is calculated by this new standard could help software programmer improve the efficiency, shorten cycle and reduce the complexity in the aspect of program understanding.",,978-0-7695-3570,10.1109/WCSE.2009.183,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5319415,Reverse engineering;program understanding;object-oriented;Program slicing,Programming profession;Software standards;Reverse engineering;Software engineering;Communication standards;Standards development;Debugging;Testing,program slicing;reverse engineering,software reverse engineering;program slicing technology;software programmer;program understanding,,,7,,,,,IEEE,IEEE Conferences
Visualizing the Java heap,S. P. Reiss,"Brown University, Providence, RI",2010 ACM/IEEE 32nd International Conference on Software Engineering,,2010,2,,251,254,"Many of the problems that occur in long-running systems involve the way that the system uses memory. We have developed a framework for extracting and building a model of the heap from a running Java system. Such a model is only useful if programmers can extract from it the information they need to understand, find, and eventually fix memory-related problems in their system. We demonstrate the tool in action, showing how it works dynamically on running processes and how it is designed to address a variety of specific memory issues.",1558-1225;0270-5257,978-1-60558-719,10.1145/1810295.1810344,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6062172,dynamic program understanding;memory management;object ownership;programming tools,Java;Visualization;Memory management;Software;Sun;Debugging;Programming,Java;storage management,Java heap;long-running system;memory-related problem,,1,30,,,,,IEEE,IEEE Conferences
An Eclipse Plugin for the Automated Reverse-Engineering of Software Programs,P. Dugerdil; D. Kony; J. Belmonte,NA; NA; NA,2009 Sixth International Conference on Information Technology: New Generations,,2009,,,284,289,"In the reverse engineering of a software program, one of the key difficulties is actually to understand the software. While the published techniques work top down or bottom up, our approach works middle-out: before trying to understand the low level code, we first rebuild a hypothetical analysis model from the use-cases of the system. This model then represents the target of the understanding task. In fact we try to map the code elements to the analysis objects. For this approach to be useable in large industrial software systems, it must be supported by a powerful tool. This paper presents the Eclipse plugin we developed to support our methodology, as well as a reverse engineering scenario using this tool. We then discuss the technology we used and the result we obtained.",,978-1-4244-3770-2978-0-7695-3596,10.1109/ITNG.2009.73,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5070631,reverse engineering;program understanding;unified development process;eclipse plugin,Reverse engineering;Power system modeling;Software tools;Computer industry;Documentation;Information technology;Information systems;Software systems;Engines;User interfaces,programming;reverse engineering;software engineering,Eclipse plugin;automated reverse engineering;software programs,,,21,,,,,IEEE,IEEE Conferences
Semantic clone detection using method IOE-behavior,R. Elva; G. T. Leavens,"University of Central Florida, Orlando FL, 32816; University of Central Florida, Orlando FL, 32816",2012 6th International Workshop on Software Clones (IWSC),,2012,,,80,81,"This paper presents an algorithm for the detection of semantic clones in Java methods. Semantic clones are defined as functionally-identical code fragments. Our detection process operates on the premise that if two code fragments are semantic clones, then their input-output behavior would be identical. We adopt a wholistic approach to the definition of input-output behavior by including not only the parameters and return values of methods; but also their effects, as reflected in the pre- and post-states of the heap. We refer to this as a method's IOE-behavior (input, output and effects).",,978-1-4673-1795-5978-1-4673-1794,10.1109/IWSC.2012.6227874,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227874,Software Clone Detection;Semantic Clones;Method IOE-behavior;Program Understanding,Cloning;Semantics;Syntactics;USA Councils;Java;Educational institutions;Testing,Java;program compilers;software maintenance,semantic clone detection;method IOE-behavior;Java methods;functionally-identical code fragments;input-output behavior;return values,,8,8,,,,,IEEE,IEEE Conferences
A Usability Analysis of Blocks-based Programming Editors using Cognitive Dimensions,R. Holwerda; F. Hermans,"Academy of Information Technology and Communication, HAN University of Applied Sciences, Arnhem, The Netherlands; Dept. of Software and Computer Technology, Delft University of Technology, Delft, The Netherlands",2018 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC),,2018,,,217,225,"Blocks-based programming holds potential for end-user developers. Like all visual programming languages, blocks-based programming languages embody both a language design and a user interface design for the editing environment. For blocks-based languages, these designs are focused on learnability and low error rates, which makes them effective for education. For end-user developers who program as part of their professions, other characteristics of usability, like efficiency of use, will also be important. This paper presents a usability analysis, supported by a user study, of the editor design of current blocks-based programming systems, based on the Cognitive Dimensions of Notations framework, and we present design manoeuvres aimed at improving programming time and effort, program comprehension and programmer comfort.",1943-6106;1943-6092,978-1-5386-4235-1978-1-5386-4236,10.1109/VLHCC.2018.8506483,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8506483,blocks-based languages;end-user development;programmer experience;cognitive dimensions,Programming profession;Task analysis;Usability;Tools;User interfaces;Interviews,cognition;programming languages;software tools;text editing;user interfaces;visual languages;visual programming,visual programming languages;blocks-based programming languages;language design;user interface design;blocks-based languages;low error rates;end-user developers;usability analysis;editor design;cognitive dimensions;design manoeuvres;programming time;program comprehension;blocks-based programming editors;blocks-based programming systems,,1,38,,,,,IEEE,IEEE Conferences
VisioTM: A Tool for Visualizing Source Code Based on Topic Modeling,S. Reddivari; M. S. Khan,University of North Florida; University of North Florida,2019 IEEE 43rd Annual Computer Software and Applications Conference (COMPSAC),,2019,1,,932,933,"Latent Dirichlet Allocation (LDA) is a statistical topic modeling approach that has been used to support various software engineering activities. However, the main problem is the probabilistic distributions generated by LDA to represent topics and documents are not intuitive and easy to comprehend. In order to address this problem, in this paper, we present VisioTM, a language-independent platform to visualize software systems based on LDA. VisioTM provides several visualizations to represent the basic elements of LDA including words, topics, and documents. We discuss the key features and functionalities of the tool.",0730-3157,978-1-7281-2607,10.1109/COMPSAC.2019.00147,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8754484,Software Visualization;Program Comprehension;Topic Modeling;LDA,Visualization;Tools;Computational modeling;Software engineering;Probabilistic logic;Software systems,,,,,10,,,,,IEEE,IEEE Conferences
Effective Exploration and Visualization of Large Execution Traces,A. Hamou-Lhadj,"ECE, Concordia University, 1455 Maisonneuve West, Montreal, Quebec, Canada. abdelw@ece.concordia.ca",2007 4th IEEE International Workshop on Visualizing Software for Understanding and Analysis,,2007,,,152,153,"Understanding the behaviour of a software system can be made easier if dynamic analysis techniques are used. Runtime information is typically represented in the form of execution traces. Raw traces, however, can be extremely large - often millions of lines long. In previous work, we presented a tool called SEAT (Software Exploration and Analysis Tool), which is a trace visualization tool that supports several features for rapid exploration of lengthy traces. In this paper, we present the new features supported by SEA T, namely, the ability to plug-in new trace filtering algorithms, a usable control widget called PictureTree for displaying traces, and several new views that display useful information about the trace under study.",,1-4244-0599-81-4244-0600,10.1109/VISSOF.2007.4290715,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4290715,Reverse engineering;dynamic analysis;trace analysis;program comprehension,Visualization;Filtering algorithms;Software systems;Software tools;Displays;User interfaces;Runtime;Reverse engineering;Graphical user interfaces;Navigation,program diagnostics;program visualisation,runtime information;Software Exploration and Analysis Tool;trace visualization tool;trace filtering algorithm;PictureTree,,,4,,,,,IEEE,IEEE Conferences
Clustering and recommending collections of code relevant to tasks,S. Lee; S. Kang,"Department of Computer Science, KAIST, Daejeon, Republic of Korea; Department of Computer Science, KAIST, Daejeon, Republic of Korea",2011 27th IEEE International Conference on Software Maintenance (ICSM),,2011,,,536,539,"When performing software evolution tasks, programmers spend a significant amount of time exploring the code base to find methods, fields or classes that are relevant to the task at hand. We propose a new clustering approach called NavClus to recommend collections of code relevant to tasks. By gradually aggregating navigation sequences from programmers' interaction history, NavClus clusters pieces of code that are contextually related. The resulting clusters become the basis for NavClus to recommend collections of code that are likely to be relevant to the programmer's given task. We compare NavClus and TeamTracks, the state of the art code recommender for sharing navigation data among programmers. The results show that NavClus recommends pieces of code relevant to tasks considerably better than TeamTracks.",1063-6773;1063-6773,978-1-4577-0664-6978-1-4577-0663-9978-1-4577-0662,10.1109/ICSM.2011.6080826,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6080826,program comprehension;code navigation;data clustering techniques;context aware recommendation systems,Navigation;History;Context;Productivity;Couplings;Software systems,pattern clustering;recommender systems;software maintenance;ubiquitous computing,collection clustering;collection recommendation;software evolution tasks;NavClus clusters;navigation sequences;TeamTracks;software systems;context aware recommendation systems;program comprehension;data clustering techniques,,5,13,,,,,IEEE,IEEE Conferences
Software Artefact Traceability: the Never-Ending Challenge,R. Oliveto; G. Antoniol; A. Marcus; J. Hayes,"Department of Mathematics and Informatics, University of Salerno, Fisciano, Salerno, Italy; Départment d'Informatique, École Polytechnique de Montréal, Montréal, Québec, Canada; Department of Computer Science, Wayne State University, Detroit, Michigan, USA; Department of Computer Science, University of Kentucky, Lexington, Kentucky, USA",2007 IEEE International Conference on Software Maintenance,,2007,,,485,488,"Software artefact traceability is widely recognised as an important factor for the effective development and maintenance of a software system. Unfortunately, the lack of automatic or semi-automatic supports makes the task of maintaining links among software artefacts a tedious and time consuming one. For this reason, often traceability information becomes out of date or it is completely absent during software development. In this working session, we discuss problems and challenges related to various aspects of trace-ability in software systems.",1063-6773,978-1-4244-1255-6978-1-4244-1256,10.1109/ICSM.2007.4362664,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362664,software artefact traceability;software maintenance;program comprehension;impact analysis;requirement tracing;information retrieval,Software maintenance;Programming;Software systems;Computer science;Guidelines;Mathematics;Informatics;Information analysis;Information retrieval;Documentation,software maintenance;system monitoring,software artefact traceability;software system;software development,,8,19,,,,,IEEE,IEEE Conferences
[Journal First] Does Syntax Highlighting Help Programming Novices?,C. Hannebauer; M. Hesenius; V. Gruhn,NA; NA; NA,2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE),,2018,,,704,704,"Background: Program comprehension is an important skill for programmers - extending and debugging existing source code is part of the daily routine. Syntax highlighting is one of the most common tools used to support developers in understanding algorithms. However, most research in this area originates from a time when programmers used a completely different tool chain. Objective: We examined the influence of syntax highlighting on novices' ability to comprehend source code. Additional analyses cover the influence of task type and programming experience on the code comprehension ability itself and its relation to syntax highlighting. Method: We conducted a controlled experiment with 390 undergraduate students in an introductory Java programming course. We measured the correctness with which they solved small coding tasks. Each test subject received some tasks with syntax highlighting and some without. Results: The data provided no evidence that syntax highlighting improves novices' ability to comprehend source code. Limitations: There are very few similar experiments and it is unclear as of yet which factors impact the effectiveness of syntax highlighting. One major limitation may be the types of tasks chosen for this experiment. Conclusion: The results suggest that syntax highlighting squanders a feedback channel from the IDE to the programmer that can be used more effectively.",1558-1225,978-1-4503-5638-1978-1-5386-5293,10.1145/3180155.3182554,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453142,Syntax Highlighting;Source Code Typography;Code Colouring;IDE Interface;Program Comprehension,Syntactics;Task analysis;Programming;Software engineering;Visualization;Human computer interaction;Tools,computer science education;educational courses;feedback;Java;programming;programming environments,source code;syntax highlighting squanders;programming novices;code comprehension;undergraduate students;program comprehension;Java programming course;feedback channel;IDE,,,,,,,,IEEE,IEEE Conferences
The Concept of Stratified Sampling of Execution Traces,H. Pirzadeh; S. Shanian; A. Hamou-Lhadj; A. Mehrabian,NA; NA; NA; NA,2011 IEEE 19th International Conference on Program Comprehension,,2011,,,225,226,"Execution traces can be overwhelmingly large. To reduce their size, sampling techniques, especially the ones based on random sampling, have been extensively used. Random sampling, however, may result in samples that are not representative of the original trace. We propose a trace sampling framework based on stratified sampling that not only reduces the size of a trace but also results in a sample that is representative of the original trace by ensuring that the desired characteristics of an execution are distributed similarly in both the sampled and the original trace.",1092-8138;1092-8138,978-1-61284-308-7978-0-7695-4398,10.1109/ICPC.2011.17,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970192,Trace analysis;program comprehension;sampling techniques;stratified sampling;execution phases,Phase detection;Visualization;Psychology;Conferences;Resource management;Software;Computers,program diagnostics;sampling methods,stratified sampling;execution traces;trace sampling framework,,9,12,,,,,IEEE,IEEE Conferences
DPDX--Towards a Common Result Exchange Format for Design Pattern Detection Tools,G. Kniesel; A. Binun; P. Hegedus; L. J. Fulop; A. Chatzigeorgiou; Y. Gueheneuc; N. Tsantalis,NA; NA; NA; NA; NA; NA; NA,2010 14th European Conference on Software Maintenance and Reengineering,,2010,,,232,235,"Tools for design pattern detection (DPD) can ease program comprehension, helping programmers understand the design and intention of certain parts of a system's implementation. Many tools have been proposed in the past. However, the many different output formats used by the tools make it difficult to compare their results and to improve their accuracy and performance through data fusion. In addition, all the output formats have been shown to have several limitations in both their forms and contents. Consequently, we develop DPDX, a rich common exchange format for DPD tools, to overcome previous limitations. DPDX provides the basis for an open federation of tools that perform comparison, fusion, visualisation, and-or validation of DPD results.",1534-5351,978-0-7695-4321-5978-1-61284-369,10.1109/CSMR.2010.40,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5714440,design pattern;program comprehension;exchange format,Software maintenance;Conferences;Europe;Programming;Visualization;Concrete,object-oriented methods;reverse engineering;sensor fusion;software tools,DPDX;common result exchange format;design pattern detection tools;program comprehension;data fusion;object-oriented design patterns,,3,13,,,,,IEEE,IEEE Conferences
A software behaviour analysis framework based on the human perception systems: NIER track,H. Pirzadeh; A. Hamou-Lhadj,"Concordia University, Montreal, Quebec, Canada; Concordia University, Montreal, Quebec, Canada",2011 33rd International Conference on Software Engineering (ICSE),,2011,,,948,951,"Understanding software behaviour can help in a variety of software engineering tasks if one can develop effective techniques for analyzing the information generated from a system's run. These techniques often rely on tracing. Traces, however, can be considerably large and complex to process. In this paper, we present an innovative approach for trace analysis inspired by the way the human brain and perception systems operate. The idea is to mimic the psychological processes that have been developed over the years to explain how our perception system deals with huge volume of visual data. We show how similar mechanisms can be applied to the abstraction and simplification of large traces. Some preliminary results are also presented.",1558-1225;0270-5257,978-1-4503-0445-0978-1-4503-0445,10.1145/1985793.1985955,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032559,dynamic analysis;human perception;phase detection;program comprehension;psychological processes;trace analysis,Humans;Visualization;Unified modeling language;Software;Psychology;Software engineering;Phase detection,brain;data analysis;psychology;software engineering;visual databases;visual perception,software engineering;software behaviour analysis;trace analysis;human brain;psychological process;human perception system;visual data;NIER track,,6,16,,,,,IEEE,IEEE Conferences
A Framework for Estimating Interest on Technical Debt by Monitoring Developer Activity Related to Code Comprehension,V. Singh; W. Snipes; N. A. Kraft,NA; NA; NA,2014 Sixth International Workshop on Managing Technical Debt,,2014,,,27,30,"Evaluating technical debt related to code structure at a fine-grained level of detail is feasible using static code metrics to identify troublesome areas of a software code base. However, estimating the interest payments at a similar level of detail is a manual process relying on developers to submit their estimates as they encounter instances of technical debt. We propose a framework that continuously estimates interest payments using code comprehension metrics produced by a tool that monitors developer activities in the Integrated Development Environment. We describe the framework and demonstrate how it is used to evaluate the presence of technical debt and interest payments accumulated for code in an industrial software product.",,978-1-4799-6791,10.1109/MTD.2014.16,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6974886,Technical Debt;program comprehension;static analysis;software maintenance;code metrics;code smells,Conferences,program diagnostics;software maintenance;software tools,technical debt interest estimation;developer activity monitoring;code comprehension metrics;integrated development environment;industrial software product;code maintainability;static analysis,,6,12,,,,,IEEE,IEEE Conferences
Poster: Path-Based Function Embeddings,D. DeFreez; A. Thakur; C. Rubio-González,NA; NA; NA,2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion),,2018,,,430,431,"Identifying relationships among program elements, such as functions, is useful for program understanding, debugging, and analysis. We present func2vec, an algorithm that uses static traces to embed functions in a vector space such that related functions are close together, even if they are semantically and syntactically dissimilar. We present applications of func2vec that aid program comprehension.",2574-1934,978-1-4503-5663-3978-1-5386-6479,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449611,Embeddings;Program Comprehension;Systems Software,Linux;Vocabulary;File systems;Heuristic algorithms;Kernel;Software engineering,program debugging;program diagnostics;reverse engineering,path-based function embeddings;program elements;program understanding;debugging;func2vec;static traces;vector space;program comprehension;program analysis,,,,,,,,IEEE,IEEE Conferences
Sound as an Aid in Understanding Low-Level Program Architecture,L. Berman,NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,58,59,"A tool and associated sound mapping have been developed for exploring and understanding the static structure of Java programs' packages, classes, interfaces, and methods. The tool supplements visual use of the Eclipse IDE. A sound mapping provides information regarding the identification of, characteristics of, and relationships among the architectural entities.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.55,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521766,sonification;program comprehension;auditory display;non-visual representations,Packaging;Java;Birds;Concrete;Satellites;Earth;Feedback;Pattern recognition;Computer architecture;Acoustical engineering,audio acoustics;Java;software architecture,low-level program architecture;sound mapping;Java programs;Eclipse IDE;integrated development environment,,1,2,,,,,IEEE,IEEE Conferences
Reverse Engineering PL/SQL Legacy Code: An Experience Report,M. Habringer; M. Moser; J. Pichler,NA; NA; NA,2014 IEEE International Conference on Software Maintenance and Evolution,,2014,,,553,556,"The reengineering of legacy code is a tedious endeavor. Automatic transformation of legacy code from an old technology to a new one preserves potential problems in legacy code with respect to obsolete, changed, and new business cases. On the other hand, manual analysis of legacy code without assistance of original developers is time consuming and error-prone. For the purpose of reengineering PL/SQL legacy code in the steel making domain, we developed tool support for the reverse engineering of PL/SQL code into a more abstract and comprehensive representation. This representation then serves as input for stakeholders to manually analyze legacy code, to identify obsolete and missing business cases, and, finally, to support the re-implementation of a new system. In this paper we briefly introduce the tool and present results of reverse engineering PL/SQL legacy code in the steel making domain. We show how stakeholders are supported in analyzing legacy code by means of general-purpose analysis techniques combined with domain-specific representations and conclude with some of the lessons learned.",1063-6773,978-1-4799-6146,10.1109/ICSME.2014.93,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6976137,reverse engineering;program comprehension;source code analysis,Production;Reverse engineering;Business;Databases;Flow graphs;Software;Steel,reverse engineering;software maintenance;SQL,reverse engineering PL/SQL legacy code;automatic transformation;business cases;legacy code analysis;steel making;general-purpose analysis techniques;domain specific representations,,3,6,,,,,IEEE,IEEE Conferences
Inferring Hierarchical Motifs from Execution Traces,S. Alimadadi; A. Mesbah; K. Pattabiraman,NA; NA; NA,2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE),,2018,,,776,787,"Program comprehension is a necessary step for performing many software engineering tasks. Dynamic analysis is effective in producing execution traces that assist comprehension. Traces are rich sources of information regarding the behaviour of a program. However, it is challenging to gain insight from traces due to their overwhelming amount of data and complexity. We propose a generic technique for facilitating comprehension by inferring recurring execution motifs. Inspired by bioinformatics, motifs are patterns in traces that are flexible to small changes in execution, and are captured in a hierarchical model. The hierarchical nature of the model provides an overview of the behaviour at a high-level, while preserving the execution details and intermediate levels in a structured manner. We design a visualization that allows developers to observe and interact with the model. We implement our approach in an open-source tool, called Sabalan, and evaluate it through a user experiment. The results show that using Sabalan improves developers' accuracy in performing comprehension tasks by 54%.",1558-1225,978-1-4503-5638-1978-1-5386-5293,10.1145/3180155.3180216,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453150,Program comprehension;behavioural model;hierarchical motifs,Tools;Task analysis;Electronic mail;Biological system modeling;Software engineering;Bioinformatics;Data visualization,bioinformatics;object-oriented programming;program visualisation;software engineering;software maintenance,execution traces;program comprehension;software engineering tasks;dynamic analysis;assist comprehension;execution motifs;hierarchical model;hierarchical nature;execution details;comprehension tasks;inferring hierarchical motifs,,1,,,,,,IEEE,IEEE Conferences
"Mining the Mind, Minding the Mine: Grand Challenges in Comprehension and Mining",A. Ko,NA,2018 IEEE/ACM 15th International Conference on Mining Software Repositories (MSR),,2018,,,118,118,"The program comprehension and mining software repository communities are, in practice, two separate research endeavors. One is concerned with what's happening in a developer's mind, while the other is concerned with what's happening in a team. And yet, implicit in these fields is a common goal to make better software and the common approach of influencing developer decisions. In this keynote, I provide several examples of this overlap, suggesting several grand challenges in comprehension and mining.",2574-3864;2574-3848,978-1-4503-5716-6978-1-5386-6171,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8595194,Mining software repositories;program comprehension,Data mining;Tools;Software engineering;Human computer interaction;Configuration management;Software maintenance,data mining;software maintenance,program comprehension;software repository communities mining,,,0,,,,,IEEE,IEEE Conferences
DynaRIA: A Tool for Ajax Web Application Comprehension,D. Amalfitano; A. R. Fasolino; A. Polcaro; P. Tramontana,NA; NA; NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,46,47,"Thanks to Rich Internet Applications (RIAs) with their enhanced interactivity, responsiveness and dynamicity, the user experience in the Web 2.0 is becoming more and more appealing and user-friendly. At the same time, the dynamic nature of RIAs, and the heterogeneous technologies, frameworks, communication models used for implementing them negatively affect their analyzability and understandability, so that specific software techniques and tools are needed for supporting their comprehension. This paper presents DynaRIA, a tool for the comprehension of RIAs implemented in Ajax that is based on dynamic analysis and provides functionalities for recording and analyzing user sessions from several perspectives, and producing various types of abstractions and visualizations about the run-time behaviour of the application.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.16,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521772,Rich Internet Applications;Dynamic Analysis;Program Comprehension Tool;Reverse Engineering;AJAX Application,Java;Internet;Runtime;User interfaces;Search engines;US Department of Transportation;Delay;Communications technology;Software tools;Visualization,Internet;program visualisation;software tools;user interfaces,DynaRIA;Ajax Web application comprehension;rich Internet applications;Web 2.0;heterogeneous technologies;communication models;software techniques;software tools;dynamic analysis;user sessions;run-time behaviour,,3,3,,,,,IEEE,IEEE Conferences
WB4SP: A tool to build the word base for specific programs,Weisong Sun; Xiaobing Sun; Hui Yang; Bin Li,"School of Information Engineering, Yangzhou University, China; School of Information Engineering, Yangzhou University, China; School of Information Engineering, Yangzhou University, China; School of Information Engineering, Yangzhou University, China",2016 IEEE 24th International Conference on Program Comprehension (ICPC),,2016,,,1,3,"Software becomes increasingly complex with its continuous maintenance activities. Given a system under maintenance, developers used to employing code search techniques to locate the code of their interests. However, they may have difficulties in understanding the source code elements and the relationship among them in the searching results. If there is a word base for a specific system, the developers can refer it to help locate and recover the source code elements and their relationships, which can improve the maintenance efficiency. In this paper, we present a tool, WB4SP(Word Base for Specific Programs), which focuses on building the word base for a specific system. WB4SP can retrieve the words, recover the relationship between them, and display the evolution of these words during the software evolution.",,978-1-5090-1428,10.1109/ICPC.2016.7503748,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7503748,Source code analysis;word base;program comprehension;code search,Software systems;Software engineering;Maintenance engineering;Natural language processing;Sun;Context,software maintenance;source code (software),WB4SP;word base for specific programs;software maintenance activities;code search techniques;source code elements;software evolution,,,8,,,,,IEEE,IEEE Conferences
An Analysis of Goal Orientation Pattern and Self-Efficacy for Explanation of Programming Plans,C. Tseng; P. Chao; K. R. Lai,NA; NA; NA,2015 IEEE 15th International Conference on Advanced Learning Technologies,,2015,,,76,77,"Since typical introductory programming curricula emphasize the features and syntax of a programming language, rather than the application of programming strategies, most novices are incapable of solving programming problems at the end of curricula. The difference between experts and novices is that experts can develop abstract representation of solutions, called the programming plans, for problems through the experiences obtained from past problems and solutions. The experts then use the programming plans to solve similar program problems. In this study, we develop a system to help students comprehend programming plans by explaining program codes as well as investigate the relationship between goal orientation patterns and self-efficacy.",2161-3761;2161-377X,978-1-4673-7334-0978-1-4673-7333,10.1109/ICALT.2015.93,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7265269,programming plans;program comprehension;intrinsic goal orientation;extrinsic goal orientation,Problem-solving;Programming profession;Computer science education;Syntactics,computer science education;programming,goal orientation patterns;self-efficacy;programming plans;introductory programming curricula;program comprehension,,,9,,,,,IEEE,IEEE Conferences
Towards Classification of Loop Idioms Automatically Extracted from Legacy Systems,J. Okada; T. Ishio; Y. Sakata; K. Inoue,"System Engineering HQ, NTT Data Corporation, Tokyo, Japan; Graduate School of Science and Technology, Nara Institute of Science and Technology, Nara, Japan; System Engineering HQ, NTT Data Corporation, Tokyo, Japan; Graduate School of Information Science and Technology, Osaka University, Osaka, Japan",2019 IEEE 13th International Workshop on Software Clones (IWSC),,2019,,,34,35,"Legacy systems are important in business but difficult to maintain. One of the causes of the difficulties is a large number of code clones in the systems; Those clones implement similar functionalities using common loop idioms in a company. Since the loop idioms have been developed to implement popular functionalities, most of them are likely to be translated into simple SQL statements in a new, modernized version of a system. To investigate the feasibility of the approach, we propose a method to automatically extract cloned loop idioms embedded in COBOL program files. We manually classified the extracted idioms and labeled them according to their functionalities. We evaluated the accuracy of our classification result with three experts.",2572-6587;2329-0595,978-1-7281-1805-5978-1-7281-1806,10.1109/IWSC.2019.8665854,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8665854,Legacy Migration;Reverse Engineering;Program Comprehension;Clustering;COBOL,Aging;Cloning;Dictionaries;Companies;Data mining;Software,pattern classification;program control structures;software maintenance;SQL,legacy systems;code clones;cloned loop idioms;classification;SQL statements,,,4,,,,,IEEE,IEEE Conferences
iTrace: Overcoming the Limitations of Short Code Examples in Eye Tracking Experiments,B. Sharif; J. I. Maletic,NA; NA,2016 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2016,,,647,647,"Summary form only given. Eye trackers are being used by software engineering researchers to study how developers work. In this technical briefing, we give an overview of eye tracking and how it can help researchers to conduct their own studies. Eye tracking studies are done on a single screen of text and there is no support for scrolling or switching between files. This scenario is impractical to study developers as they actually work on large software artifacts. To overcome this an Eclipse plugin, iTrace, is introduced that monitors developers eye movements even in the presence of scrolling and file switching within an IDE. In addition, it automatically maps the eye gaze to source code elements. Existing work using iTrace is presented followed by a scenario of how to setup and run an eye tracking study. Data filtering, data cleaning, and data analysis are also discussed.",,978-1-5090-3806-0978-1-5090-3807,10.1109/ICSME.2016.61,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7816534,eye tracking;program comprehension,Conferences;Software maintenance,data analysis;research and development;software engineering,iTrace;short code examples;eye tracking experiments;software engineering research;Eclipse plugin;software artifacts;source code elements;data filtering;data cleaning;data analysis,,1,,,,,,IEEE,IEEE Conferences
FireDetective: understanding ajax client/server interactions,N. Matthijssen; A. Zaidman,"Delft University of Technology, Delft, Netherlands; Delft University of Technology, Delft, Netherlands",2011 33rd International Conference on Software Engineering (ICSE),,2011,,,998,1000,"Ajax-enabled web applications are a new breed of highly interactive, highly dynamic web applications. Although Ajax allows developers to create rich web applications, Ajax applications can be difficult to comprehend and thus to maintain. FireDetective aims to facilitate the understanding of Ajax applications. It uses dynamic analysis at both the client (browser) and server side and subsequently connects both traces for further analysis.",1558-1225;0270-5257,978-1-4503-0445-0978-1-4503-0445,10.1145/1985793.1985973,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032573,ajax;dynamic analysis;program comprehension;web applications,Fires;Servers;Java;Browsers;Data visualization;Libraries;Visualization,client-server systems;Internet;system monitoring,FireDetective;Ajax client-server interaction;Ajax-enabled Web application;dynamic analysis,,2,9,,,,,IEEE,IEEE Conferences
jPET: An Automatic Test-Case Generator for Java,E. Albert; I. Cabanas; A. Flores-Montoya; M. Gomez-Zamalloa; S. Gutierrez,NA; NA; NA; NA; NA,2011 18th Working Conference on Reverse Engineering,,2011,,,441,442,"We present jPET, a white box test-case generator (TCG) which can be used during software development of Java applications within the Eclipse environment. jPET builds on top of PET, a TCG which automatically obtains test-cases from the byte code associated to a Java program. jPET performs reverse engineering of the test-cases obtained at the byte code level by PET in order to yield this information to the user at the source code level. This allows understanding the information gathered at the lower level and using it to test source Java programs.",2375-5369;1095-1350,978-1-4577-1948,10.1109/WCRE.2011.67,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079826,testing;test-case generation;program comprehension,Java;Positron emission tomography;Programming;Concrete;Testing;Software;Generators,automatic programming;Java;program testing;source coding,jPET;whitebox test case generator;software development;Eclipse environment;TCG;bytecode;Java program;reverse engineering;source code,,5,8,,,,,IEEE,IEEE Conferences
JStereoCode: automatically identifying method and class stereotypes in Java code,L. Moreno; A. Marcus,"Wayne State University, USA; Wayne State University, USA",2012 Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering,,2012,,,358,361,"Object-Oriented (OO) code stereotypes are low-level patterns that reveal the design intent of a source code artifact, such as, a method or a class. They are orthogonal to the problem domain of the software and they reflect the role of a method or class from the OO problem solving point of view. However, the research community in automated reverse engineering has focused more on higher-level design information, such as design patterns. Existing work on reverse engineering code stereotypes is scarce and focused on C++ code, while no tools are freely available as of today. We present JStereoCode, a tool that automatically identifies the stereotypes of methods and classes in Java systems. The tool is integrated with Eclipse and for a given Java project will classify each method and class in the system based on their stereotypes. Applications of JStereoCode include: program comprehension, defect prediction, etc.",,978-1-4503-1204-2978-1-4503-1204,10.1145/2351676.2351747,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6494955,Code stereotypes;Java;Program comprehension,,C++ language;Java;object-oriented programming;reverse engineering,JStereoCode;identifying method;class stereotypes;object-oriented code stereotypes;OO code stereotypes;low-level patterns;source code artifact;automated reverse engineering;design patterns;reverse engineering code stereotypes;C++ code;Java systems;Eclipse;Java project;program comprehension;defect prediction,,13,9,,,,,IEEE,IEEE Conferences
Dynamic model design recovery and architecture abstraction of object oriented software,Qingshan Li,"Software Eng. Inst., Xidian Univ., Xi'an, China",Ninth European Conference on Software Maintenance and Reengineering,,2005,,,284,287,"The paper gives an overview of a Ph.D. thesis and describes the main contents of the thesis. The thesis makes research on reverse engineering of object-oriented software at source codes level. According to the dynamic property of object-oriented software system, a group of models, mechanisms and algorithms that can be used to extract dynamic information and abstract high-level models of such systems are provided in the thesis. A group of systematic experiments are also conducted in the thesis so as to verify the correctness, validity and other related performance of these dynamic model design recovery and architecture abstraction algorithms.",1534-5351,0-7695-2304,10.1109/CSMR.2005.26,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1402144,Reverse Engineering;Design Recovery;Program Comprehension;Architecture Abstraction;Object Orientation,Object oriented modeling;Computer architecture;Instruments;Reverse engineering;Software systems;Software algorithms;Data mining;Reflection;Clustering algorithms;Algorithm design and analysis,reverse engineering;object-oriented programming;data structures;software architecture;formal verification,dynamic model;design recovery;architecture abstraction;object oriented software;reverse engineering;dynamic information,,3,,,,,,IEEE,IEEE Conferences
Teaching undergraduate software engineering,V. Rajlich,"Department of Computer Science, Wayne State University, Detroit, Michigan USA 48202",2010 IEEE International Conference on Software Maintenance,,2010,,,1,2,"During the last decade, software engineering changed rapidly, from the emphasis on waterfall lifecycle to the emphasis on software evolution and agile programming. This tutorial provides a brief introduction and overview of the results of this development. It presents agile programming, Personal and Team Software Process, software change, concept location, refactoring, and so forth. The organizing principle is an outline of an undergraduate software engineering course that is based on these results. The audience interested in this tutorial may be teachers of software engineering, and also software practitioners who want learn how these results fit together and how to apply them in software projects.",1063-6773;1063-6773,978-1-4244-8629-8978-1-4244-8630-4978-1-4244-8628,10.1109/ICSM.2010.5609587,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609587,Software evolution;program comprehension;software change;concept location;impact analysis;refactoring;agile development,,computer science education;software maintenance;software prototyping,undergraduate software engineering course;open-source project;waterfall lifecycle;software evolution;agile programming,,,13,,,,,IEEE,IEEE Conferences
Visual Support for Understanding Product Lines,J. Feigenspan; C. Kästner; M. Frisch; R. Dachselt; S. Apel,NA; NA; NA; NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,34,35,"The C preprocessor is often used in practice to implement variability in software product lines. Using #ifdef statements provokes problems such as obfuscated source code, yet they will still be used in practice at least in the medium-term future. With CIDE, we demonstrate a tool to improve understanding and maintaining code that contains #ifdef statements by visualizing them with colors and providing different views on the code.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.15,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521778,Program comprehension;Software product lines;Software visualization,Visualization;Scattering;Humans;Maintenance engineering;Software systems;Time to market;Mass customization;Printers;Microprogramming;Linux,program visualisation;software engineering;software tools;source coding,visual support;C preprocessor;#ifdef statements;software product lines;CIDE,,2,9,,,,,IEEE,IEEE Conferences
"Case Study of Feature Location Using Dependence Graph, after 10 Years",K. Chen; V. Rajlich,NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,1,3,"This retrospective briefly recapitulates the original paper that was published at IWPC 2000, overviews selected papers that were published in its wake, presents recent clarifications and updates of the topic, and mentions the still unfinished agenda and future work.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.40,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521782,Software evolution;program comprehension;dependency analysis;concept location,Cross layer design;Programming profession;Computer science;USA Councils;Inspection,software engineering,feature location;dependence graph;IWPC 2000,,5,21,,,,,IEEE,IEEE Conferences
Toward Comprehension of Side Effects in Framework Applications as Feature Interactions,I. Kume; M. Nakamura; E. Shibayama,NA; NA; NA,2012 19th Asia-Pacific Software Engineering Conference,,2012,1,,713,716,"Application frameworks are widely used in order to increase efficiency and reliability in object-oriented software development. In this paper we put a focus on side effects caused by misuse of frameworks. A processes of such a side effect often includes cross-border method invocations between an application and its framework, and is difficult to resolve. This paper proposes an approach to visualizing such a side effect as a feature interaction between a framework and its application. This paper shows a case study to apply our approach to a practical framework application, and discuss its practical usefulness.",1530-1362;1530-1362;1530-1362,978-1-4673-4930-7978-0-7695-4922,10.1109/APSEC.2012.128,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6462732,feature interactions;side effects;program comprehension,Visualization;Couplings;Receivers;Educational institutions;Software;Java;Electronic mail,object-oriented programming;reverse engineering;software reliability;software reusability,side effect comprehension;feature interaction;application framework;object-oriented software development;cross-border method;program comprehension,,3,8,,,,,IEEE,IEEE Conferences
On the Properties of Design-Relevant Classes for Design Anomaly Assessment,L. N. Vale; M. A. Maia,NA; NA,2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC),,2017,,,332,335,"Several object-oriented systems have their respective designs documented by using only a few design-relevant classes, which we will refer to as key classes. In this paper, we automatically detect key classes, and investigate some of their properties, and evaluate their role for assessing design. We propose focusing on such classes to make design decisions during maintenance tasks as those classes of this type are, by definition, more relevant than non-key classes. First, we show that key classes are more prone to bad smells than non-key classes. Although, structural metrics of key classes tend to be, in general, higher than non-key classes, there are still a significant set of non-key classes with poor structural metrics, suggesting that prioritizing design anomaly assessment using key classes would likely to be more effective.",,978-1-5386-0535-6978-1-5386-0536,10.1109/ICPC.2017.17,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961533,key classes;program comprehension;dynamic analysis;structural complexity,Measurement;Couplings;Documentation;Software design;Complexity theory;Software systems,software architecture,design anomaly assessment;design-relevant classes;object-oriented systems;maintenance tasks;design decisions;non-key classes;key classes;structural metrics,,,12,,,,,IEEE,IEEE Conferences
A Systematic Analysis of Software Architecture Visualization Techniques,Z. Sharafi,NA,2011 IEEE 19th International Conference on Program Comprehension,,2011,,,254,257,"The visualization of software systems allows a software developer to build a mental model of the program supporting her to better understand its design and functionality. This research aims at studying current visualization techniques and practices to propose a set of principles for designing effective software architecture visualization techniques, focusing on their support for program comprehension. The research will be carried out in three main phases. First, we will complement current works by proposing a taxonomy of visualization techniques. The second contribution will be to identify different requirements and characteristics of architecture visualization techniques. Finally, to evaluate software visualization's usability and effectiveness in practice, we will measure the performance of developers in terms of their percentage of the correct answers and effort developers spend to answer given questions. To compute the developer's effort, we will use eye-tracker's data.",1092-8138;1092-8138,978-1-61284-308-7978-0-7695-4398,10.1109/ICPC.2011.40,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970175,Software visualization;Software architecture;program comprehension;usability;eye tracking;usability,Visualization;Usability;Software architecture;Computer architecture;Software systems;Measurement,data visualisation;reverse engineering;software architecture;software quality,systematic analysis;software architecture visualization technique;program comprehension,,3,37,,,,,IEEE,IEEE Conferences
CodeTopics: which topic am I coding now?,M. Gethers; T. Savage; M. Di Penta; R. Oliveto; D. Poshyvanyk; A. De Lucia,"College of William and Mary, Williamsburg, VA, USA; Carnegie Mellon University, Pittsburgh, PA, USA; University of Sannio, Benevento, Italy; University of Molise, Pesche, Italy; College of William and Mary, Williamsburg, VA, USA; University of Salerno, Fisciano, Italy",2011 33rd International Conference on Software Engineering (ICSE),,2011,,,1034,1036,"Recent studies indicated that showing the similarity between the source code being developed and related high-level artifacts (HLAs), such as requirements, helps developers improve the quality of source code identifiers. In this paper, we present CodeTopics, an Eclipse plug-in that in addition to showing the similarity between source code and HLAs also highlights to what extent the code under development covers topics described in HLAs. Such views complement information derived by showing only the similarity between source code and HLAs helping (i) developers to identify functionality that are not implemented yet or (ii) newcomers to comprehend source code artifacts by showing them the topics that these artifacts relate to.",1558-1225;0270-5257,978-1-4503-0445-0978-1-4503-0445,10.1145/1985793.1985988,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032585,program comprehension;source code lexicon;traceability,Educational institutions;Object oriented modeling;Software;Games;Information retrieval;Java;Monopoly,reverse engineering;software quality;software tools,CodeTopics;high-level artifacts;source code identifier quality;Eclipse plug-in;source code artifacts comprehension,,11,9,,,,,IEEE,IEEE Conferences
Interactive Model Mining from Embedded Legacy Software,W. Said,NA,2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion),,2018,,,484,487,"Model mining from software systems can be very helpful for program comprehension. The few existing approaches for extracting high level models from code - when applied to real-world systems written in C - deliver too detailed and complex models that cannot be understood by humans. In my Ph.D. project, I propose an approach that complements fully-automatic model mining approaches with user interaction to get understandable models. The evaluation of this approach includes a controlled experiment with a large number of experts, in order to assess the effectiveness of the interactively mined models for understanding complex legacy software.",2574-1934,978-1-4503-5663-3978-1-5386-6479,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449633,model mining;state machines;software analysis;program comprehension;reverse engineering;embedded software,Object oriented modeling;Data mining;Software;Adaptation models;Static analysis;Tools;Analytical models,data mining;embedded systems;software maintenance,fully-automatic model mining approaches;user interaction;interactively mined models;complex legacy software;interactive model mining;embedded legacy software;software systems;program comprehension,,,,,,,,IEEE,IEEE Conferences
Toward Automatic Summarization of Arbitrary Java Statements for Novice Programmers,M. Hassan; E. Hill,NA; NA,2018 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2018,,,539,543,"Novice programmers sometimes need to understand code written by others. Unfortunately, most software projects lack comments suitable for novices. The lack of comments have been addressed through automated techniques of generating comments based on program statements. However, these techniques lacked the context of how these statements function since they were aimed toward experienced programmers. In this paper, we present a novel technique towards automatically generating comments for Java statements suitable for novice programmers. Our technique not only goes beyond existing approaches to method summarization to meet the needs of novices, it also leverages API documentation when available. In an experimental study of 30 computer science undergraduate students, we observed explanations based on our technique to be preferred over an existing approach.",2576-3148;1063-6773,978-1-5386-7870-1978-1-5386-7871,10.1109/ICSME.2018.00063,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530061,Java;Automatic Summarization;Novice Program Comprehension,Documentation;Java;Computer bugs;Current measurement;Switches;Conferences;Software maintenance,application program interfaces;Java;software engineering,program statements;experienced programmers;generating comments;novice programmers;toward automatic summarization;arbitrary Java statements;automated techniques,,,20,,,,,IEEE,IEEE Conferences
FLAT3: feature location and textual tracing tool,T. Savage; M. Revelle; D. Poshyvanyk,"College of William and Mary, Williamsburg, VA; College of William and Mary, Williamsburg, VA; College of William and Mary, Williamsburg, VA",2010 ACM/IEEE 32nd International Conference on Software Engineering,,2010,2,,255,258,"Feature location is the process of finding the source code that implements a functional requirement of a software system. It plays an important role in software maintenance activities, but when it is performed manually, it can be challenging and time-consuming, especially for large, long-lived systems. This paper describes a tool called FLAT<sup>3</sup> that integrates textual and dynamic feature location techniques along with feature annotation capabilities and a useful visualization technique, providing a complete suite of tools that allows developers to quickly and easily locate the code that implements a feature and then save these annotations for future use.",1558-1225;0270-5257,978-1-60558-719,10.1145/1810295.1810345,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6062173,concept location;dynamic analysis;information retrieval;program comprehension;software evolution and maintenance,Visualization;Information retrieval;Software engineering;Software maintenance;Libraries;Computer science,formal specification;software maintenance;software tools,textual tracing tool;source code;functional requirement;software system;software maintenance;FLAT3 tool;dynamic feature location;feature annotation capability;visualization technique,,15,20,,,,,IEEE,IEEE Conferences
MetricAttitude++: Enhancing Polymetric Views with Information Retrieval,R. Francese; M. Risi; G. Tortora,NA; NA; NA,2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC),,2017,,,368,371,"MetricAttitude is a visualization tool based on static analysis that provides a mental picture by viewing an object-oriented software by means of polymetric views. In this tool demonstration paper, we integrate an information retrieval engine in MetricAttitude and name this new version as MetricAttitude++. This new tool allows the software engineer to formulate free-form textual queries and shows results on the polymetric views. In particular, MetricAttitude++ shows on the visual representation of a subject software the elements that are more similar to that query. The navigation among elements of interest can be then driven by the polymetric views of the depicted elements and/or reformulating the query and applying customizable filters on the software view. Due to its peculiarities, MetricAttitude++ can be applicable to many kinds of software maintenance and evolution tasks (e.g., concept location and program comprehension).",,978-1-5386-0535-6978-1-5386-0536,10.1109/ICPC.2017.15,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961539,Program Comprehension;Reverse Engineering;Software Visualization;Information Retrieval,Software;Visualization;Java;Tools;Engines;Software metrics,object-oriented methods;program diagnostics;program visualisation;query processing;software maintenance,MetricAttitude++;polymetric views enhancement;information retrieval engine;visualization tool;static analysis;object-oriented software;free-form textual queries;customizable filters;software maintenance task;software evolution task;concept location;program comprehension,,,16,,,,,IEEE,IEEE Conferences
Dynamic Analysis of SQL Statements for Data-Intensive Applications Reverse Engineering,A. Cleve; J. Hainaut,NA; NA,2008 15th Working Conference on Reverse Engineering,,2008,,,192,196,"Analyzing SQL statements brings invaluable information that can be used in various applications such as program understanding and database reverse engineering. While static SQL statements are fairly easy to analyze, dynamic SQL statements most often require dynamic analysis techniques that may prove more difficult to implement. This paper addresses the problem of dynamic SQL query analysis in the context of software and database reverse engineering. It explores the use of dynamic analysis techniques such as aspect-based tracing and SQL trace analysis for extracting implicit information about both the program behavior and the database structure.",1095-1350;2375-5369,978-0-7695-3429,10.1109/WCRE.2008.38,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656409,Dynamic analysis;SQL;aspects;data reverse engineering;program comprehension,Reverse engineering;Databases;Data mining;Cities and towns;Software;Relational databases;Time factors,information retrieval;query processing;reverse engineering;SQL,SQL statements;database reverse engineering;dynamic analysis techniques;dynamic SQL query analysis;software reverse engineering;aspect-based tracing;SQL trace analysis,,13,12,,,,,IEEE,IEEE Conferences
Requirements guided dynamic software clustering,Wei Zhao; Lu Zhang; Hong Mei; Jiasu Sun,"Inst. of Software, Peking Univ., Beijing, China; Inst. of Software, Peking Univ., Beijing, China; Inst. of Software, Peking Univ., Beijing, China; Inst. of Software, Peking Univ., Beijing, China",21st IEEE International Conference on Software Maintenance (ICSM'05),,2005,,,605,608,"In this paper, we propose a requirements guided dynamic approach to address software clustering -which aims at providing the logically meaningful and high-level decompositions of large and complex systems. In our approach, the hierarchical structure of functional requirements are constructed by a text document clustering technique named hierarchical agglomerative clustering (HAC) as a high-level skeleton to facilitate the further decomposition of source code through dynamic analysis. We also perform an experimental study based on a GNU system and present the quantitative and qualitative analysis of the experimental results.",1063-6773,0-7695-2368,10.1109/ICSM.2005.76,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510155,software clustering;hierarchical agglomerative clustering;program comprehension,Software maintenance;Skeleton;Sun;Computer science;Performance analysis;Software systems;Collaboration;Software performance;Merging;Software measurement,text analysis;formal specification,requirements guided dynamic software clustering;text document clustering technique;hierarchical agglomerative clustering;source code;dynamic analysis;quantitative analysis;qualitative analysis,,,19,,,,,IEEE,IEEE Conferences
Inventive Tool Use to Comprehend Big Code,S. Ratanotayanon; S. E. Sim,"University of California, Irvine; University of California, Irvine",IEEE Software,,2008,25,5,91,92,"Software developers often need to understand a large body of unfamiliar code with little or no documentation, no experts to consult, and little time to do it. A post appeared in January 2008 on Slashdot, a technology news Web site, asking for tools and techniques that could help. This article analyzes 301 often passionate and sometimes articulate responses to this query, including the themes and the associated tool recommendations. The most common suggestions were to use a code navigation tool, use a design recovery tool, use a debugger to step through the code, create a runtime trace, use problem-based learning, ask people for help, study the code from top down, and print out all the code. This analysis presents an intriguing snapshot of how software developers in industry go about comprehending big code.",0740-7459;1937-4194,,10.1109/MS.2008.118,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4602681,software maintenance;program comprehension;navigation and visualization tools,Programming profession;Runtime;Unified modeling language;Application software;Software libraries;Printing;Navigation;Testing,,,,1,2,,,,,IEEE,IEEE Magazines
"Locating and Understanding Features of Complex Software Systems by Synchronizing Time-, Collaboration- and Code-Focused Views on Execution Traces",J. Bohnet; S. Voigt; J. Doellner,NA; NA; NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,268,271,"Extending or modifying features of complex software systems is often a highly time-consuming and cost-intensive task as, beforehand, the features have to be located within the code and to be understood in detail. To support developers in performing this task, we propose a technique that takes execution traces and implementation unit structuring as input data and provides various views thereupon. Views focus on different trace characteristics, namely they are time-, collaboration-, and code-focused. Synchronizing the views creates a rich user interface that helps developers to effectively identify and understand feature relevant parts of the implementation.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.21,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556142,Software Visualization;Program Comprehension;Feature Location;Feature Comprehension;Reverse Engineering;Dynamic Analysis;Maintenance,Software systems;Collaborative software;User interfaces;Data mining;International collaboration;Information analysis;Control systems;Phase detection;Visualization;Software prototyping,software engineering;user interfaces,complex software systems;code-focused views;execution traces;unit structuring;trace characteristics;user interface,,9,14,,,,,IEEE,IEEE Conferences
COSS: Comprehension by ontologising software system,H. Zhou,"Software Technology Research Laboratory, De Montfort University, Leicester, UK",2008 IEEE International Conference on Software Maintenance,,2008,,,432,435,"Ontology has been investigated in the context of knowledge representation among heterogeneous and disparate knowledge base systems. Our study and experiments suggest that ontology also has a great potential for program comprehension. The main idea is to extract the ontological perspective of existing software system, which is a combination of two kinds of ontology: domain ontology and source code ontology. Domain ontology is domain vocabulary which is built by domain experts, while source code ontology is automatically populated from source code, which represents the knowledge in the existing software. Combining these two ontologies will generate a third ontology, application specific ontology, which is used in program comprehension.",1063-6773,978-1-4244-2613-3978-1-4244-2614,10.1109/ICSM.2008.4658097,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4658097,Program Comprehension;Domain knowledge;Source Code;Concepts;Properties;Relations,Ontologies;Software;Software systems;Software algorithms;Knowledge based systems;Documentation;Knowledge representation,ontologies (artificial intelligence);reverse engineering;software maintenance,comprehension by ontologising software system;knowledge representation;knowledge base systems;program comprehension;domain ontology;source code ontology;domain vocabulary;software maintenance,,1,10,,,,,IEEE,IEEE Conferences
Measuring the Impact of Code Dependencies on Software Architecture Recovery Techniques,T. Lutellier; D. Chollak; J. Garcia; L. Tan; D. Rayside; N. Medvidović; R. Kroeger,"University of Waterloo, Waterloo, ON, Canada; University of Waterloo, Waterloo, ON, Canada; University of California, Irvine, CA; University of Waterloo, Waterloo, ON, Canada; University of Waterloo, Waterloo, ON, Canada; University of Southern California, Los Angeles, CA; Google Inc., Mountain View, CA",IEEE Transactions on Software Engineering,,2018,44,2,159,181,"Many techniques have been proposed to automatically recover software architectures from software implementations. A thorough comparison among the recovery techniques is needed to understand their effectiveness and applicability. This study improves on previous studies in two ways. First, we study the impact of leveraging accurate symbol dependencies on the accuracy of architecture recovery techniques. In addition, we evaluate other factors of the input dependencies such as the level of granularity and the dynamic-bindings graph construction. Second, we recovered the architecture of a large system, Chromium, that was not available previously. Obtaining the ground-truth architecture of Chromium involved two years of collaboration with its developers. As part of this work, we developed a new submodule-based technique to recover preliminary versions of ground-truth architectures. The results of our evaluation of nine architecture recovery techniques and their variants suggest that (1) using accurate symbol dependencies has a major influence on recovery quality, and (2) more accurate recovery techniques are needed. Our results show that some of the studied architecture recovery techniques scale to very large systems, whereas others do not.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2017.2671865,"Natural Sciences and Engineering Research Council of Canada; Google Faculty Research Award; Ontario Ministry of Research and Innovation; U.S. National Science Foundation; Infosys Technologies, Ltd.; ",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7859416,Software architecture;empirical software engineering;maintenance and evolution;program comprehension,Computer architecture;Software architecture;Software;Heuristic algorithms;Chromium;Software algorithms;Manuals,software architecture;software quality;system recovery,symbol dependencies;accurate recovery techniques;recovery quality;submodule-based technique;ground-truth architecture;input dependencies;software implementations;software architectures;software architecture recovery techniques;code dependencies,,3,72,,,,,IEEE,IEEE Journals
On Software Odysseys and How to Prevent Them,S. Scalabrino,NA,2017 IEEE/ACM 39th International Conference on Software Engineering Companion (ICSE-C),,2017,,,91,93,"Acting on a software system developed by someone else may be difficult. Performing any kind of maintenance task requires knowledge about many parts of the system. Therefore, program comprehension plays a lead role in software maintenance, above all when new resources are added to a project. At the same time, acquiring full knowledge about big codebases can be utopian, because it requires a big effort if no sufficient documentation is provided. In this paper I present TIRESIAS, an approach able to suggest a subset of important software artifacts which are good entry points for newcomers. The suggested artifacts can be used in order to acquire knowledge about the system in an initial stage. TIRESIAS uses a knowledge graph to model the references among source code artifacts and to find (i) the artifacts that lead to acquire the widest knowledge about the system and (ii) the most important artifacts that are worth keeping in mind. The approach is validated through a case study conducted on a software system and three professional software developers.",,978-1-5386-1589-8978-1-5386-1590,10.1109/ICSE-C.2017.157,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7965266,software maintenance;program comprehension;recommender systems,Software engineering;Software systems;Measurement;Maintenance engineering;Information retrieval;Documentation,graph theory;knowledge acquisition;software maintenance;source code (software),software odysseys;software system;program comprehension;software maintenance;TIRESIAS;software artifacts;knowledge acquisition;source code artifacts;knowledge graph,,,12,,,,,IEEE,IEEE Conferences
Recovering Workflows from Functional Tests,C. Khadke; S. Rana; V. Shah,NA; NA; NA,2015 IEEE 23rd International Conference on Program Comprehension,,2015,,,287,288,"When enterprises outsource maintenance of IT systems to service providers, thorough knowledge acquisition is critical to the success of the engagement. Program comprehension contributes significantly to acquiring knowledge of the IT systems. It is a common practice to execute test scripts to identify critical scenarios in the system and then trace these as flows in the programs. Instead of executing test scripts, we propose the novel idea of mining workflows from test scripts to construct formal process models. The global view provided by the mined model can not only help transition teams gain high level understanding of the system but also help identify critical flows. We also suggest categorization of test cases using supervised learning to improve comprehension.",1092-8138,978-1-4673-8159-8978-1-4673-8158,10.1109/ICPC.2015.41,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181459,Test Script;Knowledge Acquisition;Program Comprehension;Process Mining,Navigation;Data mining;Supervised learning;Accuracy;Entropy;Maintenance engineering;Testing,data mining;information technology;knowledge acquisition;learning (artificial intelligence),workflow recovery;functional tests;enterprises outsource maintenance;IT systems;service providers;knowledge acquisition;program comprehension;mining workflows;formal process models;supervised learning,,,5,,,,,IEEE,IEEE Conferences
"SVS, BORS, SVSi: Three Strategies to Relate Problem and Program Domains",M. M. Berón; M. J. V. Pereira; N. Oliveira; D. da Cruz,NA; NA; NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,60,61,"Program Comprehension is improved if: i) the Problem and Program Domains can be related, and ii) this relation is shown in a suitable way to the programmer. Currently, there are few strategies for reaching this important goal because it is not easy to: i) Identify meaningful representations of the problem and program domains, and ii) Define a linking procedure. This poster describes three strategies to overcome the difficulties mentioned above. These strategies use static and dynamic information and traditional compilation techniques for relating both domains.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.24,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521767,Program Comprehension;Program Domain;Problem Domain;Comprehension Strategies,Programming profession;Visualization;Instruments;Monitoring;Joining processes;Software engineering;Problem-solving;Software performance;Software maintenance;Data mining,software engineering,SVS;BORS;SVSi;program comprehension;program domains;dynamic information;compilation techniques,,1,2,,,,,IEEE,IEEE Conferences
The ConAn Tool to Identify Crosscutting Concerns in Object Oriented Systems,M. L. Bernardi; G. A. Di Lucca,NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,48,49,"This paper presents the main features of ConAn, a tool supporting an approach to find scattered and tangled class members in OO systems and to group them in concerns. The recovered information is useful for refactoring/migration tasks, such as towards Aspect Oriented Programming (AOP).",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.34,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521773,Aspect Oriented Programming;Program Comprehension;Reverse Engineering,Scattering;Performance analysis;Symmetric matrices;Java;Data mining;Genetic programming;Encapsulation;Helium;Inspection,aspect-oriented programming;software tools,ConAn tool;OO systems;object-oriented systems;aspect oriented programming;refactoring task;migration tasks;crosscutting concern identification,,1,2,,,,,IEEE,IEEE Conferences
Blaze,J. Krämer; J. Kurz; T. Karrer; J. Borchers,"RWTH Aachen University 52062 Aachen, Germany; RWTH Aachen University 52062 Aachen, Germany; RWTH Aachen University 52062 Aachen, Germany; RWTH Aachen University 52062 Aachen, Germany",2012 34th International Conference on Software Engineering (ICSE),,2012,,,1457,1458,"Understanding source code is crucial for successful software maintenance. To understand source code, navigation in the call graph has been shown to be particularly important. Programmers often employ a two-phased strategy for effective call graph exploration. We present Blaze, a source code exploration tool designed to explicitly support this strategy. In a study, we show that call graph exploration tools significantly increase success rates in typical software maintenance tasks and that using Blaze significantly reduces task completion times compared to using the Call Hierarchy or Xcode.",1558-1225;0270-5257;0270-5257,978-1-4673-1067-3978-1-4673-1066-6978-1-4673-1065,10.1109/ICSE.2012.6227066,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227066,Tools and environments;Software visualization;Program comprehension,Navigation;Software maintenance;Visualization;Maintenance engineering;Educational institutions;Computer bugs,reverse engineering;software maintenance,software maintenance;source code understanding;call graph exploration;source code exploration tool;call hierarchy;Blaze;Xcode;two-phased strategy,,,10,,,,,IEEE,IEEE Conferences
Do You Remember This Source Code?,J. Krüger; J. Wiemann; W. Fenske; G. Saake; T. Leich,NA; NA; NA; NA; NA,2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE),,2018,,,764,775,"Being familiar with the source code of a program comprises knowledge about its purpose, structure, and details. Consequently, familiarity is an important factor in many contexts of software development, especially for maintenance and program comprehension. As a result, familiarity is considered to some extent in many different approaches, for example, to model costs or to identify experts. Still, all approaches we are aware of require a manual assessment of familiarity and empirical analyses of forgetting in software development are missing. In this paper, we address this issue with an empirical study that we conducted with 60 open-source developers. We used a survey to receive information on the developers' familiarity and analyze the responses based on data we extract from their used version control systems. The results show that forgetting is an important factor when considering familiarity and program comprehension of developers. We find that a forgetting curve is partly applicable for software development, investigate three factors - the number of edits, ratio of owned code, and tracking behavior - that can impact familiarity with code, and derive a general memory strength for our participants. Our findings can be used to scope approaches that have to consider familiarity and they provide insights into forgetting in the context of software development.",1558-1225,978-1-4503-5638-1978-1-5386-5293,10.1145/3180155.3180215,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453149,familiarity;forgetting;empirical study;maintenance;program comprehension;expert identification;knowledge management,Software;Software engineering;Task analysis;Maintenance engineering;Psychology;Software reliability,configuration management;software development management;software maintenance,source code;software development;owned code;open-source developers,,,,,,,,IEEE,IEEE Conferences
Robot ON!: A Serious Game for Improving Programming Comprehension,M. A. Miljanovic; J. S. Bradbury,NA; NA,2016 IEEE/ACM 5th International Workshop on Games and Software Engineering (GAS),,2016,,,33,36,"A number of educational games have been created to help students programming. Many of these games focus on problem solving and the actual act of writing programs, while very few focus on programming comprehension. We introduce a serious game called Robot ON! aimed at players who have never programmed before. Unlike other serious programming games, Robot ON! focuses on comprehension rather than problem-solving challenges; players do not actually write any programs, but are instead given the task of demonstrating their knowledge and understanding of a program's behavior. Robot ON! includes tools that allow players to demonstrate understanding of variable values, data types, program statements, and control flow. We include an evaluation plan to assess Robot ON!'s playability, enjoyment, and benefits to program comprehension.",,978-1-4503-4160-8978-1-5090-2203,10.1109/GAS.2016.014,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7809514,programming;software engineering;computer science;education;serious games;game-based learning;code walkthrough;code review;program comprehension,Games;Programming profession;Educational robots;Writing,computer aided instruction;computer science education;serious games (computing);software engineering,serious game;Robot ON!;programming comprehension;educational games;student programming;writing programs;program statements,,,12,,,,,IEEE,IEEE Conferences
A business process explorer,J. Guo; K. Foo; L. Barbour; Y. Zou,"Queens University, Kingston, Ontario, Canada; Queens University, Kingston, Ontario, Canada; Queens University, Kingston, Ontario, Canada; Queens University, Kingston, Ontario, Canada",2008 ACM/IEEE 30th International Conference on Software Engineering,,2008,,,871,874,"A business process is composed of a set of interrelated tasks which are joined together by control flow elements. E-commerce systems implement business processes to automate the daily operations of an organization. Organizations must continuously modify their e-commerce systems to accommodate changes to business processes. However, modifying e-commerce systems is a time consuming and error prone task. To correctly perform this task, developers require an in-depth understanding of multi-tiered e-commerce systems and the business processes that they implement. In this paper, we present a business process explorer tool which automatically recovers business processes from three tier e-commerce systems. Developers can explore the recovered business processes and browse the corresponding source code. We integrate our tool with IBM WebSphere Business Modeler (WBM), a leading commercial tool for business process management and modeling. Business analysts could then visualize and analyze the recovered processes using WBM. The business process explorer eases the co-evolution of business processes and their e-commerce system implementation.",0270-5257;1558-1225,978-1-4244-4486-1978-1-60558-079,10.1145/1368088.1368227,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4814213,business process;e-commerce;process recovery;program comprehension,Visualization;Documentation;Databases;Books;Automatic control;Electronic commerce;Business communication;Cost function;Merging;User interfaces,business data processing;electronic commerce,e-commerce business processes;control flow elements;multitiered e-commerce systems;business process explorer tool;source code;IBM WebSphere Business Modeler;business process management;business process modeling,,,7,,,,,IEEE,IEEE Conferences
On the Effect of the Query in IR-based Concept Location,S. Haiduc; A. Marcus,NA; NA,2011 IEEE 19th International Conference on Program Comprehension,,2011,,,234,237,"Concept location is an essential task during software maintenance and in particular program comprehension activities. One of the approaches to this task is the based on leveraging the lexical information found in the source code by means of Information Retrieval techniques. All IR-based approaches to concept location are highly dependent on the queries written by the users. An IR approach, even though good on average, might fail when the input query is poor. Currently there is no way to tell when a query leads to poor results for IR-based concept location, unless a considerable effort is put into analyzing the results after the fact. We propose an approach based on recent advances in the field of IR research, which aims at automatically determining the difficulty a query poses to an IR-based concept location technique. We plan to evaluate several models and relate them to IR performance metrics.",1092-8138;1092-8138,978-1-61284-308-7978-0-7695-4398,10.1109/ICPC.2011.48,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970170,program comprehension;concept location;search;source code;information retrieval;query,Prediction algorithms;Correlation;Conferences;Estimation;Measurement;Search engines,query processing;software maintenance;software metrics;software performance evaluation,IR-based concept location;software maintenance;program comprehension activity;lexical information;source code;information retrieval techniques;IR performance metrics,,11,16,,,,,IEEE,IEEE Conferences
Locating features in dynamically configured avionics software,M. Ouellet; E. Merlo; N. Sozen; M. Gagnon,"Computer and Software Engineering Department, École Polytechnique de Montréal, Montréal, Canada; Computer and Software Engineering Department, École Polytechnique de Montréal, Montréal, Canada; CMC Electronics inc. Saint-Laurent, Canada; CMC Electronics inc. Saint-Laurent, Canada",2012 34th International Conference on Software Engineering (ICSE),,2012,,,1453,1454,"Locating features in software is an important activity for program comprehension and to support software reengineering. We present a novel automated approach to locate features in source code based on static analysis and model checking. The technique is aimed at dynamically configured software, which is software in which the activation of specific features is controlled by configuration variables. The approach is evaluated on an industrial avionics system.",1558-1225;0270-5257;0270-5257,978-1-4673-1067-3978-1-4673-1066-6978-1-4673-1065,10.1109/ICSE.2012.6227068,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227068,Feature;Feature Location;Feature Mapping;Reengineering;Program Comprehension,Software;Aerospace electronics;Analytical models;Security;Aircraft;Information retrieval;Feature extraction,avionics;formal verification;program diagnostics;systems re-engineering,feature location;program comprehension;software reengineering;source code;static analysis;model checking;configuration variables;industrial avionics system,,,8,,,,,IEEE,IEEE Conferences
Towards Automatic Generation of Short Summaries of Commits,S. Jiang; C. McMillan,NA; NA,2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC),,2017,,,320,323,"Committing to a version control system means submitting a software change to the system. Each commit can have a message to describe the submission. Several approaches have been proposed to automatically generate the content of such messages. However, the quality of the automatically generated messages falls far short of what humans write. In studying the differences between auto-generated and human-written messages, we found that 82% of the human-written messages have only one sentence, while the automatically generated messages often have multiple lines. Furthermore, we found that the commit messages often begin with a verb followed by an direct object. This finding inspired us to use a ""verb+object"" format in this paper to generate short commit summaries. We split the approach into two parts: verb generation and object generation. As our first try, we trained a classifier to classify a diff to a verb. We are seeking feedback from the community before we continue to work on generating direct objects for the commits.",,978-1-5386-0535-6978-1-5386-0536,10.1109/ICPC.2017.12,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961530,program comprehension;commit log;commit message;version control system;code differencing;natural language processing,Data analysis;Software;Grammar;Syntactics;Histograms;Control systems;Training,configuration management;pattern classification,automatic generation;short commit summaries;version control system;software change;message content;auto-generated message;human-written message;classifier training,,3,14,,,,,IEEE,IEEE Conferences
Visualization Techniques for Effective Software Comprehend,E. Aldahari,NA,2016 International Conference on Computational Science and Computational Intelligence (CSCI),,2016,,,1355,1359,"Program comprehension procedure have been attracted a lot of attentions and have been investigated using a variant methodologies such as thinking aloud, summary analysis, and Eye-tracking. Program comprehension tools main objective is understanding source code which is substantial factor in software maintenance activities. Visualization is a popular approach in earning this understanding. This paper present a comprehend analysis of concepts and techniques that have been used in building the visualization tools. Then we display a thorough comparison between two widely visualization tools which are SHriMP and LEONARDO.",,978-1-5090-5510-4978-1-5090-5511,10.1109/CSCI.2016.0253,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7881546,Program comprehension;visualization;SHriMP;LEONARDO,Data visualization;Software;Switches;Programming profession;Image color analysis;Context,program visualisation;reverse engineering;software maintenance;source code (software),visualization techniques;software comprehend;program comprehension procedure;variant methodologies;source code;software maintenance activities;SHriMP;LEONARDO,,,8,,,,,IEEE,IEEE Conferences
A Data Set of Program Invariants and Error Paths,D. Beyer,LMU Munich,2019 IEEE/ACM 16th International Conference on Mining Software Repositories (MSR),,2019,,,111,115,"The analysis of correctness proofs and counterexamples of program source code is an important way to gain insights into methods that could make it easier in the future to find invariants to prove a program correct or to find bugs. The availability of high-quality data is often a limiting factor for researchers who want to study real program invariants and real bugs. The described data set provides a large collection of concrete verification results, which can be used in research projects as data source or for evaluation purposes. Each result is made available as verification witness, which represents either program invariants that were used to prove the program correct (correctness witness) or an error path to replay the actual bug (violation witness). The verification results are taken from actual verification runs on 10522 verification problems, using the 31 verification tools that participated in the 8th edition of the International Competition on Software Verification (SV-COMP). The collection contains a total of 125720 verification witnesses together with various meta data and a map to relate a witness to the C program that it originates from. Data set is available at: https://doi.org/10.5281/zenodo.2559175",2574-3864;2574-3848,978-1-7281-3412-3978-1-7281-3370,10.1109/MSR.2019.00026,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8816801,"Invariant Mining, Program Comprehension, Formal Verification, Model Checking, Program Analysis, Verification Witnesses, Program Invariants, Error Paths, Bugs",,,,,,43,,,,,IEEE,IEEE Conferences
Work in progress - evolution of code reusing practices during a sequence of three CS courses,O. Clua; M. Feldgen; R. Wachenchauzer,"Universidad de Buenos Aires, Facultad de Ingeniería, Argentina; Universidad de Buenos Aires, Facultad de Ingeniería, Argentina; Universidad de Buenos Aires, Facultad de Ingeniería, Argentina","2007 37th Annual Frontiers In Education Conference - Global Engineering: Knowledge Without Borders, Opportunities Without Passports",,2007,,,F2J-3,F2J-4,"A certain amount of reuse practices are embedded in the CS courses. Some languages have also incorporated reuse as part of their design. We had the opportunity of teaching a group of students in three sequential programming courses ranging from the first notions (imperative programming) to a medium sized programming project in the third course (Java). During the three courses, different kinds and amounts of reuse were required from students, such as stepwise refinement of instructor's code and the use of design patterns. In this work in progress we present the first results of revisiting the code production of a group of students from the reuse point of view. We linked the reuse quality of students practice to some program comprehension parameters.",0190-5848;2377-634X,978-1-4244-1083-5978-1-4244-1084,10.1109/FIE.2007.4417922,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4417922,software reuse;CS education;reuse practices;program comprehension,Object oriented modeling;Programming profession;Educational programs;Object oriented programming;Microstructure;Problem-solving;Education;Java;Production;Educational products,computer science education;educational courses;programming languages;software reusability,code reusing practices;CS courses;teaching;sequential programming courses;medium sized programming project;stepwise refinement;code production,,,15,,,,,IEEE,IEEE Conferences
Novice comprehension of Object-Oriented OO programs: An empirical study,A. S. Alardawi; A. M. Agil,"The College of Computer Technology, Tripoli-Libya; The College of Computer Technology, Tripoli-Libya",2015 World Congress on Information Technology and Computer Applications (WCITCA),,2015,,,1,4,"Class structure represents one of the essential concepts of Object-Oriented paradigm and therefore, a good understanding of this concept will positively affect the effectiveness of novice programmers. Comprehension underpins many programming activities such as program design and program implementation. Program comprehension represents in this context a mental model approach that involves interesting theoretical frameworks of program comprehension. Our starting point is Burkhardt cognitive model for OO program comprehension [1]. The model considers two distinct but interacting models: program and situation. Our focus does not rely primarily in distinguishing between these models, but use both of them to assess the influence on novices of class structure on program comprehension. We report on an empirical study that aims of to investigate the effect of class structure on program comprehension for novices using controlled experimentation in which the treatments were a simple program without class structure versus the same program with classes present; they are termed respectively as: Non-Class based program and as Class based program. Data was collected from three different sets of experiments comprising of a total of 211 undergraduate first year computer science students from different institutions. Preliminary findings of this investigation are reported, in particular results indicate that Class based programs were more understandable, readable, and accessible than the corresponding Non-Class based programs. Our findings align with and support those works that claim the cognitive benefits of the OO paradigm. Directions for future research are highlighted.",,978-1-4673-6636-6978-1-4673-6635,10.1109/WCITCA.2015.7367057,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7367057,empirical study;program comprehension;class structure;mental model,Object oriented modeling;Encapsulation;Cognitive science;Software;Programming profession;Object recognition,computer science education;object-oriented programming,object-oriented program comprehension;OO program comprehension;class structure;novice programmers;mental model approach;Burkhardt cognitive model;program model;situation model;nonclass based program;class based programs,,1,21,,,,,IEEE,IEEE Conferences
Extending Bug Localization Using Information Retrieval and Code Clone Location Techniques,M. Beard,NA,2011 18th Working Conference on Reverse Engineering,,2011,,,425,428,"Bug localization involves the use of information about a bug to assist in locating sections of code that must be modified to fix the bug. Such a task can involve a considerable amount of time and effort on the part of software developers and/or maintainers. Recently, several automated bug localization techniques based on information retrieval (IR) models have been developed to speed the process of bug localization. Another code analysis technique involves locating duplicated sections of code in software projects, called code clones. We examine the application of code clone location techniques in the context of bug localization. We attempt to determine the advantages of extending existing code clone location techniques through the inclusion of IR models in the analysis process. We also examine a technique for extending the use of bug logging repositories and version control systems by analyzing the two using IR techniques.",2375-5369;1095-1350,978-1-4577-1948,10.1109/WCRE.2011.61,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079872,code clones;bugzilla;bug repository;program comprehension;feature identification;concept location;static analysis;information retrieval;concurrent versions system,Cloning;Software;Computer bugs;Semantics;Information retrieval;Context;Joining processes,information retrieval;program debugging;software engineering,bug localization;information retrieval;code clone location techniques;code analysis technique;software projects;IR models,,,16,,,,,IEEE,IEEE Conferences
Introducing Parameter Sensitivity to Dynamic Code-Clone Analysis Methods,T. Kamiya,NA,"2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)",,2016,3,,19,20,"This paper presents topics introducing ""parameter sensitivity"" in a dynamic code-clone detection. First, this paper briefly describes a dynamic code-clone detection method andpossible implementation of parameter sensitivity in the method. Second, this paper describes three topics of parameter sensitivity: untangling clones, introducing value semantics, and abstract code-block labels, and includes the benefits and possible further directions for these topics.",,978-1-5090-1855,10.1109/SANER.2016.111,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7476790,code clone;program comprehension;program analysis;dynamic analysis;visualization,Cloning;Sensitivity;Semantics;Switches;Software;Libraries;Conferences,program diagnostics;source code (software),parameter sensitivity;dynamic code-clone analysis methods;value semantics;abstract code-block labels,,,5,,,,,IEEE,IEEE Conferences
Metric Attitude,M. Risi; G. Scanniello; G. Tortora,NA; NA; NA,2013 17th European Conference on Software Maintenance and Reengineering,,2013,,,405,408,"We present Metric Attitude, an Eclipse Rich Client Platform application, for the reverse engineering of object-oriented software systems. The approach graphically represents a suite of object-oriented design metrics and ""traditional"" code-size metrics. To assess the validity of Metric Attitude and its underlying approach, we have conducted a case study on the framework Eclipse 3.5.",1534-5351,978-0-7695-4948-4978-1-4673-5833,10.1109/CSMR.2013.59,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6498498,Program Comprehension;Reverse Engineering;Software Maintenance;Software Metrics;Software Visualization Tool,Visualization;Measurement;Software;Reverse engineering;Java;Layout;Color,object-oriented methods;reverse engineering;software metrics,metric attitude;Eclipse rich client platform application;reverse engineering;object-oriented software systems;object-oriented design metrics;code-size metrics;Eclipse 3.5 framework,,2,9,,,,,IEEE,IEEE Conferences
Using ontology fragments in concept location,L. A. Wilson,"Department of Computer Science, Wayne State University, Detroit, MI USA",2010 IEEE International Conference on Software Maintenance,,2010,,,1,2,"Concept location is the process of locating relevant source code fragments where a change must be made. Concept location requires programmers' understanding of the program and their ability to formulate effective concept location queries. This research presents a systematic approach to query formulation that uses ontology fragments. Preliminary results of a case study demonstrate that only small, partial knowledge represented by small ontology fragments is needed for a successful concept location. The ontology fragments also document programmer learning that takes place during the concept location.",1063-6773;1063-6773,978-1-4244-8629-8978-1-4244-8630-4978-1-4244-8628,10.1109/ICSM.2010.5609555,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609555,concept location;program comprehension;software maintenance,Software maintenance,ontologies (artificial intelligence);query formulation;source coding,ontology fragment;concept location;source code fragment;query formulation,,3,8,,,,,IEEE,IEEE Conferences
JSummarizer: An automatic generator of natural language summaries for Java classes,L. Moreno; A. Marcus; L. Pollock; K. Vijay-Shanker,"Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA; Computer and Information Sciences Department, University of Delaware, Newark, USA; Computer and Information Sciences Department, University of Delaware, Newark, USA",2013 21st International Conference on Program Comprehension (ICPC),,2013,,,230,232,"JSummarizer is an Eclipse plug-in for automatically generating natural language summaries of Java classes. The summary is based on the stereotype of the class, which implicitly encodes the design intent of the class and is automatically inferred by JSummarizer. The tool uses a set of predefined heuristics to determine what information will be reflected in the summary, and it uses natural language processing and generation techniques to form the summary. The generated summaries can be used to re-document the code and to help developers to easier understand large and complex classes.",1092-8138,978-1-4673-3092,10.1109/ICPC.2013.6613855,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613855,Source code summarization;program comprehension;documentation generation,Java;Natural languages;Conferences;Documentation;Software engineering;Software maintenance,Java;natural language processing,JSummarizer;automatic generator;natural language summaries;Java classes;Eclipse plug-in;natural language processing;generation techniques,,12,12,,,,,IEEE,IEEE Conferences
View infinity: a zoomable interface for feature-oriented software development,M. Stengel; M. Frisch; S. Apel; J. Feigenspan; C. Kastner; R. Dachselt,"University of Magdeburg, Magdeburg, Germany; University of Magdeburg, Magdeburg, Germany; University of Passau, Passau, Germany; University of Magdeburg, Magdeburg, Germany; University of Marburg, Marburg, Germany; University of Magdeburg, Magdeburg, Germany",2011 33rd International Conference on Software Engineering (ICSE),,2011,,,1031,1033,"Software product line engineering provides efficient means to develop variable software. To support program comprehension of software product lines (SPLs), we developed View Infinity, a tool that provides seamless and semantic zooming of different abstraction layers of an SPL. First results of a qualitative study with experienced SPL developers are promising and indicate that View Infinity is useful and intuitive to use.",1558-1225;0270-5257,978-1-4503-0445-0978-1-4503-0445,10.1145/1985793.1985987,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032584,program comprehension;semantic zooming;software product lines;variability,Software;Image color analysis;Semantics;Programming;Software engineering;Histograms;Visualization,product development;reverse engineering;software reusability,view infinity;zoomable interface;feature-oriented software development;software product line engineering;program comprehension;semantic zooming;seamless zooming;abstraction layers,,2,8,,,,,IEEE,IEEE Conferences
Enhancing Object-Oriented Programming Comprehension Using Optimized Sequence Diagram,M. Srinivasan; Y. Lee; J. Yang,NA; NA; NA,2016 IEEE 29th International Conference on Software Engineering Education and Training (CSEET),,2016,,,81,85,"This paper presents how to generate an optimized sequence diagram from static java source code and dynamic execution trace at a web-based educational programming environment. The aim of this research is to help student programmers better understand the dynamic behavior of a java program using optimized sequence diagram, therefore to enhance object-oriented programming learning experience.",2377-570X,978-1-5090-0765-3978-1-5090-0764,10.1109/CSEET.2016.37,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7474469,sequence diagram;polymorphism;object-oriented;visualization;program comprehension,Shape;Visualization;Java;Unified modeling language;Grammar;Object oriented programming;Complexity theory,computer aided instruction;computer science education;Internet;Java;object-oriented programming;source code (software);Unified Modeling Language,optimized sequence diagram;static Java source code;dynamic execution trace;Web-based educational programming environment;object-oriented programming learning experience,,1,18,,,,,IEEE,IEEE Conferences
Automatic comment generation using only source code,E. Yildiz; E. Ekin,"Bilgisayar M&#x00FC;hendisli&#x011F;i B&#x00F6;l&#x00FC;m&#x00FC;, I&#x015F;&#x0131;k &#x00DC;niversitesi, &#x0130;stanbul, T&#x00FC;rkiye; Bilgisayar M&#x00FC;hendisli&#x011F;i B&#x00F6;l&#x00FC;m&#x00FC;, I&#x015F;&#x0131;k &#x00DC;niversitesi, &#x0130;stanbul, T&#x00FC;rkiye",2017 25th Signal Processing and Communications Applications Conference (SIU),,2017,,,1,4,"In this study, automatic comment generation for Java methods is described. It is sufficient that the codes conform to the syntax rules of the Java programming language, and it is not expected to be runnable. In order to generate comments, source code is examined syntactically. At this stage, only the method signature and its return type is needed. By working on open source Java projects, different templates have been developed for different method types. Using the compiled information which is the result of the examining source code that is currently being developed, the most suitable template is chosen and texts are created. These texts explain the aim of the method. Created texts are added to source code as a comment.",,978-1-5090-6494-6978-1-5090-6495,10.1109/SIU.2017.7960702,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7960702,source code summarization;documentation generation;program comprehension,Java;Documentation;Syntactics;Reactive power;Cloning;Two dimensional displays,automatic programming;Java;object-oriented programming,automatic comment generation;source code;Java methods;Java programming language;syntax rule;open source Java project;compiled information,,1,9,,,,,IEEE,IEEE Conferences
Towards Promoting Design and UML Modeling Practices in the Open Source Community,A. Aldaeej; O. Badreddin,NA; NA,2016 IEEE/ACM 38th International Conference on Software Engineering Companion (ICSE-C),,2016,,,722,724,"Despite the emergence of UML as the defacto modeling and design tool for software engineering, its adoption remains dismal. Software development, particularly in the open source community, remains code-centric. Adoption of UML in open source projects represents a significant lost opportunity. In this paper, we present an approach to encourage upfront design practices and the adoption of UML modeling in open source projects. In particular, we demonstrate the approach for small contributions and bug fixes. The approach relies on integrating UML-level abstractions into the code. This integration means that open source developers can continue to use their familiar text-based tools to manage the source code and contributions, while at the same time benefit from UML added value of abstractions and comprehension. Other benefits of this approach include broadening the boundaries of bug fix contribution by including modelers and end-users, and incrementally add UML model diagrams into open source project's documentation.",,978-1-4503-4205-6978-1-5090-2245,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7883384,Umple;Model Oriented Programming;Open Source Projects;UML;Program Comprehension;Bug Fixing;Software Design;Reserve Engineering;Forward Engineering;Code Generation,Unified modeling language;Computer bugs;Object oriented modeling;Open source software;Java;Software engineering,program debugging;public domain software;software engineering;source code (software);system documentation;Unified Modeling Language,UML modeling practices;open source community;design tool;software engineering;software development;UML adoption;bug fixes;UML-level abstractions;open source developers;text-based tools;bug fix contribution;UML model diagrams;open source project documentation;source code,,,11,,,,,IEEE,IEEE Conferences
Tarimliq: A new internal metric for software clustering analysis,M. Kargar; H. Izadkhah; A. Isazadeh,"Dept. computer engineering Qazvin Branch, Islamic Azad University, Qazvin, Iran; Dept. of computer science, University of Tabriz, Tabriz, Iran; Dept. of computer science, University of Tabriz, Tabriz, Iran",2019 27th Iranian Conference on Electrical Engineering (ICEE),,2019,,,1879,1883,"Clustering techniques are utilized in the maintenance process of a software system to understand it. Different clustering algorithms have been proposed for this purpose in the literature. In the field of software clustering, a number of external criteria are presented to evaluate and validate the obtained clusters. External criteria use a reference clustering to evaluate an achieved clustering. Because of the comparison with reference clustering, the validity and accuracy of these methods are reliable in the assessment. When there is no reference clustering, internal criteria are used to validate clustering algorithms. Since there is no internal criterion for evaluating software clustering algorithms, the internal criteria available in data clustering are employed. In this paper, we propose an internal metric for evaluating software clustering algorithms. The results on Mozilla Firefox, as a large-scale software, demonstrate that the proposed internal metric is more accurate than the tested internal criteria and can also be a suitable alternative for external criteria.",2642-9527;2164-7054,978-1-7281-1508-5978-1-7281-1507-8978-1-7281-1509,10.1109/IranianCEE.2019.8786745,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8786745,clustering algorithms;program understandability;cluster validity;validity indices,Clustering algorithms;Software algorithms;Measurement;Software systems;Indexes;Computer architecture,pattern clustering;search engines;software maintenance,data clustering;large-scale software;software clustering analysis;Tarimliq;maintenance process;Mozilla Firefox,,,18,,,,,IEEE,IEEE Conferences
Automatically assessing code understandability: How far are we?,S. Scalabrino; G. Bavota; C. Vendome; M. Linares-Vásquez; D. Poshyvanyk; R. Oliveto,"University of Molise, Italy; Università della Svizzera italiana (USI), Switzerland; The College of William and Mary, USA; Universidad de los Andes, Colombia; The College of William and Mary, USA; University of Molise, Italy",2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE),,2017,,,417,427,"Program understanding plays a pivotal role in software maintenance and evolution: a deep understanding of code is the stepping stone for most software-related activities, such as bug fixing or testing. Being able to measure the understandability of a piece of code might help in estimating the effort required for a maintenance activity, in comparing the quality of alternative implementations, or even in predicting bugs. Unfortunately, there are no existing metrics specifically designed to assess the understandability of a given code snippet. In this paper, we perform a first step in this direction, by studying the extent to which several types of metrics computed on code, documentation, and developers correlate with code understandability. To perform such an investigation we ran a study with 46 participants who were asked to understand eight code snippets each. We collected a total of 324 evaluations aiming at assessing the perceived understandability, the actual level of understanding, and the time needed to understand a code snippet. Our results demonstrate that none of the (existing and new) metrics we considered is able to capture code understandability, not even the ones assumed to assess quality attributes strongly related with it, such as code readability and complexity.",,978-1-5386-2684-9978-1-5386-3976,10.1109/ASE.2017.8115654,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115654,Software metrics;Code understandability;Empirical study;Negative result,Measurement;Complexity theory;Software;Computer bugs;Correlation;Maintenance engineering;Documentation,program debugging;public domain software;software maintenance;software metrics;software quality,program understanding;software maintenance;software-related activities;perceived understandability;code readability;code snippet;code complexity;automatic code understandability assessibility;quality attributes,,3,37,,,,,IEEE,IEEE Conferences
An Analysis of Some Commercial PL/I Programs,J. L. Elshoff,"Computer Science Department, General Motors Research Laboratories",IEEE Transactions on Software Engineering,,1976,SE-2,2,113,120,The source code for 120 production PL/I programs from several General Motors' commercial computing installations has been collected. The programs have been scanned both manually and automatically. Some data from the scanning process are presented and interpreted.,0098-5589;1939-3520;2326-3881,,10.1109/TSE.1976.233538,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1702349,Computer program analysis;program complexity;program readability;program size;programmer discipline;programming language usage;software economics,Production;Programming profession;Computer languages;Guidelines;Personnel;Information analysis;History;Terrorism;Computer science;Computer industry,,Computer program analysis;program complexity;program readability;program size;programmer discipline;programming language usage;software economics,,64,17,,,,,IEEE,IEEE Journals
Impact of Coding Style Checker on Code Review - A Case Study on the OpenStack Projects,Y. Ueda; A. Ihara; T. Ishio; K. Matsumoto,NA; NA; NA; NA,2018 9th International Workshop on Empirical Software Engineering in Practice (IWESEP),,2018,,,31,36,"Code review is key to ensuring the absence of potential issues in source code. Code review is changing from a costly manual check by reviewer to a cost-efficient automatic check by coding style checkers. So that patch authors can verify the changed code before submitting their patches. Although cost-efficiency, the checkers do not detect all potential issues, requiring reviewers to verify the submitted patches based on their knowledge. It would be most efficient if patch authors will learn potential issues and remove the same type of issues from patches prior to code review. This study investigates potential issues that patch authors have repeatedly introduced in their patch submissions despite receiving feedback. To understand the impact of adopting checkers to patch authors' coding style improvement, this study compares two types of potential issues: Automatically Detected Issues by checkers (ADIs) and Manually Detected Issues by reviewers (MDIs). In a case study using an OpenStack code review dataset, we found that the patch authors have repeatedly introduced the same type of MDIs, while they do not repeat ADIs. This result suggests that the introduction of code style checkers might promote the patch authors' effective potential issues learning.",2573-2021;2333-519X,978-1-7281-0439-3978-1-7281-0440,10.1109/IWESEP.2018.00014,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8661217,Code-Review;Maintainability;Source-Code-Analysis;Source-Code-Understanding,Encoding;Tools;Manuals;Software;Bars;Measurement;Syntactics,formal verification;program diagnostics;public domain software;software quality;software tools;source code (software),patch authors;source code;OpenStack projects;coding style checker;automatically detected issues;code review tools;manually detected issues;software quality,,1,13,,,,,IEEE,IEEE Conferences
An Eye Tracking Study on camelCase and under_score Identifier Styles,B. Sharif; J. I. Maletic,NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,196,205,"An empirical study to determine if identifier-naming conventions (i.e., camelCase and under_score) affect code comprehension is presented. An eye tracker is used to capture quantitative data from human subjects during an experiment. The intent of this study is to replicate a previous study published at ICPC 2009 (Binkley et al.) that used a timed response test method to acquire data. The use of eye-tracking equipment gives additional insight and overcomes some limitations of traditional data gathering techniques. Similarities and differences between the two studies are discussed. One main difference is that subjects were trained mainly in the underscore style and were all programmers. While results indicate no difference in accuracy between the two styles, subjects recognize identifiers in the underscore style more quickly.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.41,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521745,identifier styles;eye-tracking study;code readability,Programming profession;Computer science;Humans;Testing;Cognitive science;Computer languages;Java;Keyboards;Writing;Software maintenance,programming,camelCase;under_score identifier styles;code comprehension;eye-tracking equipment,,36,27,,,,,IEEE,IEEE Conferences
The Expansion of Source Code Abbreviations Using a Language Model,A. Alatawi; W. Xu; J. Yan,NA; NA; NA,2018 IEEE 42nd Annual Computer Software and Applications Conference (COMPSAC),,2018,2,,370,375,"Programmers often abbreviate identifiers names in source code to represent single words, i.e. unigrams, or phrases, i.e. multigrams. However, the difficulty to retrieve the original word(s) of an abbreviation during the maintenance phase makes the source code more problematic to comprehend. Incorrect abbreviations expansion may lead to introducing defects in the code. There are many approaches that that automatically expand abbreviations to their original words, unfortunately, they are based on predefined patterns and single-words dictionaries which cannot address abbreviations that are expandable to phrases. In this paper, we describe a bigram-based inference model which utilizes unigrams statistical properties as evidence to retrieve the original word automatically. We evaluated our approach on a set of 100 abbreviations randomly picked from eight open source projects and found that our approach correctly expands 78% of the set.",0730-3157,978-1-5386-2667,10.1109/COMPSAC.2018.10260,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8377888,"Automatic Abbreviation Expansion, Software Comprehension, Code Readability, Software Maintenance",Mathematical model;Dictionaries;Software;Computer science;Bayes methods;Conferences,dictionaries;information retrieval;natural language processing;source coding;statistical analysis;text analysis;word processing,source code abbreviations;language model;maintenance phase;incorrect abbreviations expansion;single-words dictionaries;bigram-based inference model;unigrams statistical properties;open source projects,,,14,,,,,IEEE,IEEE Conferences
Visualization of C++ Template Metaprograms,Z. Borok-Nagy; V. Majer; J. Mihalicza; N. Pataki; Z. Porkolab,NA; NA; NA; NA; NA,2010 10th IEEE Working Conference on Source Code Analysis and Manipulation,,2010,,,167,176,"Template metaprograms have become an essential part of today's C++ programs: with proper template definitions we can force the C++ compiler to execute algorithms at compilation time. Among the application areas of template metaprograms are the expression templates, static interface checking, code optimization with adaptation, language embedding and active libraries. Despite all of its already proven benefits and numerous successful applications there are surprisingly few tools for creating, supporting, and analyzing C++ template metaprograms. As metaprograms are executed at compilation time they are even harder to understand. In this paper we present a code visualization tool, which is utilizing Tem plight, our previously developed C++ template metaprogram debugger. Using the tool it is possible to visualize the instantiation chain of C++ templates and follow the execution of metaprograms. Various presentation layers, filtering of template instances and step-by-step replay of the instantiations are supported. Our tool can help to test, optimize, maintain C++ template metaprograms, and can enhance their acceptance in the software industry.",,978-1-4244-8655,10.1109/SCAM.2010.16,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5601850,C++ template metaprogram;code comprehension,Visualization;Data structures;Context;Instruments;Debugging;Libraries;Programming,C++ language;data visualisation;program compilers;program debugging,C++ template metaprogram visualization;C++ compiler;expression templates;static interface checking;code optimization;language embedding;active libraries;code visualization tool;tem plight;C++ template metaprogram debugger,,,28,,,,,IEEE,IEEE Conferences
Automated Detection of Test Fixture Strategies and Smells,M. Greiler; A. van Deursen; M. Storey,NA; NA; NA,"2013 IEEE Sixth International Conference on Software Testing, Verification and Validation",,2013,,,322,331,"Designing automated tests is a challenging task. One important concern is how to design test fixtures, i.e. code that initializes and configures the system under test so that it is in an appropriate state for running particular automated tests. Test designers may have to choose between writing in-line fixture code for each test or refactor fixture code so that it can be reused for other tests. Deciding on which approach to use is a balancing act, often trading off maintenance overhead with slow test execution. Additionally, over time, test code quality can erode and test smells can develop, such as the occurrence of overly general fixtures, obscure in-line code and dead fields. In this paper, we show that test smells related to fixture set-up occur in industrial projects. We present a static analysis technique to identify fixture related test smells. We implemented this test analysis technique in a tool, called TestHound, which provides reports on test smells and recommendations for refactoring the smelly test code. We evaluate the tool through three industrial case studies and show that developers find that the tool helps them to understand, reflect on and adjust test code.",2159-4848,978-0-7695-4968-2978-1-4673-5961,10.1109/ICST.2013.45,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6569744,test code comprehension;maintainability;test fixture;test smells;software testing;test code refactoring,Fixtures;Measurement;Maintenance engineering;Java;Testing;Software systems;Medical services,program diagnostics;program testing;software maintenance,automated detection;test fixture strategies;automated tests design;maintenance overhead;test code quality;static analysis technique;test smells;test analysis technique;TestHound;software refactoring,,18,20,,,,,IEEE,IEEE Conferences
From Code to Design: A Reverse Engineering Approach,E. Varoy; J. Burrows; J. Sun; S. Manoharan,NA; NA; NA; NA,2016 21st International Conference on Engineering of Complex Computer Systems (ICECCS),,2016,,,181,186,"Understanding existing pieces of software is a challenge faced by many software developers regardless of their experience. This project researches into existing reverse engineering tools used for code comprehension and identifies the limitations of the current approaches. Furthermore, a prototype implementation was developed to extract design models from available source code in order to achieve better program comprehension. The design and implementation of the model extraction tool were defined, with a focus on Java systems and an agile methodology. This tool was realised by extending the existing open source diagrammatic software, UMLet, with a set of features to aid in code comprehension. Finally, the prototype implementation was evaluated against the related tools in the field as well as by a group of professional experts.",,978-1-5090-5527-2978-1-5090-5526-5978-1-5090-5528,10.1109/ICECCS.2016.030,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7816583,Code Comprehension;Design Models;UML,Unified modeling language;Software;Java;Reverse engineering;Measurement;Prototypes;Complexity theory,Java;reverse engineering;software engineering;Unified Modeling Language,software developers;reverse engineering tools;source code;Java systems;agile methodology;open source diagrammatic software;UMLet,,,14,,,,,IEEE,IEEE Conferences
Effects of Variable Names on Comprehension: An Empirical Study,E. Avidan; D. G. Feitelson,NA; NA,2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC),,2017,,,55,65,"It is widely accepted that meaningful variable names are important for comprehension. We conducted a controlled experiment in which 9 professional developers try to understand 6 methods from production util classes, either with the original variable names or with names replaced by meaningless single letters. Results show that parameter names are more significant for comprehension than local variables. But, surprisingly, we also found that in 3 of the methods there were no significant differences between the control and experimental groups, due to poor and even misleading variable names. These disturbingly common bad names reflect the subjective nature of naming, and highlight the need for additional research on how variable names are interpreted and how better names can be chosen.",,978-1-5386-0535-6978-1-5386-0536,10.1109/ICPC.2017.27,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961504,code comprehension;variable names;misleading names;method parameters;local variables,Conferences;Random access memory,professional aspects;software maintenance;source code (software),variable names effects;proessional developers;parameter names;code comprehension;misleading names,,2,27,,,,,IEEE,IEEE Conferences
Replicating Novices' Struggles with Coding Style,E. S. Wiese; A. N. Rafferty; D. M. Kopta; J. M. Anderson,"University of Utah, USA; Carleton College, USA; University of Utah, USA; University of Utah, USA",2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC),,2019,,,13,18,"Good style makes code easier for others to read and modify. Control flow is one element of style where experts expect particular structure, such as conjoining conditions rather than nesting if statements. Empirical work is necessary to understand why novices use poor style, so they can be taught to use good style. Previous work shows that many students know what control flows experts prefer, but may say that novice-styled code is more readable. Yet, these same students showed similarly high comprehension across both expert-and novice-styled code. We propose a replication of that work that more fully assesses students' code comprehension and code writing. Our replication focuses on students who are earlier in their computer science courses and are less likely to be majors, to determine whether the pattern of results is particular to students who are relatively attuned to style concerns. Our pilot of the proposed replication finds that: students in this new population are less able to identify expert code; expert style may reduce comprehension for some control flows; and writing with good style does not always predict a preference for reading code with good style.",2643-7171;2643-7147,978-1-7281-1519-1978-1-7281-1520,10.1109/ICPC.2019.00015,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813294,Computer science education;Novice code comprehension;Programming style,,,,,,10,,,,,IEEE,IEEE Conferences
On Using Tree Visualisation Techniques to Support Source Code Comprehension,I. Bacher; B. M. Namee; J. D. Kelleher,NA; NA; NA,2016 IEEE Working Conference on Software Visualization (VISSOFT),,2016,,,91,95,"This paper presents a design study that investigates the use of compact tree visualisations to provide software developers with an overview of the static structure of a source code document within a code editor in order to facilitate source code understanding and navigation. A prototype is presented which utilises an icicle tree visualisation to encode the control structure hierarchy of a source code document, as well as a circular treemap visualisation to encode the scope hierarchy of a source code document. An overview of the prototype and its functionality is given as well as a detailed discussion on the design rationale behind the tool. Possible applications and future work plans are also discussed.",,978-1-5090-3850-3978-1-5090-3851,10.1109/VISSOFT.2016.8,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780163,Software visualisation;Tree visualisations techniques;Source code comprehension,Visualization;Software;Prototypes;Context;Navigation;Aerospace electronics;Data visualization,data visualisation;program control structures;software engineering;source code (software);trees (mathematics),static structure;source code document;code editor;source code understanding;source code navigation;icicle tree visualisation;control structure hierarchy;circular treemap visualisation;scope hierarchy;design rationale;software development,,,23,,,,,IEEE,IEEE Conferences
Metric pictures: The approach and applications,R. Francese; S. Murad; I. Passero; G. Tortora,"Dipartimento di Matem&#x00E1;tica e Informatica, University of Salerno - Italy; Dipartimento di Matem&#x00E1;tica e Informatica, University of Salerno - Italy; Dipartimento di Matem&#x00E1;tica e Informatica, University of Salerno - Italy; Dipartimento di Matem&#x00E1;tica e Informatica, University of Salerno - Italy",The 2010 International Conference on Computer Engineering & Systems,,2010,,,320,325,"Source code metrics evaluate some aspects of software artefacts and provide synthetic measures of examined characteristics. Metrics are broadly adopted for code tracking, analysis and comprehension. In this paper, we present Metric Pictures, raster images obtained from source code metrics. With this method, the paper introduces algebra, derived from Image Elaboration, sounding with metric definitions. Metric Pictures with their operation set can be generally useful for underlining interesting features of analyzed code. As an example, the paper describes the application of the underlying logic and operators to Dead Code detection.",,978-1-4244-7042-6978-1-4244-7040-2978-1-4244-7041,10.1109/ICCES.2010.5674876,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5674876,Object oriented metrics;code comprehension;code analysis;metric visualization;image elaboration,Software;Visualization;Data visualization;Image color analysis;Software measurement;Algebra,algebra;software metrics,metric pictures;source code metrics;software artifacts;code tracking;algebra;image elaboration;dead code detection,,,48,,,,,IEEE,IEEE Conferences
Recognizing eye tracking traits for source code review,K. R. Chandrika; J. Amudha; S. D. Sudarsan,"Dept of Computer Science & Engineering, Amrita School of Engineering, Bengaluru, Amrita Vishwa Vidyapeetham, Amrita University, India; Dept of Computer Science & Engineering, Amrita School of Engineering, Bengaluru, Amrita Vishwa Vidyapeetham, Amrita University, India; Industrial Software Systems, ABB Corporate Research, Bengaluru, India",2017 22nd IEEE International Conference on Emerging Technologies and Factory Automation (ETFA),,2017,,,1,8,"Source code review is a core activity in software engineering where a reviewer examines the code with the intention of finding bugs in the program. A lot of research has been carried out in understanding how software engineers perform code comprehension; however contribution of eye tracking traits seems to have not been addressed. This paper outlines a study conducted in an industrial environment of software engineers. It focused on understanding the visual attention of subjects with programming skills and subjects without programming skills and recognize the eye tracking traits required for source code review. The results indicate a significant difference in gaze behaviors of these groups. The key aspects of subjects with programming skills while source code review are required to have certain eye tracking traits like better code coverage, attention span on error lines and comments.",1946-0759,978-1-5090-6505-9978-1-5090-6504-2978-1-5090-6506,10.1109/ETFA.2017.8247637,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8247637,Eye Tracking;Software Engineering;Source Code Review;Source Code Comprehension,Gaze tracking;Programming;Visualization;Computer bugs;Tracking;Debugging,gaze tracking;program debugging;program diagnostics;program testing;software maintenance;source code (software),eye tracking traits;software engineers;programming skills;source code review;code coverage;software engineering;code comprehension;visual attention;gaze behaviors,,1,15,,,,,IEEE,IEEE Conferences
Source code comprehension strategies and metrics to predict comprehension effort in software maintenance and evolution tasks - an empirical study with industry practitioners,K. Nishizono; S. Morisakl; R. Vivanco; K. Matsumoto,"Graduate School, of Information Science, Nara Institute of Science and Technology, 8916-5 Takayama, Ikoma, 630-0192 JAPAN; Faculty of Informatics, Shizuoka University, 3-5-1 Johoku, Naka, Hamamatsu, 432-8011 JAPAN; Department of Computer Science, University of Manitoba, Winnipeg, Canada R3T 2N2; Graduate School, of Information Science, Nara Institute of Science and Technology, 8916-5 Takayama, Ikoma, 630-0192 JAPAN",2011 27th IEEE International Conference on Software Maintenance (ICSM),,2011,,,473,481,"The goal of this research was to assess the consistency of source code comprehension strategies and comprehension effort estimation metrics, such as LOC, across different types of modification tasks in software maintenance and evolution. We conducted an empirical study with software development practitioners using source code from a small paint application written in Java, along with four semantics-preserving modification tasks (refactoring, defect correction) and four semantics-modifying modification tasks (enhancive and modification). Each task has a change specification and corresponding source code patch. The subjects were asked to comprehend the original source code and then judge whether each patch meets the corresponding change specification in the modification task. The subjects recorded the time to comprehend and described the comprehension strategies used and their reason for the patch judgments. The 24 subjects used similar comprehension strategies. The results show that the comprehension strategies and effort estimation metrics are not consistent across different types of modification tasks. The recorded descriptions indicate the subjects scanned through the original source code and the patches when trying to comprehend patches in the semantics-modifying tasks while the subjects only read the source code of the patches in semantics-preserving tasks. An important metric for estimating comprehension efforts of the semantics-modifying tasks is the Code Clone Subtracted from LOC(CCSLOC), while that of semantics-preserving tasks is the number of referred variables.",1063-6773;1063-6773,978-1-4577-0664-6978-1-4577-0663-9978-1-4577-0662,10.1109/ICSM.2011.6080814,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6080814,source code comprehension;comprehension effort estimation metrics;semantics-preserving;semantics-modifying;software maintenance and evolution,Analytical models;Measurement,software maintenance;software metrics,source code comprehension;software maintenance;evolution task;comprehension effort estimation metrics;software evolution;software development practitioner;semantics-preserving modification task;refactoring;defect correction;semantics-modifying modification task;source code patch;code clone subtracted from LOC,,5,17,,,,,IEEE,IEEE Conferences
Learning a Classifier for Prediction of Maintainability Based on Static Analysis Tools,M. Schnappinger; M. H. Osman; A. Pretschner; A. Fietzke,"Technical University of Munich, Germany; Technical University of Munich, Germany; Technical University of Munich, Germany; itestra GmbH, Germany",2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC),,2019,,,243,248,"Static Code Analysis Tools are a popular aid to monitor and control the quality of software systems. Still, these tools only provide a large number of measurements that have to be interpreted by the developers in order to obtain insights about the actual quality of the software. In cooperation with professional quality analysts, we manually inspected source code from three different projects and evaluated its maintainability. We then trained machine learning algorithms to predict the human maintainability evaluation of program classes based on code metrics. The code metrics include structural metrics such as nesting depth, cloning information and abstractions like the number of code smells. We evaluated this approach on a dataset of more than 115,000 Lines of Code. Our model is able to predict up to 81% of the threefold labels correctly and achieves a precision of 80%. Thus, we believe this is a promising contribution towards automated maintainability prediction. In addition, we analyzed the attributes in our created dataset and identified the features with the highest predictive power, i.e. code clones, method length, and the number of alerts raised by the tool Teamscale. This insight provides valuable help for users needing to prioritize tool measurements.",2643-7171;2643-7147,978-1-7281-1519-1978-1-7281-1520,10.1109/ICPC.2019.00043,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813252,Software Quality;Software Maintenance;Code Comprehension;Static Code Analysis;Maintenance Tools,,,,,,24,,,,,IEEE,IEEE Conferences
CodeSurveyor: Mapping large-scale software to aid in code comprehension,N. Hawes; S. Marshall; C. Anslow,"Oracle Labs, Brisbane, Australia; Victoria University of Wellington, New Zealand; Middlesex University, London, UK",2015 IEEE 3rd Working Conference on Software Visualization (VISSOFT),,2015,,,96,105,"Large codebases - in the order of millions of lines of code (MLOC) - are incredibly complex. Whether fixing a fault, or implementing a new feature, changes to such systems often have unanticipated effects, as it is impossible for a developer to maintain a complete understanding of the code in their head. This paper presents CodeSurveyor, a spatial visualization technique that aims to support code comprehension in large codebases by allowing developers to view large-scale software at all levels of abstraction. It uses a cartographic metaphor to produce an interactive map of a codebase where users can zoom from a view of a system's high-level architectural components, represented as continents, down to the individual source files and the entities they define, shown as countries and states, respectively. The layout of the produced code map incorporates system dependency data and sizes regions according to a userconfigurable metric (line count by default), to create distinctive shapes and positions that serve as strong visual landmarks and keep users oriented. We detail the CodeSurveyor algorithm, show it generates code maps of the Linux kernel (1.4 MLOC) in 1.5 minutes, and evaluate the intuitiveness of the metaphor to software developers and its utility in navigation tasks. Results show the effectiveness of the approach with developers of varying experience levels.",,978-1-4673-7526-9978-1-4673-7525,10.1109/VISSOFT.2015.7332419,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7332419,software visualization;code comprehension,Layout;Visualization;Shape;Vocabulary;Measurement;Software systems,data visualisation;Linux;source code (software),CodeSurveyor;large-scale software mapping;code comprehension;codebase;millions of lines of code;MLOC;spatial visualization technique;cartographic metaphor;interactive map;system high-level architectural components;source files;code map;system dependency data;user configurable metric;visual landmark;Linux kernel;navigation task;time 1.5 min,,4,17,,,,,IEEE,IEEE Conferences
Decoding the Representation of Code in the Brain: An fMRI Study of Code Review and Expertise,B. Floyd; T. Santander; W. Weimer,NA; NA; NA,2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE),,2017,,,175,186,"Subjective judgments in software engineering tasks are of critical importance but can be difficult to study with conventional means. Medical imaging techniques hold the promise of relating cognition to physical activities and brain structures. In a controlled experiment involving 29 participants, we examine code comprehension, code review and prose review using functional magnetic resonance imaging. We find that the neural representations of programming languages vs. natural languages are distinct. We can classify which task a participant is undertaking based solely on brain activity (balanced accuracy 79%, p <; 0.001). Further, we find that the same set of brain regions distinguish between code and prose (near-perfect correlation, r = 0.99, p <; 0.001). Finally, we find that task distinctions are modulated by expertise, such that greater skill predicts a less differentiated neural representation (r = -0.44, p = 0.016) indicating that more skilled participants treat code and prose more similarly at a neural activation level.",1558-1225,978-1-5386-3868-2978-1-5386-3869,10.1109/ICSE.2017.24,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985660,medical imaging;code comprehension;prose review,Biomedical imaging;Software engineering;Brain;Software;Computer science;Natural languages;Tools,biomedical MRI;medical image processing;software engineering,fMRI study;software engineering tasks;medical imaging techniques;functional magnetic resonance imaging;code comprehension;code review;prose review;neural representations;programming languages;natural languages,,7,85,,,,,IEEE,IEEE Conferences
Delivering comprehension features into source code editors through LSP,M. Mészáros; M. Cserép; A. Fekete,"Dept. of Programming Languages And Compilers, Eötvös Loránd University, Budapest, Hungary; Dept. of Software Technology And Methodology, Eötvös Loránd University, Budapest, Hungary; Dept. of Software Technology And Methodology, Eötvös Loránd University, Budapest, Hungary","2019 42nd International Convention on Information and Communication Technology, Electronics and Microelectronics (MIPRO)",,2019,,,1581,1586,"The maintenance of large, legacy software often results in higher development time and cost due to increasing size and complexity of the codebase and its documentation, their continuously eroding quality and fluctuation among developers. Code comprehension tools are designed to tackle this issue by providing various textual information, visualization views and source code metrics on multiple abstraction levels. These tools usually process not only the codebase, but also the build information, the version control repository and other available information sources. Meanwhile source code editors and integrated development environments (IDEs) are not performing well in the field of code comprehension as they are optimized for writing new code, not for effective browsing. This can easily result in frequent switching between environments during development, hindering effective programming and raising development cost. Language Server Protocol (LSP) is an open-source protocol to connect source code editors with servers that provide language-specific features. In this research we analyze how LSP can be utilized to improve the code comprehension experience inside code editors by integrating the features of such tools through remote procedure calls. As a prototype solution we showcase the integration of two open-source applications: Visual Studio Code and the Code Compass code comprehension tool.",2623-8764,978-953-233-098-4978-1-5386-9296,10.23919/MIPRO.2019.8756695,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8756695,code comprehension;software maintenance;language server protocol;source code editor,,configuration management;data visualisation;program diagnostics;programming environments;public domain software;remote procedure calls;software maintenance;software metrics,LSP;open-source protocol;source code editors;code comprehension experience;open-source applications;Visual Studio Code;source code metrics;integrated development environments;information sources;code comprehension tools;code compass code comprehension tool;language server protocol,,,11,,,,,IEEE,IEEE Conferences
Tracing requirements to tests with high precision and recall,C. Ziftci; I. Krueger,"Computer Science Department, University of California at San Diego, USA; Computer Science Department, University of California at San Diego, USA",2011 26th IEEE/ACM International Conference on Automated Software Engineering (ASE 2011),,2011,,,472,475,"Requirements traceability is linking requirements to software artifacts, such as source code, test-cases and configuration files. For stakeholders of software, it is important to understand which requirements were tested, whether sufficiently, if at all. Hence tracing requirements in test-cases is an important problem. In this paper, we build on existing research and use features, realization of functional requirements in software [15], to automatically create requirements traceability links between requirements and test-cases. We evaluate our approach on a chat system, Apache Pool [21] and Apache Log4j [11]. We obtain precision/recall levels of more than 90%, an improvement upon currently existing Information Retrieval approaches when tested on the same case studies.",1938-4300,978-1-4577-1639-3978-1-4577-1638,10.1109/ASE.2011.6100102,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6100102,requirements traceability;testing;program understanding;automated analysis,Large scale integration;Documentation;Software engineering;Programming;Testing;Software systems,formal specification;formal verification;information retrieval;program diagnostics;source coding,requirement traceability;software artifacts;source code;software stakeholders;functional software Celal requirements;chat system;Apache Pool;Apache Log4j;information retrieval approaches,,6,26,,,,,IEEE,IEEE Conferences
How effective developers investigate source code: an exploratory study,M. P. Robillard; W. Coelho; G. C. Murphy,"Sch. of Comput. Sci., McGill Univ., Montreal, Que., Canada; NA; NA",IEEE Transactions on Software Engineering,,2004,30,12,889,903,"Prior to performing a software change task, developers must discover and understand the subset of the system relevant to the task. Since the behavior exhibited by individual developers when investigating a software system is influenced by intuition, experience, and skill, there is often significant variability in developer effectiveness. To understand the factors that contribute to effective program investigation behavior, we conducted a study of five developers performing a change task on a medium-size open source system. We isolated the factors related to effective program investigation behavior by performing a detailed qualitative analysis of the program investigation behavior of successful and unsuccessful developers. We report on these factors as a set of detailed observations, such as evidence of the phenomenon of inattention blindness by developers skimming source code. In general, our results support the intuitive notion that a methodical and structured approach to program investigation is the most effective.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2004.101,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1377187,Index Terms- Software evolution;empirical software engineering;program investigation;program understanding.,Software systems;Performance analysis;Programming;Software tools;Computer Society;Software performance;Blindness;Software engineering;Scattering;Inspection,software prototyping;reverse engineering;public domain software;open systems;programming environments,source code;software system investigation;program investigation behavior;medium-size open source system;software evolution;empirical software engineering;program understanding,,100,35,,,,,IEEE,IEEE Journals
Part-of-speech tagging of program identifiers for improved text-based software engineering tools,S. Gupta; S. Malik; L. Pollock; K. Vijay-Shanker,"Computer and Information Sciences, University of Delaware, Newark, 19716 USA; Department of Computer Science, University of Maryland, College Park, 20742 USA; Computer and Information Sciences, University of Delaware, Newark, 19716 USA; Computer and Information Sciences, University of Delaware, Newark, 19716 USA",2013 21st International Conference on Program Comprehension (ICPC),,2013,,,3,12,"To aid program comprehension, programmers choose identifiers for methods, classes, fields and other program elements primarily by following naming conventions in software. These software “naming conventions” follow systematic patterns which can convey deep natural language clues that can be leveraged by software engineering tools. For example, they can be used to increase the accuracy of software search tools, improve the ability of program navigation tools to recommend related methods, and raise the accuracy of other program analyses. After splitting multi-word names into their component words, the next step to extracting accurate natural language information is tagging each word with its part of speech (POS) and then chunking the name into natural language phrases. State-of-theart approaches, most of which rely on “traditional POS taggers” trained on natural language documents, do not capture the syntactic structure of program elements. In this paper, we present a POS tagger and syntactic chunker for source code names that takes into account programmers' naming conventions to understand the regular, systematic ways a program element is named. We studied the naming conventions used in Object Oriented Programming and identified different grammatical constructions that characterize a large number of program identifiers. This study then informed the design of our POS tagger and chunker. Our evaluation results show a significant improvement in accuracy(11%-20%) of POS tagging of identifiers, over the current approaches. With this improved accuracy, both automated software engineering tools and developers will be able to better capture and understand the information available in code.",1092-8138,978-1-4673-3092,10.1109/ICPC.2013.6613828,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613828,Program understanding;comprehension;part-of-speech;natural language processing;identifiers,Tagging;Software;Natural languages;Syntactics;Accuracy;Context;Software engineering,natural language processing;object-oriented programming;reverse engineering;software engineering;text analysis,part-of-speech tagging;program identifiers;text-based software engineering tools;program comprehension;method identifier;class identifier;field identifier;program elements;software naming conventions;deep natural language clues;software search tools;program navigation tools;program analysis;multiword name splitting;component words;natural language information extraction;word tagging;part of speech;natural language phrases;natural language documents;syntactic structure;POS tagger;syntactic chunker;source code names;programmer naming convention;object oriented programming;grammatical construction,,26,27,,,,,IEEE,IEEE Conferences
Butterflies: a visual approach to characterize packages,S. Ducasse; M. Lanza; L. Ponisio,"Software Composition Group, Bern Univ., Switzerland; NA; NA",11th IEEE International Software Metrics Symposium (METRICS'05),,2005,,,10 pp.,7,"Understanding sets of classes, or packages, is an important activity in the development and reengineering of large object-oriented systems. Packages represent the coarse grained structure of an application. They are artefacts to deploy and structure software, and therefore more than a simple generalization of classes. The relationships between packages and their contained classes are key in the decomposition of an application and its (re)-modularisation. However, it is difficult to quickly grasp the structure of a package and to understand how a package interacts with the rest of the system. We tackle this problem using butterfly visualizations, i.e., dedicated radar charts built from simple package metrics based on a language-independent meta-model. We illustrate our approach on two applications and show how we can retrieve the relevant characteristics of packages",1530-1435,0-7695-2371,10.1109/METRICS.2005.15,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1509285,Program understanding;package metrics;reverse engineering;software visualization,Packaging;Application software;Software maintenance;Software packages;Visualization;Reverse engineering;Software systems;Java;Informatics;Radar,object-oriented programming;program visualisation;reverse engineering;software metrics;software packages;systems re-engineering,software package characterization;system development;system reengineering;object-oriented systems;class generalization;butterfly visualization;radar charts;package metrics;language-independent metamodel;program understanding;reverse engineering;software visualization,,62,30,,,,,IEEE,IEEE Conferences
Teaching software engineering with projects,J. Ludewig; I. Bogicevic,"Institute for Software Technology, University of Stuttgart, Germany; Institute for Software Technology, University of Stuttgart, Germany",2012 First International Workshop on Software Engineering Education Based on Real-World Experiences (EduRex),,2012,,,25,28,"The software engineering curriculum offered by the University of Stuttgart emphasizes project work from the first to the last semester. While some of the projects are similar to those in other programs, others are less common. In this paper, we describe an introductory course called “Program Understanding”, and the so called “Consulting Task”. We also give a short description of what we call the First Software Project and the Large Software Project. In the Program Understanding course, new students learn to understand a fairly large, complex program in order to implement some modifications. In the Large Software Project, some ten people work on a serious software development for one year. In the Consulting Task, a group of three students analyses a problem, usually one given by an industrial partner. The students investigate possible solutions, and finally deliver a recommendation. Both our experience and feedback from students, including feedback from alumni, prove that these projects are very successful and highly esteemed.",,978-1-4673-1805-1978-1-4673-1804,10.1109/EduRex.2012.6225701,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6225701,software projects;Program Understanding;Consulting Task;software engineering curriculum,Software;Software engineering;Educational institutions;Programming;Industries;Companies;Java,project management;reverse engineering;software engineering;teaching,software engineering curriculum;University of Stuttgart;introductory course;consulting task;first software project;large software project;program understanding course;software development;industrial partner;feedback;teaching,,3,4,,,,,IEEE,IEEE Conferences
Things structural clones tell that simple clones don't,H. A. Basit; U. Ali; S. Haque; S. Jarzabek,"School of Science and Engineering, Lahore University of Management Sciences, Lahore, Pakistan; School of Science and Engineering, Lahore University of Management Sciences, Lahore, Pakistan; School of Science and Engineering, Lahore University of Management Sciences, Lahore, Pakistan; School of Computing, National University of Singapore, Singapore",2012 28th IEEE International Conference on Software Maintenance (ICSM),,2012,,,275,284,"In previous work, we described a technique for detecting design-level similar program structures (structural clones) formed from recurring configurations of similar code fragments (simple clones). In this paper, we analyze in detail how frequently these structural clones occur in software systems and how structural clone analysis extends the benefits of analysis based on simple clones only. Our case study of 11 open source systems revealed that over 50% of simple clones are captured by structural clones that often correspond to meaningful design or application domain concepts. Because of their larger size, it is easier for programmers to perceive the similarity situation in a system from structural clone perspective rather than from simple clone perspective only. We also discuss the contribution of structural clone detection towards program understanding, design recovery, maintenance, and refactoring using examples from the case study systems.",1063-6773,978-1-4673-2312-3978-1-4673-2313,10.1109/ICSM.2012.6405283,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6405283,code clones;high level similarities;clone analysis;design recovery;program understanding;refactoring,Cloning;FCC;Conferences;Software maintenance;Educational institutions;Software systems;Containers,reverse engineering;software maintenance,structural clone detection;design-level similar program structure;recurring configuration;code fragment;simple clone;software system;open source system;application domain concept;program understanding;design recovery;program maintenance;program refactoring,,8,18,,,,,IEEE,IEEE Conferences
Understanding Log Lines Using Development Knowledge,W. Shang; M. Nagappan; A. E. Hassan; Z. M. Jiang,NA; NA; NA; NA,2014 IEEE International Conference on Software Maintenance and Evolution,,2014,,,21,30,"Logs are generated by output statements that developers insert into the code. By recording the system behaviour during runtime, logs play an important role in the maintenance of large software systems. The rich nature of logs has introduced a new market of log management applications (e.g., Splunk, XpoLog and log stash) that assist in storing, querying and analyzing logs. Moreover, recent research has demonstrated the importance of logs in operating, understanding and improving software systems. Thus log maintenance is an important task for the developers. However, all too often practitioners (i.e., operators and administrators) are left without any support to help them unravel the meaning and impact of specific log lines. By spending over 100 human hours and manually examining all the email threads in the mailing list for three open source systems (Hadoop, Cassandra and Zookeeper) and performing web search on sampled logging statements, we found 15 email inquiries and 73 inquiries from web search about different log lines. We identified that five types of development knowledge that are often sought from the logs by practitioners: meaning, cause, context, impact and solution. Due to the frequency and nature of log lines about which real customers inquire, documenting all the log lines or identifying which ones to document is not efficient. Hence in this paper we propose an on-demand approach, which associates the development knowledge present in various development repositories (e.g., code commits and issues reports) with the log lines. Our case studies show that the derived development knowledge can be used to resolve real-life inquiries about logs.",1063-6773,978-1-4799-6146,10.1109/ICSME.2014.24,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6976068,Software maintenance;Software Logs;Program understanding,Web search;Electronic mail;Context;Google;Software systems;Knowledge engineering;Engines,Internet;public domain software;software maintenance;system monitoring,log lines;development knowledge;log maintenance;open source systems;Web search,,15,37,,,,,IEEE,IEEE Conferences
Feature identification: a novel approach and a case study,G. Antoniol; Y. -. Gueheneuc,"RCOST, Univ. of Sannio, Italy; NA",21st IEEE International Conference on Software Maintenance (ICSM'05),,2005,,,357,366,"Feature identification is a well-known technique to identify subsets of a program source code activated when exercising a functionality. Several approaches have been proposed to identify features. We present an approach to feature identification and comparison for large object-oriented multi-threaded programs using both static and dynamic data. We use processor emulation, knowledge filtering, and probabilistic ranking to overcome the difficulties of collecting dynamic data, i.e., imprecision and noise. We use model transformations to compare and to visualise identified features. We compare our approach with a naive approach and a concept analysis-based approach using a case study on a real-life large object-oriented multi-threaded program, Mozilla, to show the advantages of our approach. We also use the case study to compare processor emulation with statistical profiling.",1063-6773,0-7695-2368,10.1109/ICSM.2005.48,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510131,Program understanding;dynamic and static analyses;feature analysis;meta-modelling,Computer aided software engineering;Object oriented modeling;Software maintenance;Emulation;Filtering;Performance analysis;Data structures;Uniform resource locators;Visualization;Software performance,program diagnostics;object-oriented programming;multi-threading;program visualisation,feature identification;program source code identification;object-oriented multithreaded programs;processor emulation;knowledge filtering;probabilistic ranking;model transformations;concept analysis-based approach;Mozilla;statistical profiling,,48,23,,,,,IEEE,IEEE Conferences
Program Learning Using Static Information and Dynamic Program Execution Slices,J. Sawamoto; E. Sugino; N. Segawa; Y. Wada,NA; NA; NA; NA,2010 IEEE 24th International Conference on Advanced Information Networking and Applications Workshops,,2010,,,157,162,"Nowadays, we can easily obtain a copy of practically any used program in our open source community for learning. However, the reality is that the level of such practically used programs is often complex and of such a large scale so that it is not as easy to understand them as one might expect. We believe that we do need some kind of environment to help the learner read and understand programs. Learning programs is necessary for other reasons such as program maintenance, reuse of programs. In this research, we built a model to use for program understanding. Using it, we examined possible ways of supporting program learning. Based on that, the objective of this paper is to present our efforts at developing a program learning environment, which helps narrow down the scope of a program to facilitate reading and understanding it while finding the differences of such dynamic information, as found in the program execution history, and also provide an environment in which the learner can use static information. We evaluate the efficiency of the proposed program learning environment through experiments.",,978-1-4244-6702-0978-1-4244-6701-3978-0-7695-4019,10.1109/WAINA.2010.15,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5480864,program understanding;program learning;execution history;program reuse;program maintenance,History;Large-scale systems;Application software;Conferences;Open source software;Information science;Costs;Programming;Documentation,learning systems;programming environments;public domain software;software maintenance;software reusability,static information;dynamic program execution slices;open source community;practically used programs;program maintenance;program reusability;program understanding;program learning environment;dynamic information;program execution history;learner,,,9,,,,,IEEE,IEEE Conferences
The Programmer's Apprentice: Knowledge Based Program Editing,R. C. Waters,"Artificial Intelligence Laboratory, Massachusetts Institute of Technology",IEEE Transactions on Software Engineering,,1982,SE-8,1,1,12,"An initial implementation of an interactive programming assistant system called the programmer's apprentice (PA) is described. The PA is designed to be midway between an improved programming methodology and an automatic programming system. The intention is that the programmer will do the hard parts of design and implementation while the PA will assist him wherever possible. One of the major underpinnings of the PA is a representation (called a plan) for programs which abstracts away from the inessential features of a program, and represents the basic logical properties of the algorithm explicitly.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.1982.234769,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1702900,Computer-aided design;editing;Lisp;plans;program analysis;programmer's apprentice;program modification;program synthesis;program understanding;transformations,Programming profession;Libraries;Automatic programming;Programming environments;Computer languages;Abstracts;Algorithm design and analysis;Program processors;Documentation;Debugging,,Computer-aided design;editing;Lisp;plans;program analysis;programmer's apprentice;program modification;program synthesis;program understanding;transformations,,57,15,,,,,IEEE,IEEE Journals
Cross-Language Code Analysis and Refactoring,P. Mayer; A. Schroeder,NA; NA,2012 IEEE 12th International Working Conference on Source Code Analysis and Manipulation,,2012,,,94,103,"Software composed of artifacts written in multiple (programming) languages is pervasive in today's enterprise, desktop, and mobile applications. Since they form one system, artifacts from different languages reference one another, thus creating what we call semantic cross-language links. By their very nature, such links are out of scope of the individual programming language, they are ignored by most language-specific tools and are often only established -- and checked for errors -- at runtime. This is unfortunate since it requires additional testing, leads to brittle code, and lessens maintainability. In this paper, we advocate a generic approach to understanding, analyzing and refactoring cross-language code by explicitly specifying and exploiting semantic links with the aim of giving developers the same amount of control over and confidence in multi-language programs they have for single-language code today.",,978-0-7695-4783-1978-1-4673-2398,10.1109/SCAM.2012.11,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6392106,cross-language;multi-language;analysis;program understanding;refactoring;constraints;tooling;polyglot programming,Semantics;Java;XML;Programming;Software;Layout;Navigation,program diagnostics;software maintenance,cross-language code analysis;mobile applications;desktop applications;enterprise applications;semantic cross-language links;programming language;language-specific tools;brittle code;maintainability;cross-language code refactoring;multilanguage programs;single-language code,,12,27,,,,,IEEE,IEEE Conferences
A Framework for Debugging Java Programs in a Bytecode,S. Soomro; M. R. Belgaum; Z. Alansari; M. H. Miraz,"Department of Computer Studies, AMA International University, Salmabad, Bahrain; Department of Computer Studies, AMA International University, Salmabad, Bahrain; Department of Computer Studies, AMA International University, Salmabad, Bahrain; Centre for Financial Regulations and Economic Development (CFRED), The Chinese University of Hong Kong, Sha Tin, Hong Kong","2018 International Conference on Computing, Electronics & Communications Engineering (iCCECE)",,2018,,,317,322,"In the domain of Software Engineering, program analysis and understanding has been considered to be a very challenging task since decade, as it demands dedicated time and efforts. The analysis of source code may occasionally be comparatively easier due to its static nature, however, the back-end code (Bytecode), especially in terms of Java programming, is complicated to be analysed. In this paper, we present a methodological approach towards understanding the Bytecode of Java programs. We put forward a framework for the debugging process of Java Bytecode. Furthermore, we discuss the debugging process of Bytecode understanding from simple to multiple statements with regards to data flow analysis. Finally, we present a comparative analysis of Bytecode along with the simulation of the proposed framework for the debugging process.",,978-1-5386-4904-6978-1-5386-4903-9978-1-5386-4905,10.1109/iCCECOME.2018.8658589,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8658589,Software Maintenance;Bytecode Analysis;Software Testing;Control and Data Flow Analysis;Program Understanding,Java;Debugging;Tools;Computer bugs;Software maintenance;Testing,data flow analysis;Java;program debugging;program diagnostics;software engineering,software engineering;Java bytecode;bytecode understanding;data flow analysis;Java programming;back-end code;source code;program analysis;Java programs;debugging process;comparative analysis,,,20,,,,,IEEE,IEEE Conferences
A Method for Analyzing Loop Programs,R. C. Waters,"Artificial Intelligence Laboratory and the Laboratory for Computer Science, Massachusetts Institute of Technology",IEEE Transactions on Software Engineering,,1979,SE-5,3,237,247,"This paper presents a method for automatically analyzing loops, and discusses why it is a useful way to look at loops. The method is based on the idea that there are four basic ways in which the logical structure of a loop is built up. An experiment is presented which shows that this accounts for the structure of a large class of loops. The paper discusses how the method can be used to automatically analyze the structure of a loop, and how the resulting analysis can be used to guide a proof of correctness for the loop. An automatic system is described which performs this type of analysis. The paper discusses the relationship between the structure building methods presented and programming language constructs. A system is described which is designed to assist a person who is writing a program. The intent is that the system will cooperate with a programmer throughout aUl phases of work on a program and be able to communicate with the programmer about it.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.1979.234185,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1702623,Loops;plans;program analysis;program verification;program understanding,Computer languages;Programming profession;Artificial intelligence;Performance analysis;Writing;Buildings;Abstracts;Contracts;Computer science;Algorithms,,Loops;plans;program analysis;program verification;program understanding,,42,29,,,,,IEEE,IEEE Journals
Prevalence of Confusing Code in Software Projects: Atoms of Confusion in the Wild,D. Gopstein; H. H. Zhou; P. Frankl; J. Cappos,NA; NA; NA; NA,2018 IEEE/ACM 15th International Conference on Mining Software Repositories (MSR),,2018,,,281,291,"Prior work has shown that extremely small code patterns, such as the conditional operator and implicit type conversion, can cause considerable misunderstanding in programmers. Until now, the real world impact of these patterns - known as 'atoms of confusion' - was only speculative. This work uses a corpus of 14 of the most popular and influential open source C and C++ projects to measure the prevalence and significance of these small confusing patterns. Our results show that the 15 known types of confusing micro patterns occur millions of times in programs like the Linux kernel and GCC, appearing on average once every 23 lines. We show there is a strong correlation between these confusing patterns and bug-ix commits as well as a tendency for confusing patterns to be commented. We also explore patterns at the project level showing the rate of security vulnerabilities is higher in projects with more atoms. Finally, we examine real code examples containing these atoms, including ones that were used to ind and ix bugs in our corpus. In total this work demonstrates that beyond simple misunderstanding in the lab setting, atoms of confusion are both prevalent - occurring often in real projects, and meaningful - being removed by bug-fix commits at an elevated rate.",2574-3864;2574-3848,978-1-4503-5716-6978-1-5386-6171,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8595211,Programming Languages;Program Understanding,Atomic measurements;Software;Computer bugs;Linux;Computers;Syntactics;Semantics,C++ language;Linux;program debugging;public domain software;security of data;software development management,confusing patterns;confusing micropatterns;project level;confusing code;software projects;extremely small code patterns;implicit type conversion;open source C;C++ projects;Linux kernel;GCC;security vulnerabilities;ind bugs;bug-fix commits,,,35,,,,,IEEE,IEEE Conferences
Pruning the AST with Hunks to Speed up Tree Differencing,C. Yang; E. J. Whitehead,"School of Computer Science and Technology, QILU University of Technology(Shandong Academy of Sciences), Shandong, China; Dept. of Computational Media, University of California, Santa Cruz, Santa Cruz, USA","2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)",,2019,,,15,25,"Inefficiency is a problem in tree-differencing approaches. As textual-differencing approaches are highly efficient and the hunks returned by them reflect the line range of the modified code, we propose a novel approach to prune the AST with hunks. We define the pruning strategies at the declaration level and the statement level, respectively. And, we have designed an algorithm to implement the strategies. Furthermore, we have integrated the algorithm to Change Distiller and GumTree. Through an evaluation on four open source projects, the results show that the approach is very effective in reducing the number of nodes and shortening the running time. On average, with declaration-level pruning, the number of nodes in the two tools is reduced by at least 64%. With statement-level pruning, the number of nodes in both tools is reduced by at least 74%. By using the declaration-level pruning and the statement-level pruning, GumTree's runtime is reduced by at least 70% and 75%, respectively.",1534-5351,978-1-7281-0591-8978-1-7281-0592,10.1109/SANER.2019.8668032,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8668032,tree-differencing;tree pruning;software evolution;program understanding,Tools;Couplings;Software;Filtering algorithms;Runtime;Syntactics;Computer science,public domain software;software engineering;trees (mathematics),AST;hunks;tree differencing;pruning strategies;open source projects;declaration-level pruning;statement-level pruning;Change Distiller;GumTree;textual-differencing,,,18,,,,,IEEE,IEEE Conferences
Automatic Segmentation of Method Code into Meaningful Blocks to Improve Readability,X. Wang; L. Pollock; K. Vijay-Shanker,NA; NA; NA,2011 18th Working Conference on Reverse Engineering,,2011,,,35,44,"With the goal of increasing program readability for easier understanding, coding guidelines often include formatting standards such as indenting loop and conditional branch body statements. Similarly, good programming practice suggests that programmers use blank lines to visibly delineate between code segments that represent different algorithmic steps or high level actions. Unfortunately, programmers do not always follow these guidelines. While editors and IDEs can easily indent code based on syntax, they do not currently support automatic blank line insertion, which presents more significant challenges involving the semantics. This paper presents a heuristic solution to the automatic blank line insertion problem, by leveraging both program structure and naming information to identify ""meaningful blocks"", consecutive statements that logically implement a high level action. Our tool, SEGMENT, takes as input a Java method, and outputs a segmented version that separates meaningful blocks by vertical spacing. We report on an evaluation of the effectiveness of SEGMENT based on developers' opinions. SEGMENT assists in making users obtain an overall picture of a method's actions and comprehend it quicker r as well as provides hints for internal documentation placement.",2375-5369;1095-1350,978-1-4577-1948,10.1109/WCRE.2011.15,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079773,program understanding;readability;software tool;automatic formatting,Syntactics;Java;Semantics;Humans;Reverse engineering;Encoding;Compounds,document handling;Java;program compilers;software maintenance;source coding,automatic method code segmentation;program readability;formatting standards;indenting loop;conditional branch body statements;blank lines;IDE;automatic blank line insertion problem;SEGMENT;Java method;internal documentation placement,,14,31,,,,,IEEE,IEEE Conferences
On State Machine Mining from Embedded Control Software,W. Said; J. Quante; R. Koschke,NA; NA; NA,2018 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2018,,,138,148,"Program understanding is a time-consuming and tedious activity for software developers. Manually building abstractions from source code requires in-depth analysis of the code in the first place. Model mining can support program comprehension by semi-automatically extracting high-level models from code. One potentially helpful model is a state machine, which is an established formalism for specifying the behavior of a software component. There exist only few approaches for state machine mining, and they either deal with object-oriented systems or expect specific state implementation patterns. Both preconditions are usually not met by real-world embedded control software written in procedural languages. Other approaches extract only API protocols instead of the component's behavior. In this paper, we propose and evaluate several techniques that enable state machine mining from embedded control code: 1) We define criteria for state variables in procedural code based on an empirical study. This enables adaptation of an existing approach for extracting state machines from object-oriented software to embedded control code. 2) We present a refinement of the transition extraction process of that approach by removing infeasible transitions, which on average leads to more than 50% reduction of the number of transitions. 3) We evaluate two approaches to reduce the complexity of transition conditions. 4) An empirical study examines the limits of transition conditions' complexity that can still be understood by humans. These techniques and studies constitute major building blocks towards mining understandable state machines from embedded control software.",2576-3148;1063-6773,978-1-5386-7870-1978-1-5386-7871,10.1109/ICSME.2018.00024,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530024,software maintenance;program understanding;static analysis;model mining;state machines;boolean minimization;embedded software;legacy code,Software;Object oriented modeling;Data mining;Complexity theory;Switches;Cost accounting;Process control,data mining;embedded systems;finite state machines;object-oriented programming;source code (software),state machine mining;software developers;source code;model mining;software component;real-world embedded control software;embedded control code;state variables;procedural code;object-oriented software;transition extraction process;program understanding;program comprehension;object-oriented systems,,2,36,,,,,IEEE,IEEE Conferences
Towards Understandable Guards of Extracted State Machines from Embedded Software,W. Said; J. Quante; R. Koschke,"Robert Bosch GmbH, Renningen, Germany; Robert Bosch GmbH, Renningen, Germany; University of Bremen, Bremen, Germany","2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)",,2019,,,264,274,"The extraction of state machines from complex software systems can be very useful to understand the behavior of a software, which is a prerequisite for other software activities, such as maintenance, evolution and reengineering. However, using static analysis to extract state machines from real-world embedded software often leads to models that cannot be understood by humans: The extracted models contain a high number of states and transitions and very complex guards (transition conditions). Integrating user interaction into the extraction process can reduce these state machines to an acceptable size. However, the problem of highly complex guards remains. In this paper, we present a novel approach to reduce the complexity of guards in such state machines to a degree that is understandable for humans. The conditions are reduced by a combination of heuristic logic minimization, masking of infeasible paths, and using transition priorities. The approach is evaluated with software developers on industrial embedded C code. The results show that the approach is highly effective in making the guards understandable. Our controlled experiment shows that guards reduced by our approach and presented with priorities are easier to understand than guards without priorities.",1534-5351,978-1-7281-0591-8978-1-7281-0592,10.1109/SANER.2019.8667983,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8667983,software reengineering;program understanding;static analysis;model mining;state machines;boolean minimization;embedded software;legacy code,Complexity theory;Minimization;Object oriented modeling;Cost accounting;Embedded software;Analytical models,C language;embedded systems;finite state machines;formal logic;minimisation;program diagnostics;software engineering;source code (software),software developers;complex software systems;software activities;extraction process;state machines;embedded software;heuristic logic minimization;transition priorities;industrial embedded C code;complex guards,,,29,,,,,IEEE,IEEE Conferences
Building Approximate Calling Context from Partial Call Traces,M. Serrano; X. Zhuang,NA; NA,2009 International Symposium on Code Generation and Optimization,,2009,,,221,230,"We present an approach for building calling context information useful for program understanding, performance analysis and optimizations. Our approach exploits a lightweight profiling mechanism providing partial call traces. The goal is to reconstruct calling context information as accurately as possible, and to help the user navigate through it. We propose three steps to merge partial call traces into a smaller number of partial calling context trees. We intend to minimize errors such that the final partial contexts represent actual components of the real calling context tree with a very high probability. The first step concatenates call traces based on their common sequences. The second step converts call traces into partial calling context trees, and the last step merges partial context trees through maximal matching. To gauge how well the merged trees represent the full calling context tree, several criteria are presented. Our results indicate that call traces are successfully merged into a small number of large calling context trees. The merged trees are highly accurate.We have also developed a semi-automatic tool to navigate across partial calling context trees for program understanding and performance analysis purposes. Our results for several Java benchmarks show that our merging strategies exhibit a maximum 1% inaccuracy when compared to the exact solution.",,978-0-7695-3576,10.1109/CGO.2009.12,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4907666,Calling Context Tree;Call Context Analysis;Program Understanding,Performance analysis;Legged locomotion;Instruments;Sampling methods;Navigation;Operating systems;Hardware;Java;Merging;Monitoring,optimising compilers;pattern matching;probability;program debugging;program diagnostics;reverse engineering;tree data structures,partial call trace;approximate calling context information building;program understanding;performance analysis;program optimization;lightweight profiling mechanism;partial calling context tree;probability;maximal matching;semi automatic tool,,10,20,,,,,IEEE,IEEE Conferences
Discovering Comprehension Pitfalls in Class Hierarchies,P. F. Mihancea; R. Marinescu,NA; NA,2009 13th European Conference on Software Maintenance and Reengineering,,2009,,,7,16,"Despite many advances in program comprehension, polymorphism and inheritance are still the cause of many misunderstandings in object-oriented code. In this paper, we present a suite of such concrete, recurrent patterns where particular ways of using inheritance and polymorphism can easily mislead developers and maintainers during software understanding activities. We define these as comprehension pitfalls. Furthermore, the paper describes a metric-based approach aimed to automatically detect such situations in code. The experimental results presented in this paper, based on three medium-sized systems, indicate that the identified comprehension pitfalls and the approach used to detect them are a promising support for maintenance.",1534-5351,978-1-4244-3755-9978-0-7695-3589,10.1109/CSMR.2009.31,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812734,program understanding;polymorphism;inheritance;metrics,Software maintenance;Costs;Concrete;Computer bugs;Electronic mail;Target tracking;Application software;Software systems;Software engineering;Maintenance engineering,object-oriented methods;reverse engineering;software maintenance,comprehension pitfalls;class hierarchies;program comprehension;object-oriented code;recurrent patterns;software understanding activities;medium-sized systems;program understanding,,2,24,,,,,IEEE,IEEE Conferences
Towards the Extraction of Domain Concepts from the Identifiers,S. L. Abebe; P. Tonella,NA; NA,2011 18th Working Conference on Reverse Engineering,,2011,,,77,86,"Program identifiers represent an invaluable source of information for developers who are not familiar with the code to be evolved. Domain concepts and inter-concept relationships can be automatically extracted by means of natural language processing techniques applied to the program identifiers. However, the ontology produced by this approach tends to be very large and to include implementation details that reduce its usefulness for domain concept understanding. In this paper, we analyze the effectiveness of information retrieval based techniques used to filter domain concepts and relations from the implementation details, so as to obtain a smaller, more informative domain ontology. In particular, we show that fully automated techniques based on keywords or topics have quite poor performance, while a semi-automated approach, requiring limited user involvement, can highly improve the filtering of domain concepts.",2375-5369;1095-1350,978-1-4577-1948,10.1109/WCRE.2011.19,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079777,Program understanding;ontology extraction;domain concept filtering;information retrieval,Ontologies;Gold;Servers;Manuals;Documentation;Filtering;Natural languages,information filtering;natural language processing;ontologies (artificial intelligence),domain concept extraction;program identifier;natural language processing technique;domain concept understanding;information retrieval based techniques;domain ontology;domain concept filtering,,10,26,,,,,IEEE,IEEE Conferences
Feature Location Using Probabilistic Ranking of Methods Based on Execution Scenarios and Information Retrieval,D. Poshyvanyk; Y. Gueheneuc; A. Marcus; G. Antoniol; V. Rajlich,"Department of Computer Science, Wayne State University, Detroit, MI; Departement d'informatique et recherche operationnelle, Universite de Montreal, Center-Ville, Monrreal Quebec, Canada; Department of Computer Science, Wayne State University, Detroit, MI; Departement d'informatique, Ecole Polytechnique de Montreal, Centre-Ville, Montreal, Quebec, Canada; Department of Computer Science, Wayne State University, Detroit, MI",IEEE Transactions on Software Engineering,,2007,33,6,420,432,"This paper recasts the problem of feature location in source code as a decision-making problem in the presence of uncertainty. The solution to the problem is formulated as a combination of the opinions of different experts. The experts in this work are two existing techniques for feature location: a scenario-based probabilistic ranking of events and an information-retrieval-based technique that uses latent semantic indexing. The combination of these two experts is empirically evaluated through several case studies, which use the source code of the Mozilla Web browser and the Eclipse integrated development environment. The results show that the combination of experts significantly improves the effectiveness of feature location as compared to each of the experts used independently",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2007.1016,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4181710,Program understanding;feature identification;concept location;dynamic and static analyses;information retrieval;Latent Semantic Indexing;scenario-based probabilistic ranking;open source software.,Information retrieval;Performance analysis;Indexing;Programming profession;Computer Society;Decision making;Uncertainty;Information analysis;Open source software;Computer bugs,decision making;information retrieval;probability;program diagnostics,feature location;information retrieval;decision-making problem;scenario-based probabilistic event ranking;latent semantic indexing;Mozilla Web browser;Eclipse integrated development,,224,49,,,,,IEEE,IEEE Journals
Recovering Views of Inter-System Interaction Behaviors,C. Ackermann; M. Lindvall; R. Cleaveland,NA; NA; NA,2009 16th Working Conference on Reverse Engineering,,2009,,,53,61,"This paper presents an approach for recovering application-level views of the interaction behaviors between systems that communicate via networks. Rather than illustrating a single behavior, a sequence diagram is constructed that describes the characteristics of multiple combined behaviors. The approach has several properties that make it particularly suitable for analyzing heterogeneous systems. First, since the interactions are retrieved from observing the network communication, our technique can be applied to systems that are implemented in different languages and run on different platforms. Second, it does not require the availability or modification of source code. After the behaviors are extracted, we employ methods to merge multiple observed behaviors to a single sequence diagram that illustrates the overall behavior.The contributions of this paper are a technique for observing and processing the network communication to derive a model of the behavior. Furthermore, it describes a series of model transformations to construct a sequence diagram view of all observed behaviors.",1095-1350;2375-5369,978-0-7695-3867,10.1109/WCRE.2009.34,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5328697,Program understanding;distributed systems;reliability,Data mining;Reverse engineering;Monitoring;Telecommunication traffic;Software engineering;Educational institutions;Telecommunication network reliability;Software systems;Instruments;Visualization,distributed processing;reverse engineering,intersystem interaction behaviors;sequence diagram;heterogeneous systems;network communication;reverse engineering;distributed systems;program understanding,,5,12,,,,,IEEE,IEEE Conferences
Feature Identification: An Epidemiological Metaphor,G. Antoniol; Y. -. Gueheneuc,NA; NA,IEEE Transactions on Software Engineering,,2006,32,9,627,641,"Feature identification is a technique to identify the source code constructs activated when exercising one of the features of a program. We propose new statistical analyses of static and dynamic data to accurately identify features in large multithreaded object-oriented programs. We draw inspiration from epidemiology to improve previous approaches to feature identification and develop an epidemiological metaphor. We build our metaphor on our previous approach to feature identification, in which we use processor emulation, knowledge-based filtering, probabilistic ranking, and metamodeling. We carry out three case studies to assess the usefulness of our metaphor, using the ""save a bookmark"" feature of Web browsers as an illustration. In the first case study, we compare our approach with three previous approaches (a naive approach, a concept analysis-based approach, and our previous probabilistic approach) in identifying the feature in MOZILLA, a large, real-life, multithreaded object-oriented program. In the second case study, we compare the implementation of the feature in the FIREFOX and MOZILLA Web browsers. In the third case study, we identify the same feature in two more Web browsers, Chimera (in C) and ICEBrowser (in Java), and another feature in JHOTDRAW and XFIG, to highlight the generalizability of our metaphor",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2006.88,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1707664,Program understanding;dynamic analysis;static analysis;feature identification;epidemiology;Firefox and Mozilla Web browsers.,Microarchitecture;Statistical analysis;Emulation;Filtering;Uniform resource locators;Metamodeling;Java;Software maintenance;Data structures;Documentation,multi-threading;object-oriented programming;program diagnostics;software maintenance;statistical analysis,feature identification;epidemiological metaphor;source code identification;statistical analysis;multithreaded object-oriented program;processor emulation;knowledge-based filtering;probabilistic ranking;metamodeling;Web browser;naive approach;concept analysis-based approach;MOZILLA;FIREFOX;Chimera;ICEBrowser;JHOTDRAW;XFIG;program understanding;dynamic program analysis;static program analysis;software maintenance;legacy software,,46,45,,,,,IEEE,IEEE Journals
I Know What You Did Last Summer - An Investigation of How Developers Spend Their Time,R. Minelli; A. Mocci; M. Lanza,NA; NA; NA,2015 IEEE 23rd International Conference on Program Comprehension,,2015,,,25,35,"Developing software is a complex mental activity, requiring extensive technical knowledge and abstraction capabilities. The tangible part of development is the use of tools to read, inspect, edit, and manipulate source code, usually through an IDE (integrated development environment). Common claims about software development include that program comprehension takes up half of the time of a developer, or that certain UI (user interface) paradigms of IDEs offer insufficient support to developers. Such claims are often based on anecdotal evidence, throwing up the question of whether they can be corroborated on more solid grounds. We present an in-depth analysis of how developers spend their time, based on a fine-grained IDE interaction dataset consisting of ca. 740 development sessions by 18 developers, amounting to 200 hours of development time and 5 million of IDE events. We propose an inference model of development activities to precisely measure the time spent in editing, navigating and searching for artifacts, interacting with the UI of the IDE, and performing corollary activities, such as inspection and debugging. We report several interesting findings which in part confirm and reinforce some common claims, but also disconfirm other beliefs about software development.",1092-8138,978-1-4673-8159-8978-1-4673-8158,10.1109/ICPC.2015.12,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181430,interaction data;empirical study;program understanding;user interface,Mice;Keyboards;Navigation;Browsers;Inspection;Software;History,software engineering,software development;IDE;fine-grained IDE interaction dataset;user interface,,31,37,,,,,IEEE,IEEE Conferences
An XML C Source Code Interchange Format for CASE Tools,N. Atsumi; T. Kobayashi; S. Yamamoto; K. Agusa,NA; NA; NA; NA,2011 IEEE 35th Annual Computer Software and Applications Conference,,2011,,,498,503,"We propose an XML C source code representation to support developing CASE tools. Since source code is a main artifact of software development, most CASE tools have some features related to source code editor, static analyzer, profiler, etc. To develop such tools, detailed information related to source code is needed. However, it is quite difficult to reuse program analysis features because they do not have common interfaces even for parsing and data/control-flow analysis that are most common features for such CASE tools. To address this issue, we focus on XML as an intermediate representation for source code information. Existing XML representations only represent structure of syntax trees and lack some important information required for CASE tools. We propose two models for representing source code, one is for intra-file information, which consists of syntax structure, flow, and type information, the other is for inter-file relation, which is cross-reference information. We also introduce CASE tools with our representation and demonstrate the efficacy in CASE tool development. To evaluate the efficacy, we show that a coding rule checker and a cross-referencer can be easily implemented using common XML processing libraries such as XSLT and XPath.",0730-3157;0730-3157;0730-3157,978-1-4577-0544-1978-0-7695-4439,10.1109/COMPSAC.2011.102,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032387,Program Analysis;CASE Tool Program Understanding;Coding Checker,XML;Computer aided software engineering;Syntactics;Encoding;Semantics;Data mining;Switches,data flow analysis;software engineering;XML,XML C source code interchange format;CASE tools;XML C source code representation;software development;source code editor;static analyzer;program analysis feature;parsing;data flow analysis;control flow analysis;source code information;syntax trees;syntax structure;coding rule checker;cross-referencer;XML processing libraries;XSLT;XPath,,2,23,,,,,IEEE,IEEE Conferences
Bit-Level Taint Analysis,B. Yadegari; S. Debray,NA; NA,2014 IEEE 14th International Working Conference on Source Code Analysis and Manipulation,,2014,,,255,264,"Taint analysis has a wide variety of applications in software analysis, making the precision of taint analysis an important consideration. Current taint analysis algorithms, including previous work on bit-precise taint analyses, suffer from shortcomings that can lead to significant loss of precision (under/over tainting) in some situations. This paper discusses these limitations of existing taint analysis algorithms, shows how they can lead to imprecise taint propagation, and proposes a generalization of current bit-level taint analysis techniques to address these problems and improve their precision. Experiments using a deobfuscation tool indicate that our enhanced taint analysis algorithm leads to significant improvements in the quality of deobfuscation.",,978-1-4799-6148,10.1109/SCAM.2014.43,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6975659,Taint Analysis;Reverse Engineering;Program Understanding,Algorithm design and analysis;Semantics;Registers;Standards;Heuristic algorithms;Data handling;Performance analysis,data flow analysis,software analysis;taint analysis algorithms;bit-precise taint analysis;taint propagation;bit-level taint analysis;deobfuscation tool,,8,31,,,,,IEEE,IEEE Conferences
Measuring Code Quality to Improve Specification Mining,C. Le Goues; W. Weimer,"University of Virginia, Charlottesville; University of Virginia, Charlottesville",IEEE Transactions on Software Engineering,,2012,38,1,175,190,"Formal specifications can help with program testing, optimization, refactoring, documentation, and, most importantly, debugging and repair. However, they are difficult to write manually, and automatic mining techniques suffer from 90-99 percent false positive rates. To address this problem, we propose to augment a temporal-property miner by incorporating code quality metrics. We measure code quality by extracting additional information from the software engineering process and using information from code that is more likely to be correct, as well as code that is less likely to be correct. When used as a preprocessing step for an existing specification miner, our technique identifies which input is most indicative of correct program behavior, which allows off-the-shelf techniques to learn the same number of specifications using only 45 percent of their original input. As a novel inference technique, our approach has few false positives in practice (63 percent when balancing precision and recall, 3 percent when focused on precision), while still finding useful specifications (e.g., those that find many bugs) on over 1.5 million lines of code.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2011.5,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5680914,Specification mining;machine learning;software engineering;code metrics;program understanding.,Software measurement;Refactoring;Data mining;Maintenance engineering;Cloning;Optimization,data mining;formal specification;program debugging;program testing;software quality,specification mining;formal specifications;program testing;optimization;refactoring;documentation;debugging;repair;automatic mining techniques;temporal-property miner;code quality metrics;software engineering process,,13,61,,,,,IEEE,IEEE Journals
Understanding Source Code Differences by Separating Refactoring Effects,S. Thangthumachit; S. Hayashi; M. Saeki,NA; NA; NA,2011 18th Asia-Pacific Software Engineering Conference,,2011,,,339,347,"Comparing and understanding differences between old and new versions of source code are necessary in various software development situations. However, if refactoring is applied between those versions, then the source code differences are more complicated, and understanding them becomes more difficult. Although many techniques for extracting refactoring effects from the differences have been studied, it is necessary to exclude the extracted refactorings' effects and reconstruct the differences for meaningful and understandable ones with no refactoring effect. As described in this paper, we propose a novel technique to address this difficulty. Using our technique, we extract the refactoring effects and then apply them to the old version of source code to produce the differences without refactoring effects. We also implemented a support tool that helps separate refactorings automatically. An evaluation of open source software showed that our tool is applicable to all target refactorings. Our technique is therefore useful in real situations. Evaluation testing also demonstrated that the approach reduced the code differences more than 21%, on average, and that developers can understand more changes from the differences using our approach than when using the original one in the same limited time.",1530-1362;1530-1362;1530-1362,978-1-4577-2199-1978-0-7695-4609,10.1109/APSEC.2011.47,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6130705,source code differencing;program understanding;refactoring,Synchronization;Open source software;Programming;Testing;Java;Data mining;Browsers,program debugging;software engineering;source coding,source code differences;refactoring effect separation;software development;open source software;software testing;software debugging,,4,20,,,,,IEEE,IEEE Conferences
Can Lexicon Bad Smells Improve Fault Prediction?,S. L. Abebe; V. Arnaoudova; P. Tonella; G. Antoniol; Y. Guéhéneuc,NA; NA; NA; NA; NA,2012 19th Working Conference on Reverse Engineering,,2012,,,235,244,"In software development, early identification of fault-prone classes can save a considerable amount of resources. In the literature, source code structural metrics have been widely investigated as one of the factors that can be used to identify faulty classes. Structural metrics measure code complexity, one aspect of the source code quality. Complexity might affect program understanding and hence increase the likelihood of inserting errors in a class. Besides the structural metrics, we believe that the quality of the identifiers used in the code may also affect program understanding and thus increase the likelihood of error insertion. In this study, we measure the quality of identifiers using the number of Lexicon Bad Smells (LBS) they contain. We investigate whether using LBS in addition to structural metrics improves fault prediction. To conduct the investigation, we assess the prediction capability of a model while using i) only structural metrics, and ii) structural metrics and LBS. The results on three open source systems, ArgoUML, Rhino, and Eclipse, indicate that there is an improvement in the majority of the cases.",2375-5369;1095-1350,978-0-7695-4891-3978-1-4673-4536,10.1109/WCRE.2012.33,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385119,Fault prediction;lexicon bad smells;structural metrics;program understanding,Measurement;Predictive models;Principal component analysis;Computational modeling;Logistics;Support vector machines;Fault diagnosis,computational complexity;public domain software;software fault tolerance;software metrics;Unified Modeling Language,fault prediction;software development;fault-prone classes;source code structural metrics;faulty classes;structural metrics;code complexity;source code quality;error insertion likelihood;lexicon bad smells;LBS;open source systems;ArgoUML;Rhino;Eclipse,,14,33,,,,,IEEE,IEEE Conferences
Automatic Extraction of Heap Reference Properties in Object-Oriented Programs,B. Demsky; M. Rinard,"University of California, Irvine, Irvine; Massachusetts Institute of Technology, Cambridge",IEEE Transactions on Software Engineering,,2009,35,3,305,324,"We present a new technique for helping developers understand heap referencing properties of object-oriented programs and how the actions of the program affect these properties. Our dynamic analysis uses the aliasing properties of objects to synthesize a set of roles; each role represents an abstract object state intended to be of interest to the developer. We allow the developer to customize the analysis to explore the object states and behavior of the program at multiple different and potentially complementary levels of abstraction. The analysis uses roles as the basis for three abstractions: role transition diagrams, which present the observed transitions between roles and the methods responsible for the transitions; role relationship diagrams, which present the observed referencing relationships between objects playing different roles; and enhanced method interfaces, which present the observed roles of method parameters. Together, these abstractions provide useful information about important object and data structure properties and how the actions of the program affect these properties. We have implemented the role analysis and have used this implementation to explore the behavior of several Java programs. Our experience indicates that, when combined with a powerful graphical user interface, roles are a useful abstraction for helping developers explore and understand the behavior of object-oriented programs.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2008.91,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4693716,Program understanding;roles;design recovery.;Requirements/Specifications;Design Tools and Techniques;Software Engineering;Software/Software Engineering;Testing and Debugging,Data structures;Computer Society;Java;Graphical user interfaces;Information analysis;Data mining,data structures;diagrams;graphical user interfaces;Java;object-oriented programming;reverse engineering,automatic extraction;heap reference property;object-oriented program;role transition diagram;enhanced method interface;data structure;Java program;graphical user interface;program understanding;role relationship diagram,,2,30,,,,,IEEE,IEEE Journals
On the Discovery of Business Processes Orchestration Patterns,N. M. F. Rodrigues; L. S. Barbosa,NA; NA,2008 IEEE Congress on Services - Part I,,2008,,,391,398,"COORDINSPECTOR is a Software Tool aiming at extracting the coordination layer of a software system. Such a reverse engineering process provides a clear view of the actually invoked services as well as the logic behind such invocations. The analysis process is based on program slicing techniques and the generation of, system dependence graphs and coordination dependence graphs. The tool analyzes common intermediate language (CIL), the native language of the Microsoft .Net Framework, thus making suitable for processing systems developed in any .Net Framework compilable language. COORDINSPECTOR generates graphical representations of the coordination layer together with business process orchestrations specified in WSBPEL 2.0.",2378-3818,978-0-7695-3286,10.1109/SERVICES-1.2008.58,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4578352,Service Discovery;Reverse Engineering;Program Understanding;Program Slicing;Sofware Architectures,,business data processing;graph theory;program slicing;reverse engineering,business processes orchestration pattern;CoordInspector;reverse engineering process;program slicing technique;system dependence graph;coordination dependence graph;common intermediate language,,,9,,,,,IEEE,IEEE Conferences
Identifying Features of Android Apps from Execution Traces,Q. Xin; F. Behrang; M. Fazzini; A. Orso,Georgia Institute of Technology; Georgia Institute of Technology; Georgia Institute of Technology; Georgia Institute of Technology,2019 IEEE/ACM 6th International Conference on Mobile Software Engineering and Systems (MOBILESoft),,2019,,,35,39,"Understanding a program and the features it provides is essential for a number of software engineering tasks, including refactoring, debugging, and debloating. Unfortunately, program understanding and feature identification are also extremely challenging and time consuming activities. To support developers when they perform these activities, we propose FeatureFinder, an approach that aims to identify and understand the features of a program by analyzing its executions. Specifically, we defined our approach for Android apps, given their widespread use. Given an app, FeatureFinder generates traces that capture different properties of the app executions through instrumentation. It then leverages the user events in the trace to split the trace into segments, and clusters these segments based on their characteristics, using a classifier. Each identified cluster indicates a feature exercised in the execution. Finally, FeatureFinder suitably labels each identified cluster, so as to provide a human-readable description of the corresponding feature. We performed a case study in which we used FeatureFinder to identify features in two executions of the K-9 MAIL app. In the study, FeatureFinder was able to correctly identify 6 of the 11 manually identified features, which we believe is an encouraging result and motivates further research.",,978-1-7281-3395-9978-1-7281-3396,10.1109/MOBILESoft.2019.00015,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8816950,feature identification;program understanding;trace analysis,,,,,,24,,,,,IEEE,IEEE Conferences
Using Dataflow Information for Concern Identification in Object-Oriented Software Systems,M. Trifu,"FZI Forschungszentrum Informatik, 10-14 Haid-und-Neu Str., Karlsruhe, Germany, mtrifu@fzi.de",2008 12th European Conference on Software Maintenance and Reengineering,,2008,,,193,202,"Improper encapsulation of cross-cutting concerns significantly hinders software understandability and contributes to rising software maintenance costs. Concern identification covers the necessary first step towards separating and encapsulating concerns in existing object-oriented code. Because most of the current approaches rely on syntactic rather than semantic information, they do not provide sufficient support for software understanding. This paper proposes a new semi-automated approach for concern identification specifically designed to support software understanding, which starts from a set of related variables and uses static dataflow information to determine the concern skeleton, a data-oriented abstraction of a concern. We discuss the application of this approach to the JHotDraw case-study, the de facto standard benchmark for concern identification, and show that it can be used to identify a significant number of concerns, including several concerns not previously discussed in the existing literature.",1534-5351,978-1-4244-2157,10.1109/CSMR.2008.4493314,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4493314,concern identification;program understanding;feature extraction;dataflow analysis,Software systems;Software maintenance;Skeleton;Encapsulation;Costs;Software design;Application software;Feature extraction;Data analysis;Computer science,object-oriented methods;software maintenance,static dataflow information;concern identification;object-oriented software systems;cross-cutting concerns;software understandability;software maintenance costs;data-oriented abstraction;JHotDraw case-study,,12,21,,,,,IEEE,IEEE Conferences
The impact of component interconnections on software quality: A network analysis approach,L. Jiang; K. M. Carley; M. W. Bigrigg; A. Eberlein; M. Galster,"School of Computer Science, University of Adelaide, Australia; Institute of Software Research, Carnegie Mellon University, USA; Institute of Software Research, Carnegie Mellon University, USA; Department of Computer Science & Engineering, American University of Sharjah, UAE; University of Groningen, The Netherlands","2012 IEEE International Conference on Systems, Man, and Cybernetics (SMC)",,2012,,,1865,1872,"The growing complexity of software has posed challenges for the design, understanding and maintenance of software. Software developers often spend a lot of effort on understanding how software components are connected. Through analysis of the data obtained from a real software application, this paper demonstrates that network analysis approaches can help understand software component interconnections and their impact on software quality. Additionally, this paper shows that there is a correlation between the number of bugs found in an application and a set of measures used in component (interconnection) networks. Furthermore, a case study showed that the software performance improved over two releases as a result of improving the component network.",1062-922X,978-1-4673-1714-6978-1-4673-1713-9978-1-4673-1712,10.1109/ICSMC.2012.6378010,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6378010,Component network;software quality;program understanding;network science;centrality;network measures,Software;Educational institutions;USA Councils;Australia;Computer bugs;Complexity theory;Measurement,network theory (graphs);software maintenance;software metrics;software quality,component interconnection;software quality;network analysis approach;software complexity;software design;software understanding;software maintenance;software component;data analysis;software application;interconnection network;software performance,,,26,,,,,IEEE,IEEE Conferences
iFL: An interactive environment for understanding feature implementations,S. Hayashi; K. Sekine; M. Saeki,"Tokyo Institute of Technology, 152-8552, Japan; Tokyo Institute of Technology, 152-8552, Japan; Tokyo Institute of Technology, 152-8552, Japan",2010 IEEE International Conference on Software Maintenance,,2010,,,1,5,"We propose iFL, an interactive environment that is useful for effectively understanding feature implementation by application of feature location (FL). With iFL, the inputs for FL are improved incrementally by interactions between users and the FL system. By understanding a code fragment obtained using FL, users can find more appropriate queries from the identifiers in the fragment. Furthermore, the relevance feedback obtained by partially judging whether or not a fragment is relevant improves the evaluation score of FL. Users can then obtain more accurate results. Case studies with iFL show that our interactive approach is feasible and that it can reduce the understanding cost more effectively than the non-interactive approach.",1063-6773;1063-6773,978-1-4244-8629-8978-1-4244-8630-4978-1-4244-8628,10.1109/ICSM.2010.5609669,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609669,program understanding;feature/concept location;relevance feedback,Schedules;Java;Biological system modeling;Software;Navigation;Information retrieval;Natural languages,relevance feedback;reverse engineering;software maintenance,interactive environment;iFL;feature location;code fragment understanding;relevance feedback;software maintenance,,5,16,,,,,IEEE,IEEE Conferences
"Syntax, Predicates, Idioms - What Really Affects Code Complexity?",S. Ajami; Y. Woodbridge; D. G. Feitelson,NA; NA; NA,2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC),,2017,,,66,76,"Program comprehension concerns the ability to understand code written by others. But not all code is the same. We use an experimental platform fashioned as an online game-like environment to measure how quickly and accurately 222 professional programmers can interpret code snippets with similar functionality but different structures. The results indicate, inter alia, that 'for' loops are significantly harder than 'if's, that some but not all negations make a predicate harder, and that loops counting down are slightly harder than loops counting up. This demonstrates how the effect of syntactic structures, different ways to express predicates, and the use of known idioms can be measured empirically, and that syntactic structures are not necessarily the most important factor. By amassing many more empirical results like these it may be possible to derive better code complexity metrics than we have today.",,978-1-5386-0535-6978-1-5386-0536,10.1109/ICPC.2017.39,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961505,Code complexity;program understanding;gamification,Complexity theory;Compounds;Syntactics;Programming;Context;Time measurement,computational linguistics;professional aspects;program control structures;program interpreters;reverse engineering;software metrics,program comprehension;online game-like environment;professional programmers;code snippets;code interpretation;loops;syntactic structures;predicates;idioms;code complexity metrics,,1,44,,,,,IEEE,IEEE Conferences
Support vector machines for anti-pattern detection,A. Maiga; N. Ali; N. Bhattacharya; A. Sabané; Y. Guéhéneuc; G. Antoniol; E. Aïmeur,"Université de Montréal, Canada; École Polytechnique de Montréal, Canada; École Polytechnique de Montréal, Canada; École Polytechnique de Montréal, Canada; École Polytechnique de Montréal, Canada; École Polytechnique de Montréal, Canada; Université de Montréal, Canada",2012 Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering,,2012,,,278,281,"Developers may introduce anti-patterns in their software systems because of time pressure, lack of understanding, communication, and--or skills. Anti-patterns impede development and maintenance activities by making the source code more difficult to understand. Detecting anti-patterns in a whole software system may be infeasible because of the required parsing time and of the subsequent needed manual validation. Detecting anti-patterns on subsets of a system could reduce costs, effort, and resources. Researchers have proposed approaches to detect occurrences of anti-patterns but these approaches have currently some limitations: they require extensive knowledge of anti-patterns, they have limited precision and recall, and they cannot be applied on subsets of systems. To overcome these limitations, we introduce SVMDetect, a novel approach to detect anti-patterns, based on a machine learning technique---support vector machines. Indeed, through an empirical study involving three subject systems and four anti-patterns, we showed that the accuracy of SVMDetect is greater than of DETEX when detecting anti-patterns occurrences on a set of classes. Concerning, the whole system, SVMDetect is able to find more anti-patterns occurrences than DETEX.",,978-1-4503-1204-2978-1-4503-1204,10.1145/2351676.2351723,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6494935,Anti-pattern;empirical software engineering;program comprehension;program maintenance,,learning (artificial intelligence);software maintenance;support vector machines,support vector machines;antipattern detection;software systems;source code;parsing time;manual validation;SVMDetect;machine learning technique;DETEX,,10,13,,,,,IEEE,IEEE Conferences
Examining Programmer's Cognitive Skills Using Regular Language,A. Cox; M. Fisher,NA; NA,First International Conference on Advances in Computer-Human Interaction,,2008,,,249,256,"Regular expressions - a notation for regular languages - provide alternation and iteration operators, and can thus be viewed as highly simplified programming languages. Insight into the manipulation of regular expressions will consequently provide insight on the cognition underlying the human-computer interaction of programming. We predicted a relationship between accuracy and completeness, thereby indicating that no tradeoff exists, as one would expect to find in a pattern-matching task. As well, we hypothesised a close relationship between the tasks of pattern application and creation, since analogously to reading and writing, they potentially rely on associated cognitive abilities. Our findings indicate that one's skills in using regular expressions do not match one's ability to learn natural language, or to perform pattern matching. However, we do find evidence that the manipulation of regular expressions is similar to the manipulation of Boolean expressions and suggest that the ability to use formal languages, and hence program computers, is thus rooted in the skills associated with rule-based systems such as mathematics.",,978-0-7695-3086,10.1109/ACHI.2008.33,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4455990,formal language;regular languages;regular expressions;cognitive skills;programming skills;program comprehension,Formal languages;Boolean algebra;Computer languages;Pattern matching;Humans;Computer science;Psychology;Cognition;Writing;Natural languages,formal languages;human computer interaction;human factors;pattern matching;programming languages,programmer cognitive skill;regular language;regular expressions;programming languages;human-computer interaction;pattern matching task;formal languages;Boolean expressions,,,14,,,,,IEEE,IEEE Conferences
Enhancing Polymetric Views with Coarse-Grained Views,R. Francese; M. Risi; G. Scanniello; G. Tortora,NA; NA; NA; NA,2016 20th International Conference Information Visualisation (IV),,2016,,,57,62,"MetricAttitude is a visualization approach implemented in an environment that provides a mental picture by viewing an object-oriented software by means of polymetric views of classes (i.e., fine-grained). In this paper, we present an extension of MetricAttitude which visualizes a software by levels considering not only its class view but also its package views in terms of nested packages (i.e., coarse-grained). Packages are represented by using visual properties associated to Martin's metrics [15]. The new approach and its supporting visualization environment also allow showing relationships among packages.",2375-0138,978-1-4673-8942-6978-1-4673-8943,10.1109/IV.2016.33,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7557904,Polymetric Views;Program Comprehension;Reverse Engineering;Software Evolution;Software Maintenance;Software Metrics;Software Visualization,Software;Visualization;Couplings;Concrete;Software metrics;Color,software maintenance;software metrics,polymetric view enhancement;coarse-grained views;MetricAttitude visualization approach;object-oriented software;polymetric class views;fine-grained views;software visualization;nested package views;visual properties;Martin metrics,,1,24,,,,,IEEE,IEEE Conferences
Automatic generation of natural language summaries for Java classes,L. Moreno; J. Aponte; G. Sridhara; A. Marcus; L. Pollock; K. Vijay-Shanker,"Wayne State University, Detroit, MI, USA; Universidad Nacional de Colombia, Bogotá, Colombia; IBM Research India, Bangalore, India; Wayne State University, Detroit, MI, USA; University of Delaware, Newark, USA; University of Delaware, Newark, USA",2013 21st International Conference on Program Comprehension (ICPC),,2013,,,23,32,"Most software engineering tasks require developers to understand parts of the source code. When faced with unfamiliar code, developers often rely on (internal or external) documentation to gain an overall understanding of the code and determine whether it is relevant for the current task. Unfortunately, the documentation is often absent or outdated. This paper presents a technique to automatically generate human readable summaries for Java classes, assuming no documentation exists. The summaries allow developers to understand the main goal and structure of the class. The focus of the summaries is on the content and responsibilities of the classes, rather than their relationships with other classes. The summarization tool determines the class and method stereotypes and uses them, in conjunction with heuristics, to select the information to be included in the summaries. Then it generates the summaries using existing lexicalization tools. A group of programmers judged a set of generated summaries for Java classes and determined that they are readable and understandable, they do not include extraneous information, and, in most cases, they are not missing essential information.",1092-8138,978-1-4673-3092,10.1109/ICPC.2013.6613830,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613830,Source code summarization;program comprehension;documentation generation,Java;Production facilities;Context;Documentation;Taxonomy;Natural languages;Educational institutions,Java;natural language processing;software engineering;system documentation,automatic generation;natural language summary;Java classes;software engineering tasks;source code;internal documentation;external documentation;human readable summary;summarization tool;stereotypes;lexicalization tools;essential information,,76,23,,,,,IEEE,IEEE Conferences
Reflexion Models for State Machine Extraction and Verification,W. Said; J. Quante; R. Koschke,NA; NA; NA,2018 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2018,,,149,159,"High-level design models are often used for describing the behavior or structure of a software system. It is generally much easier and more adequate to understand a software system on this level than on the level of individual code lines. Such models are also created by developers as they gain an understanding of the software. Unfortunately, these models often do not correspond to what is really in the code. Murphy et al. introduced the idea of reflexion models in 1995 to overcome this problem. Their approach is today widely used for architecture conformance checking and reconstruction. In this paper, we introduce reflexion models for state machines. Our approach allows to check the correspondence of a hypothetical state machine model with the code. It returns information about convergence, partial convergence, divergence, or absence of the specified states and transitions. Similar to the original reflexion model, the approach can be used for conformance checking as well as interactive reverse engineering of state machine models. We concentrate on the latter and show the potential of the approach in several case studies.",2576-3148;1063-6773,978-1-5386-7870-1978-1-5386-7871,10.1109/ICSME.2018.00025,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530025,Software maintenance;program comprehension;state machines;reflexion model;model checking,Software;Computer architecture;Analytical models;Model checking;Cost accounting;Object oriented modeling;Tools,conformance testing;finite state machines;program verification;reverse engineering;software architecture;software maintenance,reflexion models;state machine extraction;high-level design models;software system;individual code lines;architecture conformance checking;state machines;hypothetical state machine model;specified states;original reflexion model;state machine models;interactive reverse engineering,,,31,,,,,IEEE,IEEE Conferences
An Interactive Microarray Call-Graph Visualization,M. D. Shah; S. Z. Guyer,NA; NA,2016 IEEE Working Conference on Software Visualization (VISSOFT),,2016,,,86,90,"In this paper we present an interactive call-graph visualization tool for viewing large programs. Our space-filling grid-based visualization shows the functions of a programs call-graph. The grid view provides an overview of all of the methods, allowing the user to investigate and view subsets of functions, and finally jump to source code for more details on demand. Our tool assists programmers by reducing large call graphs into smaller subgraphs with function relationships that matter for program comprehension. In our benchmarks, we view and explore code relationships in programs with 18,720 functions at interactive frame rates. We provide two use cases with several findings on investigating profile-guided optimizations in C++ and critical sections in concurrent Java programs. Our software visualization tool is Java based and portable across multiple platforms.",,978-1-5090-3850-3978-1-5090-3851,10.1109/VISSOFT.2016.14,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780162,Java;LLVM;Critical Sections;Concurrency;Program Comprehension;Software Visualization,Visualization;Data visualization;Software;Optimization;Java;Metadata,C++ language;concurrency control;interactive programming;Java;software tools;source code (software),interactive microarray call-graph visualization tool;space-filling grid-based visualization;program call- graph;grid view;source code;function relationships;program comprehension;code relationships;interactive frame rates;profile-guided optimization;C++ language;concurrent Java programs;software visualization tool,,1,20,,,,,IEEE,IEEE Conferences
Mediating Turf Battles! Prioritizing Shared Modules in Locating Multiple Features,M. Nakano; K. Noda; S. Hayashi; T. Kobayashi,NA; NA; NA; NA,2017 IEEE 41st Annual Computer Software and Applications Conference (COMPSAC),,2017,1,,363,368,"Dynamic feature location techniques (DFLTs), which use execution profiles of scenarios that trigger a feature, are a promising approach to locating features in the source code. A sufficient set of scenarios is key to obtaining highly accurate results, however, its preparation is laborious and difficult in practice. In most cases, a scenario exercises not only the desired feature but also other features. We focus on the relationship between a module and multiple features that can be calculated with no extra scenarios, to improve the accuracy of locating the desired feature in the source code. In this paper, we propose a DFLT using the odds ratios of the multiple relationships between modules and features. We use the similarity coefficient, which is used in fault localization techniques, as a relationship. Our DFLT better orders shared modules compared with an existing DFLT. To reduce developer costs in our DFLT, we also propose a filtering technique that uses formal concept analysis. We evaluate our DFLT on the features of an open source software project with respect to developer costs and show that our DFLT outperforms the existing approach, the average cost of our DFLT is almost half that of the state-of-the-art DFLT.",0730-3157,978-1-5386-0367-3978-1-5386-0368,10.1109/COMPSAC.2017.167,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8029629,Feature Location;Program Comprehension;Fault Localization;Dynamic Analysis;Formal Concept Analysis,Tools;Lattices;Formal concept analysis;Open source software;Conferences;Electronic mail,formal concept analysis;public domain software;software fault tolerance,shared modules;dynamic feature location techniques;DFLT;multiple features location;fault localization techniques;similarity coefficient;formal concept analysis;open source software project,,,14,,,,,IEEE,IEEE Conferences
On the automatic modularization of software systems using the Bunch tool,B. S. Mitchell; S. Mancoridis,"Dept. of Comput. Sci., Drexel Univ., Philadelphia, PA, USA; Dept. of Comput. Sci., Drexel Univ., Philadelphia, PA, USA",IEEE Transactions on Software Engineering,,2006,32,3,193,208,"Since modern software systems are large and complex, appropriate abstractions of their structure are needed to make them more understandable and, thus, easier to maintain. Software clustering techniques are useful to support the creation of these abstractions by producing architectural-level views of a system's structure directly from its source code. This paper examines the Bunch clustering system which, unlike other software clustering tools, uses search techniques to perform clustering. Bunch produces a subsystem decomposition by partitioning a graph of the entities (e.g., classes) and relations (e.g., function calls) in the source code. Bunch uses a fitness function to evaluate the quality of graph partitions and uses search algorithms to find a satisfactory solution. This paper presents a case study to demonstrate how Bunch can be used to create views of the structure of significant software systems. This paper also outlines research to evaluate the software clustering results produced by Bunch.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2006.31,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1610610,Clustering;reverse engineering;reengineering;program comprehension;optimization;maintainability.,Software systems;Software tools;Software maintenance;Clustering algorithms;Reverse engineering;Software quality;Search problems;Software performance;Partitioning algorithms;Chaos,software architecture;software maintenance;reverse engineering;systems re-engineering;software tools;search problems,automatic modularization;Bunch software clustering tool;software system abstraction;software system architectural-level view;graph partition;search algorithm;reverse engineering;software system reengineering;program comprehension;software maintainability,,231,56,,,,,IEEE,IEEE Journals
Awareness and Comprehension in Software/Systems Engineering Practice and Education: Trends and Research Directions,M. Schots; C. Werner; M. Mendonça,NA; NA; NA,2012 26th Brazilian Symposium on Software Engineering,,2012,,,186,190,"The creation of tools, techniques and methodologies to support the manipulation of large data sets has been receiving special attention of both scientific and industrial communities, in order to discover new ways of dealing with the underlying information, including learning purposes, identification of patterns, decision making support, amongst others. However, making use of computing resources to enhance awareness and understanding of software information and the software itself is still a challenge in software/systems engineering, since it involves the identification of suitable mechanisms, adequate abstractions, and studies on stimulation of the human perceptive and cognitive abilities. This paper presents some of the challenges in this context, based on current trends of software development lifecycle, program comprehension, and software engineering education. At the end, a special focus is given on ongoing research on using and improving current mechanisms for supporting software reuse practices and software comprehension in general.",,978-0-7695-4868-5978-1-4673-4472,10.1109/SBES.2012.25,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6337872,software engineering;awareness;program comprehension;software visualization;software engineering education;grand challenges,Software;Software engineering;Education;Visualization;Conferences;Industries;Data visualization,computer science education;software reusability,software-system engineering practice;software-system engineering education;software information awareness;software information understanding;human perceptive stimulation;cognitive ability;software development lifecycle;program comprehension;software engineering education;software reuse practices;software comprehension,,,40,,,,,IEEE,IEEE Conferences
D-Cube: Tool for Dynamic Design Discovery from Multi-threaded Applications Using PIN,S. Majumdar; N. Chatterjee; S. R. Sahoo; P. P. Das,NA; NA; NA; NA,"2016 IEEE International Conference on Software Quality, Reliability and Security (QRS)",,2016,,,25,32,"Program comprehension is a major challenge for system maintenance. Reverse engineering has been employed for control-flow analysis of applications but not much work has been done for comprehending concurrent non-deterministic behavior of multi-threaded applications. We present D-CUBE, built using dynamic instrumentation APIs, which plugs in during execution and infers various thread models like concurrency, safety, data access, thread-pool state, exception model etc. for multi-threaded applications at runtime. We extract run-time events traced according to pre-specified logic and feed them to decision trees for inference. We use 3 benchmark suites (LOC: 50-3200) -- CDAC Pthreads benchmark [1] (18 Cases), Open POSIX Test-Suites [2] (21 Cases) and PARSEC 3.0 benchmarks [3] (3 Cases) for accuracy and volume testing and validate our approach by comparing the documented behavior of test-suites with D-CUBE's output models. We achieve over 90% accuracy. D-CUBE produces graphical event-traces with every inference for quick and effective comprehension of large code.",,978-1-5090-4127-5978-1-5090-4128,10.1109/QRS.2016.13,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7589781,Concurrency Models;Multi-threaded Program Analysis;Dynamic Instrumentation;Execution Patterns;Program Comprehension;Reverse-Engineering,Concurrent computing;Feature extraction;Instruction sets;Benchmark testing;Pins;Data models;Instruments,application program interfaces;concurrency (computers);decision trees;multi-threading;program testing;reverse engineering;software maintenance,D-Cube;dynamic design discovery;multithreaded applications;PIN;program comprehension;system maintenance;reverse engineering;control-flow analysis;dynamic instrumentation APIs;decision trees;CDAC Pthreads benchmark;Open POSIX Test-Suites;PARSEC 3.0 benchmarks;volume testing;graphical event-traces,,,23,,,,,IEEE,IEEE Conferences
An Approach for Mapping Features to Code Based on Static and Dynamic Analysis,A. Rohatgi; A. Hamou-Lhadj; J. Rilling,NA; NA; NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,236,241,"System evolution depends greatly on the ability of a maintainer to locate source code that is specific to feature implementation. Existing feature location techniques require either exercising several features of the system, or rely heavily on domain experts to guide the feature location process. In this paper, we present a novel approach for feature location that combines static and dynamic analysis techniques. An execution trace is generated by exercising the feature under study (dynamic analysis). A component dependency graph (static analysis) is used to rank the components invoked in the trace according to their relevance to the feature. Our ranking technique is based on the impact of a component modification on the rest of the system. The proposed approach is automatic to a large extent relieving users from any decision that would otherwise require extensive domain knowledge of the system. A case study is presented to support and evaluate the applicability of our approach.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.35,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556137,Feature location;dynamic analysis;static analysis;program comprehension,Software maintenance;Information analysis;Computer science;Software engineering;Indexing;Unified modeling language;Information resources;Performance analysis;Software performance;Reconnaissance,data flow analysis;software maintenance,mapping features;static analysis;dynamic analysis;system evolution;feature location;component dependency graph,,15,13,,,,,IEEE,IEEE Conferences
How to Interconnect Operational and Behavioral Views of Web Applications,D. C. d. Cruz; R. F. C. d. Fonseca; P. M. R. S. Henriques; M. J. V. Pereira,NA; NA; NA; NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,263,267,"In the context of our research project, we are looking for program comprehension tools that are able to interconnect operational and behavioral views, aiming at aiding the programmer to relate problem and program domains to reach a full understanding of software systems. In particular we have been studying the adaptation of that principle to Web applications. In this context, we had designed and implemented a tool called WebAppViewer. In this paper, we emphasize the development of the module (BORS) that is responsible for providing interconnection functionalities and we propose a tool demonstration. A dedicated Web server is included in the system to allow the execution of the piece of code selected by the user. This feature is used to relate the source text (html, php, etc) executed by the server, with the web page received by the client. Code instrumentation is used to collect dynamic information.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.25,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556141,WebAppViewer;operational view;behavior view;web applications;program comprehension,Application software;Software systems;Web server;HTML;Dynamic programming;Data mining;Computer science;Programming profession;Web pages;Instruments,Internet;software engineering,Web applications;program comprehension tools;software systems;WebAppViewer;code instrumentation,,,15,,,,,IEEE,IEEE Conferences
A Look into Programmers' Heads,N. Peitek; J. Siegmund; S. Apel; C. Kästner; C. Parnin; A. Bethmann; T. Leich; G. Saake; A. Brechmann,"SLNIB, Leibniz-Institut fur Neurobiologie, 28390 Magdeburg, Saxony Anhalt Germany (e-mail: norman.peitek@lin-magdeburg.de); Department of Informatics and Mathematics, University of Passau, Passau, Bavaria Germany 94032 (e-mail: Janet.Siegmund@uni-passau.de); Department of Informatics and Mathematics, University of Passau, Passau, Bavaria Germany 94032 (e-mail: apel@uni-passau.de); Institute for Software Reserach, Carnegie Mellon University, Pittsburgh, Pennsylvania United States 15213-3890 (e-mail: kaestner@cs.cmu.edu); Computer Science, North Carolina State University, Raleigh, North Carolina United States 27608 (e-mail: cjparnin@ncsu.edu); SLNIB, Leibniz-Institut fur Neurobiologie, 28390 Magdeburg, Sachsen-Anhalt Germany (e-mail: bethmann@lin-magdeburg.de); Applied Computer Science, Metop Research Institute, Magdeburg, Saxony-Anhalt Germany (e-mail: thomas.leich@metop.de); Department of Computer Science, Otto-von-Guericke Universitaet Magdeburg, Magdeburg, Saxony Anhalt Germany (e-mail: saake@iti.cs.uni-magdeburg.de); SLNIB, Leibniz-Institut fur Neurobiologie, 28390 Magdeburg, Sachsen-Anhalt Germany (e-mail: brechmann@lin-magdeburg.de)",IEEE Transactions on Software Engineering,,2018,PP,99,1,1,"Program comprehension is an important, but hard to measure cognitive process. This makes it difficult to provide suitable programming languages, tools, or coding conventions to support developers in their everyday work. Here, we explore whether functional magnetic resonance imaging (fMRI) is feasible for soundly measuring program comprehension. To this end, we observed 17 participants inside an fMRI scanner while they were comprehending source code. The results show a clear, distinct activation of five brain regions, which are related to working memory, attention, and language processing, which all fit well to our understanding of program comprehension. Furthermore, we found reduced activity in the default mode network, indicating the cognitive effort necessary for program comprehension. We also observed that familiarity with Java as underlying programming language reduced cognitive effort during program comprehension. To gain confidence in the results and the method, we replicated the study with 11 new participants and largely confirmed our findings. Our results encourage us and, hopefully, others to use fMRI to observe programmers and, in the long run, answer questions, such as: How should we train programmers? Can we train someone to become an excellent programmer? How effective are new languages and tools for program comprehension?",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2018.2863303,National Science Foundation; Deutsche Forschungsgemeinschaft; Defense Advanced Research Projects Agency; Bayerisches Staatsministerium fur Bildung und Kultus Wissenschaft und Kunst; H2020 European Research Council; ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8425769,Functional magnetic resonance imaging;program comprehension,Functional magnetic resonance imaging;Task analysis;Cognition;Brain;Programming;Blood,,,,,,,,,,IEEE,IEEE Early Access Articles
Automated Slicing of Aspect-Oriented Programs Using Bytecode Analysis,D. Munjal; J. Singh; S. Panda; D. P. Mohapatra,NA; NA; NA; NA,2015 IEEE 39th Annual Computer Software and Applications Conference,,2015,2,,191,199,"Program slicing has numerous applications in software engineering activities like debugging, testing, maintenance, model checking etc. The main objective of this paper is to automate the generation of System Dependency Graphs (SDG) for aspect-oriented programs to efficiently compute accurate slices. The construction of SDG is automated by analysing the byte code of aspect-oriented programs that incorporates the representation of aspect-oriented features. After constructing the SDG, we propose a slicing algorithm that uses the intermediate graph and computes slices for a given AOP. To implement our proposed slicing technique, we have developed a prototype tool that takes an AOP as input and compute its slices using our proposed slicing algorithm. To evaluate our proposed technique, we have considered some case studies by taking open source projects. The comparative study of our proposed slicing algorithm with some existing algorithms show that our approach is an efficient and scalable approach of slicing for different applications with respect to aspect-oriented programs.",0730-3157,978-1-4673-6564-2978-1-4673-6563,10.1109/COMPSAC.2015.98,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7273618,Program Slicing;intermediate graph;aspects;Aspect-Oriented Program;weaving;program comprehension,Weaving;Algorithm design and analysis;Debugging;Complexity theory;Programming;Heuristic algorithms;Computers,aspect-oriented programming;graph theory;program slicing;public domain software;systems analysis,program slicing;aspect-oriented program;bytecode analysis;system dependency graph;SDG;open source project,,2,16,,,,,IEEE,IEEE Conferences
Building Domain Specific Dictionaries of Verb-Object Relation from Source Code,Y. Hayase; Y. Kashima; Y. Manabe; K. Inoue,NA; NA; NA; NA,2011 15th European Conference on Software Maintenance and Reengineering,,2011,,,93,100,"An identifier is an important key in mapping program elements onto domain knowledge for the purpose of program comprehension. Therefore, if identifiers in a program have inappropriate names, developers can waste a lot of time trying to understand the program. This paper proposes a method for extracting and gathering verb-object (V-O) relations, as good examples of naming, from source code written in an object-oriented programming language. For each of several application domains, dictionaries containing the V-O relations are built and evaluated by software developers. The evaluation results confirm that the relations in the dictionaries are adequate in many cases.",1534-5351;1534-5351,978-1-61284-259-2978-0-7695-4343,10.1109/CSMR.2011.15,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5741251,naming convention;programmer's lexicon;program comprehension,Dictionaries;Pattern matching;Software;Java;XML;Databases;Graphical user interfaces,object-oriented languages;programming languages;software maintenance,domain specific dictionary;verb-object relation;program comprehension;source code;object-oriented programming language,,4,13,,,,,IEEE,IEEE Conferences
SArF map: Visualizing software architecture from feature and layer viewpoints,K. Kobayashi; M. Kamimura; K. Yano; K. Kato; A. Matsuo,"Software Systems Laboratories, Fujitsu Laboratories Ltd., Kawasaki, Japan; Software Systems Laboratories, Fujitsu Laboratories Ltd., Kawasaki, Japan; Software Systems Laboratories, Fujitsu Laboratories Ltd., Kawasaki, Japan; Software Systems Laboratories, Fujitsu Laboratories Ltd., Kawasaki, Japan; Software Systems Laboratories, Fujitsu Laboratories Ltd., Kawasaki, Japan",2013 21st International Conference on Program Comprehension (ICPC),,2013,,,43,52,"To facilitate understanding the architecture of a software system, we developed SArF Map technique that visualizes software architecture from feature and layer viewpoints using a city metaphor. SArF Map visualizes implicit software features using our previous study, SArF dependency-based software clustering algorithm. Since features are high-level abstraction units of software, a generated map can be directly used for high-level decision making such as reuse and also for communications between developers and non-developer stakeholders. In SArF Map, each feature is visualized as a city block, and classes in the feature are laid out as buildings reflecting their software layer. Relevance between features is represented as streets. Dependency links are visualized lucidly. Through open source and industrial case studies, we show that the architecture of the target systems can be easily overviewed and that the quality of their packaging designs can be quickly assessed.",1092-8138,978-1-4673-3092,10.1109/ICPC.2013.6613832,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613832,Software visualization;city metaphor;software architecture;program comprehension;software clustering;dependency graph,Software;Cities and towns;Layout;Buildings;Software algorithms;Clustering algorithms;Visualization,decision making;program visualisation;reverse engineering;software architecture,SArF map;software architecture visualization;software feature viewpoints;software layer viewpoints;software system architecture understanding;city metaphor;SArF dependency-based software clustering algorithm;high-level abstraction units;high-level decision making;reuse;city block;dependency links,,7,25,,,,,IEEE,IEEE Conferences
Immediacy through Interactivity: Online Analysis of Run-time Behavior,M. Perscheid; B. Steinert; R. Hirschfeld; F. Geller; M. Haupt,NA; NA; NA; NA; NA,2010 17th Working Conference on Reverse Engineering,,2010,,,77,86,"Visualizations of actual run-time data support the comprehension of programs, like examples support the explanation of abstract concepts and principles. Unfortunately, the required run-time analysis is often associated with an inconvenient overhead that renders current tools impractical for frequent use. We propose an interactive approach to collect and present run-time data. An initial shallow analysis provides for immediate access to visualizations of run-time information. As users explore this information, it is incrementally refined on-demand. We present an implementation that realizes our proposed approach and enables developers to instantly explore run-time behavior of selected code entities. We evaluate our interactive approach by measuring time and memory overhead in the context of ten different-sized projects. Our empirical results show that run-time data for an initial overview can be collected in less than 300 milliseconds for 95% of cases.",2375-5369;1095-1350,978-1-4244-8911,10.1109/WCRE.2010.17,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5645442,program comprehension;dynamic analysis;object collaboration;test cases;development environments,Observers;Clocks;Instruments;Visualization;Indexes;Concrete,program diagnostics;program visualisation,online analysis;run-time behavior;program visualizations;run-time data;program comprehension;run-time analysis;interactive approach;initial shallow analysis;run-time information;selected code entity;memory overhead,,5,31,,,,,IEEE,IEEE Conferences
Explaining Why Methods Change Together,A. Lozano; C. Noguera; V. Jonckers,NA; NA; NA,2014 IEEE 14th International Working Conference on Source Code Analysis and Manipulation,,2014,,,185,194,"By analyzing historical information from Source Code Management systems, previous research has observed that certain methods tend to change together consistently. Co-change has been identified as a good predictor of the entities that are likely to be affected by a change, which ones might be missing modifications, and which ones might change in the future. However, existing co-change analysis provides no insight on why methods consistently co-change. Being able to identify the rationale that explains co-changes could allow to document and enforce design knowledge. This paper proposes an automatic approach to derive the reason behind a co-change. We define the reason of a (set) of co-changes as a set of properties common to the elements that co-change. We consider two kinds of properties: structural properties which indicate explicit dependencies, and semantic properties which reveal implicit dependencies. Then we attempt to identify the reasons behind single commits, as well as the reasons behind co-changes that repeatedly affect the same set of methods. These sets of methods are identified by clustering methods that tend to be modified in the same commit-transactions. We perform our analysis over the history of two open-source systems, analyzing nearly 19.000 methods and over 3700 commits. We show that it is possible to automatically extract explanations for co-changes, that the quality of such explanations improves when structural and semantic properties are taken into account, and when the methods analyzed co-change recurrently.",,978-1-4799-6148,10.1109/SCAM.2014.27,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6975652,Co-change;Empirical software engineering;Program comprehension,Semantics;History;Documentation;Measurement;Java;Libraries;Clustering methods,pattern clustering;program diagnostics;public domain software,co-change analysis;structural properties;explicit dependencies;semantic properties;implicit dependencies;clustering methods;commit-transactions;open-source systems,,1,18,,,,,IEEE,IEEE Conferences
On the use of visual clustering to identify landmarks in code navigation,S. Reddivari; M. Kotapalli,"School of Computing, University of North Florida, Jacksonville, Florida, USA 32224; School of Computing, University of North Florida, Jacksonville, Florida, USA 32224","2017 IEEE 15th International Conference on Software Engineering Research, Management and Applications (SERA)",,2017,,,219,228,"Recovering the legibility features is key to reverse engineering as the legible software systems can ease developer's code navigation and comprehension. Landmarks are important legibility features that developers use as reference points. In this paper, we leverage visual clustering to explore how landmarks can be identified via static dependencies. Besides organizing software entities with coherent patterns, visual clustering offers additional insights by rigorously rendering a holistic picture of the code base to the two-dimensional space. We contribute a couple of heuristics based on the cluster layout to identify the landmark files. Our visual exploration of Eclipse Mylyn open source Java project reveals developer's reliance on the landmarks during code navigation and shows the promise of using static dependencies to uncover the landmarks in the software space.",,978-1-5090-5756-6978-1-5090-5757,10.1109/SERA.2017.7965731,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7965731,software clustering;program comprehension;code navigation;visual clustering;software exploration;layout-based clustering;software visualization;static dependencies,Navigation;Visualization;Software systems;Reverse engineering;Layout;Urban areas,Java;pattern clustering;program visualisation;public domain software;reverse engineering;source code (software),visual clustering;landmark identification;code navigation;legibility feature recovery;reverse engineering;legible software systems;code comprehension;static dependencies;software entities;2D space;Eclipse Mylyn open source Java project,,,53,,,,,IEEE,IEEE Conferences
Architecture recovery and abstraction from the perspective of processes,Li Qingshan; Chu Hua; Hu Shengming; Chen Ping; Zhao Yun,"Software Eng. Inst., XiDian Univ., Xi'an, China; Software Eng. Inst., XiDian Univ., Xi'an, China; Software Eng. Inst., XiDian Univ., Xi'an, China; Software Eng. Inst., XiDian Univ., Xi'an, China; Software Eng. Inst., XiDian Univ., Xi'an, China",12th Working Conference on Reverse Engineering (WCRE'05),,2005,,,10 pp.,66,"For the increasing complexity of software systems, the main work of software development, maintenance and evolution has been focused on the comprehension of the existing systems. In order to help users comprehend at all aspects and levels of a target system, it is necessary to reversely recover and abstract its high-level architecture, which can reflect the framework and holistic behavioral features of the software system. This paper deals with the problems of architecture recovery from the perspective of process. An approach of extracting process structure graph (PSG) from a target system is presented based on the features of the relations among processes on UNIX platform. First, the static code fragment of a dynamic process can be recognized, then a mapping algorithm that can identify the correspondence between the dynamic process ID and the static process module is given. On the basis of the algorithm, an incremental construction algorithm of PSG and a slicing algorithm for class structure in a process module are implemented respectively. The experimental results show that the extracted PSG is correct, effective and can reflect the high-level structure of the target system in detail at the process level.",1095-1350;2375-5369,0-7695-2474,10.1109/WCRE.2005.6,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1566146,Reverse Engineering;Program Comprehension;Architecture Recovery;Process;Object Orientation,Software systems;Computer architecture;Software maintenance;Costs;Software engineering;Programming;Reverse engineering;Software design;Modular construction;Computer science,software architecture;software reusability;formal specification;program slicing;software maintenance;software metrics;Unix,architecture recovery;architecture abstraction;software system complexity;software development;software maintenance;software evolution;high-level architecture;process structure graph;UNIX platform;static code fragment;mapping algorithm;dynamic process ID;static process module;incremental construction algorithm;slicing algorithm;class structure;reverse engineering;program comprehension,,8,26,,,,,IEEE,IEEE Conferences
"Patcher: An Online Service for Detecting, Viewing and Patching Web Application Vulnerabilities",F. Yu; Y. Tung,NA; NA,2014 47th Hawaii International Conference on System Sciences,,2014,,,4878,4886,"Web application security becomes a critical issue as more and more web applications appear and serve common life and business routines in recent years. It is known that web applications are vulnerable due to software defects. Open to public users, vulnerable websites may encounter lots of malicious attacks from the Internet. We present a new web service platform where system developers can detect, view and patch potential vulnerabilities of their web applications online. Taking advantage of static string analysis techniques, our analysis ensures that the patched programs are free from vulnerabilities with respect to given attack patterns. Specifically, we integrate the service front end with program visualization techniques, developing a 3D interface/presentation for users to access and view the analysis result under visualization environment with the aim of improving users' comprehension on programs, especially how vulnerabilities get exploited and patched. We report our analysis result on several open source applications, finding and patching various unknown/known vulnerabilities.",1530-1605,978-1-4799-2504,10.1109/HICSS.2014.598,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6759201,visualization;web security;string analysis;program comprehension,Security;Visualization;Automata;Mobile handsets;Web services;Three-dimensional displays;Reachability analysis,program diagnostics;program visualisation;public domain software;security of data;software maintenance;Web services;Web sites,Patcher;online service;Web application vulnerability detection;Web application vulnerability viewing;Web application vulnerability patching;Web application security;software defects;Web sites;malicious attacks;Internet;Web service platform;static string analysis techniques;service front end integration;program visualization techniques;3D interface development;3D presentation development;open source applications;program comprehension,,,33,,,,,IEEE,IEEE Conferences
Automatically detecting and describing high level actions within methods,G. Sridhara; L. Pollock; K. Vijay-Shanker,"University of Delaware, Newark, DE, USA; University of Delaware, Newark, DE, USA; University of Delaware, Newark, DE, USA",2011 33rd International Conference on Software Engineering (ICSE),,2011,,,101,110,"One approach to easing program comprehension is to reduce the amount of code that a developer has to read. Describing the high level abstract algorithmic actions associated with code fragments using succinct natural language phrases potentially enables a newcomer to focus on fewer and more abstract concepts when trying to understand a given method. Unfortunately, such descriptions are typically missing because it is tedious to create them manually. We present an automatic technique for identifying code fragments that implement high level abstractions of actions and expressing them as a natural language description. Our studies of 1000 Java programs indicate that our heuristics for identifying code fragments implementing high level actions are widely applicable. Judgements of our generated descriptions by 15 experienced Java programmers strongly suggest that indeed they view the fragments that we identify as representing high level actions and our synthesized descriptions accurately express the abstraction.",1558-1225;0270-5257,978-1-4503-0445-0978-1-4503-0445,10.1145/1985793.1985808,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032449,documentation;program comprehension,Natural languages;Pragmatics;Java;Syntactics;Documentation;Semantics;Software,Java;natural language processing;program compilers;program diagnostics,high level actions;program comprehension;high level abstract algorithmic actions;code fragments;succinct natural language phrases;abstract concepts;automatic technique;natural language description;Java programs;Java programmers,,39,24,,,,,IEEE,IEEE Conferences
Ensuring Well-Behaved Usage of APIs through Syntactic Constraints,M. Feilkas; D. Ratiu,NA; NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,248,253,"Libraries are the most widespreaded form of software reuse. In order to properly use a library API, its clients should fulfill a series of (many times implicit) assumptions made by the API programmers. Failing to fulfill these assumptions leads to a misuse of the library and thereby to defects in the client's code. In this paper we present a method for checking a well-behaved usage of an API through a set of context-sensitive syntactic constraints over the API clients. These constraints restrict the set of programs that can be written with an API only to programs that fulfill the API assumptions and thereby represent a well-behaved and valid usage of the API. In this paper we present a set of typical assumption classes made by API providers about their clients. We define a framework for formalizing the context- sensitive constraints over the API client code and propose a typical constraint for each class of assumptions. Thereby we provide a mechanism that allows the provider of an API to describe the knowledge of how an API is intended to be used in an automatically checkable form. We present our experience with parts of the Java Standard APIs.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.12,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556139,Syntactic Constraints;Static Analysis;Program Comprehension,Java;Software libraries;Packaging;Programming profession;Documentation;Testing;Computer bugs;Computer languages;Writing,application program interfaces,context-sensitive syntactic constraint;API client;application program interfaces,,4,11,,,,,IEEE,IEEE Conferences
Towards Better Symbol Resolution for C/C++ Programs: A Cluster-Based Solution,R. Szalay; Z. Porkoláb; D. Krupp,NA; NA; NA,2017 IEEE 17th International Working Conference on Source Code Analysis and Manipulation (SCAM),,2017,,,101,110,"Resolving symbol references is an important part of many application areas from development environments to various static analyser tools, especially when it is used for code comprehension purposes. Different occurrences of the same program elements, like function definitions and their call sites, variable declarations and their usage, or type definitions and their applications should be connected. In case of the C++ programming language, the most current tools use mangled names to correlate symbols, e.g. when implementing actions like ""go to definition"" or ""list all references"". However, for large projects, where multiple binaries are created, symbol resolution based on mangled names can be, and usually is, ambiguous. This leads to inaccurate behaviour even in major development tools. In this paper we explore the reason of this ambiguity, and propose our clustering algorithm based on essential build information to improve the accuracy of symbol resolution. We implemented our method as part of the CodeCompass open source code comprehension tool and measured its efficiency.",2470-6892,978-1-5386-3238-3978-1-5386-3239,10.1109/SCAM.2017.15,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8090143,static analysis;program comprehension;code navigation;C++ programming language,Tools;C++ languages;Libraries;Correlation;Software systems,C++ language;object-oriented programming;pattern clustering;program diagnostics;public domain software;software maintenance,cluster-based solution;symbol references;development environments;static analyser tools;code comprehension purposes;program elements;function definitions;variable declarations;type definitions;mangled names;list all references;symbol resolution;development tools;clustering algorithm;CodeCompass open source code comprehension tool;C programs;call sites;C++ programming language;C++ programs,,1,30,,,,,IEEE,IEEE Conferences
Physical and conceptual identifier dispersion: Measures and relation to fault proneness,V. Arnaoudova; L. Eshkevari; R. Oliveto; Y. Guéhéneuc; G. Antoniol,"SOCCER Lab. - DGIGL, École Polytechnique de Montréal, Québec, Canada; SOCCER Lab. - DGIGL, École Polytechnique de Montréal, Québec, Canada; SE@SA Lab - DMI, University of Salerno - Italy; Ptidej Team - DGIGL, École Polytechnique de Montréal, Québec, Canada; SOCCER Lab. - DGIGL, École Polytechnique de Montréal, Québec, Canada",2010 IEEE International Conference on Software Maintenance,,2010,,,1,5,"Poorly-chosen identifiers have been reported in the literature as misleading and increasing the program comprehension effort. Identifiers are composed of terms, which can be dictionary words, acronyms, contractions, or simple strings. We conjecture that the use of identical terms in different contexts may increase the risk of faults. We investigate our conjecture using a measure combining term entropy and term context coverage to study whether certain terms increase the odds ratios of methods to be fault-prone. Entropy measures the physical dispersion of terms in a program: the higher the entropy, the more scattered across the program the terms. Context coverage measures the conceptual dispersion of terms: the higher their context coverage, the more unrelated the methods using them. We compute term entropy and context coverage of terms extracted from identifiers in Rhino 1.4R3 and ArgoUML 0.16. We show statistically that methods containing terms with high entropy and context coverage are more fault-prone than others.",1063-6773;1063-6773,978-1-4244-8629-8978-1-4244-8630-4978-1-4244-8628,10.1109/ICSM.2010.5609748,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609748,Source Code Identifiers;Program Comprehension;Fault Models;Information Retrieval;Entropy,Entropy;Context;Measurement;Correlation;Presses;Software engineering;Conferences,entropy;software fault tolerance;software metrics;statistical analysis;Unified Modeling Language,conceptual identifier dispersion;physical identifier dispersion;fault proneness;program comprehension;term entropy;term context coverage;Rhino 1.4R3;ArgoUML 0.16,,10,28,,,,,IEEE,IEEE Conferences
LINSEN: An efficient approach to split identifiers and expand abbreviations,A. Corazza; S. Di Martino; V. Maggio,Dipartimento di Scienze Fisiche - Sezione Informatica University of Naples “Federico II”; Dipartimento di Scienze Fisiche - Sezione Informatica University of Naples “Federico II”; Dipartimento di Scienze Fisiche - Sezione Informatica University of Naples “Federico II”,2012 28th IEEE International Conference on Software Maintenance (ICSM),,2012,,,233,242,"Information Retrieval (IR) techniques are being exploited by an increasing number of tools supporting Software Maintenance activities. Indeed the lexical information embedded in the source code can be valuable for tasks such as concept location, clustering or recovery of traceability links. The application of such IR-based techniques relies on the consistency of the lexicon available in the different artifacts, and their effectiveness can worsen if programmers introduce abbreviations (e.g: rect) and/or do not strictly follow naming conventions such as Camel Case (e.g: UTFtoASCII). In this paper we propose an approach to automatically split identifiers in their composing words, and expand abbreviations. The solution is based on a graph model and performs in linear time with respect to the size of the dictionary, taking advantage of an approximate string matching technique. The proposed technique exploits a number of different dictionaries, referring to increasingly broader contexts, in order to achieve a disambiguation strategy based on the knowledge gathered from the most appropriate domain. The approach has been compared to other splitting and expansion techniques, using freely available oracles for the identifiers extracted from 24 C/C++ and Java open source systems. Results show an improvement in both splitting and expanding performance, in addition to a strong enhancement in the computational efficiency.",1063-6773,978-1-4673-2312-3978-1-4673-2313,10.1109/ICSM.2012.6405277,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6405277,Source Code Identifiers;Program Comprehension;Splitting;Expansion,Dictionaries;Software algorithms;Approximation algorithms;Context;Software maintenance;Conferences,C++ language;information retrieval;Java;pattern clustering;public domain software;software maintenance,LINSEN;identifier splitting;abbreviation expansion;information retrieval techniques;software maintenance activities;lexical information;concept location;traceability links clustering;traceability links recovery;IR-based techniques;camel case;dictionary;approximate string matching technique;disambiguation strategy;C-C++;Java open source systems;oracles,,14,20,,,,,IEEE,IEEE Conferences
A Taxonomy for Program Metamodels in Program Reverse Engineering,H. Washizaki; Y. Guéhéneuc; F. Khomh,NA; NA; NA,2016 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2016,,,44,55,"To support program comprehension, maintenance, and evolution, metamodels are frequently used during program reverse engineering activities to describe and analyze constituents of a program and their relations. Reverse engineering tools often define their own metamodels according to the intended purposes and features. Although each metamodel has its own advantages, its limitations may be addressed by other metamodels. Existing works have evaluated and compared metamodels and tools, but none have considered all the possible characteristics and limitations to provide a comprehensive guideline for classifying, comparing, reusing, and extending program metamodels. To aid practitioners and researchers in classifying, comparing, reusing, and extending program metamodels and their corresponding reverse engineering tools according to the intended goals, we establish a conceptual framework with definitions of program metamodels and related concepts. Then this framework is used to provide a comprehensive taxonomy, named Program Metamodel TAxonomy (ProMeTA), which incorporates newly identified characteristics into those stated in previous works, which were identified via a systematic literature survey on program metamodels, while keeping the orthogonality of the entire taxonomy. Additionally, we validate the taxonomy in terms of its orthogonality and usefulness through the classification of popular metamodels.",,978-1-5090-3806-0978-1-5090-3807,10.1109/ICSME.2016.82,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7816453,reverse engineering;program metamodels;program comprehension and analysis;taxonomy,Reverse engineering;Taxonomy;Unified modeling language;Biological system modeling;Syntactics;Grammar;Data mining,pattern classification;program diagnostics;reverse engineering;software maintenance,program reverse engineering tools;program comprehension;program maintenance;program evolution;comprehensive taxonomy;program metamodel taxonomy;ProMeTA,,3,93,,,,,IEEE,IEEE Conferences
TRIS: A Fast and Accurate Identifiers Splitting and Expansion Algorithm,L. Guerrouj; P. Galinier; Y. Guéhéneuc; G. Antoniol; M. Di Penta,NA; NA; NA; NA; NA,2012 19th Working Conference on Reverse Engineering,,2012,,,103,112,"Understanding source code identifiers, by identifying words composing them, is a necessary step for many program comprehension, reverse engineering, or redocumentation tasks. To this aim, researchers have proposed several identifier splitting and expansion approaches such as Samurai, TIDIER and more recently GenTest. The ultimate goal of such approaches is to help disambiguating conceptual information encoded in compound (or abbreviated) identifiers. This paper presents TRIS, TRee-based Identifier Splitter, a two-phases approach to split and expand program identifiers. First, TRIS pre-compiles transformed dictionary words into a tree representation, associating a cost to each transformation. In a second phase, it maps the identifier splitting/expansion problem into a minimization problem, i.e., the search of the shortest path (optimal split/expansion) in a weighted graph. We apply TRIS to a sample of 974 identifiers extracted from JHotDraw, 3,085 from Lynx, and to a sample of 489 identifiers extracted from 340 C programs. Also, we compare TRIS with GenTest on a set of 2,663 mixed Java, C and C++ identifiers. We report evidence that TRIS split (and expansion) is more accurate than state-of-the-art approaches and that it is also efficient in terms of computation time.",2375-5369;1095-1350,978-0-7695-4891-3978-1-4673-4536,10.1109/WCRE.2012.20,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385106,Identifier Splitting/Expansion;Program Comprehension;Linguistic Analysis;Optimal Path;Weighted Acyclic Graph,Dictionaries;Java;Complexity theory;Buildings;Software;Context,identification;program diagnostics;reverse engineering;source coding;trees (mathematics),identifier splitting algorithm;identifier expansion algorithm;source code identifiers;program comprehension;reverse engineering;redocumentation tasks;Samurai;TIDIER;GenTest;TRIS;tree-based identifier splitter;two-phase approach;transformed dictionary words;tree representation;minimization problem;shortest path;weighted graph;JHotDraw;Lynx;C programs;C++ identifiers;C identifiers;Java identifiers;state-of-the-art approaches,,3,13,,,,,IEEE,IEEE Conferences
Lexical categories for source code identifiers,C. D. Newman; R. S. AlSuhaibani; M. L. Collard; J. I. Maletic,"Computer Science, Kent State University, OH 44240 USA; Computer Science, Kent State University, OH 44240 USA; Computer Science, The University of Akron, Ohio, USA; Computer Science, Kent State University, Ohio, 44240 USA","2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER)",,2017,,,228,239,"A set of lexical categories, analogous to part-of-speech categories for English prose, is defined for source-code identifiers. The lexical category for an identifier is determined from its declaration in the source code, syntactic meaning in the programming language, and static program analysis. Current techniques for assigning lexical categories to identifiers use natural-language part-of-speech taggers. However, these NLP approaches assign lexical tags based on how terms are used in English prose. The approach taken here differs in that it uses only source code to determine the lexical category. The approach assigns a lexical category to each identifier and stores this information along with each declaration. srcML is used as the infrastructure to implement the approach and so the lexical information is stored directly in the srcML markup as an additional XML element for each identifier. These lexical-category annotations can then be later used by tools that automatically generate such things as code summarization or documentation. The approach is applied to 50 open source projects and the soundness of the defined lexical categories evaluated. The evaluation shows that at every level of minimum support tested, categorization is consistent at least 79% of the time with an overall consistency (across all supports) of at least 88%. The categories reveal a correlation between how an identifier is named and how it is declared. This provides a syntax-oriented view (as opposed to English part-of-speech view) of developer intent of identifiers.",,978-1-5090-5501-2978-1-5090-5502,10.1109/SANER.2017.7884624,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7884624,Natural Language Processing;part-of-speech tagging;identifier analysis;program comprehension,Tagging;Speech;Context;Syntactics;Natural languages;Computer languages,natural language processing;program diagnostics;public domain software;source code (software);text analysis;XML,source code identifiers;English prose;syntactic meaning;programming language;static program analysis;natural-language part-of-speech taggers;lexical information storage;srcML markup;XML element;lexical category annotations;code summarization;code documentation;syntax-oriented view;NLP;open source projects,,3,44,,,,,IEEE,IEEE Conferences
A History Querying Tool and Its Application to Detect Multi-version Refactorings,R. Stevens; C. De Roover; C. Noguera; V. Jonckers,NA; NA; NA; NA,2013 17th European Conference on Software Maintenance and Reengineering,,2013,,,335,338,"Version Control Systems (VCS) have become indispensable in developing software. In order to provide support for change management, they track the history of software projects. Tool builders can exploit this latent historical information to provide insights in the evolution of the project. For example, the information needed to identify when and where a particular refactoring was applied is implicitly present in the VCS. However, tool support for eliciting this information is lacking. So far, no general-purpose history querying tool capable of answering a wide variety of questions about the evolution of software exists. Therefore, we generalize the idea of a program querying tool to a history querying tool. A program querying tool reifies the program's code into a knowledge base, from which it retrieves elements that exhibit characteristics specified through a user-provided program query. Our history querying tool, QwalKeko, enables specifying the evolution of source code characteristics across multiple versions of Java projects versioned in Git. We apply QwalKeko to the problem of detecting refactorings, specified as the code changes induced by each refactoring. These specifications stem from the literature, but are limited to changes between two successive versions. We demonstrate the expressiveness of our tool by generalizing the specifications such that refactorings can span multiple versions.",1534-5351,978-0-7695-4948-4978-1-4673-5833,10.1109/CSMR.2013.44,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6498483,program comprehension tools;software repositories;refactoring,History;Java;Database languages;Europe;Software maintenance;Control systems,configuration management;Java;query processing;software maintenance,history querying tool;multiversion refactoring detection;VCS;version control system;software development;change management;QwalKeko history querying tool;user-provided program query;Java project,,6,12,,,,,IEEE,IEEE Conferences
Critical Section Investigator: Building Story Visualizations with Program Traces,M. D. Shah; S. Z. Guyer,NA; NA,2016 IEEE Working Conference on Software Visualization (VISSOFT),,2016,,,136,140,"Detecting performance problems that infrequently occur can be very difficult with traditional profilers. Most profilers only show the average time of execution or the total time a method contributes to the overall program's execution time. Most profilers do not explain or show why different control paths within a method executed may have resulted in variable execution times. When debugging concurrent programs for performance problems, the complexity and variability in execution time can potentially be even greater. In this paper we take a first step in visualizing individual method's different execution paths within multithreaded Java programs. We restrict our domain to looking at critical sections for this initial analysis, as variability in critical sections may cause more noticeable performance variation. Our software visualization tool, Critical Section Investigator (CSI), builds on the visualization and interaction techniques in previous works like KCachegrind with several enhancements. The result of our work is the first tool to our knowledge that visually shows potential performance differences in synchronized methods in Java programs using a profiling and storytelling structure.",,978-1-5090-3850-3978-1-5090-3851,10.1109/VISSOFT.2016.13,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780170,Java;Critical Sections;Concurrency;Program Comprehension;Software Visualization,Data visualization;Java;Synchronization;Visualization;Software;Instruments,data visualisation;Java;multi-threading,critical section investigator;story visualizations;program traces;profilers;concurrent program debugging;performance problems;multithreaded Java programs;software visualization tool;CSI;KCachegrind;storytelling structure,,,17,,,,,IEEE,IEEE Conferences
A Tree Kernel based approach for clone detection,A. Corazza; S. Di Martino; V. Maggio; G. Scanniello,"Dipartimento di Scienze Fisiche - Sezione Informatica University of Naples &#x201C;Federico II&#x201D;, Italy; Dipartimento di Scienze Fisiche - Sezione Informatica University of Naples &#x201C;Federico II&#x201D;, Italy; Dipartimento di Scienze Fisiche - Sezione Informatica University of Naples &#x201C;Federico II&#x201D;, Italy; Universit&#x00E0; della Basilicata, Potenza, Italy",2010 IEEE International Conference on Software Maintenance,,2010,,,1,5,"Reusing software by copying and pasting is a common practice in software development. This phenomenon is widely known as code cloning. Problems with clones are mainly due to the need of managing each duplication, thus increasing the effort to maintain software systems. Clone detection approaches generally take into account either the syntactic structure (e.g., Abstract Syntax Tree) or lexical elements (e.g., the signature of a function). In this paper we propose an approach to detect code clones, based on syntactic information enriched by lexical elements. To this end, we have defined a Tree Kernel function to compare Abstract Syntax Trees. A preliminary investigation has been also conducted to assess the validity of the proposed approach.",1063-6773;1063-6773,978-1-4244-8629-8978-1-4244-8630-4978-1-4244-8628,10.1109/ICSM.2010.5609715,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609715,Clone Detection;Program Comprehension;Software Maintenance;Tree Kernels,Cloning;Kernel;Software systems;Syntactics;Java;Context,reverse engineering;software maintenance;software reusability,tree kernel function;clone detection;software reuse;software development;code cloning;software maintenance;syntactic structure;abstract syntax tree;lexical element;syntactic information;program comprehension,,7,25,,,,,IEEE,IEEE Conferences
Visualizing traceability information with iTrace,I. Santiago; J. M. Vara; V. de Castro; E. Marcos,"Kybele Research Group, Rey Juan Carlos University, Avd. Tulipán S/N, Móstoles - Madrid, Spain; Kybele Research Group, Rey Juan Carlos University, Avd. Tulipán S/N, Móstoles - Madrid, Spain; Kybele Research Group, Rey Juan Carlos University, Avd. Tulipán S/N, Móstoles - Madrid, Spain; Kybele Research Group, Rey Juan Carlos University, Avd. Tulipán S/N, Móstoles - Madrid, Spain",2014 9th International Conference on Evaluation of Novel Approaches to Software Engineering (ENASE),,2014,,,1,11,"The key role of models in Model-Driven Engineering (MDE) provides a new landscape for dealing with traceability. However, despite the certain maturity reached by some MDE tools, providing efficient views of traceability data is still in its early stages. To contribute in this direction, this work introduces the visualization mechanisms provided by iTrace, a framework for the management of traceability in MDE projects. In particular, a multipanel editor for trace models supports the low-level edition of traceability data whereas different dashboards provide high-level views of such data. Both proposals are illustrated by means of a running example.",,978-989-758-065,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7077112,Model-driven Engineering;Program Comprehension;Visualization Techniques and Tools,Unified modeling language;Data models;Data visualization;Proposals;Software;Production;Context,,,,,35,,,,,IEEE,IEEE Conferences
Towards tool support for analyzing legacy systems in technical domains,C. Klammer; J. Pichler,"Software Analytics and Evolution Software Competence Center Hagenberg GmbH A-4232 Hagenberg, Austria; Software Analytics and Evolution Software Competence Center Hagenberg GmbH A-4232 Hagenberg, Austria","2014 Software Evolution Week - IEEE Conference on Software Maintenance, Reengineering, and Reverse Engineering (CSMR-WCRE)",,2014,,,371,374,"Software in technical domains contains extensive and complex computations in a highly-optimized and unstructured way. Such software systems developed and maintained over years are prone to become legacy code based on old technology and without accurate documentation. We have conducted several industrial projects to reengineer and re-document legacy systems in electrical engineering and steel making domains by means of self-provided techniques and tools. Based on this experience, we derived requirements for a toolkit to analyze legacy code in technical domains and developed a corresponding toolkit including feature location and static analysis on a multi-language level. We have applied our approach and toolkit for software systems implemented in the C++, Fortran, and PL/SQL programming languages and illustrate main benefits of our approach from these experiences.",,978-1-4799-3752,10.1109/CSMR-WCRE.2014.6747197,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6747197,Software analytics;legacy code;reverse engineering;source code analysis;feature location;program comprehension,Software systems;Algorithms;Reverse engineering;Computer languages;Syntactics;Aging,C++ language;FORTRAN;program diagnostics;programming languages;reverse engineering;software maintenance;source code (software);SQL;system documentation,tool support;technical domains;software systems;legacy code;documentation;industrial projects;redocument legacy systems;electrical engineering;steel making domains;self-provided techniques;feature location;static analysis;multilanguage level;C++;Fortran;PL/SQL programming languages,,7,11,,,,,IEEE,IEEE Conferences
Normalizing Source Code Vocabulary,D. Lawrie; D. Binkley; C. Morrell,NA; NA; NA,2010 17th Working Conference on Reverse Engineering,,2010,,,3,12,"Information Retrieval (IR) based tools complement traditional static and dynamic analysis tools by exploiting the natural language found within a program's text. Tools incorporating IR have tackled problems, such as feature location, that previously required considerable human effort. However, to reap the full benefit of IR-based techniques, the language used across all software artifacts (e.g., requirement and design documents, test plans, as well as the source code) must be consistent. Vocabulary normalization aligns the vocabulary found in source code with that found in other software artifacts. Normalization both splits an identifier into its constituent parts and expands each part into a full dictionary word to match vocabulary in other artifacts. An algorithm for normalization is presented. Its current implementation incorporates a greatly improved splitter that exploits a collection of resources including several dictionaries, frequency distributions derived from the corpus of programs, and co-occurrence data. Empirical study of this new splitter, GenTest, on almost 8000 identifiers finds that it correctly splits 82%, outperforming the current state-of-the-art. A preliminary experiment with the normalization algorithm finds it improving the FLAT ̂ 3 feature locator's scores of relevant code from 0.60 to 0.95 on a scale from 0 to 1.",2375-5369;1095-1350,978-1-4244-8911,10.1109/WCRE.2010.10,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5645479,source code analysis tools;information retrieval;program comprehension,Dictionaries;Measurement;Google;Vocabulary;Software;Documentation;Natural languages,information retrieval;natural languages;software engineering;source coding,source code vocabulary normalization;information retrieval;software artifact;GenTest;natural language,,35,36,,,,,IEEE,IEEE Conferences
VT-Revolution: Interactive Programming Video Tutorial Authoring and Watching System,L. Bao; Z. Xing; X. Xia; D. Lo,"College of Computer Science and Technology, Zhejiang University, Hangzhou, Zhejiang, China; Research School of Computer Science, Australian National University, Canberra, ACT, Australia; Faculty of Information Technology, Monash University, Clayton, VIC, Australia; School of Information Systems, Singapore Management University, Singapore",IEEE Transactions on Software Engineering,,2019,45,8,823,838,"Procedural knowledge describes actions and manipulations that are carried out to complete programming tasks. An effective way to document procedural knowledge is programming video tutorials. Unlike text-based software artifacts and tutorials that can be effectively searched and linked using information retrieval techniques, the streaming nature of programming videos limits the ways to explore the captured workflows and interact with files, code and program output in the videos. Existing solutions to adding interactive workflow and elements to programming videos have a dilemma between the level of desired interaction and the efforts required for authoring tutorials. In this work, we tackle this dilemma by designing and building a programming video tutorial authoring system that leverages operating system level instrumentation to log workflow history while tutorial authors are creating programming videos, and the corresponding tutorial watching system that enhances the learning experience of video tutorials by providing programming-specific workflow history and timeline-based browsing interactions. Our tutorial authoring system does not incur any additional burden on tutorial authors to make programming videos interactive. Given a programming video accompanied by synchronously-logged workflow history, our tutorial watching system allows tutorial watchers to freely explore the captured workflows and interact with files, code and program output in the tutorial. We conduct a user study of 135 developers to evaluate the design and effectiveness of our system in helping developers learn programming knowledge in video tutorials.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2018.2802916,NSFC; ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8283605,Program comprehension;human-computer interaction;workflow,Tutorials;Programming;Streaming media;Tools;Task analysis;History;Software,,,,1,43,,,,,IEEE,IEEE Journals
Labeling Feature-Oriented Software Clusters for Software Visualization Application,K. Yano; A. Matsuo,NA; NA,2015 Asia-Pacific Software Engineering Conference (APSEC),,2015,,,354,361,"Software clustering techniques have been used to analyze the reality of software structure. The visualization of the detected clusters has also been studied. However, the features implemented by the detected clusters are not obvious and understanding them is a crucial part of the industrial use of software clustering. In this study, we examined the existing information retrieval method and found three major issues it has. We developed technical solutions for each of them: using hierarchical labeling, weighing the words likely representing the feature by considering an architectural convention, and modifying the idf score by the scale of the cluster. The effectiveness of our approach is validated through case studies using actual software products including a COBOL business application. Also, we faced two additional practical problems: effectiveness of the method words and plural and conjugated forms of the words. We found the method name words were less useful than the class name words, and lemmatization was successfully used to normalize the form of the words even in the case of program identifiers.",1530-1362,978-1-4673-9644,10.1109/APSEC.2015.32,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7467321,software maintenance;software clustering;program comprehension;software visualization,Visualization;Labeling;Urban areas;Feature extraction;Business;Software systems,COBOL;feature extraction;information retrieval;pattern clustering;program visualisation;software engineering;software maintenance,program identifiers;class name words;conjugated forms;COBOL business application;software products;idf score;architectural convention;hierarchical weighing;hierarchical labeling;information retrieval method;software structure reality;software clustering techniques;software visualization application;feature-oriented software cluster labeling,,2,16,,,,,IEEE,IEEE Conferences
Information foraging as a foundation for code navigation: NIER track,N. Niu; A. Mahmoud; G. Bradshaw,"Mississippi State University, Mississippi State, MS, USA; Mississippi State University, Mississippi State, MS, USA; Mississippi State University, Mississippi State, MS, USA",2011 33rd International Conference on Software Engineering (ICSE),,2011,,,816,819,A major software engineering challenge is to understand the fundamental mechanisms that underlie the developer's code navigation behavior. We propose a novel and unified theory based on the premise that we can study developer's information seeking strategies in light of the foraging principles that evolved to help our animal ancestors to find food. Our preliminary study on code navigation graphs suggests that the tenets of information foraging provide valuable insight into software maintenance. Our research opens the avenue towards the development of ecologically valid tool support to augment developers' code search skills.,1558-1225;0270-5257,978-1-4503-0445-0978-1-4503-0445,10.1145/1985793.1985911,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032526,foraging theory;program comprehension;software maintenance,Navigation;Biological system modeling;Software maintenance;Maintenance engineering;Profitability;Software engineering;Debugging,software maintenance,information foraging;foundation;code navigation;NIER track;software engineering;information seeking,,6,15,,,,,IEEE,IEEE Conferences
Identifying Code Smells with Collaborative Practices: A Controlled Experiment,R. Oliveira; B. Estácio; A. Garcia; S. Marczak; R. Prikladnicki; M. Kalinowski; C. Lucena,NA; NA; NA; NA; NA; NA; NA,"2016 X Brazilian Symposium on Software Components, Architectures and Reuse (SBCARS)",,2016,,,61,70,"Code smells are often considered as key indicators of software quality degradation. If code smells are not systematically removed from a program, its continuous degradation may lead to either major maintenance effort or the complete redesign of the system. For several reasons, software developers introduce smells in their code as soon as they start to learn programming. If novice developers are ought to become either proficient programmers or skilled code reviewers, they should be early prepared to effectively identify code smells in existing programs. However, effective identification of code smells is often not a non-trivial task in particular to a novice developer working in isolation. Thus, the use of collaborative practices may have the potential to support developers in improving their effectiveness on this task at their early stages of their careers. These practices offer the opportunity for two or more developers analyzing the source code together and collaboratively reason about potential smells prevailing on it. Pair Programming (PP) and Coding Dojo Randori (CDR) are two increasingly adopted practices for improving the effectiveness of developers with limited or no knowledge in software engineering tasks, including code review tasks. However, there is no broad understanding about the impact of these collaborative practices on the effectiveness of code smell identification. This paper presents a controlled experiment involving 28 novice developers, aimed at assessing the effectiveness of collaborative practices in the identification of code smells. We compared PP and CDR with solo programming in order to better distinguish their impact on the effective identification of code smells. Our study is also the first in the literature to observe how novice developers work individually and together to identify smells. Our results suggest that collaborative practices contribute to the effectiveness on the identification of a wide range of code smells. Our findings can also be used in practice to guide educators, researchers or teams on improving detection and training on code smell identification.",,978-1-5090-5086-4978-1-5090-5087,10.1109/SBCARS.2016.18,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7789840,Code Smells;Collaborative Practices;Controlled Experiment;Program Comprehension;Software Degradation,Collaboration;Software;Programming profession;Encoding;Degradation;Software engineering,software maintenance;software quality;software reviews;source code (software),code smell identification;software quality degradation;software maintenance;source code;pair programming;Coding Dojo Randori;CDR;PP;software engineering tasks;code review tasks;solo programming,,5,23,,,,,IEEE,IEEE Conferences
Object-centric debugging,J. Ressia; A. Bergel; O. Nierstrasz,"Software Composition Group, University of Bern, Switzerland; PLEIAD Lab, Department of Computer Science (DCC), University of Chile; Software Composition Group, University of Bern, Switzerland",2012 34th International Conference on Software Engineering (ICSE),,2012,,,485,495,"During the process of developing and maintaining a complex software system, developers pose detailed questions about the runtime behavior of the system. Source code views offer strictly limited insights, so developers often turn to tools like debuggers to inspect and interact with the running system. Unfortunately, traditional debuggers focus on the runtime stack as the key abstraction to support debugging operations, though the questions developers pose often have more to do with objects and their interactions. We propose object-centric debugging as an alternative approach to interacting with a running software system. We show how, by focusing on objects as the key abstraction, natural debugging operations can be defined to answer developer questions related to runtime behavior. We present a running prototype of an object-centric debugger, and demonstrate, with the help of a series of examples, how object-centric debugging offers more effective support for many typical developer tasks than a traditional stack-oriented debugger.",1558-1225;0270-5257;0270-5257,978-1-4673-1067-3978-1-4673-1066-6978-1-4673-1065,10.1109/ICSE.2012.6227167,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227167,debugging;object-oriented programming;reflection;program comprehension,Debugging;Runtime;Data structures;Indexes;Software systems;Monitoring,object-oriented programming;program debugging;software maintenance,object-centric debugging;software system development;software system maintenance;system runtime behavior;source code views;runtime stack;key abstraction;natural debugging operations;stack-oriented debugger,,15,37,,,,,IEEE,IEEE Conferences
Execution Trace Abstraction Based on Meta Patterns Usage,K. Noda; T. Kobayashi; K. Agusa,NA; NA; NA,2012 19th Working Conference on Reverse Engineering,,2012,,,167,176,"Visualizing object interactions in an execution trace with a sequence diagram is a promising technique for helping developers to comprehend effectively the behavior of an object-oriented system. However, in most cases, the reverse-engineered sequence diagram, which is automatically generated from an execution trace, contains enormous amounts of information, which causes scalability issues. In this paper, we present a method that abstracts the history of object interactions based on Pree's meta patterns usage. We identify objects that are strongly related to each other by focusing on the relation of template-hook structures which are often used in object-oriented programming. Grouping the strongly correlated objects, we visualize the system's behavior in terms of intergroup interactions with a sequence diagram. The sequence diagram that is generated is helpful for grasping the big picture of the overall behavior of the system, and so is a valuable aid for program comprehension. In this research, we implemented a tool to visualize the history of object interactions based on our proposed method and demonstrated the feasibility of our proposed method. We applied the tool to three kinds of open-source software systems and evaluated the effectiveness of our proposed method in program comprehension tasks.",2375-5369;1095-1350,978-0-7695-4891-3978-1-4673-4536,10.1109/WCRE.2012.26,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385112,Reverse Engineering;Meta Patterns;Execution Trace Analysis;Dynamic Analysis;Program Comprehension;Sequence Diagram,Visualization;Java;Abstracts;History;Runtime;Software systems;Aggregates,data visualisation;object-oriented programming;program diagnostics;public domain software,execution trace abstraction;meta patterns usage;object interaction visualization;sequence diagram;object-oriented system;scalability issues;template-hook structures;object-oriented programming;open-source software systems;program comprehension tasks,,5,25,,,,,IEEE,IEEE Conferences
Code Comprehension Activities in Undergraduate Software Engineering Course - A Case Study,S. K. Sripada; Y. R. Reddy,NA; NA,2015 24th Australasian Software Engineering Conference,,2015,,,68,77,"In industry, inspections, reviews, and refactoring are considered as necessary software engineering activities for enhancing quality of code. In academia, such activities are rarely taught and practiced at Undergraduate level due to various reasons like limited skill set, limited knowledge of the available tools, time constraints, project setting, project client availability, flexibility with Syllabus, etc. However, we argue that such activities are an essential part of introductory software engineering courses and can result in improvement of coding skills, knowledge of coding standard and compliance to the same, and peer communication within teams. We have studied the use of such activities in a sophomore level Software Engineering course consisting of more than 200 students working in teams on projects from start-ups and present our experiences, findings and challenges. We present the results of quantitative evaluation of the impact of code comprehension activities before and after each iteration of the team projects.",1530-0803,978-1-4673-9390,10.1109/ASWEC.2015.18,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7365795,Code Inspection;Code Reviews;Program Comprehension;Refactoring;Static Code Analysis;Textual Analysis,Measurement;Inspection;Software engineering;Software;Standards;Encoding;Writing,computer science education;educational courses;further education;software engineering,undergraduate software engineering course;code comprehension activities;introductory software engineering courses,,,23,,,,,IEEE,IEEE Conferences
The Influence of the Task on Programmer Behaviour,A. T. T. Ying; M. P. Robillard,NA; NA,2011 IEEE 19th International Conference on Program Comprehension,,2011,,,31,40,"Programmers performing a change task must understand the existing software in addition to performing the actual change. This process is likely to be affected by characteristics of the task. We investigated whether the nature of a task has any relationship with when a programmer edits code during a programming session. We characterized differences in editing behaviour with three types of editing styles: edit-first, edit-last, and edit-throughout. We based our analysis on the interaction history of over 4000 programming sessions collected as part of the development history of open source projects. Our results showed that an enhancement task (as opposed to a bug fix) was less likely to be associated with a high fraction of source code edit events at the beginning of the programming session. To our surprise, we also found that the presence of a stack trace in a bug report did not significantly effect the editing style of the programming session.",1092-8138;1092-8138,978-1-61284-308-7978-0-7695-4398,10.1109/ICPC.2011.35,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970161,Program comprehension;Development interaction history;Mining software archives,History;Programming;Monitoring;Clustering algorithms;Software;Couplings;Navigation,behavioural sciences;program debugging;programming;software engineering,programmer behaviour;programming session;editing behaviour;editing style;edit-first style;edit-last style;edit-throughout style;interaction history;development history;open source projects;enhancement task;bug fix;source code editing;stack trace;bug report,,20,35,,,,,IEEE,IEEE Conferences
The Effect of Lexicon Bad Smells on Concept Location in Source Code,S. L. Abebe; S. Haiduc; P. Tonella; A. Marcus,NA; NA; NA; NA,2011 IEEE 11th International Working Conference on Source Code Analysis and Manipulation,,2011,,,125,134,"Experienced programmers choose identifier names carefully, in the attempt to convey information about the role and behavior of the labeled code entity in a concise and expressive way. In fact, during program understanding the names given to code entities represent one of the major sources of information used by developers. We conjecture that lexicon bad smells, such as, extreme contractions, inconsistent term use, odd grammatical structure, etc., can hinder the execution of maintenance tasks which rely on program understanding. We propose an approach to determine the extent of this impact and instantiate it on the task of concept location. In particular, we conducted a study on two open source software systems where we investigated how lexicon bad smells affect Information Retrieval-based concept location. In this study, the classes changed in response to past modification requests are located before and after lexicon bad smells are identified and removed from the source code. The results indicate that lexicon bad smells impact concept location when using IR-based techniques.",,978-1-4577-0932,10.1109/SCAM.2011.18,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6065171,lexicon bad smells;program comprehension;concept location;text retrieval;software lexicon;code smells,Software systems;Maintenance engineering;Computer bugs;Filtering;Containers;Terminology,grammars;object-oriented programming;public domain software;reverse engineering;software maintenance,lexicon bad smell;source code concept location;identifier name;labeled code entity;program understanding;extreme contraction;inconsistent term use;odd grammatical structure;maintenance task execution;open source software system;information retrieval;modification request;object-oriented software system,,15,29,,,,,IEEE,IEEE Conferences
Measuring the Complexity of Traces Using Shannon Entropy,A. Hamou-Lhadj,NA,Fifth International Conference on Information Technology: New Generations (itng 2008),,2008,,,489,494,"Exploring the content of large execution traces can be a tedious task without efficient tool support. Building efficient trace analysis tools, however, requires a good understanding of the complexity embedded in traces. Trace complexity has traditionally been measured using the file size or the number of lines in the trace. In this paper, we argue that these metrics provide limited indication of the effort required to understand the content of a trace. We address this issue by introducing new trace complexity metrics based on the concept of entropy. Our metrics measure two important aspects of an execution trace: repeatability and variability. We present a case study where we apply the metrics to several execution traces. A discussion on how we can reduce the complexity of a trace based on these metrics is also presented.",,978-0-7695-3099-40-7695-3099,10.1109/ITNG.2008.169,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4492527,Dynamic analysis;trace complexity;Shannon entropy;program comprehension;software maintenance,Entropy;Size measurement;Information technology;Electric variables measurement;Software maintenance;Information theory;Filtering;Software systems,information theory;program diagnostics;software metrics,trace complexity measures;Shannon entropy;trace analysis tools;repeatability aspect;variability aspect;information theory,,3,15,,,,,IEEE,IEEE Conferences
Visual Approach for Change Impact Analysis: A Controlled Experiment,F. M. Delfim; L. P. Scatalon; J. M. Prates; R. E. Garcia,NA; NA; NA; NA,2015 12th International Conference on Information Technology - New Generations,,2015,,,391,396,"In the context of Software Maintenance, when a source code element must be changed, there is the need to identify if other elements will be affected by the change, in order to keep the code consistent. This identification is performed during the activity of change impact analysis. Aiming to support maintainers during this activity, software visualization tools allow a visual exploration of source code elements. In this paper, we present a study aimed at evaluating the support provided to change impact analysis by visual representations of Java program elements and their associations. To this end, we conducted a controlled experiment involving 24 undergraduate students, comparing the visual support approach and an ad hoc approach, where only the source code is analyzed to estimate impact change. Results showed that the effectiveness obtained by using the visual approach is significantly superior. This is an indication that visual support should be considered to change impact analysis aiming at reducing software maintenance costs.",,978-1-4799-8828-0978-1-4799-8827,10.1109/ITNG.2015.69,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7113504,Software Maintenance;Program Comprehension;Change Impact Analysis;Software Visualization;Controlled Experiment,Visualization;Software;Training;Context;Java;Sun;Computer numerical control,Java;software maintenance;source code (software),visual approach;change impact analysis;software maintenance;source code element;software visualization tool;Java program element;visual representations;visual support approach;ad hoc approach,,,28,,,,,IEEE,IEEE Conferences
Toward a dynamic analysis technique to locate framework misuses that cause unexpected side effects,I. Kume; M. Nakamura; N. Nitta; E. Shibayama,"Graduate School of Information Science, Nara Institute of Science and Technology Ikoma, Nara, Japan; Graduate School of System Informatics, Kobe University Nada, Kobe, Japan; Faculty of Intelligence and Informatics, Konan University Higashinada, Kobe, Japan; Information Technology Center, The University of Tokyo Bunkyo, Tokyo, Japan","15th IEEE/ACIS International Conference on Software Engineering, Artificial Intelligence, Networking and Parallel/Distributed Computing (SNPD)",,2014,,,1,6,"Recently many frameworks are used in software development without proper documentation, and are misused by application developers in calling framework APIs. Debugging a failure caused by a wrong API call is difficult and requires a proper supporting technique. In our preceding study we developed a dynamic analysis technique to detect possibly unexpected side effects that cause failures. In this paper, we introduce a case study to identify a wrong API call using this technique.",,978-1-4799-5604,10.1109/SNPD.2014.6888730,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6888730,Application Frameworks;Debug;Side Effect;Symp-toms;Dynamic Analysis;Program Comprehension,Unified modeling language;Runtime;Educational institutions;Debugging;Java;Electronic mail;Image edge detection,application program interfaces;program debugging;system monitoring,dynamic analysis technique;software development;wrong API call;program debugging,,,16,,,,,IEEE,IEEE Conferences
Cognitive task difficulty analysis using EEG and data mining,A. Duraisingam; R. Palaniappan; S. Andrews,"Data Science (E-Health) Research Group, School of Computing, University of Kent, Chatham, UK; Data Science (E-Health) Research Group, School of Computing, University of Kent, Chatham, UK; Mahendra Engineering College, Salem, India",2017 Conference on Emerging Devices and Smart Systems (ICEDSS),,2017,,,52,57,"Existing research on task difficulty and program comprehension mainly concentrate on brain areas related to attention and meditation. In this research, an in-depth analysis of Task Difficulty Level (TDL) for program comprehension is proposed with features extracted from different areas of the brain. Two levels of task difficulty were analysed: easy and difficult. Eight students were asked to solve nine Java programs of different difficulty level and the subject's cognitive load was recorded using EEG. Four different feature extraction methods were used for analysis - Energy, Frequency ratio, Event Related De-Synchronization (ERD) and Asymmetry ratio and Naïve Bayes classifier was used for classifying different TDL. The results indicated that the recorded EEG signals could reflect TDL for program comprehension tasks for predicting easy and difficult tasks. The classifier predicted task difficulty (easy/difficult) of a new task with an overall correctly classified accuracy of 76.55% with a precision of 80.03% and recall of 76.66%. This in-depth analysis of TDL for program comprehension tasks using EEG could support in developing future generation learning tools.",,978-1-5090-5555-5978-1-5090-5556,10.1109/ICEDSS.2017.8073658,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8073658,Electroencephalogram;Naive Bayes classifier;Program comprehension;Task difficulty,Electroencephalography;Feature extraction;Java;Cognition;Electrodes;Tools,Bayes methods;cognition;data mining;electroencephalography;feature extraction;Java;learning (artificial intelligence);medical signal processing;signal classification,program comprehension tasks;easy tasks;in-depth analysis;cognitive task difficulty analysis;data mining;brain areas;Task Difficulty Level;Java programs;Naïve Bayes classifier;feature extraction methods;cognitive load;frequency ratio;event related desynchronization;asymmetry ratio;learning tools;EEG signal;meditation,,,22,,,,,IEEE,IEEE Conferences
Toward Summary Extraction Method for Functional Topic,W. Li; Y. Cao; J. Zhao; Y. Zou; B. Xie,NA; NA; NA; NA; NA,"2017 IEEE International Conference on Software Quality, Reliability and Security Companion (QRS-C)",,2017,,,16,23,"Understanding the function of software code is the basis for software reuse. Topic modeling technologies can mine functional topics from source code and help developers comprehend the functional concerns about a software system and the corresponding implementations in source code. However, lacking clear explanations makes these functional topics hard to be understood by the developers. Furthermore, giving proper interpretations to these topics manually is time consuming. In this paper, we firstly use self-parameter-optimizing Latent Dirichlet Allocation (LDA) technology to mine the functional topic for the software. Then we put forward an approach for calculating the relevancy between functional topics and software documents. The LexRank technology is used to automatically generate summary for those topics from software documents such as user manuals, pairs of question and answer, mailing lists and so on. The experiment results indicate that these summaries improve developers understanding the function of software code.",,978-1-5386-2072-4978-1-5386-2073,10.1109/QRS-C.2017.13,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8004289,topic model;LDA;functional summarization;program comprehension,Data mining;Data models;Data preprocessing;Software reusability;Resource management;Manuals,data mining;software reusability;source code (software);text analysis,software code function;software reuse;source code;software system;self-parameter-optimizing latent Dirichlet allocation technology;functional topic mining;topic modeling;software documents;LexRank technology;summary extraction method,,,36,,,,,IEEE,IEEE Conferences
Automated Documentation of Android Apps,E. Aghajani; G. Bavota; M. Linares-Vásquez; M. Lanza,"Informatics, Universita della Svizzera Italiana, 27216 Lugano, Ticino Switzerland (e-mail: emad.aghajani@usi.ch); Faculty of Informatics, Universita della Svizzera Italiana, 27216 Lugano, Lugano Switzerland 6904 (e-mail: gabriele.bavota@usi.ch); Systems Engineering and Computing, Universidad de los Andes, 27991 Bogota, Bogota Colombia (e-mail: m.linaresv@uniandes.edu.co); Faculty of Informatics, University of Lugano, Lugano, TI Switzerland 6904 (e-mail: michele.lanza@usi.ch)",IEEE Transactions on Software Engineering,,2018,PP,99,1,1,"Developers do not always have the knowledge needed to understand source code and must refer to different resources (e.g., teammates, documentation, the web). This non-trivial process, called program comprehension, is very time-consuming. While many approaches support the comprehension of a given code at hand, they are mostly focused on defining extractive summaries from the code (i.e., on selecting from a given piece of code the most important statements/comments to comprehend it). However, if the information needed to comprehend the code is not there, their usefulness is limited. We present ADANA, an approach to automatically inject comments describing a given piece of Android code. ADANA reuses the descriptions of similar and well-documented code snippets retrieved from various online resources. Our evaluation has shown that ADANA is able to aid the program comprehension process.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2018.2890652,Schweizerischer Nationalfonds zur Forderung der Wissenschaftlichen Forschung; ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8598894,Program Comprehension;Documentation;Android,Knowledge based systems;Documentation;Java;Cloning;Asia;Task analysis;Data mining,,,,,,,,,,IEEE,IEEE Early Access Articles
Identifying computational phases from inter-process communication traces of HPC applications,L. Alawneh; A. Hamou-Lhadj,"Software Behaviour Analysis (SBA) Research Lab, Department of Electrical and Computer Engineering, Concordia University, 1455 de Maisonneuve Blvd. West, Montreal, QC, Canada H3G 1M8; Software Behaviour Analysis (SBA) Research Lab, Department of Electrical and Computer Engineering, Concordia University, 1455 de Maisonneuve Blvd. West, Montreal, QC, Canada H3G 1M8",2012 20th IEEE International Conference on Program Comprehension (ICPC),,2012,,,133,142,"Understanding the behaviour of High Performance Computing (HPC) systems is a challenging task due to the large number of processes they involve as well as the complex interactions among these processes. In this paper, we present a novel approach that aims to simplify the analysis of large execution traces generated from HPC applications. We achieve this through a technique that allows semiautomatic extraction of execution phases from large traces. These phases, which characterize the main computations of the traced scenario, can be used by software engineers to browse the content of a trace at different levels of abstraction. Our approach is based on the application of information theory principles to the analysis of sequences of communication patterns found in HPC traces. The results of the proposed approach when applied to traces of a large HPC industrial system demonstrate its effectiveness in identifying the main program phases and their corresponding sub-phases.",1092-8138,978-1-4673-1216-5978-1-4673-1213-4978-1-4673-1215,10.1109/ICPC.2012.6240481,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240481,program comprehension;dynamic analysis;high performance computing aystems;inter-process communication traces;execution phases,Phase detection;Entropy;Data models;Algorithm design and analysis;Topology;Message passing;Equations,distributed processing;information theory,computational phase identification;interprocess communication traces;HPC applications;high performance computing systems;execution trace analysis;execution phase semiautomatic extraction;information theory principles;communication pattern sequence;HPC industrial system;program phases,,5,30,,,,,IEEE,IEEE Conferences
Towards Behavioral Reflexion Models,C. Ackermann; M. Lindvall; R. Cleaveland,NA; NA; NA,2009 20th International Symposium on Software Reliability Engineering,,2009,,,175,184,"Software architecture has become essential in the struggle to manage today's increasingly large and complex systems. Software architecture views are created to capture important system characteristics on an abstract and, thus, comprehensible level. As the system is implemented and later maintained, it often deviates from the original design specification. Such deviations can have implication for the quality of the system, such as reliability, security, and maintainability. Software architecture compliance checking approaches, such as the reflexion model technique, have been proposed to address this issue by comparing the implementation to a model of the systems' architecture design. However, architecture compliance checking approaches focus solely on structural characteristics and ignore behavioral conformance. This is especially an issue in Systems-of-Systems. Systems-of-Systems (SoS) are decompositions of large systems, into smaller systems for the sake of flexibility. Deviations of the implementation to its behavioral design often reduce the reliability of the entire SoS. An approach is needed that supports the reasoning about behavioral conformance on architecture level.In order to address this issue, we have developed an approach for comparing the implementation of a SoS to an architecture model of its behavioral design. The approach follows the idea of reflexion models and adopts it to support the compliance checking of behaviors. In this paper, we focus on sequencing properties as they play an important role in many SoS. Sequencing deviations potentially have a severe impact on the SoS' correctness and qualities. The desired behavioral specification is defined in UML sequence diagram notation and behaviors are extracted from the SoS implementation. The behaviors are then mapped to the model of the desired behavior and the two are compared. Finally, a reflexion model is constructed that shows the deviations between behavioral design and implementation. This paper discusses the approach and shows how it can be applied to investigate reliability issues in SoS.",1071-9458;2332-6549,978-1-4244-5375-7978-0-7695-3878,10.1109/ISSRE.2009.27,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5362111,Software engineering;software reliability;behavioral analysis;program comprehension;behavior verification,Computer architecture;Software architecture;Documentation;Maintenance;Security;Software reliability;Software engineering;Software quality;Reliability engineering;Educational institutions,large-scale systems;reliability;software architecture;Unified Modeling Language,behavioral reflexion models;software architecture;complex systems;original design specification;reliability;security;maintainability;reflexion model technique;architecture compliance checking;ignore behavioral conformance;systems of systems;behavioral design implementation;behavioral conformance architecture level;compliance checking behaviors;sequencing deviations potentially;UML sequence diagram notation;SoS implementation,,3,14,,,,,IEEE,IEEE Conferences
Autumn Leaves: Curing the Window Plague in IDEs,D. Roethlisberger; O. Nierstrasz; S. Ducasse,NA; NA; NA,2009 16th Working Conference on Reverse Engineering,,2009,,,237,246,"Navigating large software systems is difficult as the various artifacts are distributed in a huge space, while the relationships between different artifacts often remain hidden and obscure. As a consequence, developers using a modern interactive development environment (IDE) are forced to open views on numerous source artifacts to reveal these hidden relationships, leading to a crowded workspace with many opened windows or tabs. Developers often lose the overview in such a cluttered workspace as IDEs provide little support to get rid of unused windows. AutumnLeaves automatically selects windows unlikely for future use to be closed or grayed out while important ones are displayed more prominently. This reduces the number of windows opened at a time and adds structure to the developer's workspace. We validate AutumnLeaves with a benchmark evaluation using recorded navigation data of various developers to determine the prediction quality of the employed algorithms.",1095-1350;2375-5369,978-0-7695-3867,10.1109/WCRE.2009.18,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5328777,development environments;software navigation;developer activity analysis;productivity;program comprehension,Curing;Navigation;Reverse engineering;Europe;Software systems;Open source software;Productivity;Scattering;Application software;Programming,software engineering;user interfaces,Autumn Leaves;window plague;IDE;interactive development environment;source artifacts;software navigation,,12,22,,,,,IEEE,IEEE Conferences
Using stereotypes in the automatic generation of natural language summaries for C++ methods,N. J. Abid; N. Dragan; M. L. Collard; J. I. Maletic,"Department of Computer Science, Kent State University, Ohio 44242, USA; Department of Mang. and Info Systems, Kent State University, Ohio, USA; Department of Computer Science, The University of Akron, Ohio, United States of America; Department of Computer Science, Kent State University, Ohio 44242, USA",2015 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2015,,,561,565,"An approach to automatically generate natural language documentation summaries for C++ methods is presented. The approach uses prior work by the authors on stereotyping methods along with the source code analysis framework srcML. First, each method is automatically assigned a stereotype(s) based on static analysis and a set of heuristics. Then, the approach uses the stereotype information, static analysis, and predefined templates to generate a natural-language summary for each method. This summary is automatically added to the code base as a comment for each method. The predefined templates are designed to produce a generic summary for specific method stereotypes. Static analysis is used to extract internal details about the method (e.g., parameters, local variables, calls, etc.). This information is used to specialize the generated summaries.",,978-1-4673-7532-0978-1-4673-7531,10.1109/ICSM.2015.7332514,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7332514,source-code summarization;program comprehension;method stereotypes;static analysis,Documentation;Java;Taxonomy;Maintenance engineering;Natural language processing,C++ language;program diagnostics;source code (software);system documentation,natural language summaries automatic generation;C++ methods;natural language documentation summaries;stereotyping methods;source code analysis framework;srcML;static analysis,,8,22,,,,,IEEE,IEEE Conferences
Debugging Data Flows in Reactive Programs,H. Banken; E. Meijer; G. Gousios,NA; NA; NA,2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE),,2018,,,752,763,"Reactive Programming is a style of programming that provides developers with a set of abstractions that facilitate event handling and stream processing. Traditional debug tools lack support for Reactive Programming, leading developers to fallback to the most rudimentary debug tool available: logging to the console. In this paper, we present the design and implementation of RxFiddle, a visualization and debugging tool targeted to Rx, the most popular form of Reactive Programming. RxFiddle visualizes the dependencies and structure of the data flow, as well as the data inside the flow. We evaluate RxFiddle with an experiment involving 111 developers. The results show that RxFiddle can help developers finish debugging tasks faster than with traditional debugging tools.",1558-1225,978-1-4503-5638-1978-1-5386-5293,10.1145/3180155.3180156,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453148,reactive programming;debugging;visualization;program comprehension,Debugging;Programming;Tools;Observers;Libraries;Companies;Interviews,program debugging;program visualisation,debugging tool;RxFiddle;data flow;debugging tasks;traditional debugging tools;stream processing;traditional debug tools;rudimentary debug tool;reactive programming,,1,52,,,,,IEEE,IEEE Conferences
Data access visualization for legacy application maintenance,K. Yano; A. Matsuo,"Information Systems Technologies Laboratory, Fujitsu Laboratories, Kawasaki, Japan; Information Systems Technologies Laboratory, Fujitsu Laboratories, Kawasaki, Japan","2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER)",,2017,,,546,550,"Software clustering techniques have been studied and applied to analyze and visualize the actual structure of legacy applications, which have used program information, e.g., dependencies, as input. However, business data also play an important role in a business system. Revealing which programs actually use data in the current system can give us a key insight when analyzing a long-lived complicated system. In this paper, we calculate indexes indicating how a data entity is used, making use of software clustering, which can be used to detect problematic or characteristic parts of the system. The developed technique can reveal the characteristics of a data entity; i.e., it is used like master data. We applied this technique to two business systems used for many years and found that our technique can help us understand the systems in terms of business data usage. Through case studies, we evaluated the validity of the indexes and showed that software visualization with the indexes can be used to investigate a system in an exploratory way.",,978-1-5090-5501-2978-1-5090-5502,10.1109/SANER.2017.7884671,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7884671,Software clustering;software visualization;program comprehension;database,Indexes;Data visualization;Business;Maintenance engineering;Software systems;Writing,program diagnostics;software maintenance,data access visualization;legacy application maintenance;data entity;software clustering;software visualization,,1,16,,,,,IEEE,IEEE Conferences
Object Oriented Software Clustering Based on Community Structure,U. Erdemir; U. Tekin; F. Buzluca,NA; NA; NA,2011 18th Asia-Pacific Software Engineering Conference,,2011,,,315,321,"Software comprehension plays a critical role in software maintenance. Understanding a software system is not an easy task because in most cases documentation of software design is outdated, incomplete or absent. Therefore support of tools and algorithms are necessary for software developers to understand software quicker and easier. Clustering algorithms have been widely used for software architecture recovery. Their performance depends not only on the algorithm itself but also on the nature of the software system. For example, an algorithm that is successful for a procedural program or a small software system or might be unsuccessful for a large system developed in object-oriented paradigm. In this paper, we propose the adaption of the fast community detection algorithm for object-oriented software clustering and evaluate its performance with other clustering algorithms in the literature. It is an agglomerative hierarchical clustering algorithm that has been introduced to find communities in networks. The algorithm can operate on directed weighted graphs and it has a considerable speed advantage over other algorithms. Experimental results show that the algorithm also performs well for clustering object-oriented systems.",1530-1362;1530-1362;1530-1362,978-1-4577-2199-1978-0-7695-4609,10.1109/APSEC.2011.33,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6130702,Software Architecture Recovery;Software Clustering;Reverse Engineering;Program Comprehension,Clustering algorithms;Software algorithms;Communities;Software systems;Partitioning algorithms;Algorithm design and analysis,directed graphs;object-oriented methods;pattern clustering;software architecture;software maintenance,object oriented software clustering;community structure;software maintenance;software design;software developers;software architecture recovery;procedural program;software system;fast community detection algorithm;agglomerative hierarchical clustering algorithm;directed weighted graphs,,4,31,,,,,IEEE,IEEE Conferences
Behavior-Informed Algorithms for Automatic Documentation Generation,P. Rodeghero,NA,2017 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2017,,,660,664,"Programmers rely on source code documentation to quickly understand what the source code does and how they would use it. Unfortunately, many programmers do not have the time to write and maintain source code documentation. A solution to this problem is to document and summarize source code automatically. Unfortunately, research efforts to automatically generate documentation have stalled recently because the research community does not know exactly what a summary of source code should include. To solve this problem, my overall strategy is to study programmer behavior in order to write algorithms that mimic that behavior. I have four key areas of work in which I execute that strategy: First, I determine what areas of code programmers read when they create documentation. Second, I find patterns in programmers' eye movements when they reading code. Third, I use recordings of developer-client meetings to extract user story information. Finally, I propose to conduct a grounded theory study at a medium sized software company to determine whether factors outside the code influence source code summarization. This paper discusses the foundation for my career in the software engineering community, and I seek the community's advice.",,978-1-5386-0992-7978-1-5386-0993,10.1109/ICSME.2017.73,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8094477,Source code summaries;program comprehension,Documentation;Software;Tools;Data mining;Companies;Human factors,software engineering;source code (software);system documentation,automatic documentation generation;source code documentation;programmer behavior;code programmers;behavior-informed algorithms;developer-client meetings;medium sized software company;source code summarization;software engineering community,,,47,,,,,IEEE,IEEE Conferences
The SEXTANT Software Exploration Tool,T. Schafer; M. Eichberg; M. Haupt; M. Mezini,"Software Technology Group, Darmstadt University of Technology, Hochschultsr. 10, 64289 Darmstadt, Germany; Software Technology Group, Darmstadt University of Technology, Hochschultsr. 10, 64289 Darmstadt, Germany; Software Technology Group, Darmstadt University of Technology, Hochschultsr. 10, 64289 Darmstadt, Germany; Software Technology Group, Darmstadt University of Technology, Hochschultsr. 10, 64289 Darmstadt, Germany",IEEE Transactions on Software Engineering,,2006,32,9,753,768,"In this paper, we discuss a set of functional requirements for software exploration tools and provide initial evidence that various combinations of these features are needed to effectively assist developers in understanding software. We observe that current tools for software exploration only partly support these features. This has motivated the development of SEXTANT, a software exploration tool tightly integrated into the Eclipse IDE that has been developed to fill this gap. By means of case studies, we demonstrate how the requirements fulfilled by SEXTANT are conducive to an understanding needed to perform a maintenance task",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2006.94,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1707671,Software exploration;program comprehension;reverse engineering;software maintenance;software visualization.,Software tools;Visualization;Navigation;Software maintenance;Cognition;Computer architecture;Reverse engineering,formal specification;program visualisation;programming environments;reverse engineering;software maintenance,functional requirement;SEXTANT software exploration tool;software understanding;Eclipse IDE;software maintenance;program comprehension;reverse engineering;software visualization,,9,60,,,,,IEEE,IEEE Journals
Semantic Navigation Strategies for Scenario-Based Programming,M. Gordon; D. Harel,NA; NA,2010 IEEE Symposium on Visual Languages and Human-Centric Computing,,2010,,,219,226,"The scenario-based approach to specification and programming uses powerful extensions of sequence diagrams, such as LSCs (live sequence charts), to model system behavior. Previous work in this area presents interesting challenges related to the scalability of the approach and to better tool support for analysis, execution, and comprehension. Here we suggest new semantic-rich ways of viewing sequence diagrams and LSCs for better comprehension of both a single large chart and a full multi-chart specification, in a variety of software engineering tasks. Our method uses weighted messages to create a semantic order that enables semantic zooming and scrolling of different parts of a chart, providing visual hints about context.",1943-6106;1943-6092,978-1-4244-8485,10.1109/VLHCC.2010.38,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5635234,Live Sequence Charts;Sequence Diagrams;Semantic Zoom;Program Navigation;Program Comprehension,Semantics;Navigation;Visualization;Programming;Context;Unified modeling language;Scalability,formal specification;navigation;programming languages,semantic navigation strategies;scenario-based programming;specification;sequence diagrams;tool support;live sequence charts,,1,17,,,,,IEEE,IEEE Conferences
Pattern Recognition Techniques Applied to the Abstraction of Traces of Inter-Process Communication,L. Alawneh; A. Hamou-Lhadj,NA; NA,2011 15th European Conference on Software Maintenance and Reengineering,,2011,,,211,220,"The large number of processors in high performance computing and distributed applications is becoming a major challenge in the analysis of the way an application's processes communicate with each other. In this paper, we propose an approach that facilitates the understanding of large traces of inter-process communication by extracting communication patterns that characterize their main behavior. Two algorithms are proposed. The first one permits the recognition of repeating patterns in traces of MPI (Message Passing Interface) applications whereas the second algorithm searches if a given communication pattern occurs in a trace. Both algorithms are based on the n-gram extraction technique used in natural language processing. Unlike existing work, our approach operates on the trace as it is generated (i.e. on the fly) and does not require complex and computationally-expensive data structures. We show the effectiveness and efficiency of our approach in detecting communication patterns from large traces generated from two target systems.",1534-5351;1534-5351,978-1-61284-259-2978-0-7695-4343,10.1109/CSMR.2011.27,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5741263,Trace of Inter-Process Communication;Pattern Recognition;Message Passing Interface;Dynamic Analysis;Program Comprehension,Pattern matching;Software;Algorithm design and analysis;Topology;Detection algorithms;Message passing,message passing;natural language processing;pattern recognition;program diagnostics,processor;high performance computing;distributed application;interprocess communication;repeating pattern recognition;MPI;message passing interface;n-gram extraction;natural language processing;communication pattern detection;trace abstraction,,9,30,,,,,IEEE,IEEE Conferences
A Toolkit for Visualizing the Runtime Behavior of TinyOS Applications,A. R. Dalton; J. O. Hallstrom,NA; NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,43,52,"TinyOS has proven to be an effective platform for developing reactive embedded network applications. However, the platform's lean programming model and power-efficient operation come at a price: TinyOS applications are notoriously difficult to construct and debug. The development difficulties stem, in large part, from a programming model founded on events and deferred execution. In short, the model introduces non-determinism in the execution ordering of primitive actions (i.e., commands, events, and tasks). The resulting set of possible execution sequences is typically large, and can swamp developers' unaided intellectual ability to reason about program behavior. In this paper, we present a platform-neutral visualization toolkit for TinyOS 2.0 to aid in program comprehension. The goal is to assist developers in reasoning about the computation forest underlying a system under test, and the particular branches chosen during each run. The toolkit design includes (i) a full-featured static analysis and instrumentation library, (ii) a selection-based probe insertion system, (iii) a lightweight event recording service, (iv) a trace extraction and reconstruction tool, and (v) two visualization front-ends. We demonstrate the utility of the toolkit using standard system examples, and present an analysis of the toolkit's resource usage and performance characteristics.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.22,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556116,sensor networks;embedded networks;TinyOS;nesC;program visualization;program comprehension;program analysis;program tracing,Visualization;Runtime;Power system modeling;Computer networks;Hardware;Embedded computing;System testing;Instruments;Libraries;Probes,operating systems (computers);program debugging;program diagnostics;program visualisation,runtime behavior;TinyOS;reactive embedded network applications;lean programming model;program debugging;execution sequences;platform-neutral visualization toolkit;system under test;static analysis;instrumentation library;probe insertion system,,6,21,,,,,IEEE,IEEE Conferences
Impact of Limited Memory Resources,D. Binkley; D. Lawrie; S. Maex; C. Morrell,NA; NA; NA; NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,83,92,"Since early variable mnemonics were limited to as few as six to eight characters, many early programmers abbreviated concepts in their variable names. The past thirty years has seen a steady increase in permitted name length and, slowly, an increase in the actual length of identifiers. However, in theory names can be too long. Most obviously, in object-oriented programs, names often involve chaining of method calls and field selectors (e.g., class.firstAssignment().name.trim()). While longer names bring the potential for easier comprehension through more embedded sub-words, there are practical limits to length given limited human memory resources. The central hypothesis studied herein is that names used in modern programs have reached this limit. Statistical models derived from an experiment involving 158 programmers of varying degrees of experience show that longer names extracted from production code take more time to process and reduce correctness in a simple recall activity. This has clear negative implications for any attempt to read, and hence comprehend or manipulate, the source code of modern software. The experiment also evaluates the advantage of identifiers having ties to a programmer's persistent memory. Combined these results reinforce past proposals advocating the use of limited, consistent, and regular vocabulary in identifier names. In particular, good naming limits length and reduces the need for specialized vocabulary.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.31,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556120,program comprehension;memory;identifier names,Programming profession;Humans;Production;Vocabulary;Computer languages;Educational institutions;USA Councils;Object oriented modeling;Proposals;Natural languages,object-oriented programming;program compilers;resource allocation,object-oriented program;human memory resource;statistical model;modern software;source code;programmer persistent memory;program compiler,,5,13,,,,,IEEE,IEEE Conferences
Key Elements Extraction and Traces Comprehension Using Gestalt Theory and the Helmholtz Principle,R. Khoury; L. Shi; A. Hamou-Lhadj,NA; NA; NA,2016 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2016,,,478,482,"Trace analysis techniques are used by software engineers to understand the behaviour of large systems. This understanding can facilitate various software maintenance activities including debugging and feature enhancement. However, traces usually tend to be very large, which makes it difficult for software engineers to unveil the key logic and functionalities embedded in a program's execution. Hence, it is necessary to develop methods and tools that can efficiently identify the important information contained in a large trace. In this paper, we propose an approach that builds on the concept of trace segmentation to extract the major components of a traced scenario. Our approach is based on Gestalt theory and the Helmholtz principle. We show the effectiveness of our approach by applying it to a dataset of large traces.",,978-1-5090-3806-0978-1-5090-3807,10.1109/ICSME.2016.24,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7816498,Trace analysis;trace segmentation;program Comprehension;Gestalt Theory;Helmholtz Principle,Shape;Psychology;Software maintenance;Debugging;Mathematical model;Phase detection,program diagnostics,key elements extraction;traces comprehension;Gestalt theory;helmholtz principle;trace analysis techniques;software engineers;trace segmentation concept,,,23,,,,,IEEE,IEEE Conferences
Developer Reading Behavior While Summarizing Java Methods: Size and Context Matters,N. J. Abid; B. Sharif; N. Dragan; H. Alrasheed; J. I. Maletic,"Taibah University, Saudi Arabia; University of Nebraska - Lincoln, USA; Kent State University, USA; King Saud University, Saudi Arabia; Kent State University, USA",2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE),,2019,,,384,395,"An eye-tracking study of 18 developers reading and summarizing Java methods is presented. The developers provide a written summary for methods assigned to them. In total, 63 methods are used from five different systems. Previous studies on this topic use only short methods presented in isolation usually as images. In contrast, this work presents the study in the Eclipse IDE allowing access to all the source code in the system. The developer can navigate via scrolling and switching files while writing the summary. New eye-tracking infrastructure allows for this improvement in the study environment. Data collected includes eye gazes on source code, written summaries, and time to complete each summary. Unlike prior work that concluded developers focus on the signature the most, these results indicate that they tend to focus on the method body more than the signature. Moreover, both experts and novices tend to revisit control flow terms rather than reading them for a long period. They also spend a significant amount of gaze time and have higher gaze visits when they read call terms. Experts tend to revisit the body of the method significantly more frequently than its signature as the size of the method increases. Moreover, experts tend to write their summaries from source code lines that they read the most.",1558-1225;0270-5257,978-1-7281-0869-8978-1-7281-0870,10.1109/ICSE.2019.00052,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812039,source code summarization;eye tracking;program comprehension;empirical study,Java;Gaze tracking;Task analysis;Natural languages;Software engineering;Switches,,,,,48,,,,,IEEE,IEEE Conferences
Modeling the ownership of source code topics,C. S. Corley; E. A. Kammer; N. A. Kraft,"Department of Computer Science, The University of Alabama, Tuscaloosa, AL 35487-0290; Department of Computer Science, The University of Alabama, Tuscaloosa, AL 35487-0290; Department of Computer Science, The University of Alabama, Tuscaloosa, AL 35487-0290",2012 20th IEEE International Conference on Program Comprehension (ICPC),,2012,,,173,182,"Exploring linguistic topics in source code is a program comprehension activity that shows promise in helping a developer to become familiar with an unfamiliar software system. Examining ownership in source code can reveal complementary information, such as who to contact with questions regarding a source code entity, but the relationship between linguistic topics and ownership is an unexplored area. In this paper we combine software repository mining and topic modeling to measure the ownership of linguistic topics in source code. We conduct an exploratory study of the relationship between linguistic topics and ownership in source code using 10 open source Java systems. We find that classes that belong to the same linguistic topic tend to have similar ownership characteristics, which suggests that conceptually related classes often share the same owner(s). We also find that similar topics tend to share the same ownership characteristics, which suggests that the same developers own related topics.",1092-8138,978-1-4673-1216-5978-1-4673-1213-4978-1-4673-1215,10.1109/ICPC.2012.6240485,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240485,program comprehension;mining software repositories;ownership;topic modeling;pachinko allocation model,Pragmatics;Software;Data mining;Correlation;Java;Probability distribution;Resource management,data mining;Java;linguistics;public domain software;reverse engineering;source coding,ownership modelling;source code topics;linguistic topics;program comprehension activity;ownership examination;software repository mining;topic modeling;open source Java systems,,3,36,,,,,IEEE,IEEE Conferences
Representing and Integrating Dynamic Collaborations in IDEs,D. Röthlisberger; O. Greevy,NA; NA,2008 15th Working Conference on Reverse Engineering,,2008,,,74,78,Static views of object-oriented source code as presented in a development environment (IDE) do not provide explicit representations of dynamic collaboration to describe how source artifacts communicate at runtime. Direct access within an IDE to explicit representations of dynamic collaborations would provide developers with useful insights into a system's behavior. In this paper we describe how we seamlessly integrate novel interactive visual representations of dynamic collaborations between static artifacts to complement traditional static concepts within the IDE. We motivate our work and introduce our enhancements in our prototype IDE Hermion and provide validation for our work by means of case studies and benchmarks.,1095-1350;2375-5369,978-0-7695-3429,10.1109/WCRE.2008.53,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656396,dynamic analysis;dynamic collaborations;development environments;partial behavioral reflection;program comprehension,Collaboration;Runtime;Visualization;Navigation;Software;Benchmark testing;Reflection,object-oriented programming;program diagnostics;program visualisation;software engineering,object-oriented source code;integrated development environment;system behavior;interactive visual dynamic collaboration representation;static view;software developer,,1,12,,,,,IEEE,IEEE Conferences
Code Clone Graph Metrics for Detecting Diffused Code Clones,Y. Fukushima; R. Kula; S. Kawaguchi; K. Fushida; M. Nagura; H. Iida,NA; NA; NA; NA; NA; NA,2009 16th Asia-Pacific Software Engineering Conference,,2009,,,373,380,"Code clones (duplicated source code in a software system) are one of the major factors in decreasing maintainability. Many code clone detection methods have been proposed to find code clones automatically from large-scale software. However, it is still hard to find harmful code clones to improve maintainability because there are many code clones that should remain. Thus, to help find harmful code clones, we propose a code clone visualization method and a metrics application on the visualized information. Our method enables the location of harmful code clones diffused in a software system. We apply our method to three open source software programs and visualize their code clone information.",1530-1362;1530-1362,978-0-7695-3909,10.1109/APSEC.2009.53,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5358762,visualization;software maintenance;program comprehension,Cloning;Visualization;Software maintenance;Costs;Software systems;Large-scale systems;Open source software;Software engineering;Information science;Application software,data visualisation;program verification;software maintenance;software metrics,code clone graph metrics;diffused code clones detection;large-scale software;code clone visualization method;open source software programs,,4,12,,,,,IEEE,IEEE Conferences
Using Structured Queries for Source Code Search,B. P. Eddy; N. A. Kraft,NA; NA,2014 IEEE International Conference on Software Maintenance and Evolution,,2014,,,431,435,"Software maintenance tasks such as feature location and traceability link recovery are search-oriented. Most of the recently proposed approaches for automation of search-oriented tasks are based on a traditional text retrieval (TR) model in which documents are unstructured representations of text and queries consist only of keywords. Because source code has structure, approaches based on a structured retrieval model may yield improved performance. Indeed, Saha et al. Recently proposed a feature location technique based on structured retrieval that offers improved performance relative to a technique based on traditional TR. Although they use abstract syntax tree (AST) information to structure documents, they nonetheless use content-only (keyword) queries to retrieve documents. In this paper we propose an approach to source code search using AST information to structure queries in addition to documents. Such queries, known as content and structure (CAS) queries, allow developers to search for source code entities based not only on content relevance, but also on structural similarity. After introducing the structured retrieval model, we provide examples that illustrate the trade-off between the simplicity of content-only queries and the power of CAS queries.",1063-6773,978-1-4799-6146,10.1109/ICSME.2014.68,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6976112,Software maintenance;program comprehension;text retrieval;structured document retrieval;static analysis,Accuracy;Software;Context;Computer bugs;Database languages;Search engines,computational linguistics;query processing;software maintenance;source code (software);text analysis,CAS queries;structural similarity;source code entities;AST information;abstract syntax tree;feature location technique;structured retrieval model;unstructured representations;TR model;text retrieval;search-oriented tasks;automation;traceability link recovery;software maintenance tasks;source code search;structured queries,,1,9,,,,,IEEE,IEEE Conferences
Supporting task-oriented navigation in IDEs with configurable HeatMaps,D. Rothlisberger; O. Nierstrasz; S. Ducasse; D. Pollet; R. Robbes,"Software Composition Group, University of Bern, Switzerland; Software Composition Group, University of Bern, Switzerland; INRIA-Lille Nord Europe, France; University of Lille 1, France; University of Lugano, Switzerland",2009 IEEE 17th International Conference on Program Comprehension,,2009,,,253,257,"Mainstream IDEs generally rely on the static structure of a software project to support browsing and navigation. We propose HeatMaps, a simple but highly configurable technique to enrich the way an IDE displays the static structure of a software system with additional kinds of information. A HeatMap highlights software artifacts according to various metric values, such as bright red or pale blue, to indicate their potential degree of interest. We present a prototype system that implements HeatMaps, and we describe an initial study that assesses the degree to which different HeatMaps effectively guide developers in navigating software.",1092-8138,978-1-4244-3998-0978-1-4244-3997,10.1109/ICPC.2009.5090052,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090052,software analysis;static analysis;development environments;program comprehension,Navigation;History;Collaborative software;Software systems;Frequency;Object oriented modeling;Displays;Performance analysis;Visualization;Europe,object-oriented methods;software engineering,task-oriented navigation;IDE;configurable HeatMaps;software project;software system;software artifacts,,7,11,,,,,IEEE,IEEE Conferences
Developers ask reachability questions,T. D. LaToza; B. A. Myers,Carnegie Mellon University; Carnegie Mellon University,2010 ACM/IEEE 32nd International Conference on Software Engineering,,2010,1,,185,194,"A reachability question is a search across feasible paths through a program for target statements matching search criteria. In three separate studies, we found that reachability questions are common and often time consuming to answer. In the first study, we observed 13 developers in the lab and found that half of the bugs developers inserted were associated with reachability questions. In the second study, 460 professional software developers reported asking questions that may be answered using reachability questions more than 9 times a day, and 82% rated one or more as at least somewhat hard to answer. In the third study, we observed 17 developers in the field and found that 9 of the 10 longest activities were associated with reachability questions. These findings suggest that answering reachability questions is an important source of difficulty understanding large, complex codebases.",1558-1225;0270-5257,978-1-60558-719,10.1145/1806799.1806829,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6062086,code navigation;developer questions;empirical study;program comprehension;software maintenance,Navigation;Cognition;Software;Encoding;Concrete;Educational institutions;Libraries,program debugging;reachability analysis;software engineering,reachability questions;bug developers;software developers;program debugging,,29,22,,,,,IEEE,IEEE Conferences
Visualization of fine-grained code change history,Y. Yoon; B. A. Myers; S. Koo,"Institute for Software Research, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213, USA; Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213, USA; Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213, USA",2013 IEEE Symposium on Visual Languages and Human Centric Computing,,2013,,,119,126,"Conventional version control systems save code changes at each check-in. Recently, some development environments retain more fine-grain changes. However, providing tools for developers to use those histories is not a trivial task, due to the difficulties in visualizing the history. We present two visualizations of fine-grained code change history, which actively interact with the code editor: a timeline visualization, and a code history diff view. Our timeline and filtering options allow developers to navigate through the history and easily focus on the information they need. The code history diff view shows the history of any particular code fragment, allowing developers to move through the history simply by dragging the marker back and forth through the timeline to instantly see the code that was in the snippet at any point in the past. We augment the usefulness of these visualizations with richer editor commands including selective undo and search, which are all implemented in an Eclipse plug-in called “Azurite”. Azurite helps developers with answering common questions developers ask about the code change history that have been identified by prior research. In addition, many of users' backtracking tasks can be achieved using Azurite, which would be tedious or error-prone otherwise.",1943-6092;1943-6106,978-1-4799-0369,10.1109/VLHCC.2013.6645254,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6645254,program comprehension;software visualization;integrated development environments;selective undo,History;Visualization;Software;Filtering;Layout;Navigation;Real-time systems,data visualisation;software engineering,fine-grained code change history visualization;code editor interaction;timeline visualization;code history diff view;Eclipse plug-in;Azurite;user backtracking tasks,,19,47,,,,,IEEE,IEEE Conferences
Class Level Code Summarization Based on Dependencies and Micro Patterns,M. Malhotra; J. Kumar Chhabra,"Department of Computer of Engineering, National Institute of Technology, Kurukshetra, Haryana, India; Department of Computer of Engineering, National Institute of Technology, Kurukshetra, Haryana, India",2018 Second International Conference on Inventive Communication and Computational Technologies (ICICCT),,2018,,,1011,1016,Modifications in any software need to be carries out on various entities. Change in one entity may force some changes in many other dependent entities. Complete understanding of entities and there dependencies are highly desirable to carry out modifications in an efficient manner. Automated summarization of classes in object oriented software can be a good step in this direction. This paper proposes a natural language summary based code summarization of those java classes which are more change prone. Code summary is generated by using concept of micro patterns and change proneness is identified by computing different kinds of dependencies among classes. A threshold is decided to identify the classes which are more sensitive to change. The empirical evaluation of some open source classes has been carried out which clearly indicates the usefulness of the proposed work.,,978-1-5386-1974-2978-1-5386-1973-5978-1-5386-1975,10.1109/ICICCT.2018.8473199,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8473199,Program comprehension;Class level summarization;change sensitivity,Sensitivity;Java;Software systems;Natural languages;Maintenance engineering;Machine learning,Java;natural language processing;object-oriented programming,class level code summarization;micropatterns;dependent entities;complete understanding;automated summarization;object oriented software;natural language summary based code summarization;java classes;code summary;change proneness;open source classes,,,27,,,,,IEEE,IEEE Conferences
Exploiting Runtime Information in the IDE,D. Röthlisberger; O. Greevy; O. Nierstrasz,NA; NA; NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,63,72,"Developers rely on the mechanisms provided by their IDE to browse and navigate a large software system. These mechanisms are usually based purely on a system's static source code. The static perspective, however, is not enough to understand an object-oriented program's behavior, in particular if implemented in a dynamic language. We propose to enhance IDEs with a program's runtime information (e.g., message sends and type information) to support program comprehension through precise navigation and informative browsing. To precisely specify the type and amount of runtime data to gather about a system under development, dynamically and on demand, we adopt a technique known as partial behavioral reflection. We implemented navigation and browsing enhancements to an IDE that exploit this runtime information in a prototype called Hermion. We present preliminary validation of our experimental enhanced IDE by asking developers to assess its usefulness to understand an unfamiliar software system.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.32,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556118,dynamic analysis;development environments;partial behavioral reflection;reverse engineering;program comprehension,Runtime;Navigation;Reflection;Software systems;Prototypes;Reverse engineering;Switches;Software prototyping;Scattering;Software tools,information retrieval;software engineering;source coding,runtime information;software system;static source code;dynamic language;information navigation;information browsing;partial behavioral reflection,,8,27,,,,,IEEE,IEEE Conferences
Connecting Traces: Understanding Client-Server Interactions in Ajax Applications,N. Matthijssen; A. Zaidman; M. Storey; I. Bull; A. van Deursen,NA; NA; NA; NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,216,225,"Ajax-enabled web applications are a new breed of highly interactive, highly dynamic web applications. Although Ajax allows developers to create rich web applications, Ajax applications can be difficult to comprehend and thus to maintain. For this reason, we have created FireDetective, a tool that uses dynamic analysis at both the client (browser) and server side to facilitate the understanding of Ajax applications. Using an exploratory pre-experimental user study, we see that web developers encounter problems when understanding Ajax applications. We also find preliminary evidence that the FireDetective tool allows web developers to understand Ajax applications more effectively, more efficiently and with more confidence.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.14,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521743,Ajax;dynamic analysis;web applications;program comprehension;understanding,Joining processes;Application software;Java;Software maintenance;Software engineering;Computer science;XML;Runtime;HTML;Visualization,client-server systems;Internet;Java;software tools;XML,client-server interactions;Ajax-enabled Web applications;FireDetective tool;dynamic Web analysis;asynchronous Javascript and XML,,13,20,,,,,IEEE,IEEE Conferences
Inferring Use-cases from GUI Analysis,E. A. Miranda; C. N. Abdelahad; M. M. Beron; D. E. Riesco,NA; NA; NA; NA,IEEE Latin America Transactions,,2015,13,12,3942,3952,"One of the most arduous and tedious tasks in the life cycle of an application is Software Maintenance and Evolution. In this context, the most time-consuming activities are those that the programmer must execute to get a complete understanding of the system. Based on this need, Program Comprehension (PC), a Software Engineering discipline, arises to tackle the problem. This article presents SSPIA, a strategy that assists software engineers to understand a system by inferring its use case model. SSPIA uses concepts, techniques and tools of PC to carry out its purposes. In order to extract use cases, some specific system static information is collected. This information serves as input to a process that implements a clustering technique based on system's Graphical User Interface (GUI). Almost all clustering techniques take as main criteria graph's structural properties. However, in the context of PC, some Problem Domain information must be considered. The strategy proposed in this article takes into account an essential component strongly related to system's Problem Domain: Graphic User Interfaces. As a main aim, the proposed strategy seeks to assist the arduous cognitive process that involves understanding a system.",1548-0992,,10.1109/TLA.2015.7404931,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7404931,Clustering;Information Extraction;Program Comprehension;Reverse Engineering,Graphical user interfaces;Software;Silicon;Unified modeling language;Context;Data mining;Context modeling,graphical user interfaces;pattern clustering;software maintenance,GUI analysis;software maintenance;program comprehension;software engineering discipline;SSPIA;use case model inferring;system static information;graphical user interface;clustering technique;problem domain information;cognitive process,,,,,,,,IEEE,IEEE Journals
The Role of Experience and Ability in Comprehension Tasks Supported by UML Stereotypes,F. Ricca; M. Di Penta; M. Torchiano; P. Tonella; M. Ceccato,"ITC-irst, Italy; University of Sannio, Italy; Politecnico di Torino, Italy; ITC-irst, Italy; ITC-irst, Italy",29th International Conference on Software Engineering (ICSE'07),,2007,,,375,384,"Proponents of design notations tailored for specific application domains or reference architectures, often available in the form of UML stereotypes, motivate them by improved understandability and modifiability. However, empirical studies that tested such claims report contradictory results, where the most intuitive notations are not always the best performing ones. This indicates the possible existence of relevant influencing factors, other than the design notation itself. In this work we report the results of a family of three experiments performed at different locations and with different subjects, in which we assessed the effectiveness of UML stereotypes for Web design in support to comprehension tasks. Replications with different subjects allowed us to investigate whether subjects' ability and experience play any role in the comprehension of stereotyped diagrams. We observed different behaviors of users with different degrees of ability and experience, which suggests alternative comprehension strategies of (and tool support for) different categories of users.",0270-5257;1558-1225,0-7695-2828,10.1109/ICSE.2007.86,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4222599,UML stereotypes;program comprehension;empirical study;developers' experience,Unified modeling language;Testing;Navigation;Performance evaluation;Web design;Code standards;Information resources;Software engineering;Impedance,Internet;program testing;software architecture;Unified Modeling Language,UML stereotypes;reference architectures;understandability;modifiability;Web design;Unified Modeling Language,,26,22,,,,,IEEE,IEEE Conferences
"Locating the Meaning of Terms in Source Code Research on ""Term Introduction""",J. Nonnen; D. Speicher; P. Imhoff,NA; NA; NA,2011 18th Working Conference on Reverse Engineering,,2011,,,99,108,"Software developers are often facing the challenge of understanding a large code base. Program comprehension is not only achieved by looking at object interactions, but also by considering the meaning of the identifiers and the contained terms. Ideally, the source code should exemplify this meaning. We propose to call the source code locations that define the meaning of a term term introduction. We further derive a heuristic to determine the introduction location with the help of an explorative study. This study was performed on 8000 manually evaluated samples gained from 30 open source projects. To support reproducibility, all samples and classifications are also available online. The achieved results show a precision of 75% for the heuristic.",2375-5369;1095-1350,978-1-4577-1948,10.1109/WCRE.2011.21,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079832,identifier analysis;name meaning;empirical evaluation;explorative approach;program comprehension;source code analysis,Context;Dictionaries;Libraries;Vocabulary;Speech;Algorithm design and analysis;Measurement,reverse engineering,source code analysis;term introduction;program comprehension,,3,31,,,,,IEEE,IEEE Conferences
Android Repository Mining for Detecting Publicly Accessible Functions Missing Permission Checks,H. H. Nguyen; L. Jiang; T. Quan,NA; NA; NA,2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC),,2017,,,324,327,"Android has become the most popular mobile operating system. Millions of applications, including many malware, haven been developed for it. Even though its overall system architecture and many APIs are documented, many other methods and implementation details are not, not to mention potential bugs and vulnerabilities that may be exploited. Manual documentation may also be easily outdated as Android evolves constantly with changing features and higher complexities. Techniques and tool supports are thus needed to automatically extract information from different versions of Android to facilitate whole-system analysis of undocumented code. This paper presents an approach for alleviating the challenges associated with whole-system analysis. It performs usual program analysis for different versions of Android by control-flow and data-flow analyses. More importantly, it integrates information retrieval and query heuristics to customize the graphs for purposes related to the queries and make whole-system analyses more efficient. In particular, we use the approach to identify functions in Android that can be invoked by applications in either benign or malicious way, which are referred to as publicly accessible functions in this paper, and with the queries we provided, identify functions that may access sensitive system and/or user data and should be protected by certain permission checks. Based on such information, we can detect some publicly accessible functions in the system that may miss sufficient permission checks. As a proof of concept, this paper has analyzed six Android versions and shows basic statistics about the publicly accessible functions in the Android versions, and detects and verifies several system functions that miss permission checks and may have security implications.",,978-1-5386-0535-6978-1-5386-0536,10.1109/ICPC.2017.14,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961531,android;program comprehension;program analysis;information retrieval;call graph;dependency,Androids;Humanoid robots;Information retrieval;Analytical models;Object recognition;Malware;Security,Android (operating system);application program interfaces;data flow analysis;data mining;graph theory;invasive software;mobile computing;program debugging;query processing,Android repository mining;publicly accessible function missing permission check detection;mobile operating system;malware;overall system architecture;API;potential bugs;potential vulnerabilities;automatic information extraction;whole-system analysis;program analysis;control-flow analysis;data-flow analysis;information retrieval;query heuristics;function identification,,,22,,,,,IEEE,IEEE Conferences
Towards a unified software attack model to assess software protections,C. Basile; M. Ceccato,"Politecnico di Torino, Italy; Fondazione Bruno Kessler, Trento, Italy",2013 21st International Conference on Program Comprehension (ICPC),,2013,,,219,222,"Attackers can tamper with programs to break usage conditions. Different software protection techniques have been proposed to limit the possibility of tampering. Some of them just limit the possibility to understand the (binary) code, others react more actively when a change attempt is detected. However, the validation of the software protection techniques has been always conducted without taking into consideration a unified process adopted by attackers to tamper with programs. In this paper we present an extension of the mini-cycle of change, initially proposed to model the process of changing program for maintenance, to describe the process faced by an attacker to defeat software protections. This paper also shows how this new model should support a developer when considering what are the most appropriate protections to deploy.",1092-8138,978-1-4673-3092,10.1109/ICPC.2013.6613852,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613852,Program comprehension;Software protection;Software security,Software;Software protection;Testing;Context;Games;Maintenance engineering;Security,program verification;security of data;software maintenance,software security;program maintenance;binary code;program tampering;software protection techniques;usage conditions;software protection assessment;unified software attack model,,1,17,,,,,IEEE,IEEE Conferences
Modeling changeset topics for feature location,C. S. Corley; K. L. Kashuda; N. A. Kraft,"The University of Alabama, Tuscaloosa, USA; The University of Alabama, Tuscaloosa, USA; ABB Corporate Research, Raleigh, NC, USA",2015 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2015,,,71,80,"Feature location is a program comprehension activity in which a developer inspects source code to locate the classes or methods that implement a feature of interest. Many feature location techniques (FLTs) are based on text retrieval models, and in such FLTs it is typical for the models to be trained on source code snapshots. However, source code evolution leads to model obsolescence and thus to the need to retrain the model from the latest snapshot. In this paper, we introduce a topic-modeling-based FLT in which the model is built incrementally from source code history. By training an online learning algorithm using changesets, the FLT maintains an up-to-date model without incurring the non-trivial computational cost associated with retraining traditional FLTs. Overall, we studied over 600 defects and features from 4 open-source Java projects. We also present a historical simulation that demonstrates how the FLT performs as a project evolves. Our results indicate that the accuracy of a changeset-based FLT is similar to that of a snapshot-based FLT, but without the retraining costs.",,978-1-4673-7532-0978-1-4673-7531,10.1109/ICSM.2015.7332453,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7332453,program comprehension;feature location;topic modeling;mining software repositories;changesets,Feature extraction;Standards;Software;Indexes;Accuracy;Search engines;Computational modeling,Java;public domain software;source code (software);text analysis,modeling changeset topic;feature location;program comprehension activity;source code;feature location technique;text retrieval model;source code snapshot;source code evolution;topic-modeling-based FLT;online learning algorithm;open-source Java project,,,42,,,,,IEEE,IEEE Conferences
Comparing Programming Language Comprehension between Novice and Expert Programmers Using EEG Analysis,S. Lee; A. Matteson; D. Hooshyar; S. Kim; J. Jung; G. Nam; H. Lim,NA; NA; NA; NA; NA; NA; NA,2016 IEEE 16th International Conference on Bioinformatics and Bioengineering (BIBE),,2016,,,350,355,"For programming language comprehension, high cognitive skills (e.g., reading, writing, working memory, etc.) and information processing are required. However, there are few papers that approach this from a neuroscientific perspective. In this paper, we examine program comprehension neuroscientifically and also observe the differences between novice and expert programmers. We designed an EEG (electroencephalogram) experiment and observed 18 participants during a series of program comprehension tasks. We found clear differences in program comprehension ability between novice and expert programmers. Experts exhibited higher brainwave activation than novices in electrodes F3 and P8. These results indicate that experts have outstanding program comprehension-associated abilities such as digit encoding, coarse coding, short-term memory, and subsequent memory effect. Our findings can serve as a foundation for future research in this pioneering field.",2471-7819,978-1-5090-3834-3978-1-5090-3835,10.1109/BIBE.2016.30,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7790010,program comprehension;electroencephalogram;neuroscientific;human factors;empirical study,Electroencephalography;Programming profession;Brain;Time factors;Information processing;Java,cognition;computer literacy;electroencephalography;medical signal processing,programming language comprehension;EEG analysis;electroencephalogram;program comprehension tasks;brainwave activation;F3 electrode;P8 electrode,,3,16,,,,,IEEE,IEEE Conferences
Debugging Revisited: Toward Understanding the Debugging Needs of Contemporary Software Developers,L. Layman; M. Diep; M. Nagappan; J. Singer; R. Deline; G. Venolia,NA; NA; NA; NA; NA; NA,2013 ACM / IEEE International Symposium on Empirical Software Engineering and Measurement,,2013,,,383,392,"We know surprisingly little about how professional developers define debugging and the challenges they face in industrial environments. To begin exploring professional debugging challenges and needs, we conducted and analyzed interviews with 15 professional software engineers at Microsoft. The goals of this study are: 1) to understand how professional developers currently use information and tools to debug, 2) to identify new challenges in debugging in contemporary software development domains (web services, multithreaded/multicore programming), and 3) to identify the improvements in debugging support desired by these professionals that are needed from research. The interviews were coded to identify the most common information resources, techniques, challenges, and needs for debugging as articulated by the developers. The study reveals several debugging challenges faced by professionals, including: 1) the interaction of hypothesis instrumentation and software environment as a source of debugging difficulty, 2) the impact of log file information on accurate debugging of web services, and 3) the mismatch between the sequential human thought process and the non-sequential execution of multithreaded environments as source of difficulty. The interviewees also describe desired improvements to tools to support debugging, many of which have been discussed in research but not transitioned to practice.",1949-3770;1949-3789,978-0-7695-5056,10.1109/ESEM.2013.43,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6681382,debugging;software engineering;interview;professionals;qualitative analysis;program comprehension,Debugging;Interviews;Encoding;Computer bugs;Web services;Testing,multi-threading;program debugging;Web services,debugging needs;contemporary software developers;professional developers;industrial environments;professional software engineers;Microsoft;information resources;hypothesis instrumentation;software environment;Web services;log file information;sequential human thought process;nonsequential multithreaded environments execution,,8,21,,,,,IEEE,IEEE Conferences
Recognizing Words from Source Code Identifiers Using Speech Recognition Techniques,N. Madani; L. Guerrouj; M. Di Penta; Y. Gueheneuc; G. Antoniol,NA; NA; NA; NA; NA,2010 14th European Conference on Software Maintenance and Reengineering,,2010,,,68,77,"The existing software engineering literature has empirically shown that a proper choice of identifiers influences software understandability and maintainability. Researchers have noticed that identifiers are one of the most important source of information about program entities and that the semantic of identifiers guide the cognitive process. Recognizing the words forming identifiers is not an easy task when naming conventions (e.g., Camel Case) are not used or strictly followed and-or when these words have been abbreviated or otherwise transformed. This paper proposes a technique inspired from speech recognition, i.e., dynamic time warping, to split identifiers into component words. The proposed technique has been applied to identifiers extracted from two different applications: JHotDraw and Lynx. Results compared to manually-built oracles and with Camel Case algorithm are encouraging. In fact, they show that the technique successfully recognizes words composing identifiers (even when abbreviated) in about 90% of cases and that it performs better than Camel Case. Furthermore, it was able to spot mistakes in the manually-built oracle.",1534-5351,978-0-7695-4321-5978-1-61284-369,10.1109/CSMR.2010.31,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5714421,Source code identifiers;program comprehension,Dictionaries;Speech recognition;Particle separators;Heuristic algorithms;Context;Feature extraction;Manuals,software maintenance;source coding;speech recognition;text analysis;time warp simulation,word recognition;source code identifiers;speech recognition techniques;software engineering;software understandability;software maintainability;information source;cognitive process;dynamic time warping;split identifiers;JHotDraw;Lynx;manually-built oracles;Camel Case algorithm,,29,27,,,,,IEEE,IEEE Conferences
A New Software Maintenance Scenario Based on Refactoring Techniques,G. Villavicencio,NA,2012 16th European Conference on Software Maintenance and Reengineering,,2012,,,341,346,"This research line proposes the classification of refactoring techniques according to two opposite program properties: understanding and efficiency, being the former useful for maintenance while the latter for executing. Understanding-oriented refactoring and efficiency-oriented refactoring are considered the inverses of each other. Thus, through the application of the first sort of refactoring, understanding can be improved but efficiency can be affected. On the other hand, by applying the second sort of refactoring, efficiency can be improved but understanding can be damaged. So, the challenge to be faced here is to transform a software artifact through the application of a sequence of understanding-oriented refactoring, and to execute maintenance with the most appropriate version obtained. After that, we plan to restore its original efficiency by the application of the opposite sequence of refactorings, i.e. efficiency-oriented refactoring. In this way, a new maintenance scenario is outlined. Up to now, this ongoing research is being carried out in the functional setting.",1534-5351,978-0-7695-4666-7978-1-4673-0984,10.1109/CSMR.2012.41,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6178877,Program transformation;reverse and forward refactorings;program comprehension and maintenance,Maintenance engineering;Equations;Particle separators;Radiation detectors;Mathematical model;Context;Reverse engineering,software maintenance,software maintenance scenario;understanding-oriented refactoring technique;efficiency-oriented refactoring technique;software artifact;maintenance execution;program comprehension;software comprehension,,3,21,,,,,IEEE,IEEE Conferences
Software Musification,A. Mancino; G. Scanniello,NA; NA,2017 21st International Conference Information Visualisation (IV),,2017,,,127,132,"In this paper, we propose an approach that uses software metrics to comprehend attributes of a codebase: maintainability, reusability, or complexity. This approach is new because it uses gathered metrics as the basis to associate musical sounds to source code classes. These sounds are arranged to compose a melody that can be both visualized (as a musical score) and played. We named this new way to deal with a codebase: software musification. To prove the validity of our proposal, we show a sample of its application. The main goal of this paper is to show our promising idea and to present research achievements at the early stages of our research.",2375-0138,978-1-5386-0831-9978-1-5386-0832,10.1109/iV.2017.28,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8107958,Musification;Program Comprehension;Software Complexity;Software Reusability;Software Maintainability,Software;Music;Complexity theory;Data visualization;Software metrics,music;software maintenance;software metrics;software reusability,software musification;software metrics;musical sounds;source code classes;musical score;software complexity;codebase attributes;software maintainability;software reusability,,,25,,,,,IEEE,IEEE Conferences
Improving Feature Location by Enhancing Source Code with Stereotypes,N. Alhindawi; N. Dragan; M. L. Collard; J. I. Maletic,NA; NA; NA; NA,2013 IEEE International Conference on Software Maintenance,,2013,,,300,309,"A novel approach to improve feature location by enhancing the corpus (i.e., source code) with static information is presented. An information retrieval method, namely Latent Semantic Indexing (LSI), is used for feature location. Adding stereotype information to each method/function enhances the corpus. Stereotypes are terms that describe the abstract role of a method, for example get, set, and predicate are well-known method stereotypes. Each method in the system is automatically stereotyped via a static-analysis approach. Experimental comparisons of using LSI for feature location with, and without, stereotype information are conducted on a set of open-source systems. The results show that the added information improves the recall and precision in the context of feature location. Moreover, the use of stereotype information decreases the total effort that a developer would need to expend to locate relevant methods of the feature.",1063-6773,978-0-7695-4981,10.1109/ICSM.2013.41,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6676901,software maintenance;information retrieval;feature location;method stereotypes;program comprehension,Large scale integration;Taxonomy;Standards;Feature extraction;Semantics;Open source software;Context,indexing;information retrieval;program diagnostics;public domain software;source coding,feature location;source code;information retrieval;latent semantic indexing;LSI;static-analysis approach;open-source systems,,12,33,,,,,IEEE,IEEE Conferences
Investigating Program Behavior Using the Texada LTL Specifications Miner,C. Lemieux; I. Beschastnikh,NA; NA,2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE),,2015,,,870,875,"Temporal specifications, relating program events through time, are useful for tasks ranging from bug detection to program comprehension. Unfortunately, such specifications are often lacking from system descriptions, leading researchers to investigate methods for inferring these specifications from code, execution traces, code comments, and other artifacts. This paper describes Texada, a tool to dynamically mine temporal specifications in LTL from traces of program activity. We review Texada's key features and demonstrate how it can be used to investigate program behavior through two scenarios: validating an implementation that solves the dining philosophers problem and supporting comprehension of a stack implementation. We also detail Texada's other, more advanced, usage options. Texada is an open source tool: https://bitbucket.org/bestchai/texada.",,978-1-5090-0025-8978-1-5090-0024,10.1109/ASE.2015.94,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372082,texada;specification mining;linear temporal logic;program comprehension,Runtime;Concurrent computing;Data structures;Java;Distance measurement,data mining;formal specification;program debugging;public domain software,program behavior;Texada LTL specification miner;program events;bug detection;program comprehension;execution traces;code comments;dynamic temporal specification mining;program activity;open source tool,,1,19,,,,,IEEE,IEEE Conferences
Extracting Candidates of Microservices from Monolithic Application Code,M. Kamimura; K. Yano; T. Hatano; A. Matsuo,NA; NA; NA; NA,2018 25th Asia-Pacific Software Engineering Conference (APSEC),,2018,,,571,580,"Technology that facilitates rapid modification of existing business applications is necessary and it has been reported that making the system more adaptable to change is the strongest driver for legacy system modernization. There has been considerable interest in service-oriented architectures or microservices which enables the system to be quickly changed. Refactoring and, in particular, re-modularization operations can be performed to repair the design of a software system. Various approaches have been proposed to support developers during the re-modularization of a software system. The common problem in these efforts is to identify from monolithic applications the candidates of microservices, i.e., the programs or data that can be turned into cohesive, standalone services; this is a tedious manual effort that requires analyzing many dimensions of software architecture views and often heavily relies on the experience and expertise of the expert performing the extraction. To solve this problem, we developed a method that identifies the candidates of microservices from the source code by using software clustering algorithm SArF with the relation of ""program groups"" and ""data"" which we defined. Our method also visualizes the extracted candidates to show the relationship between extracted candidates and the whole structure. The candidates and visualization help the developers to capture the overview of the whole system and facilitated a dialogue with customers. We report two case studies to evaluate our results in which we applied our method to an open source application and an industrial application with our results reviewed by developers.",2640-0715;1530-1362,978-1-7281-1970-0978-1-7281-1971,10.1109/APSEC.2018.00072,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8719439,"microservice architecture, software clustering, partition, visualization, program comprehension, modernization",Software;Business;Data mining;Data visualization;Clustering algorithms;Computer architecture;Manuals,data visualisation;pattern clustering;service-oriented architecture;software maintenance,monolithic application code;business applications;legacy system modernization;service-oriented architectures;software system;monolithic applications;software architecture views;source code;open source application;SArF software clustering algorithm;remodularization operations,,,27,,,,,IEEE,IEEE Conferences
Comprehension oriented software fault location,Wang Tiantian; Su Xiaohong; Ma Peijun; Wang Kechao,"School of Computer Science and Technology, Harbin Institute of Technology, China; School of Computer Science and Technology, Harbin Institute of Technology, China; School of Computer Science and Technology, Harbin Institute of Technology, China; School of Software, Harbin University, China",Proceedings of 2011 International Conference on Computer Science and Network Technology,,2011,1,,340,343,"Software errors can potentially lead to disastrous consequences. Unfortunately, debugging software errors can be difficult and time-consuming. A comprehension oriented software fault location approach (COFL) is proposed in this paper to provide automated assistance in bug location. It not only locates program predicates predicting bugs, but also provides high efficiency demand-driven data flow and control flow analysis to help developers understand the causes and contexts of bugs.",,978-1-4577-1587-7978-1-4577-1586-0978-1-4577-1585,10.1109/ICCSNT.2011.6181971,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6181971,fault location;program comprehension;statistics-based;demand-driven,Software;Instruments;Computer bugs;Debugging;Fault location;Prediction algorithms;Conferences,data flow analysis;program debugging;software fault tolerance,comprehension oriented software fault location;software errors;COFL;bug location;high efficiency demand-driven data flow;flow analysis;software debugging,,,24,,,,,IEEE,IEEE Conferences
Towards Understanding Programs by Counting Objects,E. Tempero; P. Ralph,NA; NA,2018 25th Australasian Software Engineering Conference (ASWEC),,2018,,,1,10,"A question familiar to any developer facing legacy code for the first time is, where to start? Understanding the entire code base of any large project is impractical, so techniques for identifying the most relevant code are needed. We discuss one potential technique, which we call ""object counts:""' a report of the number of objects created during the execution of an object-oriented program. We show how object counts can help when comparing small designs, and comprehending a larger design-specifically JUnit. Our results indicate that the small amount of data provided by object counts can provide significant insight into a system's design.",2377-5408;1530-0803,978-1-7281-1241-1978-1-7281-1242,10.1109/ASWEC.2018.00009,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8587280,Object counts;Dynamic Analysis;Program Comprehension,Task analysis;Games;Performance analysis;Software,object-oriented programming;program testing,object-oriented program;object counts;legacy code;program understanding;JUnit design,,,24,,,,,IEEE,IEEE Conferences
Extracting Interaction-Based Stateful Behavior in Rich Internet Applications,Y. Maezawa; H. Washizaki; S. Honiden,NA; NA; NA,2012 16th European Conference on Software Maintenance and Reengineering,,2012,,,423,428,"Although asynchronous technologies such as Ajax make Rich Internet Applications (RIAs) responsive, they can result in unexpected behavior due to nondeterministic client-side processing and asynchronous communication. One difficulty in understanding such erroneous behavior lies in the unpredictable contexts of the running system. Dynamic behavior analysis techniques do not help to verify the correctness of certain ""blind spots"" in the execution path. In this work, we present a static approach for extracting all possible state transitions described in source code from the RIAs. Our approach is based on the assumption that user, server and self interactions with the RIAs can change the states of the application. Our method consists of three steps: (i) annotating interactions and extracting their controls in source code (ii) abstracting a call graph to extract relationships among the interactions and (iii) refining the relationships with interaction controls By extracting the state machines of test scenarios of the correct and wrong behavior, it can help developers to pinpoint the statements in the source code that lead to the erroneous behavior. Our approach has been evaluated against a few experimental cases and we conclude that it can extract comprehensible state machines in a reasonable time.",1534-5351,978-0-7695-4666-7978-1-4673-0984,10.1109/CSMR.2012.53,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6178915,Rich Internet Applications;Ajax;Reverse Engineering;Program Comprehension,Servers;Internet;Web pages;Reactive power;Libraries;HTML;Context,client-server systems;finite state machines;Internet;Java;program diagnostics;reverse engineering;source coding;user interfaces;XML,interaction-based stateful behavior extraction;rich Internet application;nondeterministic client side processing;asynchronous communication;dynamic behavior analysis;static approach;state transition extraction;source code;RIA;Ajax;call graph abstraction;interaction controls;state machines;erroneous behavior,,6,14,,,,,IEEE,IEEE Conferences
An Android Security Case Study with Bauhaus,B. J. Berger; M. Bunke; K. Sohr,NA; NA; NA,2011 18th Working Conference on Reverse Engineering,,2011,,,179,183,"Software security has made great progress, code analysis tools are widely-used in industry for detecting common implementation-level security bugs. However, given the fact that we must deal with legacy code we plead to employ the techniques long been developed in the research area of program comprehension for software security. In cooperation with a security expert, we carried out a case study with the mobile phone platform Android, and employed the reverse engineering tool-suite Bauhaus for this security assessment. During the investigation we found some inconsistencies in the implementation of the Android security concepts. Based on the lessons learned from the case study, we propose several research topics in the area of reverse engineering that would support a security analyst during security assessments.",2375-5369;1095-1350,978-1-4577-1948,10.1109/WCRE.2011.29,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079840,program comprehension;security assessment;software security;Android,Security;Software;Bluetooth;Androids;Humanoid robots;Smart phones;Documentation,mobile computing;program debugging;reverse engineering;security of data,Android security;Bauhaus;software security;code analysis tool;implementation-level security bug;legacy code;program comprehension;mobile phone;reverse engineering tool,,4,35,,,,,IEEE,IEEE Conferences
Empirical Evaluation of Diagrams of the Run-time Structure for Coding Tasks,N. Ammar; M. Abi-Antoun,NA; NA,2012 19th Working Conference on Reverse Engineering,,2012,,,367,376,"With object-oriented design, it is at least as important-possibly more important-to understand the runtime structure, in terms of objects and their relations, as to understand the code structure dealing with source files, classes and packages. Today, many tools and diagrams help developers understand the code structure. Diagrams of the runtime structure, however, are much less mature. One diagram of the run-time structure is a statically extracted, global, hierarchical Ownership Object Graph (OOG). The OOG conveys architectural abstraction by ownership hierarchy by showing architecturally significant objects near the top of the hierarchy and data structures further down. In an OOG, objects are also organized into named, conceptual groups called domains. We evaluate, in a controlled experiment, whether an OOG, as a diagram of the run-time structure, improves comprehension by giving developers the ability to distinguish the role that an object plays, not only by type, but also by named groups (domains) or by position in the run-time structure (ownership). We observed 10 participants, for 3 hours each, perform three feature implementation tasks on a framework application. Our results indicate that, on average, the OOG had a positive effect of varying extents on comprehension that reduced the time spent by 22%-60% and irrelevant code explored by 10%-60%. The difference was significant (p <; 0.05) for two of the tasks.",2375-5369;1095-1350,978-0-7695-4891-3978-1-4673-4536,10.1109/WCRE.2012.46,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385132,controlled experiment;program comprehension,Unified modeling language;Games;Navigation;Object oriented modeling;Java;Search problems;Atmospheric measurements,data structures;graph theory;object-oriented methods;reverse engineering;software maintenance,diagram empirical evaluation;run-time structure;coding tasks;object-oriented design;source files;software classes;software packages;statically extracted-global-hierarchical ownership object graph;OOG;architectural abstraction;ownership hierarchy;data structures;conceptual groups;domains;program comprehension,,8,35,,,,,IEEE,IEEE Conferences
Source Code Retrieval for Bug Localization Using Latent Dirichlet Allocation,S. K. Lukins; N. A. Kraft; L. H. Etzkorn,NA; NA; NA,2008 15th Working Conference on Reverse Engineering,,2008,,,155,164,"In bug localization, a developer uses information about a bug to locate the portion of the source code to modify to correct the bug. Developers expend considerable effort performing this task. Some recent static techniques for automatic bug localization have been built around modern information retrieval (IR) models such as latent semantic indexing (LSI); however, latent Dirichlet allocation (LDA), a modular and extensible IR model, has significant advantages over both LSI and probabilistic LSI (pLSI). In this paper we present an LDA-based static technique for automating bug localization. We describe the implementation of our technique and three case studies that measure its effectiveness. For two of the case studies we directly compare our results to those from similar studies performed using LSI. The results demonstrate our LDA-based technique performs at least as well as the LSI-based techniques for all bugs and performs better, often significantly so, than the LSI-based techniques for most bugs.",1095-1350;2375-5369,978-0-7695-3429,10.1109/WCRE.2008.33,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656405,bug localization;latent Dirichlet allocation;LDA;information retrieval;program comprehension;latent semantic indexing;LSI,Large scale integration;Computer bugs;Software systems;Software;Indexing;Probabilistic logic;Resource management,indexing;information retrieval;software engineering,source code retrieval;latent Dirichlet allocation;automatic bug localization;information retrieval;latent semantic indexing;LDA-based static technique;automating bug localization,,73,34,,,,,IEEE,IEEE Conferences
From Obfuscation to Comprehension,E. Avidan; D. G. Feitelson,NA; NA,2015 IEEE 23rd International Conference on Program Comprehension,,2015,,,178,181,"Code obfuscation techniques are widely used in industry to increase protection of source code and intellectual property. The idea is that even if attackers gain hold of source code, it will be hard for them to understand what it does and how. Thus obfuscation techniques are specifically targeted at human comprehension of code. We suggest that the ideas and experience embedded in obfuscations can be used to learn about comprehension. In particular, we survey known obfuscation techniques and use them in an attempt to derive metrics for code (in) comprehensibility. This leads to emphasis on issues such as identifier naming, which are typically left on the sidelines in discussions of code comprehension, and motivates increased efforts to measure their effect.",1092-8138,978-1-4673-8159-8978-1-4673-8158,10.1109/ICPC.2015.27,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181445,Code obfuscation;Code complexity metrics;Program comprehension,Measurement;Complexity theory;Software;Layout;Context;Java;Conferences,program compilers;software metrics;source code (software),code obfuscation techniques;source code;intellectual property;human comprehension;derive metrics;code comprehensibility,,,17,,,,,IEEE,IEEE Conferences
On the proactive and interactive visualization for feature evolution comprehension: An industrial investigation,R. Novais; C. Nunes; C. Lima; E. Cirilo; F. Dantas; A. Garcia; M. Mendonça,"Software Engineering Lab, Computer Science Department, Federal University of Bahia, Bahia, Brazil; Opus Research Group, Software Engineering Lab, Informatics Department - PUC-Rio, Rio de Janeiro, Brazil; Software Engineering Lab, Computer Science Department, Federal University of Bahia, Bahia, Brazil; Opus Research Group, Software Engineering Lab, Informatics Department - PUC-Rio, Rio de Janeiro, Brazil; Opus Research Group, Software Engineering Lab, Informatics Department - PUC-Rio, Rio de Janeiro, Brazil; Opus Research Group, Software Engineering Lab, Informatics Department - PUC-Rio, Rio de Janeiro, Brazil; Software Engineering Lab, Computer Science Department, Federal University of Bahia, Bahia, Brazil",2012 34th International Conference on Software Engineering (ICSE),,2012,,,1044,1053,"Program comprehension is a key activity through maintenance and evolution of large-scale software systems. The understanding of a program often requires the evolution analysis of individual functionalities, so-called features. The comprehension of evolving features is not trivial as their implementations are often tangled and scattered through many modules. Even worse, existing techniques are limited in providing developers with direct means for visualizing the evolution of features' code. This work presents a proactive and interactive visualization strategy to enable feature evolution analysis. It proactively identifies code elements of evolving features and provides multiple views to present their structure under different perspectives. The novel visualization strategy was compared to a lightweight visualization strategy based on a tree-structure. We ran a controlled experiment with industry developers, who performed feature evolution comprehension tasks on an industrial-strength software. The results showed that the use of the proposed strategy presented significant gains in terms of correctness and execution time for feature evolution comprehension tasks.",1558-1225;0270-5257;0270-5257,978-1-4673-1067-3978-1-4673-1066-6978-1-4673-1065,10.1109/ICSE.2012.6227115,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227115,program comprehension;feature evolution;software visualization;experimental evaluation,Visualization;Color;Industries;Software systems;History;Context,data visualisation;software maintenance,interactive visualization;proactive visualization;feature evolution comprehension;industrial investigation;program comprehension;large-scale software systems;evolution analysis;individual functionalities;lightweight visualization;tree structure,,5,33,,,,,IEEE,IEEE Conferences
RepoVis: Visual Overviews and Full-Text Search in Software Repositories,J. Feiner; K. Andrews,NA; NA,2018 IEEE Working Conference on Software Visualization (VISSOFT),,2018,,,1,11,"Project managers and software developers often have difficulty maintaining an overview of the structure, evolution, and status of collaborative software projects. Some tools are available for typical source code management systems, which provide summary statistics or simple visual representations of merge-branch graphs. However, comprehensive visual overview and search facilities for such repositories are lacking. RepoVis is a new tool which provides comprehensive visual overviews and full-text search for projects maintained in Git repositories. The overview shows folders, files, and lines of code colour-coded according to last modification, developer, file type, or associated issues. Full-text searches can be performed for terms of interest within source code files, commit messages, or any associated metadata or usability findings, with matches displayed visually in the overview. The utility of the RepoVis approach is illustrated with three use cases of real-world software inspection. Insights are presented into the utility of full-text search and visual presentation of matches for program comprehension.",,978-1-5386-8292-0978-1-5386-8293,10.1109/VISSOFT.2018.00009,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530126,"software visualisation, program comprehension, usability, metrics, visual overview, full-text search, git repositories.",Visualization;Usability;Inspection;Metadata;Security;Libraries,data visualisation;groupware;meta data;project management;software development management;software maintenance;source code (software);text analysis,collaborative software projects;typical source code management systems;simple visual representations;merge-branch graphs;search facilities;full-text search;Git repositories;source code files;RepoVis approach;real-world software inspection;visual presentation;visual overviews;software repositories;project managers;software developers;code colour;summary statistics;commit messages;metadata,,,76,,,,,IEEE,IEEE Conferences
CloCom: Mining existing source code for automatic comment generation,E. Wong; Taiyue Liu; L. Tan,"Department of Electrical and Computer Engineering, University of Waterloo, Ontario, Canada; Department of Electrical and Computer Engineering, University of Waterloo, Ontario, Canada; Department of Electrical and Computer Engineering, University of Waterloo, Ontario, Canada","2015 IEEE 22nd International Conference on Software Analysis, Evolution, and Reengineering (SANER)",,2015,,,380,389,"Code comments are an integral part of software development. They improve program comprehension and software maintainability. The lack of code comments is a common problem in the software industry. Therefore, it is beneficial to generate code comments automatically. In this paper, we propose a general approach to generate code comments automatically by analyzing existing software repositories. We apply code clone detection techniques to discover similar code segments and use the comments from some code segments to describe the other similar code segments. We leverage natural language processing techniques to select relevant comment sentences. In our evaluation, we analyze 42 million lines of code from 1,005 open source projects from GitHub, and use them to generate 359 code comments for 21 Java projects. We manually evaluate the generated code comments and find that only 23.7% of the generated code comments are good. We report to the developers the good code comments, whose code segments do not have an existing code comment. Amongst the reported code comments, seven have been confirmed by the developers as good and committable to the software repository while the rest await for developers' confirmation. Although our approach can generate good and committable comments, we still have to improve the yield and accuracy of the proposed approach before it can be used in practice with full automation.",1534-5351,978-1-4799-8469,10.1109/SANER.2015.7081848,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7081848,comment generation;documentation;program comprehension,Cloning;Software;Databases;Java;Data mining;Context;Pattern matching,data mining;Java;natural language processing;public domain software;software maintenance;source code (software),CloCom;existing source code mining;automatic comment generation;software development;program comprehension;software maintainability;software industry;code comments;software repositories;code clone detection techniques;similar code segments;natural language processing techniques;relevant comment sentences;open source projects;GitHub;Java projects;software repository,,9,34,,,,,IEEE,IEEE Conferences
Understanding source code through projectional editor,J. Juhár; L. Vokorokos,"Department of Computers and Informatics, Faculty of Electrical Engineering and Informatics, Technical University of Košice, Slovakia; Department of Computers and Informatics, Faculty of Electrical Engineering and Informatics, Technical University of Košice, Slovakia",2015 13th International Conference on Engineering of Modern Electric Systems (EMES),,2015,,,1,4,"The purpose of this paper is to give a report of an observational study involving program comprehension with the projectional editor that enables custom views of the source code. We briefly discuss the issues of program comprehension and motives behind projectional code editing. We also give an overview of two projectional editors focused on concern location and compare their features and use cases. The Code Bubbles editor is evaluated in an observational study observing the process of a source code comprehension. The study suggests the benefits of code projections even for large, unknown code base.",,978-1-4799-7650-8978-1-4799-7649-2978-1-4799-7648,10.1109/EMES.2015.7158422,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7158422,code bubbles;concern-oriented source code projections;program comprehension tools;projectional editors,Syntactics;User interfaces;Context;Buildings;Java;Software,knowledge acquisition;object-oriented programming;source code (software),source code;program comprehension;projectional code editing;Code Bubbles editor;knowledge extraction;object-oriented design,,,12,,,,,IEEE,IEEE Conferences
Mining Iterative Generators and Representative Rules for Software Specification Discovery,D. Lo; J. Li; l. wong; S. Khoo,"Singapore Management University, Singapore; Nanyang Technological University, Singapore; National University of Singapore, Singapore; National University of Singapore, Singapore",IEEE Transactions on Knowledge and Data Engineering,,2011,23,2,282,296,"Billions of dollars are spent annually on software-related cost. It is estimated that up to 45 percent of software cost is due to the difficulty in understanding existing systems when performing maintenance tasks (i.e., adding features, removing bugs, etc.). One of the root causes is that software products often come with poor, incomplete, or even without any documented specifications. In an effort to improve program understanding, Lo et al. have proposed iterative pattern mining which outputs patterns that are repeated frequently within a program trace, or across multiple traces, or both. Frequent iterative patterns reflect frequent program behaviors that likely correspond to software specifications. To reduce the number of patterns and improve the efficiency of the algorithm, Lo et al. have also introduced mining closed iterative patterns, i.e., maximal patterns without any superpattern having the same support. In this paper, to technically deepen research on iterative pattern mining, we introduce mining iterative generators, i.e., minimal patterns without any subpattern having the same support. Iterative generators can be paired with closed patterns to produce a set of rules expressing forward, backward, and in-between temporal constraints among events in one general representation. We refer to these rules as representative rules. A comprehensive performance study shows the efficiency of our approach. A case study on traces of an industrial system shows how iterative generators and closed iterative patterns can be merged to form useful rules shedding light on software design.",1041-4347;1558-2191;2326-3865,,10.1109/TKDE.2010.24,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5416710,Frequent pattern mining;sequence database;iterative patterns;generators;representative rules;software engineering;reverse engineering;program comprehension.,Costs;Software maintenance;Investments;Data mining;Java;Authorization;Software debugging;Software performance;Computer bugs;Iterative algorithms,data mining;formal specification;iterative methods;program diagnostics;reverse engineering;software maintenance,iterative generator mining;representative rules mining;software specification discovery;software-related cost;maintenance tasks;program understanding;program tracing;closed iterative pattern mining;software design,,6,37,,,,,IEEE,IEEE Journals
SYNCTRACE: Visual thread-interplay analysis,B. Karran; J. Trümper; J. Döllner,"Hasso Plattner Institute, University of Potsdam, Germany; Hasso Plattner Institute, University of Potsdam, Germany; Hasso Plattner Institute, University of Potsdam, Germany",2013 First IEEE Working Conference on Software Visualization (VISSOFT),,2013,,,1,10,"In software comprehension, program traces are important to gain insight into certain aspects of concurrent runtime behavior, e.g., thread-interplay. Here, key tasks are finding usages of blocking operations, such as synchronization and I/O operations, assessing temporal order of such operations, and analyzing their effects. This is a hard task for large and complex program traces due to their size and number of threads involved. In this paper, we present SYNCTRACE a new visualization technique based on (bended) activity diagrams and edge bundles that allows for parallel analysis of multiple threads and their inter-thread correspondences. We demonstrate how the technique, implemented as a tool, can be applied on real-world trace datasets to support understanding concurrent behavior.",,978-1-4799-1457,10.1109/VISSOFT.2013.6650534,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6650534,Trace analysis;Software visualization;Program comprehension;Concurrency,Synchronization;Visualization;Context;Color;Instruction sets;Concurrent computing;Data visualization,concurrency control;data flow analysis;parallel processing;software engineering,concurrent behavior;real-world trace datasets;inter-thread correspondences;multiple threads;parallel analysis;edge bundles;bended activity diagrams;visualization technique;complex program traces;large program traces;I/O operations;synchronization;concurrent runtime behavior;software comprehension;visual thread-interplay analysis;SYNCTRACE,,4,48,,,,,IEEE,IEEE Conferences
Viewing Object-Oriented Software with MetricAttitude: An Empirical Evaluation,R. Francese; M. Risi; G. Scanniello; G. Tortora,NA; NA; NA; NA,2014 18th International Conference on Information Visualisation,,2014,,,59,64,"MetricAttitude is a visualization tool based on static analysis that provides a mental picture by viewing an object-oriented software system by means of polymetric views. In this paper, we present a preliminary empirical investigation based on a questionnaire-based survey to assess Metric Attitude with respect to source code comprehension tasks. Participants involved in this study were Computer Science students and software professionals. The results suggest that Metric Attitude is a viable means to comprehend source code and that both kinds of participants in the empirical investigation considered it to be appropriate in source code comprehension.",1550-6037;2375-0138,978-1-4799-4103,10.1109/IV.2014.42,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6902881,Program Comprehension;Reverse Engineering;Software Maintenance;Software Metrics;Software Visualization Tool,Measurement;Visualization;Software systems;Layout;Color;Abstracts,object-oriented methods;program diagnostics;program visualisation;source code (software),MetricAttitude;static analysis;object-oriented software system;polymetric views;preliminary empirical investigation;questionnaire-based survey;source code comprehension tasks;computer science students;software professionals;source code comprehension;software visualization tool,,5,22,,,,,IEEE,IEEE Conferences
Generating suggestions for initial program investigation using Dynamic Analysis,M. Kamran; M. Ali; A. Ahmed,"Department of Computer Engineering, College of EME, NUST, Islamabad, Pakistan; Department of Computer Science and IT, The University of Lahore, Gujrat Campus, Pakistan; Department of Computer Science, Quaid-i-Azam University, Islamabad, Pakistan","2017 International Conference on Communication, Computing and Digital Systems (C-CODE)",,2017,,,233,237,The process of building an understanding of the existing system is time consuming and takes a big portion of the allocated time for a maintenance task. Numerous efforts have been made to reduce the time consumed in the program comprehension process by providing support to the programmer during this phase. The segments of the program that can be attractive from the comprehension viewpoint must be brought into the notice of the programmer. The key contribution of this paper is a heuristic approach that can aid the programmer by automatically suggesting the classes that are potentially interesting for the initial stages of the program comprehension process.,,978-1-5090-4448-1978-1-5090-4447-4978-1-5090-4449,10.1109/C-CODE.2017.7918934,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7918934,dynamic analysis;dynamic coupling metrics;most important classes;core classes;program comprehension,Couplings;Measurement;Documentation;Software systems;Performance analysis;Buildings,software architecture;software maintenance,dynamic analysis;maintenance task;program comprehension process;dynamic coupling metrics;software development,,,18,,,,,IEEE,IEEE Conferences
Improving software maintenance efficiency with behavior-based cognitive models,R. Bayer; A. E. Milewski,"SICES LLC, Winter Springs, FL, USA; Department of Software Engineering, Monmouth University, West Long Branch, NJ, USA","2008 IEEE International Conference on Systems, Man and Cybernetics",,2008,,,3353,3358,"Currently, in most software maintenance environments, the fundamental tool used by software maintainers to perform system maintenance is the integrated development environment (IDE). Current IDEs have inadequate usability and offer little design information to the user, which may impair program comprehension activities required for efficient maintenance. We have developed and tested a prototype IDE that provides behavioral design information in graphical form, with the intent of allowing software maintainers the ability to more easily learn how a system works and locate relevant source code without the need to consult outside documentation. We show that in two experimental maintenance tasks, users were able to find and modify appropriate code more quickly when using an IDE based on a behavioral view of the software compared with a more traditional, structurally-oriented IDE. Moreover, when using an IDE with a behavioral view, users noticed software patterns more readily and more often used a top-down strategy for solving the maintenance tasks.",1062-922X,978-1-4244-2384-2978-1-4244-2383,10.1109/ICSMC.2008.4811815,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4811815,Integrated Development Environment;usability;software maintenance;program comprehension,Software maintenance;Documentation;Software systems;Software performance;Software tools;Usability;Software prototyping;Costs;Springs;Software testing,cognitive systems;inference mechanisms;object-oriented programming;software maintenance,software maintenance efficiency;behavior-based cognitive models;integrated development environment;graphical form;software patterns,,,19,,,,,IEEE,IEEE Conferences
Developer Interaction Traces Backed by IDE Screen Recordings from Think Aloud Sessions,A. Yamashita; F. Petrillo; F. Khomh; Y. Guéhéneuc,NA; NA; NA; NA,2018 IEEE/ACM 15th International Conference on Mining Software Repositories (MSR),,2018,,,50,53,"There are two well-known difficulties to test and interpret methodologies for mining developer interaction traces: first, the lack of enough large datasets needed by mining or machine learning approaches to provide reliable results; and second, the lack of ""ground truth"" or empirical evidence that can be used to triangulate the results, or to verify their accuracy and correctness. Moreover, relying solely on interaction traces limits our ability to take into account contextual factors that can affect the applicability of mining techniques in other contexts, as well hinders our ability to fully understand the mechanics behind observed phenomena. The data presented in this paper attempts to alleviate these challenges by providing 600+ hours of developer interaction traces, from which 26+ hours are backed with video recordings of the IDE screen and developer's comments. This data set is relevant to researchers interested in investigating program comprehension, and those who are developing techniques for interaction traces analysis and mining.",2574-3864;2574-3848,978-1-4503-5716-6978-1-5386-6171,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8595177,empirical study;industrial data;interaction traces;log mining;program comprehension;programming flow,Data mining;Software;Companies;Programming;Java;Machine learning;Reliability,data mining;learning (artificial intelligence);user interfaces,IDE screen recordings;video recordings;Think Aloud Sessions;mining techniques;developer interaction traces;developer comments,,,21,,,,,IEEE,IEEE Conferences
Tool-Based Interactive Software Parallelization: A Case Study,A. Wilhelm; F. Cakaric; T. Schuele; M. Gerndt,NA; NA; NA; NA,2018 IEEE/ACM 40th International Conference on Software Engineering: Software Engineering in Practice Track (ICSE-SEIP),,2018,,,115,123,"Continuous advances in multicore processor technology have placed immense pressure on the software industry. Developers are forced to parallelize their applications to make them scalable. However, applications are often very large and inherently complex; here, automatic parallelization methods are inappropriate. A dependable software redesign requires profound comprehension of the underlying software architecture and its dynamic behavior. To address this problem, we propose Parceive, a tool that supports identification of parallelization scenarios at various levels of abstraction. Parceive collects behavior information at runtime and combines it with reconstructed software architecture information to generate useful visualizations for parallelization. In this paper, we motivate our approach and explain the main components of Parceive. A case study demonstrates the usefulness of the tool.",,978-1-4503-5659-6978-1-5386-6360,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449242,Parallelization;Software Visualization;Program Comprehension;Software Architecture,Tools;Software;Software architecture;Runtime;Data visualization;Parallel processing;Computer architecture,interactive systems;multiprocessing systems;software architecture;software maintenance,tool-based interactive software parallelization;continuous advances;multicore processor technology;software industry;automatic parallelization methods;dependable software redesign;underlying software architecture;parallelization scenarios;behavior information;reconstructed software architecture information,,,27,,,,,IEEE,IEEE Conferences
Visualizing call graphs,T. D. LaToza; B. A. Myers,"School of Computer Science, Carnegie Mellon University, Pittsburgh, PA USA; School of Computer Science, Carnegie Mellon University, Pittsburgh, PA USA",2011 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC),,2011,,,117,124,"Developers navigate and reason about call graphs throughout investigation and debugging activities. This is often difficult: developers can spend tens of minutes answering a single question, get lost and disoriented, and erroneously make assumptions, causing bugs. To address these problems, we designed a new form of interactive call graph visualization - REACHER. Instead of leaving developers to manually traverse the call graph, REACHER lets developers search along control flow. The interactive call graph visualization encodes a number of properties that help developers answer questions about causality, ordering, type membership, repetition, choice, and other relationships. And developers remain oriented while navigating. To evaluate REACHER'S benefits, we conducted a lab study in which 12 participants answered control flow questions. Compared to an existing IDE, participants with REACHER were over 5 times more successful in significantly less time. All enthusiastically preferred REACHER, with many positive comments.",1943-6106;1943-6092;1943-6092,978-1-4577-1247-0978-1-4577-1246-3978-1-4577-1244,10.1109/VLHCC.2011.6070388,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6070388,code exploration;call graphs;control flow;program visualization;program comprehension,Visualization;Navigation;Context;Joining processes;Debugging;Vegetation;Upper bound,program debugging;program visualisation;reverse engineering,interactive call graph visualization;REACHER;program visualization;program comprehension;control flow,,21,25,,,,,IEEE,IEEE Conferences
Filtered mining in program code repositories,F. Taibi,"Faculty of Information Technology, University of Management and Technology, Malaysia",2012 International Conference on Information Retrieval & Knowledge Management,,2012,,,264,267,An approach to automatically mine program code repositories in order to support software reuse is proposed in this paper. Code attributes and structural relationships are used to find and rank the potential elements based on a given query. Static program analysis is used to allow a filtered mining through three well-established metrics that have a direct impact on code quality. The approach has been empirically evaluated and the results obtained were promising.,,978-1-4673-1090-1978-1-4673-1091-8978-1-4673-1089,10.1109/InfRKM.2012.6204986,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6204986,Mining Source Code Repositories;Static Program Analysis;Program Comprehension;Software Metrics;Software Reuse,Data mining;Measurement;Software reusability;Software engineering;Accuracy;Complexity theory,data mining;program diagnostics;software metrics;software quality;software reusability,filtered mining;program code repositories;software reuse;code attributes;structural relationships;potential elements;static program analysis;metrics;code quality,,1,15,,,,,IEEE,IEEE Conferences
Developing visual expertise in software engineering: An eye tracking study,M. Nivala; F. Hauser; J. Mottok; H. Gruber,"University of Regensburg, Department of Educational Science, D-93025 Regensburg; Ostbayerische Technische Hochschule (OTH) Regensburg, Laboratory for Safe and Secure Systems, LaS3, D-93025 Regensburg; Ostbayerische Technische Hochschule (OTH) Regensburg, Laboratory for Safe and Secure Systems, LaS3, D-93025 Regensburg; University of Regensburg, Department of Educational Science, D-93025 Regensburg",2016 IEEE Global Engineering Education Conference (EDUCON),,2016,,,613,620,"Program comprehension and the ability to find program errors are key skills of software engineering. The aim of this pilot study was to examine the visual processes of novice and advanced programmers in authentic tasks. Fifteen novices and eight advanced programmers were given eight short pieces of code. Their task was to either identify an error or give the output of the code. Eye movements and keyboard activity were recorded. On average, the novices spent more time reading the code than composing the response, whereas the more advanced programmers started composing the response sooner and spent more time on it. In general, the advanced programmers had shorter fixations and saccades. The results suggest that the advanced programmers are quicker to grasp the essence of the code and able to see more details in it. The advanced programmers had shorter fixations and saccade lengths during the second phase which might indicate the process of chunking.",2165-9567,978-1-4673-8633-3978-1-4673-8632,10.1109/EDUCON.2016.7474614,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7474614,program comprehension;debugging;software engineering;visual expertise;eye tracking,Software;Visualization;Programming profession;Gaze tracking;Debugging;Tracking,software engineering,visual expertise;software engineering;eye tracking study;eye movements;keyboard activity,,1,27,,,,,IEEE,IEEE Conferences
Software visualisation techniques adapted and extended for asynchronous hardware design,L. Janin; D. Edwards,"Sch. of Comput. Sci., Manchester Univ., UK; Sch. of Comput. Sci., Manchester Univ., UK",Ninth International Conference on Information Visualisation (IV'05),,2005,,,347,356,"Asynchronous circuit design shows many similarities with software design. This is due to the modular construction style associated with asynchronous circuits, where each asynchronous module can be designed as a standalone object communicating with other modules. We propose a visualisation system for asynchronous circuit design tools, based on clustered graph visualisation and coordinated views. The novelty of our approach is to apply classical software visualisation techniques to a hardware environment and take advantage of properties specific to our asynchronous design flow. This system is based on a control and data flow graph representation of the asynchronous circuit compiled from a high-level description by a syntax-directed transparent process and transferable to the final hardware circuit by a direct synthesis process. Compared to software compilation flows, this transparent design flow offers opportunities for visualisation, with representations at different stages being easily mapped onto each other to combine their visualisation qualities. Each representation also exhibits properties based on some physical attributes of the final hardware circuit, allowing us to render some abstract properties on top of real-world-based ones. This paper shows how the handshake circuit graph is used as the underlying structure onto which properties extracted from other structures are mapped, and then how this structured graph is used as the central piece in a coordinated views environment. These visualisation techniques have been exercised by designers optimising the design of a fully asynchronous ARM processor.",1550-6037;2375-0138,0-7695-2397,10.1109/IV.2005.119,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1509100,Software visualisation;coordinated views;program comprehension;asynchronous circuits,Visualization;Hardware;Asynchronous circuits;Software design;Modular construction;Flow graphs;Circuit synthesis;Control system synthesis;Software quality;Design optimization,program visualisation;integrated circuit design;asynchronous circuits;flow graphs;data flow graphs,software visualization;asynchronous hardware design;asynchronous circuit design;control flow graph representation;data flow graph representation;direct synthesis;handshake circuit graph;circuit design optimization;fully asynchronous ARM processor,,2,15,,,,,IEEE,IEEE Conferences
Executable Program Documentation Based on Debugging Break Points,Y. Cheng; J. Chen; Y. Yu,NA; NA; NA,2013 20th Asia-Pacific Software Engineering Conference (APSEC),,2013,1,,199,206,"Understanding an unfamiliar program is always a daunting task for any programmer, either experienced or inexperienced. Many studies have shown that even an experienced programmer who is already familiar with the code may still need to rediscover the code frequently during maintenance activities. Compared to that tracing the source code of an unfamiliar program is a totally different process of comprehension. Difficulties in such a process can be compounded if the code has poor or little internal program documentation. In practice, internal program documentation is often neglected or receives much less attention while most documentation techniques are designed to help programmers deal with familiar code, not unfamiliar code. In this paper, a novel internal program documentation method is proposed. In the approach, the multimedia documents, such as slides and voice recording, can be created along with a sequence of debugging break points, where the sequence of break points and its associated multimedia documents form a trace case. We show that trace cases can be very useful in documenting major control flows of a program using examples so that the time needed to construct a program model for understanding can be shortened. To demonstrate the idea, a prototype tool called polyTraceAid has been implemented as a plug-in in Visual Studio.",1530-1362;1530-1362,978-1-4799-2144-7978-1-4799-2143,10.1109/APSEC.2013.36,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6805407,program documentation;program comprehension;executable documents;debugger;multimedia documents,Documentation;Multimedia communication;Debugging;Maintenance engineering;Software;Software engineering;Visualization,multimedia systems;program debugging;software maintenance;system documentation,executable program documentation;debugging break points;internal program documentation method;multimedia documents;trace case;program control flows;program model;polyTraceAid;Visual Studio plug-in;program comprehension;software maintenance,,,18,,,,,IEEE,IEEE Conferences
SourceMiner Evolution: A Tool for Supporting Feature Evolution Comprehension,R. L. Novais; C. Nunes; A. Garcia; M. Mendonça,NA; NA; NA; NA,2013 IEEE International Conference on Software Maintenance,,2013,,,508,511,"Program comprehension is an essential activity to perform software maintenance and evolution. Comprehensibility often encompasses the analysis of individual logical units, called features, which are often scattered through many program modules. Understanding how the feature code is implemented along the software evolution history is essential, for instance, to perform refactoring activities. However, existing tools do not provide means to comprehend the feature code evolution. To overcome this shortcoming, this paper presents a tool called Source Miner Evolution (SME) that provides multiple interactive and coordinated views to comprehend feature code evolution. SME implements a feature-sensitive comparison of multiple program versions. Our usability assessment with experienced developers indicated that SME allows them to efficiently perform recurring comprehension tasks on evolving feature code. The developers' performance was influenced by the combination of visual SME mechanisms, such as colors, tool tips and menu-popup interactions over the features' code elements.",1063-6773,978-0-7695-4981,10.1109/ICSM.2013.83,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6676944,program comprehension;feature evolution;software visualization,Visualization;Color;Software systems;Feature extraction;Couplings;History,software maintenance;software reusability,usability assessment;SME;source miner evolution;software evolution;software maintenance;program comprehension;feature evolution comprehension,,3,16,,,,,IEEE,IEEE Conferences
RuntimeSearch: Ctrl+F for a running program,M. Sulír; J. Porubän,"Technical University of Košice, Slovakia; Technical University of Košice, Slovakia",2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE),,2017,,,388,393,"Developers often try to find occurrences of a certain term in a software system. Traditionally, a text search is limited to static source code files. In this paper, we introduce a simple approach, RuntimeSearch, where the given term is searched in the values of all string expressions in a running program. When a match is found, the program is paused and its runtime properties can be explored with a traditional debugger. The feasibility and usefulness of RuntimeSearch is demonstrated on a medium-sized Java project.",,978-1-5386-2684-9978-1-5386-3976,10.1109/ASE.2017.8115651,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115651,program comprehension;dynamic analysis;debugger;text search;concept location,Runtime;Debugging;Java;Tools;Graphical user interfaces;Instruments,Java;program compilers;program debugging;program diagnostics,RuntimeSearch;ctrl+f;running program;software system;text search;static source code files;string expressions;traditional debugger;medium-sized Java project,,1,27,,,,,IEEE,IEEE Conferences
Using Topic Models to Support Software Maintenance,S. Grant; J. R. Cordy; D. B. Skillicorn,NA; NA; NA,2012 16th European Conference on Software Maintenance and Reengineering,,2012,,,403,408,"Our recent research has shown that the latent information found by commonly used topic models generally relates to the development history of a software system. While it is not always possible to associate these latent topics with human-oriented concepts, it is demonstrable that they identify historical maintenance relationships in source code. Specifically, when a developer makes a change to a software project, it is common for a significant part of that change to relate to a single latent topic. A significant conclusion can be drawn from this: latent topic models identify co-maintenance relationships with no supervision, and therefore topic models can be used to support the maintenance phase of software development.",1534-5351,978-0-7695-4666-7978-1-4673-0984,10.1109/CSMR.2012.51,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6178887,software maintenance;topic models;program comprehension,History;Web services;Software systems;Maintenance engineering;Software maintenance;Visualization,project management;software maintenance,latent topic models;software maintenance;software system;historical maintenance relationship identification;source code;software project;co-maintenance relationship identification;software development,,7,22,,,,,IEEE,IEEE Conferences
A Visualization Framework for Parallelization,A. Wilhelm; V. Savu; E. Amadasun; M. Gerndt; T. Schuele,NA; NA; NA; NA; NA,2016 IEEE Working Conference on Software Visualization (VISSOFT),,2016,,,81,85,"Since the advent of multicore processors, developers struggle with the parallelization of legacy software. Automatic methods are only appropriate to identify parallelism at instruction level or within simple loops. For most applications, however, a scalable redesign require profound comprehension of the underlying software architecture and its dynamic aspects. This leads to an increasing demand for interactive tools that foster parallelization at various granularity levels. To cope with this problem, we propose a visualization framework, and three tailored views for parallelism detection. The framework is part of Parceive, a tool that utilizes dynamic binary instrumentation to trace C/C++ and C# programs. The cooperative views allow identification and analysis of potential parallelism scenarios using seamless navigation, abstraction, and filtering. In this paper, we motivate our approach, illustrate the architecture of the visualization framework, and highlight the key features of the views. A case study demonstrates the usefulness of Parceive.",,978-1-5090-3850-3978-1-5090-3851,10.1109/VISSOFT.2016.35,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780161,Parallelization;Trace analysis;Software visualization;Program comprehension,Software;Data visualization;Optimization;Runtime;Loading;Pipeline processing,data visualisation;multiprocessing systems;parallel programming;software architecture;software maintenance;software tools,visualization framework;multicore processors;legacy software parallelization;software architecture;dynamic aspects;interactive tools;granularity levels;parallelism detection;Parceive;dynamic binary instrumentation;C# programs;seamless navigation,,2,12,,,,,IEEE,IEEE Conferences
Enhancing Software Visualization with Information Retrieval,R. Francese; M. Risi; G. Scanniello,NA; NA; NA,2015 19th International Conference on Information Visualisation,,2015,,,189,194,"I have enhanced Metric Attitude. It is a visualization tool based on static analysis that provides a mental picture by viewing an object-oriented software system by means of polymetric views. In particular, we have integrated an Information Retrieval engine and named this new version of visualization tool as Metric Attitude++. It allows the user to formulate a textual query and to show on the visual representation of the subject software the elements that are more similar to that query. This could be useful in all those cases in which a user needs to identify (or to localize) features implemented in the source code. Several filters are also available to hide possibly irrelevant details and to ease the browsing and then the comprehension of a software system. Finally, we have applied Metric Attitude++ on a number of object-oriented software systems. In this paper, we report preliminary results of a quantitative study on a widely studied open-source software, namely JEdit. On the basis of our results it seems that Metric Attitude++ can be effectively applied to different kinds of source code comprehension tasks and to concept location in source code, in particular.",1550-6037;2375-0138,978-1-4673-7568-9978-1-4673-7567,10.1109/iV.2015.42,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7272600,Information Retrieval;Program Comprehension;Reverse Engineering;Software Evolution;Software Mainte-nance;Software Metrics;Software Visualization,Visualization;Measurement;Software systems;Context;Color;Navigation,object-oriented programming;program diagnostics;program visualisation;public domain software;query processing;source code (software),software visualization;information retrieval;static analysis;object-oriented software system;visualization tool;Metric Attitude++;textual query formulation;source code;open-source software;JEdit,,3,25,,,,,IEEE,IEEE Conferences
Understanding Software Architectures by Visualization--An Experiment with Graphical Elements,J. Knodel; D. Muthig; M. Naab,"Fraunhofer Institute for Experimental Software Engineering (IESE), Germany; Fraunhofer Institute for Experimental Software Engineering (IESE), Germany; Fraunhofer Institute for Experimental Software Engineering (IESE), Germany",2006 13th Working Conference on Reverse Engineering,,2006,,,39,50,"The evolution and maintenance of large-scale software systems requires first an understanding of its architecture before delving into lower level details. Tools facilitating the architecture comprehension tasks by visualization provide different sets of graphical elements. We conducted a controlled experiment that exemplifies the critical role of such graphical elements when aiming at understanding the architecture. The results show that a different configuration of graphical elements influences program comprehension tasks significantly. In particular, a gain of effectiveness by 63% in basic architectural analysis tasks was achieved simply by choosing a different set of graphical elements. Based on the results we claim that significant effort should be spent on the configuration of architecture visualization tools",1095-1350;2375-5369,0-7695-2719,10.1109/WCRE.2006.54,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4023975,architecture;experiment;graphical elements;program comprehension;SAVE;visualization.,Software architecture;Visualization;Computer architecture;Large-scale systems;Software systems;Software engineering;Software maintenance;Performance analysis;Monitoring;Information retrieval,program visualisation;reverse engineering;software architecture;software maintenance,software architectures;software evolution;software maintenance;graphical element configuration;program comprehension;architecture visualization tool,,5,26,,,,,IEEE,IEEE Conferences
Runtime Invocation Analysis of API Objects in Large Code Base,M. A. Khan; S. Muhammad; T. Muhammad,NA; NA; NA,2013 International Conference on Computer Sciences and Applications,,2013,,,463,468,"Software systems use several third party libraries via their available interfaces popularly known as the application programming interface (API). The runtime usage of the API in an object-oriented software system can be defined by several characteristics including the type and number of API objects created, the methods invoked on those objects, and the source code locations from where the objects were created or invoked during their lifetime. These characteristics can be used to identify the source code locations exhibiting different types of runtime behavior which can be used for program comprehension, debugging, performance monitoring and fault detection. In this paper, we define object invocation model based on above-mentioned characteristics. We also propose an implementation framework that can be used to extract key model parameters from any source code. The Java Collections API is one of the most widely used Java APIs. We demonstrate effectiveness of our proposed approach by analyzing object invocation model for Java Collection API in a large open source project.",,978-0-7695-5125,10.1109/CSA.2013.114,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6835641,runtime program analysis;api usage analysis;api invocation analysis;object invocation model;Java Collection API analysis;program comprehension;bytecode instrumentation,Instruments;Java;Runtime;Object recognition;Software systems;Data mining;Analytical models,application program interfaces;Java;object-oriented programming;program debugging;public domain software;software libraries;source code (software),runtime invocation analysis;API objects;large code base;third party libraries;application programming interface;object-oriented software system;source code locations;program comprehension;program debugging;performance monitoring;fault detection;object invocation model;source code;Java collection API,,,18,,,,,IEEE,IEEE Conferences
Can We Predict Dependencies Using Domain information?,A. Aryani; F. Perin; M. Lungu; A. N. Mahmood; O. Nierstrasz,NA; NA; NA; NA; NA,2011 18th Working Conference on Reverse Engineering,,2011,,,55,64,"Software dependencies play a vital role in program comprehension, change impact analysis and other software maintenance activities. Traditionally, these activities are supported by source code analysis, however, the source code is sometimes inaccessible, and not all stakeholders have adequate knowledge to perform such analysis. For example, non-technical domain experts and consultants raise most maintenance requests, however, they cannot predict the cost and impact of the requested changes without the support of the developers. We propose a novel approach to predict software dependencies by exploiting coupling present in domain-level information. Our approach is independent of the software implementation, hence, it can be used to evaluate architectural dependencies without access to the source code or the database. We evaluate our approach with a case study on a large-scale enterprise system, in which we demonstrate how up to 68% of the source code dependencies and 77% of the database dependencies are predicted solely based on domain information.",2375-5369;1095-1350,978-1-4577-1948,10.1109/WCRE.2011.17,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079775,Domain-based coupling;Architectural Dependencies;Database Dependencies;Source Code Analysis;Program Comprehension,Couplings;Software;Databases;Mathematical model;Equations;Object oriented modeling;Java,software maintenance,domain-level information;software dependencies;program comprehension;change impact analysis;software maintenance;source code analysis,,7,49,,,,,IEEE,IEEE Conferences
Mining Logical Clones in Software: Revealing High-Level Business and Programming Rules,W. Qian; X. Peng; Z. Xing; S. Jarzabek; W. Zhao,NA; NA; NA; NA; NA,2013 IEEE International Conference on Software Maintenance,,2013,,,40,49,"Software systems contain many implicit application-specific business and programming rules. These rules represent high-level logical structures and processes for application-specific business and programming concerns. They are crucial for program understanding, consistent evolution, and systematic reuse. However, existing pattern mining and analysis approaches cannot effectively mine such application-specific rules. In this paper, we present an approach for mining logical clones in software that reveal high-level business and programming rules. Our approach extracts a program model from source code, and enriches the program model with code clone information, functional clusters (i.e., a set of methods dealing with similar topics or concerns), and abstract entity classes (representing sibling entity classes). It then analyzes the enriched program model for mining recurring logical structures as logical clones. We have implemented our approach in a tool called MiLoCo (Mining Logical Clone) and conducted a case study with an open-source ERP and CRM software. Our results show that MiLoCo can identify meaningful and useful logical clones for program understanding, evolution and reuse.",1063-6773,978-0-7695-4981,10.1109/ICSM.2013.15,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6676875,logical clone;semantic clustering;program comprehension;evolution;reuse,Cloning;Business;Clustering algorithms;Data mining;Programming;Abstracts;Semantics,commerce;customer relationship management;data mining;enterprise resource planning;public domain software;software reusability,program reuse;CRM software;open-source ERP software;MiLoCo;pattern mining;application-specific business;software systems;programming rules;high-level business;logical clones mining,,5,23,,,,,IEEE,IEEE Conferences
A Tool for Visual Understanding of Source Code Dependencies,M. Pinzger; K. Graefenhain; P. Knab; H. C. Gall,NA; NA; NA; NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,254,259,"Many program comprehension tools use graphs to visualize and analyze source code. The main issue is that existing approaches create graphs overloaded with too much information. Graphs contain hundreds of nodes and even more edges that cross each other. Understanding these graphs and using them for a given program comprehension task is tedious, and in the worst case developers stop using the tools. In this paper we present DA4Java, a graph-based approach for visualizing and analyzing static dependencies between Java source code entities. The main contribution of DA4Java is a set of features to incrementally compose graphs and remove irrelevant nodes and edges from graphs. This leads to graphs that contain significantly fewer nodes and edges and need less effort to understand.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.23,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556140,Incremental Source Code Analysis;Program Comprehension;Software Visualization;Source Code Dependencies,Visualization;Java;Information filtering;Information filters;Packaging;Software systems;Informatics;Data mining;Costs;Software maintenance,graph theory;Java;program visualisation;reverse engineering,source code dependencies;program comprehension tools;DA4Java;graph-based approach;Java source code;visual understanding,,18,16,,,,,IEEE,IEEE Conferences
Visualizing Software Structure Understandability,P. Dugerdil; M. Niculescu,NA; NA,2014 23rd Australian Software Engineering Conference,,2014,,,110,119,"Software architecture design is known to be driven by the quality attributes we may want to satisfy. Among them, modifiability plays an important role since software maintenance takes the lion's share in the software development costs. However, to successfully maintain a legacy system, the latter must be sufficiently understood so that the maintenance team will not introduce new bugs when correcting others. Then we present a software metric that we called the Autonomy Ratio (AR). We show this dynamic metric to be a good indicator of the system's structure understandability. Since we end up with hundreds of values for a single system, we represent these values as a hierarchical map: the ""Autonomy Ratio Map"". The contribution of the paper is to link the AR metric with theories of software comprehension, to show how the AR Map helps in assessing software structure understand-debility, and to present an empirical validation of it.",1530-0803;2377-5408,978-1-4799-3149,10.1109/ASWEC.2014.17,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6824115,program comprehension;software metrics;software visualization;dynamic analysis;software architecture,Software;Measurement;Collaboration;Couplings;Maintenance engineering;Color;Business,data visualisation;software architecture;software maintenance;software metrics;software quality,software structure understandability visualization;software architecture design;quality attributes;modifiability;software maintenance;software development costs;legacy system;software metric;autonomy ratio map;dynamic metric;system structure understandability;hierarchical map;AR metric;software comprehension;AR map;software structure understand-debility assessment,,2,39,,,,,IEEE,IEEE Conferences
Exploiting text mining techniques in the analysis of execution traces,H. Pirzadeh; A. Hamou-Lhadj; M. Shah,"Software Behaviour Analysis Lab, Department of Electrical and Computer Engineering, Concordia University, USA; Software Behaviour Analysis Lab, Department of Electrical and Computer Engineering, Concordia University, USA; Accenture Technology Labs, 161 N Clark St, Chicago, IL, 60601, USA",2011 27th IEEE International Conference on Software Maintenance (ICSM),,2011,,,223,232,"The analysis of execution traces can be useful in many software engineering activities including debugging, feature enhancement, performance analysis, and any other task that requires some degree of understanding of the way a system behaves. Traces, however, tend to be considerably large, which often hinders effective analysis of their content. There is a need to investigate ways to help software engineers find and understand important information conveyed in a trace despite the trace being massive. Motivated by the work done in the area of text mining, we propose, in this paper, a trace exploration approach based on examining the trace execution phases. The approach consists of automatically identifying relevant information about the phases as well as the ability to provide an efficient representation of the flow of phases by detecting redundant phases using a cosine similarity metric. We applied our approach to large traces generated from two different systems and were able to quickly understand their content and extract higher level views that characterize the essence of the information conveyed in these traces.",1063-6773;1063-6773,978-1-4577-0664-6978-1-4577-0663-9978-1-4577-0662,10.1109/ICSM.2011.6080789,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6080789,Program Comprehension;Dynamic Analysis;Text mining;Software Maintenance,Levee;Bayesian methods,data flow analysis;data mining;program debugging;software maintenance;software metrics;software performance evaluation;text analysis,exploiting text mining techniques;execution trace analysis;software engineering;software debugging;software feature enhancement;software performance analysis;trace exploration approach;trace execution phases;relevant information automatic identification;redundant phase detection;cosine similarity metric,,6,33,,,,,IEEE,IEEE Conferences
Towards Prioritizing Documentation Effort,P. W. McBurney; S. Jiang; M. Kessentini; N. A. Kraft; A. Armaly; M. W. Mkaouer; C. McMillan,"Department of Computer and Information Science, University of Pennsylvania, Philadelphia, PA; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer and Information Science, University of Michigan-Dearborn, Dearborn, MI; ABB Corporate Research, Raleigh, NC; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer and Information Science, University of Michigan-Dearborn, Dearborn, MI; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN",IEEE Transactions on Software Engineering,,2018,44,9,897,913,"Programmers need documentation to comprehend software, but they often lack the time to write it. Thus, programmers must prioritize their documentation effort to ensure that sections of code important to program comprehension are thoroughly explained. In this paper, we explore the possibility of automatically prioritizing documentation effort. We performed two user studies to evaluate the effectiveness of static source code attributes and textual analysis of source code towards prioritizing documentation effort. The first study used open-source API Libraries while the second study was conducted using closed-source industrial software from ABB. Our findings suggest that static source code attributes are poor predictors of documentation effort priority, whereas textual analysis of source code consistently performed well as a predictor of documentation effort priority.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2017.2716950,National Science Foundation Graduate Research Fellowship Program; National Science Foundation; ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7953505,Code documentation;program comprehension;software maintenance,Documentation;Libraries;Java;Gold;Programming;Software;Neural networks,application program interfaces;program diagnostics;public domain software;software maintenance,prioritizing documentation effort;static source code attributes;open-source API Libraries;closed-source industrial software;documentation effort priority,,,78,,,,,IEEE,IEEE Journals
AutoComment: Mining question and answer sites for automatic comment generation,E. Wong; Jinqiu Yang; Lin Tan,"University of Waterloo, Ontario, Canada; University of Waterloo, Ontario, Canada; University of Waterloo, Ontario, Canada",2013 28th IEEE/ACM International Conference on Automated Software Engineering (ASE),,2013,,,562,567,"Code comments improve software maintainability. To address the comment scarcity issue, we propose a new automatic comment generation approach, which mines comments from a large programming Question and Answer (Q&A) site. Q&A sites allow programmers to post questions and receive solutions, which contain code segments together with their descriptions, referred to as code-description mappings.We develop AutoComment to extract such mappings, and leverage them to generate description comments automatically for similar code segments matched in open-source projects. We apply AutoComment to analyze Java and Android tagged Q&A posts to extract 132,767 code-description mappings, which help AutoComment to generate 102 comments automatically for 23 Java and Android projects. The user study results show that the majority of the participants consider the generated comments accurate, adequate, concise, and useful in helping them understand the code.",,978-1-4799-0215,10.1109/ASE.2013.6693113,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693113,automated comment generation;documentation;program comprehension;natural language processing for software engineering,Java;Software;Androids;Humanoid robots;Databases;Cloning;Natural language processing,Android (operating system);data mining;Java;public domain software;question answering (information retrieval);software maintenance,AutoComment;programming question-and-answer site mining;automatic comment generation;code comments;software maintainability improvement;comment scarcity issue;code segments;open-source projects;Java tagged Q&A post analysis;Android tagged Q&A post analysis;code-description mapping extraction;program comprehension;natural language processing;software engineering,,44,23,,,,,IEEE,IEEE Conferences
AudioHighlight: Code Skimming for Blind Programmers,A. Armaly; P. Rodeghero; C. McMillan,NA; NA; NA,2018 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2018,,,206,216,"Blind programmers use a screen reader to read code aloud. Screen readers force blind programmers to read code sequentially one line at a time. In contrast, sighted programmers are able to skim visually to the most important code areas, assisted by syntax highlighting. However, there is a place where there is a widely adopted approach to skimming a structured document: the web. Modern screen readers employ what is known as a virtual cursor to navigate structural information on webpages such as HTML heading tags. These tags can indicate different sections and subsections in the structure of a page. We harness the existing familiarity of blind computer users with this interface in our approach which we call AudioHighlight. AudioHighlight renders the code inside a web view, either as part of the Eclipse IDE or as a web service. It places HTML heading tags on the structural elements of a source file such as classes, functions and control flow statements. We compare AudioHighlight to the state of the art in code skimming represented by a previous code skimming approach called StructJumper. We also compare to the state of practice in reading code on the web as represented by GitHub. We found that AudioHighlight increased the quality and speed of code comprehension as compared to both approaches.",2576-3148;1063-6773,978-1-5386-7870-1978-1-5386-7871,10.1109/ICSME.2018.00030,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530030,accessibility;visual impairments;program comprehension,Navigation;Task analysis;Licenses;Syntactics;Productivity;Tutorials;Cloning,audio user interfaces;handicapped aids;hypermedia markup languages;Web services,blind programmers;structured document;structural information;HTML heading tags;blind computer users;AudioHighlight;code comprehension;code skimming approach;syntax highlighting;Web pages;user interface;Eclipse IDE;Web service;StructJumper;GitHub,,1,40,,,,,IEEE,IEEE Conferences
Do Code Smells Impact the Effort of Different Maintenance Programming Activities?,Z. Soh; A. Yamashita; F. Khomh; Y. Guéhéneuc,NA; NA; NA; NA,"2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)",,2016,1,,393,402,"Empirical studies have shown so far that code smells have relatively low impact over maintenance effort at file level. We surmise that previous studies have found low effects of code smells because the effort considered is a ""sheer-effort"" that does not distinguish between the kinds of developers' activities. In our study, we investigate the effects of code smells at the activity level. Examples of activities are: reading, editing, searching, and navigating, which are performed independently over different files during maintenance. We conjecture that structural attributes represented in the form of different code smells do indeed have an effect on the effort for performing certain kinds of activities. To verify this conjecture, we revisit a previous study about the impact of code smell on maintenance effort, using the same dataset, but considering activity effort. Six professional developers were hired to perform three maintenance tasks on four functionally equivalent Java Systems. Each developer performs two maintenance tasks. During maintenance task, we monitor developers' logs. Then, we define an annotation schema to identify developers' activities and assess whether code smells affect different maintenance activities. Results show that different code smells affect differently activity effort. Yet, the size of the changes performed to solve the task impacts the effort of all activities more than code smells and file size. While code smells impact the editing and navigating effort more than file size, the file size impacts the reading and searching activities more than code smells. One major implication of these results is that if code smells indeed affect the effort of certain kinds of activities, it means that their effects are contingent on the type of maintenance task at hand, where some kinds of activities will become more predominant than others.",,978-1-5090-1855,10.1109/SANER.2016.103,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7476660,code smells;programming activity;maintenance effort;program comprehension;software quality,Maintenance engineering;Navigation;Java;Programming;Software;Companies;Software engineering,file organisation;Java;software maintenance;software quality,maintenance programming activities;code smells;file level;structural attributes;maintenance effort;functionally equivalent Java systems;developer log monitoring;annotation schema;file size,,4,40,,,,,IEEE,IEEE Conferences
SMURF: A SVM-based Incremental Anti-pattern Detection Approach,A. Maiga; N. Ali; N. Bhattacharya; A. Sabané; Y. Guéhéneuc; E. Aimeur,NA; NA; NA; NA; NA; NA,2012 19th Working Conference on Reverse Engineering,,2012,,,466,475,"In current, typical software development projects, hundreds of developers work asynchronously in space and time and may introduce anti-patterns in their software systems because of time pressure, lack of understanding, communication, and-or skills. Anti-patterns impede development and maintenance activities by making the source code more difficult to understand. Detecting anti-patterns incrementally and on subsets of a system could reduce costs, effort, and resources by allowing practitioners to identify and take into account occurrences of anti-patterns as they find them during their development and maintenance activities. Researchers have proposed approaches to detect occurrences of anti-patterns but these approaches have currently four limitations: (1) they require extensive knowledge of anti-patterns, (2) they have limited precision and recall, (3) they are not incremental, and (4) they cannot be applied on subsets of systems. To overcome these limitations, we introduce SMURF, a novel approach to detect anti-patterns, based on a machine learning technique - support vector machines - and taking into account practitioners' feedback. Indeed, through an empirical study involving three systems and four anti-patterns, we showed that the accuracy of SMURF is greater than that of DETEX and BDTEX when detecting anti-patterns occurrences. We also showed that SMURF can be applied in both intra-system and inter-system configurations. Finally, we reported that SMURF accuracy improves when using practitioners' feedback.",2375-5369;1095-1350,978-0-7695-4891-3978-1-4673-4536,10.1109/WCRE.2012.56,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385142,Anti-pattern;program comprehension;program maintenance;empirical software engineering,Support vector machines;Accuracy;Measurement;Training;Maintenance engineering;Kernel,learning (artificial intelligence);program diagnostics;software development management;software maintenance;support vector machines,SMURF;SVM-based incremental antipattern detection approach;software development projects;maintenance activities;development activities;source code;machine learning technique;support vector machines;DETEX;BDTEX;intersystem configurations;intrasystem configurations,,20,32,,,,,IEEE,IEEE Conferences
The Evaluation of an Approach for Automatic Generated Documentation,N. Abid; N. Dragan; M. L. Collard; J. I. Maletic,NA; NA; NA; NA,2017 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2017,,,307,317,"Two studies are conducted to evaluate an approach to automatically generate natural language documentation summaries for C++ methods. The documentation approach relies on a method's stereotype information. First, each method is automatically assigned a stereotype(s) based on static analysis and a set of heuristics. Then, the approach uses the stereotype information, static analysis, and predefined templates to generate a natural-language summary/documentation for each method. This documentation is automatically added to the code base as a comment for each method. The result of the first study reveals that the generated documentation is accurate, does not include unnecessary information, and does a reasonable job describing what the method does. Based on statistical analysis of the second study, the most important part of the documentation is the short description as it describes the intended behavior of a method.",,978-1-5386-0992-7978-1-5386-0993,10.1109/ICSME.2017.76,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8094431,source-code summarization;program comprehension;method stereotypes;static analysis,Documentation;Static analysis;Java;Pragmatics;C++ languages,C++ language;natural language processing;program diagnostics;statistical analysis;system documentation,automatic generated documentation;natural language documentation summaries;C++ methods;stereotype information;static analysis;statistical analysis,,2,29,,,,,IEEE,IEEE Conferences
Reengineering embedded automotive software,A. Thums; J. Quante,"Corporate Sector Research and Advance Engineering Software, Robert Bosch GmbH, Stuttgart, Germany; Corporate Sector Research and Advance Engineering Software, Robert Bosch GmbH, Stuttgart, Germany",2012 28th IEEE International Conference on Software Maintenance (ICSM),,2012,,,493,502,"The fact that software ages holds for embedded automotive software as well as for any other kind of software. In comparison to IT software, the automotive domain has to deal with different kinds of requirements, such as real time properties, feedback control, and constrained resources. Therefore, used programming languages are C - to meet resource constraints - and data flow oriented graphical languages - to meet the used engineering method and notation of feedback control engineers. This makes the software quite different from what the software maintenance and reengineering community is usually working on, and their results are seldom directly applicable. In this paper, we describe results of a Bosch-internal research project that focused on the adaption of existing reengineering techniques and methods to embedded automotive software development. The goal was to make software maintenance more efficient by a) preventing software ageing and b) supporting program comprehension. Our approach was to make existing reengineering techniques usable for series development in an effective and efficient way. The result is a set of reengineering tools and practices that are specialized for the needs of the automotive domain and usable in practice.",1063-6773,978-1-4673-2312-3978-1-4673-2313,10.1109/ICSM.2012.6405312,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6405312,Embedded software;reengineering;maintainability;program comprehension;industrial application,Automotive engineering;Indexes;Measurement;Complexity theory;Software maintenance;Data models,automotive engineering;C language;mechanical engineering computing;parallel languages;software maintenance;visual languages,embedded automotive software reengineering;real time properties;feedback control;constrained resources;C programming language;resource constraints;flow oriented graphical languages;software maintenance community;Bosch-internal research project;embedded automotive software development;software ageing prevention;program comprehension,,6,20,,,,,IEEE,IEEE Conferences
Toward Interaction-Based Evaluation of Visualization Approaches to Comprehending Program Behavior,L. Kaixie; K. Noda; T. Kobayashi,"School of Computing, Tokyo Institute of Technology, Japan; School of Computing, Tokyo Institute of Technology, Japan; School of Computing, Tokyo Institute of Technology, Japan",2019 IEEE Workshop on Mining and Analyzing Interaction Histories (MAINT),,2019,,,19,23,"Reverse-engineered sequence diagrams are promising tools to comprehend the runtime behavior of object-oriented programs. To improve the readability and understandability of massive-scale sequence diagrams, various techniques for effectively exploring or compressing sequence diagrams have been proposed in the literature.When researchers analyze the effectiveness of these approaches through user studies, it is important to reveal not only what techniques can improve developer productivity but also how developers explore reverse-engineered sequence diagrams and how exploration and compression features are utilized.We developed a feature to record interactions between a developer and recovered sequence diagrams in our tool, SDExplorer. We show how the recorded interaction data can be used for in-depth analysis of developer activities, toward the evaluation of visualization approaches to helping behavioral comprehension.",,978-1-7281-0956-5978-1-7281-0957,10.1109/MAINT.2019.8666933,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8666933,interaction data analysis;scalable sequence diagram explorer;visualization;program comprehension,Tools;Navigation;Data visualization;Task analysis;Runtime;Software;Databases,data visualisation;object-oriented programming;reverse engineering,visualization approaches;reverse-engineered sequence diagrams;runtime behavior;object-oriented programs;massive-scale sequence diagrams;developer productivity;compression features;behavioral comprehension;interaction-based evaluation;program behavior;SDExplorer,,,27,,,,,IEEE,IEEE Conferences
Using Network Analysis for Recommendation of Central Software Classes,D. Steidl; B. Hummel; E. Juergens,NA; NA; NA,2012 19th Working Conference on Reverse Engineering,,2012,,,93,102,"As a new developer, getting to know a large unknown software system is a challenging task. If experienced developers are available, they can suggest which classes to read first, helping new developers to quickly grasp the system's most fundamental concepts. In practice, however, experienced developers often are no longer available. In these cases, the set of most important classes must be reverse engineered. This paper presents a thorough analysis of using different network analysis metrics on dependency graphs to retrieve central classes. An empirical study on four open source projects evaluates the results based on a survey among the systems' core developers. It demonstrates that the algorithmic results can compete with the suggestions of experienced developers.",2375-5369;1095-1350,978-0-7695-4891-3978-1-4673-4536,10.1109/WCRE.2012.19,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385105,network analysis;program comprehension;dependency graph,Algorithm design and analysis;Software systems;Measurement;Software algorithms;Indexes;Markov processes,network theory (graphs);public domain software;reverse engineering;software development management,software system;software developement;reverse engineering;network analysis metrics;dependency graph;open source project;central software class retrieval,,16,14,,,,,IEEE,IEEE Conferences
Evaluating source code summarization techniques: Replication and expansion,B. P. Eddy; J. A. Robinson; N. A. Kraft; J. C. Carver,"Department of Computer Science, The University of Alabama, Tuscaloosa, 35487-0290, USA; Department of Computer Science, The University of Alabama, Tuscaloosa, 35487-0290, USA; Department of Computer Science, The University of Alabama, Tuscaloosa, 35487-0290, USA; Department of Computer Science, The University of Alabama, Tuscaloosa, 35487-0290, USA",2013 21st International Conference on Program Comprehension (ICPC),,2013,,,13,22,"During software evolution a developer must investigate source code to locate then understand the entities that must be modified to complete a change task. To help developers in this task, Haiduc et al. proposed text summarization based approaches to the automatic generation of class and method summaries, and via a study of four developers, they evaluated source code summaries generated using their techniques. In this paper we propose a new topic modeling based approach to source code summarization, and via a study of 14 developers, we evaluate source code summaries generated using the proposed technique. Our study partially replicates the original study by Haiduc et al. in that it uses the objects, the instruments, and a subset of the summaries from the original study, but it also expands the original study in that it includes more subjects and new summaries. The results of our study both support the findings of the original and provide new insights into the processes and criteria that developers use to evaluate source code summaries. Based on our results, we suggest future directions for research on source code summarization.",1092-8138,978-1-4673-3092,10.1109/ICPC.2013.6613829,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613829,Program comprehension;text summarization;topic modeling;source code summarization;replication study,Vectors;Large scale integration;Indexing;Software;Semantics;Matrix decomposition;Probability distribution,reverse engineering;software maintenance;text analysis,source code summarization technique evaluation;replication;software evolution;software development;source code investigation;text summarization based approach;automatic class summary generation;method summary generation;topic modeling based approach,,26,24,,,,,IEEE,IEEE Conferences
Multiscale visual comparison of execution traces,J. Trümper; J. Döllner; A. Telea,"Hasso Plattner Institute, University of Potsdam, Germany; Hasso Plattner Institute, University of Potsdam, Germany; Johann Bernoulli Institute, University of Groningen, The Netherlands",2013 21st International Conference on Program Comprehension (ICPC),,2013,,,53,62,"Understanding the execution of programs by means of program traces is a key strategy in software comprehension. An important task in this context is comparing two traces in order to find similarities and differences in terms of executed code, execution order, and execution duration. For large and complex program traces, this is a difficult task due to the cardinality of the trace data. In this paper, we propose a new visualization method based on icicle plots and edge bundles. We address visual scalability by several multiscale visualization metaphors, which help users navigating from the main differences between two traces to intermediate structural-difference levels, and, finally fine-grained function call levels. We show how our approach, implemented in a tool called TRACEDIFF, is applicable in several scenarios for trace difference comprehension on real-world trace datasets.",1092-8138,978-1-4673-3092,10.1109/ICPC.2013.6613833,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613833,Trace analysis;Software visualization;Program comprehension,Electron tubes;Visualization;Data visualization;Vegetation;Bars;Shape;Image edge detection,program diagnostics;program visualisation;reverse engineering,multiscale visual comparison;execution traces;program execution understanding;program traces;software comprehension;executed code;execution order;execution duration;icicle plots;edge bundles;visual scalability;multiscale visualization metaphors;intermediate structural-difference levels;fine-grained function call levels;TRACEDIFF;trace difference comprehension,,12,38,,,,,IEEE,IEEE Conferences
Users' Perception on the Use of MetricAttitude to Perform Source Code Comprehension Tasks: A Focus Group Study,R. Francese; M. Risi; G. Scanniello; G. Tortora,NA; NA; NA; NA,2017 21st International Conference Information Visualisation (IV),,2017,,,8,13,"MetricAttitude [18] is a visualization approach implemented in an environment that provides a mental picture of an object-oriented software by means of polymetric views of classes. In this paper, we describe a qualitative investigation we have conducted with a focus group involving developers aiming at evaluating their viewpoint on the relevance of the support MetricAttitude provides to perform comprehension tasks on source code. This investigation also allowed us to gather information on the developers' opinion on the MetricAttitude features and its software visualization metaphors. The discussion was animated and participants provided a number of useful suggestions for improving the visualization. The tool was considered very useful, while some usability problems have to be addressed. Specifically, the information provided has to be further filtered to easier software comprehension tasks.",2375-0138,978-1-5386-0831-9978-1-5386-0832,10.1109/iV.2017.26,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8107941,Polymetric Views;Software Visualization;Program Comprehension;Focus Group;User Study;Qualitative Evaluation,Software;Measurement;Visualization;Computer bugs;Tools;Concrete,ergonomics;human factors;object-oriented methods;object-oriented programming;program visualisation;source code (software),focus group study;visualization approach;mental picture;software visualization metaphors;users perception;MetricAttitude;source code comprehension tasks;object-oriented software;usability problems,,1,24,,,,,IEEE,IEEE Conferences
Creating Important Statement Type Comments in Autocomment: Automatic Comment Generation Framework,E. Yildiz; E. Ekin,"Huawei Turkey R&D Center Huawei, Istanbul, Turkey; Computer Engineering Department, Işik University, Istanbul, Turkey",2018 3rd International Conference on Computer Science and Engineering (UBMK),,2018,,,642,647,"This study explains important statement comments generated by Autocomment, which is an automatic comment generation framework described in [1]. To create the comments, the source code is not expected to be runnable, but to conform to the syntax rules of the Java programming language. Two types of comments are created: summary comments and important statement comments. How the important statements are extracted in a given Java source, how they are classified, how comments are generated for each type of important statement have been explained in this work.",,978-1-5386-7893-0978-1-5386-7892-3978-1-5386-7894,10.1109/UBMK.2018.8566660,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8566660,source code summarization;documentation generation;program comprehension,Java;Grammar;Syntactics;Tools;Natural languages;Arrays,Java;public domain software;question answering (information retrieval);software maintenance,automatic comment generation framework;summary comments;important statement type comments;Java source;Java programming language;syntax rules;source code,,,17,,,,,IEEE,IEEE Conferences
A lightweight visualization of interprocedural data-flow paths for source code reading,T. Ishio; S. Etsuda; K. Inoue,"Graduate School of Information Science and Technology, Osaka University, 1-5 Yamadaoka, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, 1-5 Yamadaoka, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, 1-5 Yamadaoka, Suita, Osaka, Japan",2012 20th IEEE International Conference on Program Comprehension (ICPC),,2012,,,37,46,"To understand the behavior of a program, developers must read source code fragments in various modules. For developers investigating data-flow paths among modules, a call graph is too abstract since it does not visualize how parameters of method calls are related to each other. On the other hand, a system dependence graph is too fine-grained to investigate interprocedural data-flow paths. In this research, we propose an intermediate-level of visualization; we visualize interprocedural data-flow paths among method parameters and fields with summarized intraprocedural data-flow paths. We have implemented our visualization as an Eclipse plug-in for Java. The tool comprises a lightweight data-flow analysis and an interactive graph viewer using fractal value to extract a small subgraph of data-flow related to variables specified by a developer. A case study has shown our visualization enabled developers to investigate more data-flow paths in a fixed time slot. In addition, we report our lightweight data-flow analysis can generate precise data-flow paths for 98% of Java methods.",1092-8138,978-1-4673-1216-5978-1-4673-1213-4978-1-4673-1215,10.1109/ICPC.2012.6240506,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240506,data-flow analysis;static analysis;software visualization;program comprehension,Visualization;Java;Approximation methods;Arrays;Control systems;Software;Data visualization,data flow analysis;data flow graphs;data visualisation;Java;reverse engineering;source coding,lightweight visualization;interprocedural data-flow paths;source code reading;program behavior understanding;source code fragments;call graph;system dependence graph;visualization intermediate-level;Eclipse plug-in;data-flow analysis;interactive graph viewer;fractal value;data-flow subgraph;Java methods,,2,23,,,,,IEEE,IEEE Conferences
Mining source code descriptions from developer communications,S. Panichella; J. Aponte; M. Di Penta; A. Marcus; G. Canfora,"Dept. of Engineering-RCOST, University of Sannio, Italy; Universidad Nacional de Colombia, Bogota, Colombia; Dept. of Engineering-RCOST, University of Sannio, Italy; Wayne State University, Detroit USA; Dept. of Engineering-RCOST, University of Sannio, Italy",2012 20th IEEE International Conference on Program Comprehension (ICPC),,2012,,,63,72,"Very often, source code lacks comments that adequately describe its behavior. In such situations developers need to infer knowledge from the source code itself or to search for source code descriptions in external artifacts. We argue that messages exchanged among contributors/developers, in the form of bug reports and emails, are a useful source of information to help understanding source code. However, such communications are unstructured and usually not explicitly meant to describe specific parts of the source code. Developers searching for code descriptions within communications face the challenge of filtering large amount of data to extract what pieces of information are important to them. We propose an approach to automatically extract method descriptions from communications in bug tracking systems and mailing lists. We have evaluated the approach on bug reports and mailing lists from two open source systems (Lucene and Eclipse). The results indicate that mailing lists and bug reports contain relevant descriptions of about 36% of the methods from Lucene and 7% from Eclipse, and that the proposed approach is able to extract such descriptions with a precision of up to 79% for Eclipse and 87% for Lucene. The extracted method descriptions can help developers in understanding the code and could also be used as a starting point for source code re-documentation.",1092-8138,978-1-4673-1216-5978-1-4673-1213-4978-1-4673-1215,10.1109/ICPC.2012.6240510,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240510,Code re-documentation;mining e-mails;program comprehension,Electronic mail;Data mining;Java;Syntactics;Context;Filtering;Educational institutions,data mining;program compilers;program debugging;source coding,mining source code descriptions;developer communications;external artifacts;bug reports;emails;information source;code descriptions;bug tracking systems;mailing lists;open source systems;source code redocumentation,,30,22,,,,,IEEE,IEEE Conferences
Measuring the Cognitive Load of Software Developers: A Systematic Mapping Study,L. Gonçales; K. Farias; B. da Silva; J. Fessler,"University of Vale do Rio dos Sinos, Brazil; University of Vale do Rio dos Sinos, Brazil; California Polytechnic State University, USA; California Polytechnic State University, USA",2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC),,2019,,,42,52,"Context: In recent years, several studies explored different facets of the developers' cognitive load while executing tasks related to software engineering. Researchers have proposed and assessed different ways to measure developers' cognitive load at work and some studies have evaluated the interplay between developers' cognitive load and other attributes such as productivity and software quality. Problem: However, the body of knowledge about developers' cognitive load measurement is still dispersed. That hinders the effective use of developers' cognitive load measurements by industry practitioners and makes it difficult for researchers to build new scientific knowledge upon existing results. Objective: This work aims to pinpoint gaps providing a classification and a thematic analysis of studies on the measurement of cognitive load in the context of software engineering. Method: We carried out a Systematic Mapping Study (SMS) based on well-established guidelines to investigate nine research questions. In total, 33 articles (out of 2,612) were selected from 11 search engines after a careful filtering process. Results: The main findings are that (1) 55% of the studies adopted electroencephalogram (EEG) technology for monitoring the cognitive load; (2) 51% of the studies applied machine-learning classification algorithms for predicting cognitive load; and (3) 48% of the studies measured cognitive load in the context of programming tasks. Moreover, a taxonomy was derived from the answers of research questions. Conclusion: This SMS highlighted that the precision of machine learning techniques is low for realistic scenarios, despite the combination of a set of features related to developers' cognitive load used on these techniques. Thus, this gap makes the effective integration of the measure of developers' cognitive load in industry still a relevant challenge.",2643-7171;2643-7147,978-1-7281-1519-1978-1-7281-1520,10.1109/ICPC.2019.00018,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813301,Cognitive Load;Software Engineering;Program Comprehension;Systematic Mapping Study,,,,,,76,,,,,IEEE,IEEE Conferences
On the Optimal Order of Reading Source Code Changes for Review,T. Baum; K. Schneider; A. Bacchelli,NA; NA; NA,2017 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2017,,,329,340,"Change-based code review, e.g., in the form of pull requests, is the dominant style of code review in practice. An important option to improve review's efficiency is cognitive support for the reviewer. Nevertheless, review tools present the change parts under review sorted in alphabetical order of file path, thus leaving the effort of understanding the construction, connections, and logic of the changes on the reviewer. This leads to the question: How should a code review tool order the parts of a code change to best support the reviewer? We answer this question with a middle-range theory, which we generated inductively in a mixed methods study, based on interviews, an online survey, and existing findings from related areas. Our results indicate that an optimal order is mainly an optimal grouping of the change parts by relatedness. We present our findings as a collection of principles and formalize them as a partial order relation among review orders.",,978-1-5386-0992-7978-1-5386-0993,10.1109/ICSME.2017.28,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8094433,Change-based code review;Modern code review;Pull-based development;Cognitive support review tools;Program comprehension,Interviews;Tools;Software;Navigation;Industries;Software engineering,program diagnostics;public domain software;software quality;source code (software),optimal order;reviewer;review tools;change parts;alphabetical order;partial order relation;review orders;optimal grouping;middle-range theory;code review tool;review efficiency;change-based code review;source code change reading,,2,75,,,,,IEEE,IEEE Conferences
Software Clustering Using Dynamic Analysis and Static Dependencies,C. Patel; A. Hamou-Lhadj; J. Rilling,NA; NA; NA,2009 13th European Conference on Software Maintenance and Reengineering,,2009,,,27,36,"Decomposing a software system into smaller, more manageable clusters is a common approach to support the comprehension of large systems. In recent years, researchers have focused on clustering techniques to perform such architectural decomposition, with the most predominant clustering techniques relying on the static analysis of source code. We argue that these static structural relationships are not sufficient for software clustering due to the increased complexity and behavioral aspects found in software systems. In this paper, we present a novel software clustering approach that combines dynamic and static analysis to identify component clusters. We introduce a two-phase clustering technique that combines software features to build a core skeleton decomposition with structural information to further refine these clusters. A case study is presented to evaluate the applicability and effectiveness of our approach.",1534-5351,978-1-4244-3755-9978-0-7695-3589,10.1109/CSMR.2009.62,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812736,Software clustering;architecture recovery;program comprehension;software maintenance,Software maintenance;Skeleton;Data mining;Software systems;Computer science;Software engineering;Conference management;Engineering management;Performance analysis;Computer architecture,pattern clustering;program diagnostics;software architecture;software maintenance,software clustering techniques;dynamic analysis;static dependencies;software system;architectural decomposition;static analysis;core skeleton decomposition;software maintenance,,19,30,,,,,IEEE,IEEE Conferences
On the Use of Automated Text Summarization Techniques for Summarizing Source Code,S. Haiduc; J. Aponte; L. Moreno; A. Marcus,NA; NA; NA; NA,2010 17th Working Conference on Reverse Engineering,,2010,,,35,44,"During maintenance developers cannot read the entire code of large systems. They need a way to get a quick understanding of source code entities (such as, classes, methods, packages, etc.), so they can efficiently identify and then focus on the ones related to their task at hand. Sometimes reading just a method header or a class name does not tell enough about its purpose and meaning, while reading the entire implementation takes too long. We study a solution which mitigates the two approaches, i.e., short and accurate textual descriptions that illustrate the software entities without having to read the details of the implementation. We create such descriptions using techniques from automatic text summarization. The paper presents a study that investigates the suitability of various such techniques for generating source code summaries. The results indicate that a combination of text summarization techniques is most appropriate for source code summarization and that developers generally agree with the summaries produced.",2375-5369;1095-1350,978-1-4244-8911,10.1109/WCRE.2010.13,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5645482,text summarization;program comprehension,Lead;Large scale integration;Semantics;Software systems;Computer science;Correlation,software maintenance,automated text summarization technique;textual description;software entity;source code summarization,,76,28,,,,,IEEE,IEEE Conferences
CrowdSummarizer: Automated Generation of Code Summaries for Java Programs through Crowdsourcing,S. Badihi; A. Heydarnoori,Sharif University of Technology; Sharif University of Technology,IEEE Software,,2017,34,2,71,80,"To perform software maintenance, developers must have a relatively good understanding of the program's source code, which is often written by other developers. Code summaries, which describe a program's entities (for example, its methods), help developers better comprehend code more quickly. However, generating code summaries can be challenging. To mitigate this problem, CrowdSummarizer exploits crowdsourcing, gamification, and natural-language processing to automatically generate high-level summaries of Java program methods. Researchers have implemented it as an Eclipse plug-in together with a Web-based code summarization game that can be played by the crowd. Two empirical studies determined that CrowdSummarizer generates quality results. This article is part of a special issue on Crowdsourcing for Software Engineering.",0740-7459;1937-4194,,10.1109/MS.2017.45,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888409,CrowdSummarizer;crowdsourcing;program comprehension;source code summarization;gamification;software engineering;software development,Software reliability;Crowdsourcing;Java;Software maintenance;Software engineering;Software engineering;Software measurement,computer games;crowdsourcing;Java;natural language processing;software maintenance;source code (software),Eclipse plug-in;software engineering;Web-based code summarization game;high-level summaries;Java program;gamification;natural-language processing;program source code;software maintenance;code summary automated generation;CrowdSummarizer,,2,14,,,,,IEEE,IEEE Magazines
Extracting Meaning from Abbreviated Identifiers,D. Lawrie; H. Feild; D. Binkley,"Loyola College, USA; Loyola College, USA; Loyola College, USA",Seventh IEEE International Working Conference on Source Code Analysis and Manipulation (SCAM 2007),,2007,,,213,222,"Informative identifiers are made up of full (natural language) words and (meaningful) abbreviations. Readers of programs typically have little trouble understanding the purpose of identifiers composed of full words. In addition, those familiar with the code can (most often) determine the meaning of abbreviations used in identifiers. However, when faced with unfamiliar code, abbreviations often carry little useful information. Furthermore, tools that focus on the natural language used in the code have a hard time in the presence of abbreviations. One approach to providing meaning to programmers and tools is to translate (expand) abbreviations into full words. This paper presents a methodology for expanding identifiers and evaluates the process on a code based of just over 35 million lines of code. For example, using phrase extraction, <b>fs_exists</b> is expanded to <b>file_status_exists</b> illustrating how the expansion process can facilitate comprehension. On average, 16 percent of the identifiers in a program are expanded. Finally, as an example application, the approach is used to improve the syntactic identification of violations to Deissenbock and Pizka's rules for concise and consistent identifier construction.",,0-7695-2880-5978-0-7695-2880,10.1109/SCAM.2007.17,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362915,Software Quality;Program Identifiers;Program Comprehension,Natural languages;Software quality;Dictionaries;Information retrieval;Software engineering;Libraries;Documentation;Educational institutions;USA Councils;Programming profession,reverse engineering;software quality,abbreviated program identifier meaning extraction;program understandability;program comprehension;syntactic violation identification;software quality,,24,27,,,,,IEEE,IEEE Conferences
Automatically detecting the quality of the query and its implications in IR-based concept location,S. Haiduc,"Department of Computer Science, Wayne State University, Detroit, MI, USA",2011 26th IEEE/ACM International Conference on Automated Software Engineering (ASE 2011),,2011,,,637,640,"Concept location is an essential task during software maintenance and in particular program comprehension activities. One of the approaches to this task is based on leveraging the lexical information found in the source code by means of Information Retrieval techniques. All IR-based approaches to concept location are highly dependent on the queries written by the users. An IR approach, even though good on average, might fail when the input query is poor. Currently there is no way to tell when a query leads to poor results for IR-based concept location, unless a considerable effort is put into analyzing the results after the fact. We propose an approach based on recent advances in the field of IR research, which aims at automatically determining the difficulty a query poses to an IR-based concept location technique. We plan to evaluate several models and relate them to IR performance metrics.",1938-4300,978-1-4577-1639-3978-1-4577-1638,10.1109/ASE.2011.6100144,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6100144,program comprehension;concept location;search;source code;information retrieval;query,Prediction algorithms;Correlation;Estimation;Conferences;Measurement;Search engines,query processing;software maintenance,information retrieval-based concept location;software maintenance;program comprehension activities;lexical information;source code;query quality,,5,16,,,,,IEEE,IEEE Conferences
Software Clustering: Unifying Syntactic and Semantic Features,J. Misra; K. M. Annervaz; V. Kaulgud; S. Sengupta; G. Titus,NA; NA; NA; NA; NA,2012 19th Working Conference on Reverse Engineering,,2012,,,113,122,"Software clustering is an important technique for extracting high level component architecture from the underlying source code. One of the limitations of the existing approaches is that most of the proposed techniques use only similar types of features for estimating distance between source code elements. Therefore, in cases, where the selected features are poorly present in the source code, these techniques may not produce good quality results in absence of adequate inputs to work on. In this paper we propose an approach to overcome this limitation. Proposed approach uses a combination of multiple types of features together and applies automated weighing on the extracted features to enhance their information quality and to reduce noise. We define a way to estimate distance between code elements in terms of combination of multiple types of features. Weighted graph partitioning with a multi-objective global modularity criterion is used to select the clusters as architectural components. We describe methods for automated labeling of the extracted components and for generating inter-component interactions. We further discuss how the suggested approach extends to clustering at multiple hierarchical levels, to application portfolios, and even for improving precision for the feature location problem.",2375-5369;1095-1350,978-0-7695-4891-3978-1-4673-4536,10.1109/WCRE.2012.21,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385107,software clustering;architectural recovery;component discovery;program comprehension;lexical analysis;vector space model;latent semantic indexing,Reverse engineering,feature extraction;graph theory;object-oriented programming;pattern clustering;program diagnostics;software architecture,software clustering;syntactic features;semantic features;high level component architecture extraction;distance estimation;source code elements;feature extraction;information quality enhancement;noise reduction;weighted graph partitioning;multiobjective global modularity criterion;cluster selection;automated component labeling;inter-component interaction generation;multiple hierarchical levels;application portfolios;feature location problem,,9,28,,,,,IEEE,IEEE Conferences
The effectiveness of source code obfuscation: An experimental assessment,M. Ceccato; M. Di Penta; J. Nagra; P. Falcarin; F. Ricca; M. Torchiano; P. Tonella,"Fondazione Bruno Kessler-IRST, Trento, Italy; University of Sannio, Dept. of Engineering, Benevento, Italy; University of Trento, Italy; Politecnico di Torino, Italy; Unità CINI at DISI, Genova, Italy; Politecnico di Torino, Italy; Fondazione Bruno Kessler-IRST, Trento, Italy",2009 IEEE 17th International Conference on Program Comprehension,,2009,,,178,187,"Source code obfuscation is a protection mechanism widely used to limit the possibility of malicious reverse engineering or attack activities on a software system. Although several code obfuscation techniques and tools are available, little knowledge is available about the capability of obfuscation to reduce attackers' efficiency, and the contexts in which such an efficiency may vary. This paper reports the outcome of two controlled experiments meant to measure the ability of subjects to understand and modify decompiled, obfuscated Java code, compared to decompiled, clear code. Results quantify to what extent code obfuscation is able to make attacks more difficult to be performed, and reveal that obfuscation can mitigate the effect of factors that can alter the likelihood of a successful attack, such as the attackers' skill and experience, or the intrinsic characteristics of the system under attack.",1092-8138,978-1-4244-3998-0978-1-4244-3997,10.1109/ICPC.2009.5090041,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090041,Empirical studies;Software Obfuscation;Program comprehension,Protection;Reverse engineering;Application software;Software systems;Java;Performance analysis;Data structures;Encoding;Automatic control;Software measurement,Java;security of data,source code obfuscation techniques;protection mechanism;software system;Java code;software protection,,22,13,,,,,IEEE,IEEE Conferences
Feature Location Using Data Mining on Existing Test-Cases,C. Ziftci; I. Krüger,NA; NA,2012 19th Working Conference on Reverse Engineering,,2012,,,155,164,"Feature location is the mapping of features onto static artifacts such as source code and configuration files. Recent effective feature location methods use dynamic-analysis and scenarios, i.e. executable use-cases that represent features in source code. Almost all of these techniques require that a distinct scenario is created for every feature, which puts a great burden on developers due to the inherent manual work that needs to be carried out. First, since scenarios are typically created and exercised manually, the act of locating features is not easily repeatable as software evolves. Second, there may be dependencies between features, which will be reflected on the collected execution traces during scenario execution. For existing feature location methods to perform well, developers typically need to mark the execution traces manually to specify which parts of it exactly represent each feature. In this work, we free developers of the manual process of creating scenarios by using association rule learning on a set of labeled test-cases, i.e. test-cases labeled with the features they exercise in the existing test-suite of the system, to locate features in source code. We also provide an evaluation of our method on three case studies and compare it with a well-known feature location technique that uses probabilistic ranking. Our method achieves results within 83-97% of the probabilistic ranking method on the case studies without any need to create scenarios as in the existing dynamic-analysis based feature location techniques.",2375-5369;1095-1350,978-0-7695-4891-3978-1-4673-4536,10.1109/WCRE.2012.25,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385111,feature location;program features;data mining;program comprehension;software maintenance;reverse engineering,Association rules;Graphical user interfaces;Software;Reliability;Manuals;Servers,data mining;probability;software maintenance;system monitoring,feature location;data mining;test-cases;feature mapping;static artifact;source code;configuration file;dynamic analysis;software evolution;association rule learning;probabilistic ranking,,1,27,,,,,IEEE,IEEE Conferences
Trace-Guided Synthesis of Reactive Behavior Models of Programmable Logic Controllers,R. Schatz; H. Prähofer,NA; NA,2013 39th Euromicro Conference on Software Engineering and Advanced Applications,,2013,,,260,267,"Programmable Logic Controller (PLC) programs are programs that control physical devices by continuously reading sensor inputs and writing actuator outputs. A main challenge in designing and comprehending PLC programs is the emergent behavior which arises from the complex interaction between the dynamic behavior of the program and the physical device. In this paper we present an approach for building a formal model characterizing the reactive interaction behavior of a PLC program with the physical device it controls. Based on program recordings, first a model of the transition behavior of the program run is built. Then, using symbolic execution and a formal abstraction process, we generate a specification of the input/output behavior as a state model with transition labelings in terms of conditions on input values. We present the main ideas of the approach, a formal model for representing the reactive behavior, the abstraction process, and two application scenarios.",1089-6503;2376-9505,978-0-7695-5091,10.1109/SEAA.2013.37,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6619520,program comprehension;reverse engineering;symbolic execution;dynamic analysis;test coverage;programmable logic controllers,Reverse engineering;Symbolic execution;Programmable logic controllers;Optimization;Actuators,control engineering computing;program verification;programmable controllers;sensor fusion;symbol manipulation,trace-guided synthesis;reactive behavior models;programmable logic controller programs;physical device control;actuator output writing;sensor input reading;program dynamic behavior;formal model;PLC program reactive interaction behavior;program recordings;symbolic execution;formal abstraction process;input-output behavior;state model;transition labelings;abstraction process,,2,18,,,,,IEEE,IEEE Conferences
Monitoring user interactions for supporting failure reproduction,T. Roehm; N. Gurbanova; B. Bruegge; C. Joubert; W. Maalej,"Technische Universität München, Munich, Germany; Technische Universität München, Munich, Germany; Technische Universität München, Munich, Germany; Prodevelop, Valencia, Spain; University of Hamburg, Germany",2013 21st International Conference on Program Comprehension (ICPC),,2013,,,73,82,"The first step to comprehend and fix a software bug is usually to reproduce the corresponding failure. Reproducing a failure requires information about steps to reproduce, i.e. the steps necessary to make a failure occur in the development environment. In case of an application with a user interface, steps to reproduce consist of the interactions between a user and the application that precede the failure. Unfortunately, bug reports typically lack this information. Users are either unaware of its importance to developers, are unable to describe it, or simply do not have time to report it. In this paper, we present a simple but effective and resource efficient approach to monitor interactions between users and their applications selectively at a high level of abstraction, e.g. editing operations and commands. This minimizes the monitoring overhead and enables developers to analyze user interaction traces. We map monitored interactions to a taxonomy of user interactions to help developers comprehend user behavior. Further, we present the Timeline Tool that visualizes monitored interaction traces preceding failures. To evaluate our approach we conducted an experiment with 12 participants and asked them to reproduce bug reports from an open-source project. We found that developers are able to derive steps to reproduce from monitored interaction traces. In particular, inexperienced developers profit from the Timeline Tool, as they are able to reproduce failures that they cannot reproduce without it. The monitoring overhead is rather small (approx. 5% CPU and 2-5% memory) and users feel it does not influence their work in a negative way.",1092-8138,978-1-4673-3092,10.1109/ICPC.2013.6613835,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613835,Bug fixing;Failure reproduction;Steps to reproduce;User monitoring;Application instrumentation;Trace analysis;Program comprehension;Software maintenance;Software evolution,Monitoring;Sensors;Taxonomy;Unified modeling language;Visualization;Servers;Software,data visualisation;program debugging;public domain software;software fault tolerance;user interfaces,user interactions monitoring;failure reproduction;software bug;development environment;user interface;resource efficient approach;abstraction level;editing operations;editing commands;timeline tool;monitored interaction traces;open-source project,,9,23,,,,,IEEE,IEEE Conferences
Evaluating Software Inspection Cognition Levels Using Bloom's Taxonomy,D. A. McMeekin; B. R. von Konsky; E. Chang; D. J. A. Cooper,NA; NA; NA; NA,2009 22nd Conference on Software Engineering Education and Training,,2009,,,232,239,"This paper reports on results from a pilot study that used Bloompsilas taxonomy to observe cognition levels during software inspections conducted by undergraduate computer science and software engineering students. Cognition levels associated with three different code inspection techniques were investigated. These were the ad hoc, abstraction driven, and checklist-based reading strategies. Higher cognition levels were observed when using inspection techniques that utilise a more structured reading process. This result highlights the importance of introducing novice programmers to structured code reading strategies. Findings suggest that teaching different software inspection techniques throughout software courses, beginning with structured techniques, is an excellent way to build a studentpsilas critical software reading and analysis skills.",1093-0175;2377-570X,978-1-4244-3431-2978-0-7695-3539,10.1109/CSEET.2009.15,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812703,Bloom's taxonoomy;reading techniques;code inspections;program comprehension;cognition levels,Inspection;Cognition;Taxonomy;Writing;Open source software;Software engineering;Software maintenance;Application software;Natural languages;Ecosystems,computer aided instruction;computer science education;inference mechanisms;inspection;taxation,software inspection cognition levels;Bloom taxonomy;undergraduate computer science;software engineering students;code inspection techniques;checklist-based reading strategy;structured code reading strategies,,7,16,,,,,IEEE,IEEE Conferences
Exploring Theory of Cognition for General Theory of Software Engineering,P. Johnson; M. Ekstedt,NA; NA,2015 IEEE/ACM 4th SEMAT Workshop on a General Theory of Software Engineering,,2015,,,15,24,"In recent years, there has been significant interest in general theories of software engineering. In this article, we explore the utility of a theory of cognition, ACT-R, as a component of such a general theory. The ACT-R theory was instantiated to predict the effort of programming language comprehension for two cases: (i) a C program, and (ii) the corresponding Assembly program. An experiment was then conducted to generate empirical data on the two comprehension tasks. The theoretical predictions were compared to the empirical results. The theoretical model predicted that the effort of understanding the considered program in C is 37% of the effort of understanding a comparable program written in Assembly. The experiment generated 33% as the corresponding percentage number. The concordance between theoretical model and experimental data was surprisingly high, encouraging further investigations into the utility of cognitive theories in software engineering.",,978-1-4673-7052,10.1109/GTSE.2015.9,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7169390,ACT-R;Programming Language;General Theory of Software Engineering;Program Comprehension,Production;Computer languages;Assembly;Software engineering;Cognition;Computers;Predictive models,assembly language;C language;cognitive systems;program assemblers,cognition theory;software engineering;ACT-R;programming language comprehension;C program;Assembly program,,2,23,,,,,IEEE,IEEE Conferences
A Conceptual Framework for Application Comprehension,V. N. Gudivada; J. Nandigam; J. Bhuyan,NA; NA; NA,Fifth International Conference on Information Technology: New Generations (itng 2008),,2008,,,483,488,"The scope and purpose of application comprehension is much broader than that of program comprehension. Application comprehension can be viewed as a spectrum spanning the gamut comprising code-level understanding at one end (low level) and understanding the architecture of interorganizational systems at the other end (high level). The nature and the depth of knowledge sought through application comprehension is directly related to the purpose at hand. In this paper, we propose a unified conceptual framework for application comprehension. The framework is influenced by Bloom's taxonomy. The proposed framework considers several aspects of application comprehension and draws upon our experience in developing large-scale, multi-tier distributed applications for brokerage and financial services. We discuss how the proposed conceptual framework can be implemented by leveraging the sophisticated tools that are available as open-source software. We conclude the paper by indicating how the proposed framework can be used to learn software engineering principles, tools, and practices in education and training contexts.",,978-0-7695-3099-40-7695-3099,10.1109/ITNG.2008.1,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4492526,Application comprehension;Program comprehension;Bloom's taxonomy;Open Source;Eclipse.,Application software;Computer architecture;Taxonomy;Software systems;Computer science;Open source software;Software engineering;Service oriented architecture;Java;Information technology,data flow analysis;financial data processing;public domain software,application comprehension;spectrum spanning;code-level understanding;interorganizational systems;Bloom taxonomy;large-scale distributed applications;multitier distributed applications;brokerage;financial services;open-source software;software engineering,,,20,,,,,IEEE,IEEE Conferences
Heuristic-based part-of-speech tagging of source code identifiers and comments,R. S. Alsuhaibani; C. D. Newman; M. L. Collard; J. I. Maletic,"Computer Science Kent State University Kent, OH, USA; Computer Science Kent State University Kent, OH, USA; Computer Science The University of Akron Akron, Ohio, USA; Computer Science Kent State University Kent, OH, USA",2015 IEEE 5th Workshop on Mining Unstructured Data (MUD),,2015,,,1,6,"An approach for using heuristics and static program analysis information to markup part-of-speech for program identifiers is presented. It does not use a natural language part-ofspeech tagger for identifiers within the code. A set of heuristics is defined akin to natural language usage of identifiers usage in code. Additionally, method stereotype information, which is automatically derived, is used in the tagging process. The approach is built using the srcML infrastructure and adds part-of-speech information directly into the srcML markup.",,978-1-4673-7013-4978-1-4673-7012,10.1109/MUD.2015.7327960,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7327960,Natural Language Processing;part-of-speech tagging;identifier analysis;program comprehension,Speech;Object recognition;Tagging;Natural languages;Conferences;Software;Computational linguistics,natural language processing;program diagnostics;source code (software),heuristic-based part-of-speech tagging;source code identifier;source code comment;static program analysis information;heuristics program analysis information;stereotype information;srcML markup infrastructure,,7,36,,,,,IEEE,IEEE Conferences
Enhancing the Analysis of Large Multimedia Applications Execution Traces with FrameMiner,C. K. Kengne; L. C. Fopa; N. Ibrahim; A. Termier; M. C. Rousset; T. Washio,NA; NA; NA; NA; NA; NA,2012 IEEE 12th International Conference on Data Mining Workshops,,2012,,,595,602,"The analysis of multimedia application traces can reveal important information to enhance program comprehension. However traces can be very large, which hinders their effective exploitation. In this paper, we study the problem of finding a k-golden set of blocks that best characterize data. Sequential pattern mining can help to automatically discover the blocks, and we called k-golden set, a set of k blocks that maximally covers the trace. These kind of blocks can simplify the exploration of large traces by allowing programmers to see an abstraction instead of low-level events. We propose an approach for mining golden blocks and finding coverage of frames. The experiments carried out on video and audio application decoding show very promising results.",2375-9232;2375-9259,978-1-4673-5164-5978-0-7695-4925,10.1109/ICDMW.2012.95,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6406406,Data mining;Trace Analysis;Program Comprehension;Software Engineering,Decoding;Approximation algorithms;Multimedia communication;Approximation methods;Streaming media;Data mining;Greedy algorithms,data mining;multimedia computing,large multimedia applications execution traces;FrameMiner;sequential pattern mining;k-golden set;low-level events;golden blocks mining;video application decoding;audio application decoding,,1,23,,,,,IEEE,IEEE Conferences
An Analysis of Machine Learning Algorithms for Condensing Reverse Engineered Class Diagrams,M. H. Osman; M. R. V. Chaudron; P. v. d. Putten,NA; NA; NA,2013 IEEE International Conference on Software Maintenance,,2013,,,140,149,"There is a range of techniques available to reverse engineer software designs from source code. However, these approaches generate highly detailed representations. The condensing of reverse engineered representations into more high-level design information would enhance the understandability of reverse engineered diagrams. This paper describes an automated approach for condensing reverse engineered diagrams into diagrams that look as if they are constructed as forward designed UML models. To this end, we propose a machine learning approach. The training set of this approach consists of a set of forward designed UML class diagrams and reverse engineered class diagrams (for the same system). Based on this training set, the method 'learns' to select the key classes for inclusion in the class diagrams. In this paper, we study a set of nine classification algorithms from the machine learning community and evaluate which algorithms perform best for predicting the key classes in a class diagram.",1063-6773,978-0-7695-4981,10.1109/ICSM.2013.25,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6676885,Software Engineering;UML;Reverse Engineering;Machine Learning;Program Comprehension,Prediction algorithms;Algorithm design and analysis;Unified modeling language;Measurement;Machine learning algorithms;Software;Couplings,learning (artificial intelligence);software maintenance;systems re-engineering;Unified Modeling Language,machine learning algorithms;reverse engineered class diagrams;reverse engineer software designs;source code;UML models;forward designed UML class diagrams;classification algorithms;key classes prediction;program comprehension;software engineering;development phase;maintenance phase,,13,33,,,,,IEEE,IEEE Conferences
A Feature Model of Framework Applications,I. Kume; M. Nakamura; N. Nitta; E. Shibayama,NA; NA; NA; NA,"2013 14th ACIS International Conference on Software Engineering, Artificial Intelligence, Networking and Parallel/Distributed Computing",,2013,,,511,516,"Learning how to use application frameworks effectively becomes important in their widespread use in software development. Learning frameworks is often difficult because of lack of their documentation and their complexity. In order to help framework learning, we propose a behavioral model, called feature component model, which abstracts internal behaviors of framework applications in terms of their behavioral characteristics such as inversion of controls. We apply our behavioral model to an example misuse of a practical framework developed by a third party in order to show its practical usefulness.",,978-0-7695-5005,10.1109/SNPD.2013.14,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6598512,application frameworks;framework learning;feature model;feature interactions;program comprehension,Unified modeling language;Runtime;Java;Educational institutions;Libraries;Arrays;Electronic mail,application program interfaces;software maintenance,framework application feature model;application framework learning;software development;behavioral model;feature component model;internal behavioral characteristics;inversion-of-control method;dependency abstraction;software maintenance,,,19,,,,,IEEE,IEEE Conferences
TASSAL: Autofolding for Source Code Summarization,J. Fowkes; P. Chanthirasegaran; R. Ranca; M. Allamanis; M. Lapata; C. Sutton,NA; NA; NA; NA; NA; NA,2016 IEEE/ACM 38th International Conference on Software Engineering Companion (ICSE-C),,2016,,,649,652,"We present a novel tool, TASSAL, that automatically creates a summary of each source file in a project by folding its least salient code regions. The intended use-case for our tool is the first-look problem: to help developers who are unfamiliar with a new codebase and are attempting to understand it. TASSAL is intended to aid developers in this task by folding away less informative regions of code and allowing them to focus their efforts on the most informative ones. While modern code editors do provide \emph{code folding} to selectively hide blocks of code, it is impractical to use as folding decisions must be made manually or based on simple rules. We find through a case study that TASSAL is strongly preferred by experienced developers over simple folding baselines, demonstrating its usefulness. In short, we strongly believe TASSAL can aid program comprehension by turning code folding into a usable and valuable tool. A video highlighting the main features of TASSAL can be found at https://youtu.be/_yu7JZgiBA4.",,978-1-4503-4205-6978-1-5090-2245,,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7883362,code summarization;code folding;program comprehension;topic modelling,Java;Standards;Turning;Optimization;Programming;Conferences;Software engineering,software tools;source code (software),code folding turning;program comprehension;codebase;first-look problem;least salient code regions;source file summary;source code summarization;autofolding;TASSAL tool,,,21,,,,,IEEE,IEEE Conferences
Structural information based term weighting in text retrieval for feature location,B. Bassett; N. A. Kraft,"Department of Computer Science, The University of Alabama, Tuscaloosa, 35487-0290, USA; Department of Computer Science, The University of Alabama, Tuscaloosa, 35487-0290, USA",2013 21st International Conference on Program Comprehension (ICPC),,2013,,,133,141,"Many recent feature location techniques (FLTs) apply text retrieval (TR) techniques to corpora built from text embedded in source code. Term weighting is a standard preprocessing step in TR and is used to adjust the importance of a term within a document or corpus. Common term weighting schemes such as tf-idf may not be optimal for use with source code, because they originate from a natural language context and were designed for use with unstructured documents. In this paper we propose a new approach to term weighting in which term weights are assigned using the structural information from the source code. We then evaluate the proposed approach by conducting an empirical study of a TR-based FLT. In all, we study over 400 bugs and features from five open source Java systems and find that structural term weighting can cause a statistically significant improvement in the accuracy of the FLT.",1092-8138,978-1-4673-3092,10.1109/ICPC.2013.6613841,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613841,Program comprehension;feature location;static analysis;text retrieval;latent Dirichlet allocation,Accuracy;Large scale integration;Indexing;Probability distribution;Java;Benchmark testing;Computational modeling,feature extraction;information retrieval;Java;natural language processing;public domain software;source coding;text analysis,structural term weighting;open source Java system;TR-based FLT;term weight assignment;unstructured document;natural language;term weighting scheme;corpus;text embedding;source code;feature location technique;text retrieval,,22,30,,,,,IEEE,IEEE Conferences
Package patterns for visual architecture recovery,M. Lungu; M. Lanza; T. Girba,"Fac. of Informatics, Lugano Univ., Switzerland; Fac. of Informatics, Lugano Univ., Switzerland; NA",Conference on Software Maintenance and Reengineering (CSMR'06),,2006,,,10 pp.,196,"Recovering the architecture is the first step towards reengineering a software system. Many reverse engineering tools use top-down exploration as a way of providing a visual and interactive process for architecture recovery. During the exploration process, the user navigates through various views on the system by choosing from several exploration operations. Although some sequences of these operations lead to views which, from the architectural point of view, are mode relevant than others, current tools do not provide a way of predicting which exploration paths are worth taking and which are not. In this article, we propose a set of package patterns which are used for augmenting the exploration process with information about the worthiness of the various exploration paths. The patterns are defined based on the internal package structure and on the relationships between the package and the other packages in the system. To validate our approach, we verify the relevance of the proposed patterns for real-world systems by analyzing their frequency of occurrence in six open-source software projects",1534-5351,0-7695-2536,10.1109/CSMR.2006.39,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1602370,Software exploration;architecture recovery;reverse engineering;program comprehension;visualization,Packaging;Computer architecture;Open source software;Software systems;Reverse engineering;Navigation;Pattern analysis;Frequency;Visualization;Informatics,object-oriented programming;program visualisation;reverse engineering;software architecture;software maintenance;systems re-engineering,package patterns;visual architecture recovery;software system reengineering;reverse engineering tools;top-down exploration;visual process;interactive process;internal package structure;open-source software projects;software exploration;program comprehension;program visualization,,15,34,,,,,IEEE,IEEE Conferences
A Framework for Examining Topical Locality in Object-Oriented Software,N. Niu; J. Savolainen; T. Bhowmik; A. Mahmoud; S. Reddivari,NA; NA; NA; NA; NA,2012 IEEE 36th Annual Computer Software and Applications Conference,,2012,,,219,224,"The software entities of an object-oriented system should be organized in such a way that ""spatial relatedness entails semantic relatedness"". We refer this as the tenet of ""topical locality"" and argue that it is fundamental for the code base to be navigable. In this paper, we propose a novel experimental framework to test this key tenet and use large-scale open-source projects to assess three relationships. In particular, we find that: (1) class name along with header comments conveys class body's topic; (2) a code line is indicative of its surroundings; and (3) a contiguous code fragment may serve as a snapshot of the entire class. Our work not only shows the foundations necessary for the success of many code navigation approaches, but also opens avenues for further tool enhancements.",0730-3157;0730-3157;0730-3157,978-1-4673-1990-4978-0-7695-4736,10.1109/COMPSAC.2012.32,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6340146,program comprehension;code navigation;topical locality;information seeking;experimentation,Software;Semantics;Navigation;Indexing;Software engineering;Correlation;Visualization,object-oriented programming;public domain software;reverse engineering;software maintenance,topical locality;object-oriented software;software entity;object-oriented system;spatial relatedness;semantic relatedness;navigable code base;large-scale open-source project;class name;header comment;class body topic;code line;contiguous code fragment;code navigation;tool enhancement;program comprehension;software maintenance,,5,21,,,,,IEEE,IEEE Conferences
Autofolding for Source Code Summarization,J. Fowkes; P. Chanthirasegaran; R. Ranca; M. Allamanis; M. Lapata; C. Sutton,"School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK; Tractable, Oval Office, London, UK; School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK",IEEE Transactions on Software Engineering,,2017,43,12,1095,1109,"Developers spend much of their time reading and browsing source code, raising new opportunities for summarization methods. Indeed, modern code editors provide code folding, which allows one to selectively hide blocks of code. However this is impractical to use as folding decisions must be made manually or based on simple rules. We introduce the autofolding problem, which is to automatically create a code summary by folding less informative code regions. We present a novel solution by formulating the problem as a sequence of AST folding decisions, leveraging a scoped topic model for code tokens. On an annotated set of popular open source projects, we show that our summarizer outperforms simpler baselines, yielding a 28 percent error reduction. Furthermore, we find through a case study that our summarizer is strongly preferred by experienced developers. More broadly, we hope this work will aid program comprehension by turning code folding into a usable and valuable tool.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2017.2664836,Engineering and Physical Sciences Research Council; ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7843666,"Source code summarization, program comprehension, topic modelling",Software development;Natural languages;Source coding;Feature extraction;Complexity theory,public domain software;source code (software),source code summarization;modern code editors;code folding;autofolding problem;informative code regions;AST folding decisions;code tokens;open source projects,,3,62,Traditional,,,,IEEE,IEEE Journals
Towards a Taxonomy of Programming-Related Difficulties during Maintenance,A. Yamashita; L. Moonen,NA; NA,2013 IEEE International Conference on Software Maintenance,,2013,,,424,427,"Empirical studies that investigate the relationship between source code characteristics and maintenance outcomes rarely use causal models to explain the relations between the code characteristics and the outcomes. We conjecture that the lack of a comprehensive catalogue of programming-related difficulties and their effects on different maintenance outcomes is one of the reasons behind this. This paper takes the first step in addressing this situation based on empirical evidence collected in a longitudinal maintenance study on four systems. Professional developers were hired to implement a number of changes in each of the systems. These activities were observed in detail over a period of 7 weeks, during which we recorded on a daily basis what specific problems they faced. The collected data was transcribed and analyzed using open and axial coding. Based on an analysis of these results, we propose a preliminary taxonomy to describe the programming-related difficulties that developers face during maintenance. Our intention is not to replace the existing categorizations/taxonomies, but to take the first steps towards an integrated, comprehensive catalogue by aligning our empirical observations and the earlier literature.",1063-6773,978-0-7695-4981,10.1109/ICSM.2013.63,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6676923,maintainability;maintenance difficulties;maintenance problems;program comprehension;empirical study,Maintenance engineering;Taxonomy;Software maintenance;Programming;Complexity theory;Encoding,data analysis;software maintenance,programming-related difficulties taxonomy;source code characteristics;source code maintenance outcomes;data collection;open coding;axial coding;software system;software engineering,,2,21,,,,,IEEE,IEEE Conferences
Automatic Derivation of Concepts Based on the Analysis of Source Code Identifiers,L. Guerrouj,NA,2010 17th Working Conference on Reverse Engineering,,2010,,,301,304,"The existing software engineering literature has empirically shown that a proper choice of identifiers influences software understandability and maintainability. Indeed, identifiers are developers' main up-to-date source of information and guide their cognitive processes during program understanding when the high-level documentation is scarce or outdated and when the source code is not sufficiently commented. Deriving domain terms from identifiers using high-level and domain concepts is not an easy task when naming conventions (e.g., Camel Case) are not used or strictly followed and-or when these words have been abbreviated or otherwise transformed. Our thesis is to develop an approach that overcomes the shortcomings of the existing approaches and maps identifiers to domain concepts even in the absence of naming conventions and-or the presence of abbreviations. Our approach uses a thesaurus of words and abbreviations to map terms or transformed words composing identifiers to dictionary words. It relies on an oracle that we manually build for the validation of our results. To evaluate our technique, we apply it to derive concepts from identifiers of different systems and open source projects. We also enrich it by the use of domain knowledge and context-aware dictionaries to analyze how sensitive are its performances to the use of contextual information and specialized knowledge.",2375-5369;1095-1350,978-1-4244-8911,10.1109/WCRE.2010.45,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5645490,Identifier Splitting;Program Comprehension;Linguistic Analysis;Software Quality,Dictionaries;Software;Conferences;Thesauri;Presses;Buildings;Speech recognition,software maintenance;system documentation,automatic derivation;source code identifiers;software engineering;software understandability;software maintainability;cognitive processes;program understanding;high-level documentation;maps identifiers;domain concepts;naming conventions,,3,21,,,,,IEEE,IEEE Conferences
Understanding Asynchronous Interactions in Full-Stack JavaScript,S. Alimadadi; A. Mesbah; K. Pattabiraman,NA; NA; NA,2016 IEEE/ACM 38th International Conference on Software Engineering (ICSE),,2016,,,1169,1180,"JavaScript has become one of the most popular languages in practice. Developers now use JavaScript not only for the client-side but also for server-side programming, leading to ""full-stack"" applications written entirely in JavaScript. Understanding such applications is challenging for developers, due to the temporal and implicit relations of asynchronous and event-driven entities spread over the client and server side. We propose a technique for capturing a behavioural model of full-stack JavaScript applications' execution. The model is temporal and context-sensitive to accommodate asynchronous events, as well as the scheduling and execution of lifelines of callbacks. We present a visualization of the model to facilitate program understanding for developers. We implement our approach in a tool, called Sahand, and evaluate it through a controlled experiment. The results show that Sahand improves developers' performance in completing program comprehension tasks by increasing their accuracy by a factor of three.",1558-1225,978-1-4503-3900-1978-1-5090-2071,10.1145/2884781.2884864,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886989,Program comprehension;asynchronicity;full-stack JavaScript,Servers;Context modeling;Reactive power;Visualization;Writing;Concurrent computing,Java;object-oriented programming,asynchronous interaction;full-stack JavaScript;server-side programming;asynchronous events;program understanding;Sahand;program comprehension task,,8,48,,,,,IEEE,IEEE Conferences
Towards intelligent search support for web services evolution identifying the right abstractions,T. Reichherzer; E. El-Sheikh; N. Wilde; L. White; J. Coffey; S. Simmons,"University of West Florida, Pensacola, Florida, USA; University of West Florida, Pensacola, Florida, USA; University of West Florida, Pensacola, Florida, USA; University of West Florida, Pensacola, Florida, USA; University of West Florida, Pensacola, Florida, USA; Department of Computer Science, James Madison University, Harrisonburg, Virginia, USA",2011 13th IEEE International Symposium on Web Systems Evolution (WSE),,2011,,,53,58,"Services Oriented Architecture (SOA) is becoming a popular style for building complex systems-of-systems that allow businesses to work together across organizational boundaries. However concerns have been raised about the comprehensibility and maintainability of SOA composite applications. Integrating and deploying SOA applications requires artifacts in a variety of web-based languages (WSDL, XSD, BPEL, etc.) often produced by code-generation tools. It becomes difficult for a human to discover and understand the dependencies between these artifacts in an existing system. In this paper, we describe ongoing research on using search techniques to facilitate SOA maintenance by allowing users to query collections of artifacts making up a SOA composite application. The main focus in this paper is a case study using our prototype search tool SOAMiner to identify a set of abstractions that extract useful and critical information for maintainers, thereby bridging the heterogeneity of SOA artifacts while opportunistically exploiting their structure. Results of the study indicate that the highest priority abstractions for SOA are datatype summaries, service invocation (calling) relationships, and data usage relationships.",1550-4441,978-1-4577-0700-1978-1-4577-0699,10.1109/WSE.2011.6081819,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6081819,Services Oriented Architecture;SOA;Web Services;Evolution;Maintenance;Program Comprehension;Search,Service oriented architecture;Semiconductor optical amplifiers;Maintenance engineering;XML;Search problems,program compilers;service-oriented architecture;software maintenance;Web services,intelligent search support;Web service evolution;service oriented architecture;SOA composite application;Web-based language;code-generation tool;SOA maintenance;SOAMiner search tool,,3,15,,,,,IEEE,IEEE Conferences
Reducing Maintenance Effort through Software Operation Knowledge: An Eclectic Empirical Evaluation,H. v. d. Schuur; S. Jansen; S. Brinkkemper,NA; NA; NA,2011 15th European Conference on Software Maintenance and Reengineering,,2011,,,201,210,"Knowledge of in-the-field software operation is acquired unsophisticatedly: acquisition processes are implemented ad hoc, application-specific and are only triggered when end-users experience severe failures. Vendors that do acquire such knowledge structurally from their software applications, often are unsuccessful in visualizing it in a consistent and uniform manner. A generic approach to acquisition and presentation of software operation knowledge reduces the time vendors need to integrate acquisition logic into their applications, as well as the time needed to analyze, compare and present uniform software operation data resulting from in-the-field software operation. This paper proposes a technique for software operation knowledge acquisition and presentation through generic recording and visualization of software operation. A prototype tool implementing this technique is presented, as well as an extensive empirical evaluation of the tool using an eclectic set of instruments (an experiment, two case studies and expert focus group discussions) involving three widely-used software applications. Results show that the technique is expected to reduce software maintenance effort and increase comprehension of end-user software operation.",1534-5351;1534-5351,978-1-61284-259-2978-0-7695-4343,10.1109/CSMR.2011.26,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5741262,software maintenance;bug localization;program comprehension;software process improvement;binary instrumentation;software feedback;empirical study,Assembly;Weaving;Data visualization;Software maintenance;Instruments;Data mining,knowledge acquisition;software maintenance,software maintenance effort reduction;in-the-field software operation knowledge acquisition;software operation recording;software operation visualization;eclectic instrument set,,2,20,,,,,IEEE,IEEE Conferences
Multi-dimensional exploration of API usage,C. De Roover; R. Lämmel; E. Pek,"Software Languages Lab, Vrije Universiteit Brussel, Belgium; Software Languages Team, University of Koblenz-Landau, Germany; ADAPT Lab, University of Koblenz-Landau, Germany",2013 21st International Conference on Program Comprehension (ICPC),,2013,,,152,161,"This paper is concerned with understanding API usage in a systematic, explorative manner for the benefit of both API developers and API users. There exist complementary, less explorative methods, e.g., based on code search, code completion, or API documentation. In contrast, our approach is highly interactive and can be seen as an extension of what IDEs readily provide today. Exploration is based on multiple dimensions: i) the hierarchically organized scopes of projects and APIs; ii) metrics of API usage (e.g., number of project classes extending API classes); iii) metadata for APIs; iv) project- versus API-centric views. We also provide the QUAATLAS corpus of Java projects which enhances the existing QUALITAS corpus to enable API-usage analysis. We implemented the exploration approach in an open-source, IDE-like, Web-enabled tool EXAPUS.",1092-8138,978-1-4673-3092,10.1109/ICPC.2013.6613843,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613843,API usage;code exploration;metadata;program comprehension;reverse engineering;QUAATLAS;EXAPUS;QUALITAS,Java;Libraries;XML;Measurement;Abstracts;Software;Graphical user interfaces,application program interfaces;Java;meta data;public domain software,IDE;Web-enabled tool EXAPUS;open-source exploration approach;API-usage analysis;Java projects;QUAATLAS corpus;API metadata;API users;API developers;API usage metrics;multidimensional exploration,,17,32,,,,,IEEE,IEEE Conferences
"An initial approach to assessing program comprehensibility using spatial complexity, number of concepts and typographical style",A. Mohan; N. Gold; P. Layzell,"Dept. of Comput., UMIST, Manchester, UK; Dept. of Comput., UMIST, Manchester, UK; Dept. of Comput., UMIST, Manchester, UK",11th Working Conference on Reverse Engineering,,2004,,,246,255,"Software evolution can result in making a program harder to maintain, as it becomes more difficult to comprehend. This difficulty is related to the way the source code is formatted, the complexity of the code, and the amount of information contained within it. This work presents an initial approach that uses measures of typographical style, spatial complexity and concept assignment to measure these factors, and to model the comprehensibility of an evolving program. The ultimate aim of which is to identify when a program becomes more difficult to comprehend, triggering a corrective action to be taken to prevent this. We present initial findings from applying this approach. These findings show that this approach, through measuring these three factors, can model the change in comprehensibility of an evolving program. Our findings support the well-known claim that programs become more complex as they evolve, explaining this increase in complexity in terms of layout changes, conceptual coherence, spatial relationships between source code elements, and the relationship between these factors. This in turn can then be used to understand how maintenance affects program comprehensibility and to ultimately reduce its burden on software maintenance.",1095-1350,0-7695-2243,10.1109/WCRE.2004.11,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1374324,software evolution;software maintenance;program comprehension;software quality,Software maintenance;Costs;Software quality;Gold;Information systems;Coherence;Software systems;Maintenance engineering;Guidelines;Monitoring,software maintenance;software quality;reverse engineering;computational complexity,software evolution;software maintenance;program comprehension;software quality;spatial complexity;typographical style;source code;concept assignment;layout changes;conceptual coherence;spatial relationships,,2,29,,,,,IEEE,IEEE Conferences
Professional status and expertise for UML class diagram comprehension: An empirical study,Z. Soh; Z. Sharafi; B. Van den Plas; G. C. Porras; Y. Guéhéneuc; G. Antoniol,"Ptidej Team, SOCCER Lab, DGIGL, École Polytechnique de Montréal, Canada; Ptidej Team, SOCCER Lab, DGIGL, École Polytechnique de Montréal, Canada; FUNDP de Namur, Faculté d'Informatique, Belgique; DIRO, Université de Montréal, Canada; Ptidej Team, SOCCER Lab, DGIGL, École Polytechnique de Montréal, Canada; Ptidej Team, SOCCER Lab, DGIGL, École Polytechnique de Montréal, Canada",2012 20th IEEE International Conference on Program Comprehension (ICPC),,2012,,,163,172,"Professional experience is one of the most important criteria for almost any job offer in software engineering. Professional experience refers both to professional status (practitioner vs. student) and expertise (expert vs. novice). We perform an experiment with 21 subjects including both practitioners and students, and experts and novices. We seek to understand the relation between the speed and accuracy of the subjects and their status and expertise in performing maintenance tasks on UML class diagrams. We also study the impact of the formulation of the maintenance task. We use an eye-tracking system to gather the fixations of the subjects when performing the task. We measure the subjects' comprehension using their accuracy, the time spent, the search effort, the overall effort, and the question comprehension effort. We found that (1) practitioners are more accurate than students while students spend around 35 percent less time than practitioners, (2) experts are more accurate than novices while novices spending around 33 percent less time than experts, (3) expertise is the most important factor for accuracy and speed, (4) experienced students are more accurate and spend around 37 percent less time than experienced practitioners, and (5) when the description of the task is precise, the novice students can be accurate. We conclude that it is an illusion for project managers to focus on status only when recruiting a software engineer. Our result is the starting point to consider the differences between status and expertise when studying software engineers' productivity. Thus, it can help project managers to recruit productive engineers and motivated students to acquire the experience and ability in the projects.",1092-8138,978-1-4673-1216-5978-1-4673-1213-4978-1-4673-1215,10.1109/ICPC.2012.6240484,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240484,Program Comprehension;Professional status;Expertise;Eye-tracking,Unified modeling language;Maintenance engineering;Accuracy;Software;Testing;Context;Software engineering,software maintenance;Unified Modeling Language,professional status;professional expertise;UML class diagram comprehension;professional experience;software engineering;maintenance task formulation;eye-tracking system;accuracy;time spent;search effort;overall effort;question comprehension effort;software engineer productivity,,7,23,,,,,IEEE,IEEE Conferences
An Empirical Study on Code Comprehension: Data Context Interaction Compared to Classical Object Oriented,H. A. Valdecantos; K. Tarrit; M. Mirakhorli; J. O. Coplien,NA; NA; NA; NA,2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC),,2017,,,275,285,"Source code comprehension affects software development - especially its maintenance - where code reading is one of the most time-consuming activities. A programming language, together with the programming paradigm it supports, is a strong factor that profoundly impacts how programmers comprehend code. We conducted a human-subject controlled experiment to evaluate comprehension of code written using the Data Context Interaction (DCI) paradigm relative to code written with commonly used Object-Oriented (OO) programming. We used a new research-level language called Trygve which implements DCI concepts, and Java, a pervasive OO language in the industry. DCI revisits lost roots of the OO paradigm to address problems that are inherent to Java and most other contemporary OO languages. We observed correctness, time consumption, and locality of reference during reading comprehension tasks. We present a method which relies on the Eigenvector Centrality metric from Social Network Analysis to study the locality of reference in programmers by inspecting their sequencing of reading language element declarations and their permanence time in the code. Results indicate that DCI code in Trygve supports more comprehensible code regarding correctness and improves the locality of reference, reducing context switching during the software discovery process. Regarding reading time consumption, we found no statistically significant differences between both approaches.",,978-1-5386-0535-6978-1-5386-0536,10.1109/ICPC.2017.23,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961524,Program comprehension;Controlled experiment;Human subjects;Programming languages;Programming paradigms;Data Context Interaction;Object-Oriented,Context;Java;Programming profession;Software;Sequential analysis,eigenvalues and eigenfunctions;Java;object-oriented languages;object-oriented programming;social networking (online);software engineering,data context interaction;source code comprehension;software development;programming language;object-oriented programming;OO language;research-level language;Trygve;Java;DCI concepts;Social Network Analysis;eigenvector centrality metric;software discovery process,,,39,,,,,IEEE,IEEE Conferences
Analysis and visualization of predicate dependence on formal parameters and global variables,D. Binkley; M. Harman,"Loyola Coll., Baltimore, MD, USA; NA",IEEE Transactions on Software Engineering,,2004,30,11,715,735,"Empirical data concerning the qualitative and quantitative nature of program dependence is presented for a set of 20 programs ranging from 600 lines of code to 167,000 lines of code. The sources of dependence considered are global variables and formal parameters and the targets considered are a program's predicate nodes. The results show that as the number of formal parameters available to a predicate increases, there is a decrease in the proportion of these formal parameters which are depended upon by the predicate. No such correlation was found for global variables. Results from theoretical and actual computation time analysis indicate that the computation of dependence information is practical, suggesting that the analysis may be beneficial to several application areas. The paper also presents results concerning correlations that provide strong evidence that the global and formal dependence sources are independent of one another and that the numbers of globals and formals are independent of the size of the procedure that contains them. Finally, two visualization techniques for displaying dependence information are introduced. Illustrations show how these visualizations and predicate dependence analysis can assist in activities such as testing, comprehension, and evolution.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2004.78,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1359767,Index Terms- Dependence analysis;program slicing;program comprehension;software maintenance.,Humans;Information analysis;Independent component analysis;Data visualization;Software maintenance;Software engineering;Application software;Automatic testing;Logic;Software testing,program testing;program slicing;software maintenance;formal specification;program visualisation,predicate dependence visualization;formal parameter;global variable;program dependence;program predicate node,,19,79,,,,,IEEE,IEEE Journals
Architecture Recovery Using Latent Semantic Indexing and K-Means: An Empirical Evaluation,M. Risi; G. Scanniello; G. Tortora,NA; NA; NA,2010 8th IEEE International Conference on Software Engineering and Formal Methods,,2010,,,103,112,"A number of clustering based approaches and tools have been proposed in the past to partition a software system into subsystems. The greater part of these approaches is semiautomatic, thus requiring human decision to identify the best partition of software entities into clusters among the possible partitions. In addition, some approaches are conceived for software systems implemented using a particular programming language (e.g., C and C++). In this paper we present an approach to automate the partitioning of a given software system into subsystems. In particular, the approach first analyzes the software entities (e.g., programs or classes) and then using Latent Semantic Indexing the dissimilarity between these entities is computed. Finally, software entities are grouped using iteratively the k-means clustering algorithm. The approach has been implemented in a prototype of a supporting software system as an Eclipse plug-in. Finally, to assess the approach and the plug-in, we have conducted an empirical investigation on three open source software systems implemented using the programming languages Java and C/C++.",1551-0255;2160-7656,978-1-4244-8289,10.1109/SEFM.2010.19,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5637415,Software Partitioning;Latent Semantic Indexing;Clustering;Program Comprehension;Software Maintenance,Clustering algorithms;Software algorithms;Software systems;Partitioning algorithms;Algorithm design and analysis;Large scale integration,C++ language;indexing;Java;pattern clustering;public domain software;software maintenance,architecture recovery;latent semantic indexing;clustering based approach;k-means clustering algorithm;Eclipse plug-in;open source software systems;programming languages Java;C++,,4,38,,,,,IEEE,IEEE Conferences
My Repository Runneth Over: An Empirical Study on Diversifying Data Sources to Improve Feature Search,S. Ratanotayanon; H. J. Choi; S. E. Sim,NA; NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,206,215,"Research on feature location that applies information retrieval techniques have experimented the kinds of inputs to the corpus and the algorithms that could be used. At first, only source code was used. Later extraction techniques were improved, and data from other software tools and analyses were used to expand or augment the repository. But, does having more diverse data in the repository always produce better results? In this paper, we report on an empirical study to examine the effect of increasing data diversity to improve feature location through search. In particular, we looked at the effect of including: i) change sets from revision control system, ii) tickets from issue trackers, and iii) elements from a Static Dependency Graph (SDG). We searched for three features of Jajuk, an open source Java jukebox, and two features of jEdit, an open source Java text editor. We used four different corpuses built with a combination of the above data. We used Eclipse's code search and an index built with source code as baseline conditions. We found that it is not always better to have more diverse data. Adding SDG data to change sets increased recall, but drove down precision. Adding data from issue trackers had little effect and in one case lowered recall. We also found that large-scale refactoring of the code decreases the effectiveness using change sets for feature location.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.33,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521742,component;feature location;code search;program comprehension;change sets,Information retrieval;Control systems;Data mining;Software tools;Java;Vocabulary;Informatics;USA Councils;Large-scale systems;Software performance,data analysis;information retrieval;Java;public domain software;software maintenance,data source analysis;information retrieval techniques;source code;extraction techniques;software tools;data diversity;revision control system;static dependency graph;open source Java jukebox;Jajuk;open source Java text editor;jEdit;Eclipse code search;large-scale refactoring;feature location set research,,5,27,,,,,IEEE,IEEE Conferences
Sequence Diagram Slicing,K. Noda; T. Kobayashi; K. Agusa; S. Yamamoto,NA; NA; NA; NA,2009 16th Asia-Pacific Software Engineering Conference,,2009,,,291,298,"Software visualization with sequence diagrams is one of the promising techniques aimed at helping developers comprehend the behavior of object-oriented systems effectively. However, it is still difficult to understand this behavior, because the size of automatically generated sequence diagrams tends to be beyond the developer's capacity. In this paper, we propose a sequence diagram slicing method, which is an extension of our previous method based on a dynamic slicing technique using static information. Our proposed method is capable of accurate slice calculation based on high-precision data dependency and can support various programs, including exceptions and multithreading. In addition, our proposed new tool performs slice calculations on the Eclipse platform and we demonstrate the applicability of this method by applying the tool to two Java programs as case studies. The results confirm the effectiveness of our proposed method for understanding the behavior of object-oriented systems.",1530-1362;1530-1362,978-0-7695-3909,10.1109/APSEC.2009.35,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5358692,Sequence Diagram;Program Slicing;Reverse Engineering;Program Comprehension;Program Maintenance;Debugging,Project management;Software engineering;Computer science;Conference management;Engineering management;Programming profession;Component architectures;Computer languages;Instruments;Testing,Java;object-oriented programming;program slicing;program visualisation,sequence diagram slicing method;software visualization;object-oriented systems;dynamic slicing technique;static information;slice calculation;Eclipse platform;Java programs;multithreading,,6,13,,,,,IEEE,IEEE Conferences
Code structure visualization using 3D-flythrough,R. Oberhauser; C. Silfang; C. Lecon,"Department of Computer Science, Aalen University, Aalen, Germany; Department of Computer Science, Aalen University, Aalen, Germany; Department of Computer Science, Aalen University, Aalen, Germany",2016 11th International Conference on Computer Science & Education (ICCSE),,2016,,,365,370,"As software structures grow, it becomes increasingly difficult for those new to any software source code to conceptualize the mostly invisible structure. Historically program structures have been challenging to visualize. This paper contributes a 3D flythrough approach called FlyThruCode for visualizing facets of program structure. A prototype demonstrates its viability, and an empirical study investigates its effectiveness, efficiency, and motivational factors, showing promise for motivating the exploration of larger software structures.",,978-1-5090-2218-2978-1-5090-2217-5978-1-5090-2219,10.1109/ICCSE.2016.7581608,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7581608,Software engineering;engineering training;computer education;software visualization;program comprehension,Three-dimensional displays;Unified modeling language;Visualization;Software;Measurement;Two dimensional displays;Object oriented modeling,data visualisation;source code (software),code structure visualization;3D flythrough approach;FlyThruCode;software structures;historically program structures;motivational factors;facets visualization;software source code,,,19,,,,,IEEE,IEEE Conferences
Summarizing the Content of Large Traces to Facilitate the Understanding of the Behaviour of a Software System,A. Hamou-Lhadj; T. Lethbridge,"SITE, University of Ottawa; NA",14th IEEE International Conference on Program Comprehension (ICPC'06),,2006,,,181,190,"In this paper, we present a semi-automatic approach for summarizing the content of large execution traces. Similar to text summarization, where abstracts can be extracted from large documents, the aim of trace summarization is to take an execution trace as input and return a summary of its main content as output. The resulting summary can then be converted into a UML sequence diagram and used by software engineers to understand the main behavioural aspects of the system. Our approach to trace summarization is based on the removal of implementation details such as utilities from execution traces. To achieve our goal, we have developed a metric based on fan-in and fan-out to rank the system components according to whether they implement key system concepts or they are mere implementation details. We applied our approach to a trace generated from an object-oriented system called Weka that initially contains 97413 method calls. We succeeded to extract a summary from this trace that contains 453 calls. According to the developers of the Weka system, the resulting summary is an adequate high-level representation of the main interactions of the traced scenario",1092-8138,0-7695-2601,10.1109/ICPC.2006.45,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631120,Reverse engineering;Dynamic analysis;Design;recovery;Program comprehension,Software systems;Abstracts;Unified modeling language;Reverse engineering;Software tools;Software performance;Performance analysis;Debugging,object-oriented programming;program diagnostics;reverse engineering;software maintenance;Unified Modeling Language,software system;text summarization;execution trace summarization;UML sequence diagram;object-oriented system;Weka system;program comprehension;reverse engineering;dynamic analysis,,56,23,,,,,IEEE,IEEE Conferences
Can clone detection support test comprehension?,B. Hauptmann; M. Junker; S. Eder; E. Juergens; R. Vaas,"Technische Universita&#x00A8;t Mu&#x00A8;nchen, Garching b. Mu&#x00A8;nchen, Germany; Technische Universita&#x00A8;t Mu&#x00A8;nchen, Garching b. Mu&#x00A8;nchen, Germany; Technische Universita&#x00A8;t Mu&#x00A8;nchen, Garching b. Mu&#x00A8;nchen, Germany; CQSE GmbH, Mu&#x00A8;nchen, Germany; Munich Re Group, Mu&#x00A8;nchen, Germany",2012 20th IEEE International Conference on Program Comprehension (ICPC),,2012,,,209,218,"Tests are central artifacts of software systems. Therefore, understanding tests is essential for activities such as maintenance, test automation, and efficient execution. Redundancies in tests may significantly decrease their understandability. Clone detection is a technique to find similar parts in software artifacts. We suggest using this technique to gain a better understanding of tests and to provide guidance for testing activities. We show the capabilities as well as the limits of this approach by conducting a case study analyzing more than 4000 tests of seven industrial software systems.",1092-8138,978-1-4673-1216-5978-1-4673-1213-4978-1-4673-1215,10.1109/ICPC.2012.6240490,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240490,Program Comprehension;Software Testing;Software Maintenance;Clone Detection,Cloning;Manuals;Testing;Automation;Inspection;Optimization;Maintenance engineering,program testing,clone detection;test comprehension;software system central artifacts;industrial software systems,,4,32,,,,,IEEE,IEEE Conferences
Studying the Advancement in Debugging Practice of Professional Software Developers,B. Siegmund; M. Perscheid; M. Taeumel; R. Hirschfeld,NA; NA; NA; NA,2014 IEEE International Symposium on Software Reliability Engineering Workshops,,2014,,,269,274,"In 1997, Henry Lieberman stated that debugging is the dirty little secret of computer science. Since then, several promising debugging technologies have been developed such as back-in-time debuggers and automatic fault localization methods. However, the last study about the state-of-the-art in debugging is still more than 15 years old and so it is not clear whether these new approaches have been applied in practice or not. For that reason, we investigate the current state of debugging in a new comprehensive study. First, we review the available literature and learn about current approaches and study results. Second, we observe several professional developers while debugging and interview them about their experiences. Based on these results, we create a questionnaire that should serve as the basis for a large-scale online debugging survey later on. With these results, we expect new insights into debugging practice that help to suggest new directions for future research.",,978-1-4799-7377,10.1109/ISSREW.2014.36,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6983851,Debugging;Survey;Empirical Study;Program Comprehension,Debugging;Companies;Software;Computer bugs;Navigation;Java;Education,computer operating procedures;computer science;DP management;program debugging;software engineering,debugging practice;professional software developers;computer science;debugging technologies;back-in-time debuggers;automatic fault localization methods;large-scale online debugging,,,41,,,,,IEEE,IEEE Conferences
Hidden dependencies in software systems,R. Vanciu; V. Rajlich,"Department of Computer Science, Wayne State University, Detroit, Michigan, USA; Department of Computer Science, Wayne State University, Detroit, Michigan, USA",2010 IEEE International Conference on Software Maintenance,,2010,,,1,10,"In this paper, we study the hidden dependencies that are a special kind of data flows. They play an important role in software maintenance and evolution because they propagate changes among the classes and they are hard to detect. We propose a technique that finds hidden dependencies through the computation of an “execute completely after” relation that is filtered using dynamically generated preconditions and postconditions. We show that these hidden dependencies exist even in well-structured software, like the open source programs JUnit, Drawlets, and Apache FtpServer. We also discuss the precision of this technique.",1063-6773;1063-6773,978-1-4244-8629-8978-1-4244-8630-4978-1-4244-8628,10.1109/ICSM.2010.5609657,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609657,Software evolution;program comprehension;dependency analysis;execute completely after relation;invariants,Radio frequency;Integrated circuits,public domain software;software maintenance,hidden dependencies;software system;software maintenance;open source programs JUnit;Drawlets;Apache;FtpServer,,7,51,,,,,IEEE,IEEE Conferences
Delta extraction: An abstraction technique to comprehend why two objects could be related,N. Nitta; T. Matsuoka,"Graduate School of Natural Science, Konan University, Kobe, Japan; Graduate School of Natural Science, Konan University, Kobe, Japan",2015 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2015,,,61,70,"In an execution of a large scale program, even a simple observable behavior may be generated by a wide range of the source code. To comprehend how such a behavior is implemented in the code, a debugger would be helpful. However, when using a debugger, developers often encounter several types of cumbersome tasks and are often confused by the huge and complicated runtime information. To support such a debugger-based comprehension task, we propose an abstraction technique of runtime information, named delta, and present a delta extraction and visualization tool. Basically, a delta is defined for two linked objects in an object-oriented program's execution. It intuitively represents the reason why these objects could be related in the execution, and it can hide the details of how these objects were related. We have conducted experiments on four subject tasks from two real-world systems to evaluate how appropriately an extracted delta can answer the `why' question and how long the tool can reduce the working time to answer the question. The results show that each delta can successfully answer the question and a tens-of-minutes to one-hour debugger-based task can be reduced by extracting a delta.",,978-1-4673-7532-0978-1-4673-7531,10.1109/ICSM.2015.7332452,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7332452,dynamic analysis;back-in-time debugging;trace compression;debugger-based program comprehension,Runtime;Visualization;Java;Containers;Context;Electronic mail;Debugging,object-oriented programming;program debugging,source code;delta extraction;visualization tool;object-oriented program execution,,1,18,,,,,IEEE,IEEE Conferences
Identifying Code Smells with Multiple Concern Views,G. d. F. Carneiro; M. Silva; L. Mara; E. Figueiredo; C. Sant'Anna; A. Garcia; M. Mendonca,NA; NA; NA; NA; NA; NA; NA,2010 Brazilian Symposium on Software Engineering,,2010,,,128,137,"Code smells are anomalies often caused by the way concerns are realized in the source code. Their identification might depend on properties governing the structure of individual concerns and their inter-dependencies in the system implementation. Although code visualization tools are increasingly applied to support anomaly detection, they are mostly limited to represent modular structures, such as methods, classes and packages. This paper presents a multiple views approach that enriches four categories of code views with concern properties, namely: (i) concern's package-class method structure, (ii) concern's inheritance-wise structure, (iii)concern dependency, and (iv) concern dependency weight. An exploratory study was conducted to assess the extent to which visual views support code smell detection. Developers identified a set of well-known code smells on five versions of an open source system. Two important results came out of this study. First, the concern-driven views provided useful support to identify God Class and Divergent Change smells. Second, strategies for smell detection supported by the multiple concern views were uncovered.",,978-1-4244-8917-6978-0-7695-4273,10.1109/SBES.2010.21,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5629742,software visualization;code smells;concerns;program comprehension,Visualization;Color;Spirals;Couplings;Complexity theory;Software;Tutorials,object-oriented methods;program visualisation,code smell identification;multiple concern view;code visualization tool;anomaly detection;modular structure representation;concern inheritance wise structure;concern package class method structure;concern dependency weight;open source system;concern driven view;God Class;divergent change smell,,29,41,,,,,IEEE,IEEE Conferences
A Taxonomy of Interactions Introduced by Aspects,M. L. Bernardi; G. A. Di Lucca,NA; NA,2008 32nd Annual IEEE International Computer Software and Applications Conference,,2008,,,726,731,"Aspects have a large impact on the static structure and dynamic behaviour of the system they belong. This is due to the intrinsic intrusive nature of aspects and the woven process allowing the alteration of the structure, the control and data flow of the components of the base system in aspect oriented (AO) systems. Several and different types of interactions among aspects and the other components can be introduced according to the different mechanisms provided by AO Programming. These interactions can make higher the complexity of the overall system affecting its comprehension. In this paper we propose a taxonomy to categorize these types of interactions among aspects and the components of the base system. The taxonomy can be used to understand how each type of interaction affects the complexity, and thus the comprehensibility, of the system.",0730-3157;0730-3157,978-0-7695-3262,10.1109/COMPSAC.2008.159,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4591656,Software Quality;Program comprehension;Aspect Oriented Programming,Taxonomy;Complexity theory;Software;Flow graphs;Programming;Observers;Object recognition,object-oriented programming;software quality,taxonomy;woven process;components data flow;aspect oriented systems;aspect oriented programming,,1,14,,,,,IEEE,IEEE Conferences
Identifying Core Objects for Trace Summarization Using Reference Relations and Access Analysis,K. Noda; T. Kobayashi; T. Toda; N. Atsumi,NA; NA; NA; NA,2017 IEEE 41st Annual Computer Software and Applications Conference (COMPSAC),,2017,1,,13,22,"Behaviors of an object-oriented system can be visualized as reverse-engineered sequence diagrams from execution traces. This approach is a valuable tool for program comprehension tasks. However, owing to the massiveness of information contained in an execution trace, a reverse-engineered sequence diagram is often afflicted by a scalability issue. To address this issue, we present in this paper a method for identifying core objects for trace summarization by reference relations and access analysis. We detect and eliminate temporary objects that are trivial for a system, and then estimate the importance of non-trivial objects. By grouping objects with a focus on highly important ones (i.e., core objects), we visualize the system's behavior in terms of intergroup interactions. Consequently, we obtain a readable size of a reverse-engineered sequence diagram containing the system's key behavior. We implemented our technique in our tool and evaluated it by using traces from open-source software systems. The results showed that our reverse-engineered sequence diagrams contained only less than 30 lifelines, whereas the original diagrams (no abstraction methods were applied) contained approximately 1,000 to 3,000 lifelines. Our proposed method achieved significant reduction of the horizontal size of the diagram and is expected to be a valuable tool for program comprehension.",0730-3157,978-1-5386-0367-3978-1-5386-0368,10.1109/COMPSAC.2017.142,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8029585,Dynamic Analysis;Reverse-engineered Sequence Diagram;Trace Summarization;Core Object;Program Comprehension,Visualization;Object recognition;Tools;Scalability;Software systems;Open source software;Frequency estimation,object-oriented methods;public domain software;reverse engineering,core objects;trace summarization;reference relations;access analysis;object-oriented system;reverse-engineered sequence diagrams;execution traces;program comprehension tasks;nontrivial objects;intergroup interactions;system key behavior;open-source software systems,,1,34,,,,,IEEE,IEEE Conferences
Using the Kleinberg Algorithm and Vector Space Model for Software System Clustering,G. Scanniello; A. D'Amico; C. D'Amico; T. D'Amico,NA; NA; NA; NA,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,180,189,"Clustering based approaches are generally difficult to use in practice since they need a significant human interaction for recovering software architectures, are conceived for a specific programming language, and very often do not use design knowledge (e.g., the implemented architectural model). In this paper we present a clustering based approach to recover the implemented architecture of software systems with a hierarchical structure and implemented with any object oriented programming language. The approach is based on the combination of structural and lexical dimensions. The structural dimension is used to decompose a software system into layers (i.e., horizontal decomposition), while the lexical dimension is then employed to partition each layer (i.e., vertical decomposition) into software modules. Layers are identified using a well known and widely employed link analysis algorithm, i.e., the Kleinberg algorithm, while Vector Space Model is used to vertically decompose the layers. To assess the approach and the underlying techniques, we also present a prototype of a supporting tool and the results from a case study conducted on subsequent versions of three open source Java software systems.",1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.17,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521746,Architecture Recovery;Clustering;Link Analysis;Reverse Engineering;Program Comprehension,Clustering algorithms;Software algorithms;Software systems;Object oriented modeling;Partitioning algorithms;Humans;Software architecture;Computer languages;Computer architecture;Object oriented programming,Java;object-oriented programming;pattern clustering;programming languages;public domain software;software architecture,Kleinberg Algorithm;vector space model;software system clustering approach;software architectures;specific programming language;hierarchical structure;object oriented programming language;software modules;open source Java software systems,,19,34,,,,,IEEE,IEEE Conferences
Changeset-Based Topic Modeling of Software Repositories,C. S. Corley; K. Damevski; N. A. Kraft,"Department of Computer Science, The University of Alabama, Tuscaloosa, Alabama United States (e-mail: cscorley@crimson.ua.edu); Department of Computer Science, Virginia Commonwealth University, Richmond, Virginia United States 23284 (e-mail: damevski@acm.org); N/A, ABB Corporate Research, Raleigh, North Carolina United States (e-mail: nicholas.a.kraft@us.abb.com)",IEEE Transactions on Software Engineering,,2018,PP,99,1,1,"The standard approach to applying text retrieval models to code repositories is to train models on documents representing program elements. However, code changes lead to model obsolescence and to the need to retrain the model from the latest snapshot. To address this, we previously introduced an approach that trains a model on documents representing changesets from a repository and demonstrated its feasibility for feature location. In this paper, we expand our work by investigating: a second task (developer identification), the effects of including different changeset parts in the model, the repository characteristics that affect the accuracy of our approach, and the effects of the time invariance assumption on evaluation results. Our results demonstrate that our approach is as accurate as the standard approach for projects with most changes localized to a subset of the code, but less accurate when changes are highly distributed throughout the code. Moreover, our results demonstrate that context and messages are key to the accuracy of changeset-based models and that the time invariance assumption has a statistically significant effect on evaluation results, providing overly-optimistic results. Our findings indicate that our approach is a suitable alternative to the standard approach, providing comparable accuracy while eliminating retraining costs.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2018.2874960,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8486696,changesets;feature location;developer identification;program comprehension;mining software repositories;online topic modeling,Task analysis;Standards;Feature extraction;Resource management;Software maintenance;Maintenance engineering,,,,,,,,,,IEEE,IEEE Early Access Articles
Expanding identifiers to normalize source code vocabulary,D. Lawrie; D. Binkley,"Loyola University Maryland, Baltimore, 21210-2699, USA; Loyola University Maryland, Baltimore, 21210-2699, USA",2011 27th IEEE International Conference on Software Maintenance (ICSM),,2011,,,113,122,"Maintaining modern software requires significant tool support. Effective tools exploit a variety of information and techniques to aid a software maintainer. One area of recent interest in tool development exploits the natural language information found in source code. Such Information Retrieval (IR) based tools compliment traditional static analysis tools and have tackled problems, such as feature location, that otherwise require considerable human effort. To reap the full benefit of IR-based techniques, the language used across all software artifacts (e.g., requirements, design, change requests, tests, and source code) must be consistent. Unfortunately, there is a significant proportion of invented vocabulary in source code. Vocabulary normalization aligns the vocabulary found in the source code with that found in other software artifacts. Most existing work related to normalization has focused on splitting an identifier into its constituent parts. The next step is to expand each part into a (dictionary) word that matches the vocabulary used in other software artifacts. Building on a successful approach to splitting identifiers, an implementation of an expansion algorithm is presented. Experiments on two systems find that up to 66% of identifiers are correctly expanded, which is within about 20% of the current system's best-case performance. Not only is this performance comparable to previous techniques, but the result is achieved in the absence of special purpose rules and not limited to restricted syntactic contexts. Results from these experiments also show the impact that varying levels of documentation (including both internal documentation such as the requirements and design, and external, or user-level, documentation) have on the algorithm's performance.",1063-6773;1063-6773,978-1-4577-0664-6978-1-4577-0663-9978-1-4577-0662,10.1109/ICSM.2011.6080778,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6080778,source code analysis tools;natural language processing;program comprehension,Context;Vocabulary;Software;Documentation;Natural languages;Dictionaries,information retrieval;natural language processing;program diagnostics;software maintenance;source coding;vocabulary,identifier expansion;source code vocabulary normalization;software maintenance;natural language information;information retrieval based tools;static analysis tools;feature location;IR-based techniques;software artifacts;splitting identifiers,,25,31,,,,,IEEE,IEEE Conferences
A Context-Driven Software Comprehension Process Model,W. J. Meng; J. Rilling; Y. Zhang; R. Witte; S. Mudur; P. Charland,"Concordia University, Montreal, Canada; Concordia University, Montreal, Canada; Concordia University, Montreal, Canada; Concordia University, Montreal, Canada; Concordia University, Montreal, Canada; Defence Research and Development Canada Val-Belair, Quebec, Canada",2006 Second International IEEE Workshop on Software Evolvability (SE'06),,2006,,,50,57,"Comprehension is an essential part of software evolution. Only software that is well understood can evolve in a controlled manner. In this paper, we present a formal process model to support the comprehension of software systems by using ontology and description logic. This formal representation supports the use of reasoning services across different knowledge resources and therefore, enables us to provide users with guidance during the comprehension process that is context sensitive to their particular comprehension task. As part of the process model, we also adopt a new interactive story metaphor, to represent the interactions between users and the comprehension process",,0-7695-2698,10.1109/SOFTWARE-EVOLVABILITY.2006.1,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4032448,Software evolution;program comprehension;process modeling;story metaphor;ontological reasoning,Context modeling;Ontologies;Logic;Software maintenance;Information resources;Computer science;Software engineering;Research and development;Software systems;Context-aware services,formal logic;ontologies (artificial intelligence);software architecture;software prototyping,context-driven software comprehension process model;software evolution;software systems;ontology;description logic;reasoning services;interactive story metaphor,,5,29,,,,,IEEE,IEEE Conferences
Measuring the Accuracy of Information Retrieval Based Bug Localization Techniques,M. Beard; N. Kraft; L. Etzkorn; S. Lukins,NA; NA; NA; NA,2011 18th Working Conference on Reverse Engineering,,2011,,,124,128,"Bug localization involves using information about a bug to locate affected code sections. Several automated bug localization techniques based on information retrieval (IR) models have been constructed recently. The ""gold standard"" of measuring an IR technique's accuracy considers the technique's ability to locate a ""first relevant method."" However, the question remains -- does finding this single method enable the location of a complete set of affected methods? Previous arguments assume this to be true, however, few analyses of this assumption have been performed. In this paper, we perform a case study to test the reliability of this ""gold standard"" assumption. To further measure IR accuracy in the context of bug localization, we analyze the relevance of the IR model's ""first method returned."" We use various structural analysis techniques to extend relevant methods located by IR techniques and determine accuracy and reliability of these assumptions.",2375-5369;1095-1350,978-1-4577-1948,10.1109/WCRE.2011.23,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079835,program comprehension;feature identification;concept location;static analysis;information retrieval;latent Dirichlet allocation;latent semantic indexing,Accuracy;Computer bugs;Large scale integration;Gold;Magnetic resonance;Semantics;Reliability,information retrieval;program debugging;software maintenance,automated bug localization techniques;information retrieval models;gold standard assumption;first method returned,,6,15,,,,,IEEE,IEEE Conferences
Reverse Engineering of Web Based Systems,A. Hamou-Lhadj; A. En-Nouaary; K. Sultan,"Electrical and Computer Engineering Department, Concordia University, Montreal, Canada. abdelw@ece.concordia.ca; Electrical and Computer Engineering Department, Concordia University, Montreal, Canada. ennouaar@ece.concordia.ca; Electrical and Computer Engineering Department, Concordia University, Montreal, Canada. k_sultan@ece.concordia.ca",2007 Innovations in Information Technologies (IIT),,2007,,,193,197,"Maintaining a poorly documented Web application is not an easy task; software engineers must understand various parts of an application before they can make changes that preserve reliability and other system attributes. In recent years, there has been a noticeable increase in the number of studies that aim at reverse engineering web applications. These studies embody a rich set of techniques that differ in a variety of ways. In this paper, we study several techniques for reverse engineering of Web applications. The objective is to understand the trends in this area as well as uncover key research questions that remain unaddressed.",,978-1-4244-1840-4978-1-4244-1841,10.1109/IIT.2007.4430375,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4430375,Reverse engineering;web applications;program comprehension;software maintenance,Reverse engineering;Application software;Software maintenance;Computer architecture;Maintenance engineering;Reliability engineering;Internet;Software engineering;HTML;Java,Internet;reverse engineering;software reliability,reverse engineering;Web based systems;software engineers;reliability;system attributes,,,17,,,,,IEEE,IEEE Conferences
Documenting and sharing knowledge about code,A. Guzzi,"Software Engineering Research Group, Delft University of Technology, Delft, The Netherlands",2012 34th International Conference on Software Engineering (ICSE),,2012,,,1535,1538,"Software engineers spend a considerable amount of time on program comprehension. Current research has primarily focused on assisting the developer trying to build up his understanding of the code. This knowledge remains only in the mind of the developer and, as time elapses, often “disappears”. In this research, we shift the focus to the developer who is using her Integrated Development Environment (IDE) for writing, modifying, or reading the code, and who actually understands the code she is working with. The objective of this PhD research is to seek ways to support this developer to document and share her knowledge with the rest of the team. In particular, we investigate the full potential of micro-blogging integrated into the IDE for addressing the program comprehension problem.",1558-1225;0270-5257;0270-5257,978-1-4673-1067-3978-1-4673-1066-6978-1-4673-1065,10.1109/ICSE.2012.6227043,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227043,Program comprehension;micro-blogging;IDEs;recommender systems;CSCW,Software;USA Councils;Recommender systems;History;Context;Programming;Prototypes,groupware;recommender systems;reverse engineering;software maintenance;Web sites,software engineers;program comprehension;integrated development environment;IDE;micro-blogging;recommender systems;CSCW;knowledge documentation;knowledge sharing;software maintenance,,3,19,,,,,IEEE,IEEE Conferences
Bytecode-based class dependency extraction tool: Bytecode-CDET,A. Nanthaamornphong; A. Leatongkam; T. Kitpanich; P. Thongnuan,"Department of Information and Communication Technology, Prince of Songkla University, Phuket Campus Phuket, Thailand 83120; Department of Information and Communication Technology, Prince of Songkla University, Phuket Campus Phuket, Thailand 83120; Department of Information and Communication Technology, Prince of Songkla University, Phuket Campus Phuket, Thailand 83120; Department of Information and Communication Technology, Prince of Songkla University, Phuket Campus Phuket, Thailand 83120",2015 7th International Conference on Information Technology and Electrical Engineering (ICITEE),,2015,,,6,11,"Program comprehension is an important task in the software maintenance process. One of the challenges faced by Java developers is the inability to determine the correct number of class dependencies. The ability to recover class dependencies would help developers to understand the design of an existing system prior to modifying it. Many Java dependency analysis tools for this purpose have been proposed, but few are able to analyze the dependency types associated with Java bytecode. In this paper, we propose a reverse engineering tool to extract the dependencies from a compiled Java program. The tool provides a visualization of the recovered dependencies in a form that facilitates the developer's ability to examine the classes and class relationships in the software system. The resulting dependency extraction capability will also enhance software maintenance and evolution. The results of experiments conducted with the intent of evaluating the proposed tool demonstrate both its accuracy and a few of its limitations.",,978-1-4673-7863-5978-1-4673-7862,10.1109/ICITEED.2015.7408903,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7408903,Software Engineering;Program Comprehension;Dependency Tool;Java Programming,Java;XML;Data mining;Software maintenance;Data visualization;Image color analysis,Java;program compilers;program visualisation;reverse engineering;software maintenance,bytecode-based class dependency extraction tool;bytecode-CDET;program comprehension;software maintenance process;Java dependency analysis tools;reverse engineering tool;compiled Java program;recovered dependency visualization;software maintenance enhancement,,,22,,,,,IEEE,IEEE Conferences
Flexible design pattern detection based on feature types,G. Rasool; P. Mäder,"COMSATS Institute of Information Technology, Lahore, Pakistan; Institute for Systems Engineering and Automation (SEA), Johannes Kepler University, Linz, Austria",2011 26th IEEE/ACM International Conference on Automated Software Engineering (ASE 2011),,2011,,,243,252,"Accurately recovered design patterns support development related tasks like program comprehension and reengineering. Researchers proposed a variety of recognition approaches already. Though, much progress was made, there is still a lack of accuracy and flexibility in recognition. A major problem is the large variety of variants for implementing the same pattern. Furthermore, the integration of multiple search techniques is required to provide more accurate and effective pattern detection. In this paper, we propose variable pattern definitions composed of reusable feature types. Each feature type is assigned to one of multiple search techniques that is best fitting for its detection. A prototype implementation was applied to three open source applications. For each system a baseline was determined and used for comparison with the results of previous techniques. We reached very good results with an improved pattern catalog, but also demonstrated the necessity for customizations on new inspected systems. These results demonstrate the importance of customizable pattern definitions and multiple search techniques in order to overcome accuracy and flexibility issues of previous approaches.",1938-4300,978-1-4577-1639-3978-1-4577-1638,10.1109/ASE.2011.6100060,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6100060,Design Pattern Recognition;Pattern Detection;Pattern Definition;Feature-Based Pattern Recognition;Program Comprehension;Code Analysis;Regular Expressions,Feature extraction;Pattern recognition;Catalogs;Production facilities;Analytical models;Accuracy;Java,pattern recognition;program diagnostics;search problems;software prototyping;software reusability,flexible design pattern detection;program comprehension;reengineering;recognition approaches;multiple search techniques;variable pattern definitions;reusable feature types;prototype implementation;pattern catalog;customizable pattern definitions,,13,18,,,,,IEEE,IEEE Conferences
Combining Dynamic Analysis and Visualization to Explore the Distribution of Unit Test Suites,A. Tahir; S. G. MacDonell,NA; NA,2015 IEEE/ACM 6th International Workshop on Emerging Trends in Software Metrics,,2015,,,21,30,"As software systems have grown in scale and complexity the test suites built alongside those systems have also become increasingly complex. Understanding key aspects of test suites, such as their coverage of production code, is important when maintaining or reengineering systems. This work investigates the distribution of unit tests in Open Source Software (OSS) systems through the visualization of data obtained from both dynamic and static analysis. Our long-term aim is to support developers in their understanding of test distribution and the relationship of tests to production code. We first obtain dynamic coupling information from five selected OSS systems and we then map the test and production code results. The mapping is shown in graphs that depict both the dependencies between classes and static test information. We analyze these graphs using Centrality metrics derived from graph theory and SNA. Our findings suggest that, for these five systems at least, unit test and dynamic coupling information 'do not match', in that unit tests do not appear to be distributed in line with the systems' dynamic coupling. We contend that, by mapping dynamic coupling data onto unit test information, and through the use of software metrics and visualization, we can locate central system classes and identify to which classes unit testing effort has (or has not) been dedicated.",2327-0969;2327-0950,978-1-4673-7103-2978-1-4673-7102,10.1109/WETSoM.2015.12,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181587,test analysis;program comprehension;unit testing;visualization;dynamic metrics;dynamic analysis,Measurement;Couplings;Data visualization;Testing;Software systems,program diagnostics;program testing;public domain software;software metrics,dynamic analysis;unit test suites;software systems;open source software systems;static analysis;test distribution;centrality metrics;graph theory,,1,40,,,,,IEEE,IEEE Conferences
Slicing and replaying code change history,K. Maruyama; E. Kitsu; T. Omori; S. Hayashi,"Ritsumeikan University, Japan; Ritsumeikan University, Japan; Ritsumeikan University, Japan; Tokyo Institute of Technology, Japan",2012 Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering,,2012,,,246,249,"Change-aware development environments have recently become feasible and reasonable. These environments can automatically record fine-grained code changes on a program and allow programmers to replay the recorded changes in chronological order. However, they do not always need to replay all the code changes to investigate how a particular entity of the program has been changed. Therefore, they often skip several code changes of no interest. This skipping action is an obstacle that makes many programmers hesitate in using existing replaying tools. This paper proposes a slicing mechanism that can extract only code changes necessary to construct a particular class member of a Java program from the whole history of past code changes. In this mechanism, fine-grained code changes are represented by edit operations recorded on source code of a program. The paper also presents a running tool that implements the proposed slicing and replays its resulting slices. With this tool, programmers can avoid replaying edit operations nonessential to the construction of class members they want to understand.",,978-1-4503-1204-2978-1-4503-1204,10.1145/2351676.2351713,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6494927,Code change;Integrated development environments;Program comprehension;Program slicing;Software maintenance and evolution,,Java;software maintenance,code change history;change-aware development environment;fine-grained code change;skipping action;slicing mechanism;Java program;edit operation;program source code;running tool;software maintenance,,4,13,,,,,IEEE,IEEE Conferences
Program Behavior Discovery and Verification: A Graph Grammar Approach,C. Zhao; J. Kong; K. Zhang,"The University of Texas at Dallas, Richardson; North Dakota State University, Fargo; The University of Texas at Dallas, Richardson",IEEE Transactions on Software Engineering,,2010,36,3,431,448,"Discovering program behaviors and functionalities can ease program comprehension and verification. Existing program analysis approaches have used text mining algorithms to infer behavior patterns or formal models from program execution. When one tries to identify the hierarchical composition of a program behavior at different abstraction levels, textual descriptions are not informative and expressive enough. To address this, we present a semi-automatic graph grammar approach to retrieving the hierarchical structure of the program behavior. The hierarchical structure is built on recurring substructures in a bottom-up fashion. We formulate the behavior discovery and verification problem as a graph grammar induction and parsing problem, i.e., automatically iteratively mining qualified patterns and then constructing graph rewriting rules. Furthermore, using the induced grammar to parse the behavioral structure of a new program could verify if the program has the same behavioral properties specified by the grammar.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2010.3,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5383371,Visual language;graph grammar induction;program comprehension;reengineering.,Software maintenance;Reverse engineering;Learning automata;Software systems;Data mining;Clustering algorithms;Pattern analysis;Algorithm design and analysis;Text mining;Documentation,data mining;graph grammars;program verification,program behavior discovery;program behavior verification;program comprehension;text mining algorithms;behavior patterns;formal models;program execution;semi-automatic graph grammar approach;graph rewriting rules;mining qualified patterns,,15,60,,,,,IEEE,IEEE Journals
A Framework Profile of .NET,R. Lammel; R. Linke; E. Pek; A. Varanovich,NA; NA; NA; NA,2011 18th Working Conference on Reverse Engineering,,2011,,,141,150,"We develop a basic form of framework comprehension which is based on simple, reuse-related metrics for the as-implemented design and usage of frameworks. To this end, we provide a framework profile which incorporates potential reuse characteristics (e.g., specializability of types in a framework) as well as actual reuse characteristics (e.g., evidence of specialization of framework types in projects). We apply framework comprehension in an empirical study of the Microsoft. NET Framework. The approach is helpful in several contexts of software reverse and re-engineering.",2375-5369;1095-1350,978-1-4577-1948,10.1109/WCRE.2011.25,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079837,framework;.NET;framework design;framework usage;framework profile;reuse;type specialization;late binding;polymorphism;inheritance;program comprehension;software metrics;dynamic program analysis,Measurement;Libraries;Concrete;Performance analysis;Open source software;Context,network operating systems;reverse engineering;software metrics;software reusability;systems re-engineering,framework profile;framework comprehension;reuse-related metrics;Microsoft;.NET framework;software reverse;software reengineering,,2,24,,,,,IEEE,IEEE Conferences
Context-Aware Software Documentation,E. Aghajani,NA,2018 IEEE International Conference on Software Maintenance and Evolution (ICSME),,2018,,,727,731,"Software developers often do not possess the knowledge needed to understand a piece of code at hand, and the lack of code comments and outdated documentation exacerbates the problem. Asking for the help of colleagues, browsing the official documentation, or accessing online resources, such as Stack Overflow, can clearly help in this ""code comprehension"" activity that, however, still remains highly time-consuming and is not always successful. Enhancing this process has been addressed in different studies under the subject of automatic documentation of software artifacts. For example, ""recommender systems"" have been designed with the goal of retrieving and suggesting relevant pieces of information (e.g., Stack Overflow discussions) for a given piece of code inspected in an IDE. However, these techniques rely on limited contextual information, mainly solely source code. Our goal is to build a context-aware proactive recommender system supporting the code comprehension process. The system must be able to understand the context, consider the developer's profile, and help her by generating pieces of documentation at whatever granularity is required, e.g., going from summarizing the responsibilities implemented in a subsystem, to explaining how two classes collaborate to implement a functionality, down to documenting a single line of code. Generated documentation will be tailored for the current context (e.g., the task at hand, the developer's background knowledge, the history of interactions). In this paper we present our first steps toward our goal by introducing the ADANA project, a framework which generates fine-grained code comments for a given piece of code.",2576-3148;1063-6773,978-1-5386-7870-1978-1-5386-7871,10.1109/ICSME.2018.00090,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530093,software documentation;program comprehension;context-aware;recommender system,Documentation;Recommender systems;Task analysis;Software;Knowledge based systems;Data mining;Cloning,document handling;information retrieval;Internet;recommender systems;software maintenance;system documentation;ubiquitous computing;Web sites,contextual information;context-aware proactive recommender system;code comprehension process;generated documentation;fine-grained code comments;context-aware software documentation;software developers;official documentation;online resources;automatic documentation;software artifacts;source code;time-consuming;developer profile;stack overflow;information retrieval,,,46,,,,,IEEE,IEEE Conferences
Understanding Large-Scale Software – A Hierarchical View,O. Levy; D. Feitelson,"The Hebrew University of Jerusalem, Israel; The Hebrew University of Jerusalem, Israel",2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC),,2019,,,283,293,"Program comprehension accounts for a large portion of software development costs and effort. The academic literature contains research on program comprehension of short code snippets, but comprehension at the system level is no less important. We claim that comprehending a software system is a distinct activity that differs from code comprehension. We interview experienced developers, architects, and managers in the software industry and open-source community, to uncover the meaning of program comprehension at the system level. The interviews demonstrate, among other things, that system comprehension is detached from code and programming language, and includes scope that is not captured in the code. It focuses on the structure of the system and less on the code itself. This is a continuous, iterative process, which mixes white-box and black-box approaches at different layers of the system, and combines both bottom-up and top-down comprehension strategies.",2643-7171;2643-7147,978-1-7281-1519-1978-1-7281-1520,10.1109/ICPC.2019.00047,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813291,system comprehension;program comprehension;top down;bottom up;white box;black box;design;architecture;source code;documentation;interview;large scale software,,,,,,35,,,,,IEEE,IEEE Conferences
Deriving a State Model of a Control Program by Symbolic Execution,H. Prähofer; T. Böhm; J. Pichler,"Institute for System Software, Johannes Kepler University, Linz, Austria; Institute for System Software, Johannes Kepler University, Linz, Austria; Software Competence Center Hagenberg, Hagenberg, Austria",2018 IEEE 16th International Conference on Industrial Informatics (INDIN),,2018,,,754,759,"This paper presents an approach for deriving a state transition model which represents the behavior of a control component using symbolic execution. Symbolic execution is a technique for executing a program using symbolic values for unknowns. It explores execution paths in a program and then uses a SAT/SMT solver to prove that paths are feasible. Further, the approach allows using constraints on the environment and simplifications with a widening operator similar to abstract interpretation.We present the formal foundation of the approach, depict the the tool implementation, present results from a preliminary evaluation, and discuss various application scenarios.",2378-363X,978-1-5386-4829-2978-1-5386-4828-5978-1-5386-4830,10.1109/INDIN.2018.8472013,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8472013,Symbolic execution;program comprehension;programmable logic controllers;state transition model,Unified modeling language;Automata;Safety;Electronic mail;Tools;System software,computability;program testing;program verification,state transition model;control component;symbolic execution;control program;SAT solver;SMT solver;program execution;satisfiability,,,17,,,,,IEEE,IEEE Conferences
Towards Open Source Software System Architecture Recovery Using Design Metrics,E. Constantinou; G. Kakarontzas; I. Stamelos,NA; NA; NA,2011 15th Panhellenic Conference on Informatics,,2011,,,166,170,"Over the past years, software development practices include open source code reuse. Since documentation gives little or no information about the system architecture, a prohibitive amount of effort is required to comprehend the source code and the overall system architecture. In this paper, we investigate how design metrics can reveal architectural information about a software system and more specifically, how architectural layers are correlated to design metrics. Finally, we present an empirical study on two large open source systems written in Java, attempting to identify metrics revealing information about the system architecture.",,978-1-61284-962,10.1109/PCI.2011.36,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6065045,system understanding;program comprehension;object-oriented;reuse;architecture layer;design metrics,Measurement;Computer architecture;Correlation;Software architecture;Java;Software,Java;public domain software;software architecture;software metrics,open source software system architecture recovery;design metrics;software system architectural information;Java,,4,13,,,,,IEEE,IEEE Conferences
Semantic zooming of code change history,Y. Yoon; B. A. Myers,"Institute for Software Research, Carnegie Mellon University, Pittsburgh, PA 15213, USA; Human-Computer Interaction Institute, Carnegie Mellon University, Pittsburgh, PA 15213, USA",2015 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC),,2015,,,95,99,"Previously, we presented our technique for visualizing fine-grained code changes in a timeline view, designed to facilitate reviewing and interacting with the code change history. During user evaluations, it became evident that users often wanted to see the code changes at a higher level of abstraction. Therefore, we developed a novel approach to automatically summarize fine-grained code changes into more conceptual, higher-level changes in real time. Our system provides four collapse levels, which are integrated with the timeline via semantic zooming: raw level (no collapsing), statement level, method level, and type level. Compared to the raw level, the number of code changes shown in the timeline at each level is reduced by 55%, 77%, and 83%, respectively. This implies that the semantic zooming would help users better understand and interact with the history by minimizing the potential information overload.",,978-1-4673-7457-6978-1-4673-7456,10.1109/VLHCC.2015.7357203,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7357203,semantic zooming;edit collapsing;program comprehension;software visualization;timeline visualization;Azurite,,programming environments;user interfaces,code change history;raw level;statement level;method level;type level;semantic zooming,,,17,,,,,IEEE,IEEE Conferences
Automatic identification of class stereotypes,N. Dragan; M. L. Collard; J. I. Maletic,"Department of Computer Science, Kent State University, OH 44242, USA; Department of Computer Science, The University of Akron, OH 44325, USA; Department of Computer Science, Kent State University, OH 44242, USA",2010 IEEE International Conference on Software Maintenance,,2010,,,1,10,"An approach is presented to automatically determine a class's stereotype. The stereotype is based on the frequency and distribution of method stereotypes in the class. Method stereotypes are automatically determined using a defined taxonomy given in previous work. The stereotypes, boundary, control and entity are used as a basis but refined based on an empirical investigation of 21 systems. A number of heuristics, derived from empirical evidence, are used to determine a class's stereotype. For example, the prominence of certain types of methods can indicate a class's main role. The approach is applied to five open source systems and evaluated. The results show that 95% of the classes are stereotyped by the approach. Additionally, developers (via manual inspection) agreed with the approach's results.",1063-6773;1063-6773,978-1-4244-8629-8978-1-4244-8630-4978-1-4244-8628,10.1109/ICSM.2010.5609703,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609703,method stereotypes;class stereotypes;program comprehension;reverse engineering,Taxonomy;Production facilities;Measurement;Libraries;Computer science;Software systems;Data models,public domain software;reverse engineering;system documentation,automatic identification;class stereotype;method stereotype;taxonomy;heuristics;empirical evidence;open source system;program comprehension;reverse engineering;documentation,,26,22,,,,,IEEE,IEEE Conferences
Inferring semantically related words from software context,J. Yang; L. Tan,"University of Waterloo, Waterloo, ON, Canada; University of Waterloo, Waterloo, ON, Canada",2012 9th IEEE Working Conference on Mining Software Repositories (MSR),,2012,,,161,170,"Code search is an integral part of software development and program comprehension. The difficulty of code search lies in the inability to guess the exact words used in the code. Therefore, it is crucial for keyword-based code search to expand queries with semantically related words, e.g., synonyms and abbreviations, to increase the search effectiveness. However, it is limited to rely on resources such as English dictionaries and WordNet to obtain semantically related words in software, because many words that are semantically related in software are not semantically related in English. This paper proposes a simple and general technique to automatically infer semantically related words in software by leveraging the context of words in comments and code. We achieve a reasonable accuracy in seven large and popular code bases written in C and Java. Our further evaluation against the state of art shows that our technique can achieve a higher precision and recall.",2160-1860;2160-1852,978-1-4673-1761-0978-1-4673-1760,10.1109/MSR.2012.6224276,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6224276,Semantically related words;code search;program comprehension,Context;Dictionaries;Gold;Linux;Java;Kernel,C language;Java;query processing;software engineering;word processing,semantically related word inference;software context;code search;software development;program comprehension;keyword-based code search;abbreviations;synonyms;English dictionaries;WordNet;C language;Java,,21,48,,,,,IEEE,IEEE Conferences
How do professional developers comprehend software?,T. Roehm; R. Tiarks; R. Koschke; W. Maalej,"TU M&#x00FC;nchen, Munich, Germany; University of Bremen, Bremen, Germany; University of Bremen, Bremen, Germany; TU M&#x00FC;nchen, Munich, Germany",2012 34th International Conference on Software Engineering (ICSE),,2012,,,255,265,"Research in program comprehension has considerably evolved over the past two decades. However, only little is known about how developers practice program comprehension under time and project pressure, and which methods and tools proposed by researchers are used in industry. This paper reports on an observational study of 28 professional developers from seven companies, investigating how developers comprehend software. In particular we focus on the strategies followed, information needed, and tools used. We found that developers put themselves in the role of end users by inspecting user interfaces. They try to avoid program comprehension, and employ recurring, structured comprehension strategies depending on work context. Further, we found that standards and experience facilitate comprehension. Program comprehension was considered a subtask of other maintenance tasks rather than a task by itself. We also found that face-to-face communication is preferred to documentation. Overall, our results show a gap between program comprehension research and practice as we did not observe any use of state of the art comprehension tools and developers seem to be unaware of them. Our findings call for further careful analysis and for reconsidering research agendas.",1558-1225;0270-5257;0270-5257,978-1-4673-1067-3978-1-4673-1066-6978-1-4673-1065,10.1109/ICSE.2012.6227188,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227188,program comprehension;empirical studies;software documentation;maintenance;context awareness,Software;Interviews;Companies;Documentation;Java;Content management;Visualization,reverse engineering;software maintenance,professional developers;program comprehension;project pressure;user interfaces;structured comprehension strategies;work context;maintenance tasks;face-to-face communication;comprehension tools,,70,24,,,,,IEEE,IEEE Conferences
Meaningful Identifier Names: The Case of Single-Letter Variables,G. Beniamini; S. Gingichashvili; A. K. Orbach; D. G. Feitelson,NA; NA; NA; NA,2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC),,2017,,,45,54,"It is widely accepted that variable names in computer programs should be meaningful, and that this aids program comprehension. ""Meaningful"" is commonly interpreted as favoring long descriptive names. However, there is at least some use of short and even single-letter names: using 'i' in loops is very common, and we show (by extracting variable names from 1000 popular github projects in 5 languages) that some other letters are also widely used. In addition, controlled experiments with different versions of the same functions (specifically, different variable names) failed to show significant differences in ability to modify the code. Finally, an online survey showed that certain letters are strongly associated with certain types and meanings. This implies that a single letter can in fact convey meaning. The conclusion from all this is that single letter variables can indeed be used beneficially in certain cases, leading to more concise code.",,978-1-5386-0535-6978-1-5386-0536,10.1109/ICPC.2017.18,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961503,Program comprehension;meaningful identifier names;single-letter names,Data mining;Programming;Encoding;Standards;Syntactics;Java,software maintenance;source code (software),variable names;program comprehension;long descriptive names;single letter variables;meaningful identifier names,,2,18,,,,,IEEE,IEEE Conferences
Automated Identification of Tasks in Development Sessions,I. D. Coman; A. Sillitti,NA; NA,2008 16th IEEE International Conference on Program Comprehension,,2008,,,212,217,"Task switching occurs frequently during the work of software developers. While there are already several approaches aiming at assisting developers in recovering their contexts of previous tasks, they generally rely on the developer to identify the beginning of each task. We propose a new technique for automatically splitting a development session into task-related subsections, based on the interaction of the developer with the IDE. The technique also shows potential benefits for automatic concern detection and for suggestions for code investigation. We present the technique, the results of a study conducted for its initial validation, and we discuss the additional potential benefits under investigation.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.16,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556133,Task Detection;Program Comprehension;Concerns,Switches;History;Visualization;Programming;Packaging;Hydrogen,software engineering,automated identification;development sessions tasks;task switching;software developers;automatic concern detection,,16,11,,,,,IEEE,IEEE Conferences
Identifying Knowledge Divergence by Vocabulary Monitoring in Software Projects,J. Nonnen; P. Imhoff,NA; NA,2012 16th European Conference on Software Maintenance and Reengineering,,2012,,,441,446,"During the development of a project, words used in source code add up to a big vocabulary, which may lead to a divergent word-understanding and word-knowledge between developers. Even the drop out of a single developer may lead to a big loss of knowledge about words and their meaning. By keeping track of the active developers vocabulary one is able to identify and react upon such situations, e.g., by applying pair programming to spread the knowledge around the team. In this work we propose a way to identify such situations by analysing the words contained in identifiers obtained through the commit history in a version control system. Initial empirical results are presented and analysed.",1534-5351,978-0-7695-4666-7978-1-4673-0984,10.1109/CSMR.2012.56,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6178918,vocabulary;active vocabulary;vocabulary evolution;software evolution;history mining;program comprehension;project health,Vocabulary;History;Visualization;Software;Programming;Correlation;Measurement,knowledge management;software development management;vocabulary,knowledge divergence;vocabulary monitoring;software projects;source code;divergent word-understanding;divergent word-knowledge;pair programming;version control system,,1,23,,,,,IEEE,IEEE Conferences
Docio: Documenting API Input/Output Examples,S. Jiang; A. Armaly; C. McMillan; Q. Zhi; R. Metoyer,NA; NA; NA; NA; NA,2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC),,2017,,,364,367,"When learning to use an Application Programming Interface (API), programmers need to understand the inputs and outputs (I/O) of the API functions. Current documentation tools automatically document the static information of I/O, such as parameter types and names. What is missing from these tools is dynamic information, such as I/O examples-actual valid values of inputs that produce certain outputs. In this paper, we demonstrate Docio, a prototype toolset we built to generate I/O examples. Docio logs I/O values when API functions are executed, for example in running test suites. Then, Docio puts I/O values into API documents as I/O examples. Docio has three programs: 1) funcWatch, which collects I/O values when API developers run test suites, 2) ioSelect, which selects one I/O example from a set of I/O values, and 3) ioPresent, which embeds the I/O examples into documents. In a preliminary evaluation, we used Docio to generate four hundred I/O examples for three C libraries: ffmpeg, libssh, and protobuf-c. Docio is open-source and available at: http://www3.nd.edu/~sjiang1/docio/.",,978-1-5386-0535-6978-1-5386-0536,10.1109/ICPC.2017.13,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961538,api documentation;program comprehension;dynamic program analysis,Libraries;Tools;HTML;Layout;Visualization;Documentation;Prototypes,application program interfaces;system documentation,Docio;API input/output example documentation;application programming interface;I/O static information;dynamic information;funcWatch;I/O values;API developers;ioSelect;ioPresent;C libraries;ffmpeg;libssh;protobuf-c,,1,18,,,,,IEEE,IEEE Conferences
Feature Maps: A Comprehensible Software Representation for Design Pattern Detection,H. Thaller; L. Linsbauer; A. Egyed,"Institute for Software Systems Engineering, Johannes Kepler University Linz, Austria; Institute for Software Systems Engineering, Johannes Kepler University Linz, Austria; Institute for Software Systems Engineering, Johannes Kepler University Linz, Austria","2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)",,2019,,,207,217,"Design patterns are elegant and well-tested solutions to recurrent software development problems. They are the result of software developers dealing with problems that frequently occur, solving them in the same or a slightly adapted way. A pattern's semantics provide the intent, motivation, and applicability, describing what it does, why it is needed, and where it is useful. Consequently, design patterns encode a well of information. Developers weave this information into their systems whenever they use design patterns to solve problems. This work presents Feature Maps, a flexible human-and machine-comprehensible software representation based on micro-structures. Our algorithm, the Feature-Role Normalization, presses the high-dimensional, in homogeneous vector space of micro-structures into a feature map. We apply these concepts to the problem of detecting instances of design patterns in source code. We evaluate our methodology on four design patterns, a wide range of balanced and imbalanced labeled training data, and compare classical machine learning (Random Forests) with modern deep learning approaches (Convolutional Neural Networks). Feature maps yield robust classifiers even under challenging settings of strongly imbalanced data distributions without sacrificing human comprehensibility. Results suggest that feature maps are an excellent addition in the software analysis toolbox that can reveal useful information hidden in the source code.",1534-5351,978-1-7281-0591-8978-1-7281-0592,10.1109/SANER.2019.8667978,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8667978,feature maps;micro-structures;design patterns;machine learning;random forest;deep learning;convolutional neural networks;program comprehension;reverse engineering,Software;Machine learning;Graphics;Feature extraction;Semantics;Convolutional neural networks;Correlation,convolutional neural nets;learning (artificial intelligence);object-oriented methods;pattern classification;software engineering,Feature Maps;design pattern detection;recurrent software development problems;software developers;classical machine learning;random forests;deep learning approach;convolutional neural networks;feature-role normalization algorithm;human-machine-comprehensible software representation;software analysis toolbox,,,41,,,,,IEEE,IEEE Conferences
How Does Feature Dependency Affect Configurable System Comprehensibility?,D. Santos; C. Sant' Anna,Federal Institute of Bahia; Federal University of Bahia,2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC),,2019,,,19,29,"Background: Conditional compilation is often used to implement variability in configurable systems. This technique relies on #ifdefs to delimit feature code. Previous studies have shown that #ifdefs may hinder code comprehensibility. However, they did not explicitly took feature dependencies into account. Feature dependency occurs when different features refer to the same program element, such as a variable. Comprehensibility may be even more affected in the presence of feature dependency, as the developer must reason about different scenarios affecting the same variable. Aim: Our goal is to understand how feature dependency affects the comprehensibility of configurable system source code. Method: We carried out an experiment in which 30 developers debugged programs with different types of feature dependency. We recorded the time each of them had spent to find a bug. Also, we used an eye-tracking device to record developers' gaze movements while they debugged programs. Results: Debugging programs with global and interprocedural dependency required more time and higher visual effort. Conclusion: Our study showed that #ifdefs affect comprehensibility in different degrees depending on the type of feature dependency. Therefore, when possible, developers should take more care when dealing with code with global and interprocedural dependencies.",2643-7171;2643-7147,978-1-7281-1519-1978-1-7281-1520,10.1109/ICPC.2019.00016,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813293,"Feature dependency, Program comprehension, Configurable Systems, Variability bugs, Eye tracking",,,,,,41,,,,,IEEE,IEEE Conferences
On the effectiveness of accuracy of automated feature location technique,T. Ishio; S. Hayashi; H. Kazato; T. Oshima,"Osaka University, Osaka 565-0871, Japan; Tokyo Institute of Technology, Tokyo 152-8552, Japan; NTT DATA INTELLILINK CORPORATION, Tokyo 104-0052, Japan; NTT Software Innovation Center, Tokyo 180-8585, Japan",2013 20th Working Conference on Reverse Engineering (WCRE),,2013,,,381,390,"Automated feature location techniques have been proposed to extract program elements that are likely to be relevant to a given feature. A more accurate result is expected to enable developers to perform more accurate feature location. However, several experiments assessing traceability recovery have shown that analysts cannot utilize an accurate traceability matrix for their tasks. Because feature location deals with a certain type of traceability links, it is an important question whether the same phenomena are visible in feature location or not. To answer that question, we have conducted a controlled experiment. We have asked 20 subjects to locate features using lists of methods of which the accuracy is controlled artificially. The result differs from the traceability recovery experiments. Subjects given an accurate list would be able to locate a feature more accurately. However, subjects could not locate the complete implementation of features in 83% of tasks. Results show that the accuracy of automated feature location techniques is effective, but it might be insufficient for perfect feature location.",1095-1350;2375-5369,978-1-4799-2931,10.1109/WCRE.2013.6671313,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6671313,feature location;impact analysis;program comprehension;human factor,Feature extraction;Large scale integration;Gold;Benchmark testing;Accuracy;Manuals;Electronic mail,program diagnostics;software maintenance,automated feature location technique;program element extraction;traceability recovery;software maintenance,,,28,,,,,IEEE,IEEE Conferences
A Search Based Context-Aware Approach for Understanding and Localizing the Fault via Weighted Call Graph,J. Tu; X. Xie; Y. Zhou; B. Xu; L. Chen,NA; NA; NA; NA; NA,2016 Third International Conference on Trustworthy Systems and their Applications (TSA),,2016,,,64,72,"Strictly speaking, fault localization includes assessing the code risk of being faulty and identifying the real fault. In practice, only highlighting some possible faulty statements is not helpful enough to reason the roots of the observed failures in a system. Programmers need to manually inspect the highlighted risky statements one by one, reading and understanding their contexts, in order to identify the real faulty ones. However, most related works have been focusing on risk assessment by simply ignoring the fault identification, which makes such techniques much less practical in real world. Therefore, in this paper, we propose a context-aware approach to assist fault comprehension and identification. Built on risk assessment results, our approach searches for the faults on Weighted Call Graph. In our approach the risky statements are re-ordered by function call chains, which can provide much richer information to understand the context and hence reduce the efforts in manual code inspection. Case studies with three open-source systems show that the proposed approach could help to improve the effectiveness of the whole fault localization process.",,978-1-5090-3539-7978-1-5090-3540,10.1109/TSA.2016.20,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780227,Program comprehension;fault identification;fault localization;weighted call graph,Risk management;Fault diagnosis;Context;Navigation;Inspection;Testing;Debugging,graph theory;program debugging;public domain software;risk management,search based context-aware approach;weighted call graph;code risk assessment;risky statements;fault identification;fault comprehension;function call chains;open-source systems;software fault localization,,1,37,,,,,IEEE,IEEE Conferences
An Interprocedural Aspect Control Flow Graph to Support the Maintenance of Aspect Oriented Systems,M. L. Bernardi; G. A. di Lucca,"Research Center on Software Technology (RCOST) - University of Sannio, mlbernar@unisannio.it; Research Center on Software Technology (RCOST) - University of Sannio, dilucca@unisannio.it",2007 IEEE International Conference on Software Maintenance,,2007,,,435,444,"Aspect oriented programming (AOP) supports the cross-cutting of concerns by means of aspects. The maintenance of AO systems may be more difficult than 'traditional' ones, due to the large impact that aspects have on the static structure and dynamic behavior of the overall system. In this paper an inter-procedural aspect control flow graph is proposed to represent the interactions among the aspects and the object oriented (OO) components of an AO system. The graph allows an easier identification of the impact between aspects and the OO components. It helps the maintainer to identify sources of undesired side and ripple effects in the code and avoid the introduction of new ones when modifying an AOP system.",1063-6773,978-1-4244-1255-6978-1-4244-1256,10.1109/ICSM.2007.4362656,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362656,Software maintenance;Aspect Oriented Programming;program comprehension;reverse engineering,Control systems;Flow graphs;Weaving;Software maintenance;Dynamic programming;Reverse engineering;Logic;Software systems;Joining processes,flow graphs;object-oriented programming;software maintenance,interprocedural aspect control flow graph;aspect oriented programming;AOP system maintenance;object oriented components,,4,22,,,,,IEEE,IEEE Conferences
A Survey of the Forms of Java Reference Names,S. Butler; M. Wermelinger; Y. Yu,NA; NA; NA,2015 IEEE 23rd International Conference on Program Comprehension,,2015,,,196,206,"The readability of identifiers is a major factor of program comprehension and an aim of naming convention guidelines. Due to their semantic content, identifiers are also used in feature and bug location, among other software maintenance tasks. Looking at how names are used in practice may lead to insights on potential problems for comprehension and for programming support tools that process identifiers. Class and method names are already well represented in the literature. This paper presents an investigation of Java field, formal argument and local variable names, which we collectively call reference names. These names cannot be ignored because they constitute over half the unique names and almost 70% of the name declarations in the corpus investigated. We analysed the forms of 3.5 million reference name declarations in 60 well known Java projects, examining the phrasal structure of names composed of known words and acronyms. The structures found in practice were evaluated against those given in the literature. The use of unknown abbreviations and words, which may pose a problem for program comprehension, was also identified. Based on our observations of the rich diversity of reference names, we suggest issues to be taken into account for future academic research and for improving tools that rely on names as sources of information.",1092-8138,978-1-4673-8159-8978-1-4673-8158,10.1109/ICPC.2015.30,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181448,identifier names;naming conventions;program comprehension;natural language processing;empirical study,Java;Ciphers;Vocabulary;Dictionaries;Guidelines;Tagging,Java;software maintenance,Java reference names;program comprehension;software maintenance tasks;phrasal structure,,2,25,,,,,IEEE,IEEE Conferences
Effectiveness of Flowcharting as a Scaffolding Tool to Learn Python,C. Cabo,"Departments of Computer Systems, New York City College of Technology/CUNY, New York City, USA",2018 IEEE Frontiers in Education Conference (FIE),,2018,,,1,7,"This Research to Practice Full Paper evaluates the effectiveness of flowcharting as a scaffolding tool to learn a programming language like Python in the setting of an urban institution that serves mostly underrepresented minority students. We found that the abilities of students to solve problems using flowcharts is a good predictor of their ability to solve problems with Python (r-squared = 0.68). This means that the majority of students who perform well using flowcharts will perform well in Python. A majority of students found flowcharting easier than Python (63%), and reported that flowcharting helped them understand how to write programs in Python (73%). However, flowcharting is not a magic bullet for learning programming because about 31% of students have difficulty solving problems with a flowcharting tool (and Python). We also found that the ability of students to read code is not highly correlated with their ability to write code in Python. In conclusion: 1) For a majority of students flowcharting is an effective scaffolding tool to learn Python; 2) The ability to read and trace code is not predictive of the ability of students to solve problems and write viable programs in Python.",2377-634X;1539-4565,978-1-5386-1174-6978-1-5386-1175,10.1109/FIE.2018.8658891,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8658891,"Flowcharting, Python, program comprehension, program generation, novice programmers, computer science education",Python;Flowcharts;Programming profession;Tools;Problem-solving,computer aided instruction;computer science education;educational institutions;flowcharting;programming languages;Python,Python;flowcharting tool;scaffolding tool;programming language;urban institution,,,23,,,,,IEEE,IEEE Conferences
Consistent Layout for Thematic Software Maps,A. Kuhn; P. Loretan; O. Nierstrasz,NA; NA; NA,2008 15th Working Conference on Reverse Engineering,,2008,,,209,218,"Software visualizations can provide a concise overview of a complex software system. Unfortunately, since software has no physical shape, there is no ``natural'' mapping of software to a two-dimensional space. As a consequence most visualizations tend to use a layout in which position and distance have no meaning, and consequently layout typical diverges from one visualization to another. We propose a consistent layout for software maps in which the position of a software artifact reflects its vocabulary, and distance corresponds to similarity of vocabulary. We use latent semantic indexing (LSI) to map software artifacts to a vector space, and then use multidimensional scaling (MDS) to map this vector space down to two dimensions.The resulting consistent layout allows us to develop a variety of thematic software maps that express very different aspects of software while making it easy to compare them. The approach is especially suitable for comparing views of evolving software, since the vocabulary of software artifacts tends to be stable over time.",1095-1350;2375-5369,978-0-7695-3429,10.1109/WCRE.2008.45,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656412,software visualization;program comprehension,Software;Layout;Distance measurement;Vocabulary;Visualization;Large scale integration;Software systems,data visualisation,thematic software maps;software visualizations;complex software system;software artifact;latent semantic indexing;multidimensional scaling,,18,31,,,,,IEEE,IEEE Conferences
REPENT: Analyzing the Nature of Identifier Renamings,V. Arnaoudova; L. M. Eshkevari; M. D. Penta; R. Oliveto; G. Antoniol; Y. Guéhéneuc,"Polytechnique Montréal, Québec, Canada; Polytechnique Montréal, Québec, Canada; University of Sannio, Benevento, Italy; University of Molise, Pesche (IS), Italy; Polytechnique Montréal, Québec, Canada; Polytechnique Montréal, Québec, Canada",IEEE Transactions on Software Engineering,,2014,40,5,502,532,"Source code lexicon plays a paramount role in software quality: poor lexicon can lead to poor comprehensibility and even increase software fault-proneness. For this reason, renaming a program entity, i.e., altering the entity identifier, is an important activity during software evolution. Developers rename when they feel that the name of an entity is not (anymore) consistent with its functionality, or when such a name may be misleading. A survey that we performed with 71 developers suggests that 39 percent perform renaming from a few times per week to almost every day and that 92 percent of the participants consider that renaming is not straightforward. However, despite the cost that is associated with renaming, renamings are seldom if ever documented-for example, less than 1 percent of the renamings in the five programs that we studied. This explains why participants largely agree on the usefulness of automatically documenting renamings. In this paper we propose REanaming Program ENTities (REPENT), an approach to automatically document-detect and classify-identifier renamings in source code. REPENT detects renamings based on a combination of source code differencing and data flow analyses. Using a set of natural language tools, REPENT classifies renamings into the different dimensions of a taxonomy that we defined. Using the documented renamings, developers will be able to, for example, look up methods that are part of the public API (as they impact client applications), or look for inconsistencies between the name and the implementation of an entity that underwent a high risk renaming (e.g., towards the opposite meaning). We evaluate the accuracy and completeness of REPENT on the evolution history of five open-source Java programs. The study indicates a precision of 88 percent and a recall of 92 percent. In addition, we report an exploratory study investigating and discussing how identifiers are renamed in the five programs, according to our taxonomy.",0098-5589;1939-3520;2326-3881,,10.1109/TSE.2014.2312942,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6776542,Identifier renaming;refactoring;program comprehension;mining software repositories;empirical study,Taxonomy;Semantics;Java;Grammar;Software;History;Documentation,data flow analysis;pattern classification;software fault tolerance;software quality;source code (software),identifier renaming analysis;REPENT;source code lexicon;software quality;software fault-proneness;program entity renaming;entity identifier;software evolution;reanaming program entities;data flow analysis;natural language tools;taxonomy dimensions;public API;open-source Java programs,,24,58,,,,,IEEE,IEEE Journals
Do Extracted State Machine Models Help to Understand Embedded Software?,W. Said; J. Quante; R. Koschke,"Robert Bosch GmbH, Germany; Robert Bosch GmbH, Germany; University of Bremen, Germany",2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC),,2019,,,191,196,"Program understanding is a prerequisite for several software activities, such as maintenance, evolution, and reengineering. Code in itself is so detailed that it is often hard to understand. More abstract models describing its behaviour may ease program understanding. Manually building understandable abstractions from complex source code – as an explicit or just mental model – requires in-depth analysis of the code in the first place. Therefore, it is a time-consuming and tedious activity for developers. Model mining can support program comprehension by semi-automatically extracting high-level models from code. One helpful model is a state machine, which is an established formalism for specifying the behaviour of a software component. In this paper, we report on a controlled experiment that investigates the question: Do semi-automatically extracted state machines make understanding of complex embedded code more effective? The experiment was conducted with 30 participants on two industrial embedded C code functions. The results show that the share of correct answers increases and the required time to solve the tasks decreases significantly when extracted state machines are available. We conclude that mined state machines do in fact help in program understanding.",2643-7171;2643-7147,978-1-7281-1519-1978-1-7281-1520,10.1109/ICPC.2019.00038,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813256,"program comprehension, controlled experiment, reverse engineering, state machines, embedded legacy software",,,,,,36,,,,,IEEE,IEEE Conferences
Code understanding,,,2012 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC),,2012,,,109,109,Start of the above-titled section of the conference proceedings record.,1943-6106;1943-6092;1943-6092,978-1-4673-0853-3978-1-4673-0852-6978-1-4673-0851,10.1109/VLHCC.2012.6344493,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6344493,,,,,,,,,,,,IEEE,IEEE Conferences
Proceedings 11th IEEE International Workshop on Program Comprehension,,,"11th IEEE International Workshop on Program Comprehension, 2003.",,2003,,,,,The following topics are dealt with: static analysis techniques; program understanding tools and techniques; dynamic analysis techniques; program comprehension approaches; fact extraction techniques; comprehension frameworks and evaluation; clustering applications and evaluation.,1092-8138,0-7695-1883,10.1109/WPC.2003.1199183,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199183,,,reverse engineering;systems analysis;program debugging,static analysis techniques;program understanding tools;dynamic analysis;program comprehension;fact extraction techniques;comprehension frameworks,,,,,,,,IEEE,IEEE Conferences
Proceedings. 6th International Workshop on Program Comprehension. IWPC'98 (Cat. No.98TB100242),,,Proceedings. 6th International Workshop on Program Comprehension. IWPC'98 (Cat. No.98TB100242),,1998,,,iii,,,1092-8138,0-8186-8560,10.1109/WPC.1998.693270,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=693270,,,reverse engineering;systems re-engineering;software maintenance;grammars,program visualisation;software architecture;integration frameworks;comprehension strategies;parsing;program decomposition;empirical studies;program analysis;program comprehension,,,,,,,,IEEE,IEEE Conferences
Research track: Session I — Program comprehension,,,2012 28th IEEE International Conference on Software Maintenance (ICSM),,2012,,,5,5,Start of the above-titled section of the conference proceedings record.,1063-6773,978-1-4673-2312-3978-1-4673-2313,10.1109/ICSM.2012.6405246,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6405246,,,,,,,,,,,,IEEE,IEEE Conferences
Proceedings of the 2009 IEEE 17th International Conference on Program Comprehension [USB welcome page],,,2009 IEEE 17th International Conference on Program Comprehension,,2009,,,ii,ii,USB welcome page for the 2009 IEEE 17th International Conference on Program Comprehension.,1092-8138,978-1-4244-3998-0978-1-4244-3997,10.1109/ICPC.2009.5090013,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090013,,,,,,,,,,,,IEEE,IEEE Conferences
15th IEEE International Conference on Program Comprehension - Cover,,,15th IEEE International Conference on Program Comprehension (ICPC '07),,2007,,,c1,c1,Presents the front and back cover art for the 15th IEEE International Conference on Program Comprehension (ICPC '07) proceedings.,1092-8138,0-7695-2860,10.1109/ICPC.2007.3,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268226,,,,,,,,,,,,IEEE,IEEE Conferences
15th IEEE International Conference on Program Comprehension - Copyright,,,15th IEEE International Conference on Program Comprehension (ICPC '07),,2007,,,iv,iv,"Copyright and Reprint Permissions: Abstracting is permitted with credit to the source. Libraries may photocopy beyond the limits of US copyright law, for private use of patrons, those articles in this volume that carry a code at the bottom of the first page, provided that the per-copy fee indicated in the code is paid through the Copyright Clearance Center. The papers in this book comprise the proceedings of the meeting mentioned on the cover and title page. They reflect the authors' opinions and, in the interests of timely dissemination, are published as presented and without change. Their inclusion in this publication does not necessarily constitute endorsement by the editors or the Institute of Electrical and Electronics Engineers, Inc.",1092-8138,0-7695-2860,10.1109/ICPC.2007.2,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268228,,,,,,,,,,,,IEEE,IEEE Conferences
Proceedings. 12th IEEE International Workshop on Program Comprehension,,,"Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.",,2004,,,,,,1092-8138,0-7695-2149,10.1109/WPC.2004.1311035,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311035,,,reverse engineering;program visualisation;Unified Modeling Language;Internet,program comprehension;UML;software comprehension;analysis techniques;reverse engineering;software visualization;software artifacts;Web-based systems;program clustering,,,,,,,,IEEE,IEEE Conferences
14th IEEE International Conference on Program Comprehension - Title Page,,,14th IEEE International Conference on Program Comprehension (ICPC'06),,2006,,,i,iii,The following topics are dealt with: program comprehension; software engineering; software maintenance; software system evolution; static analysis; quality assessment; dynamic analysis; tool demonstration; cognitive approaches; program traceability; programming languages,1092-8138,0-7695-2601,10.1109/ICPC.2006.4,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631091,,,reverse engineering;software maintenance;software prototyping;software quality;software tools;system monitoring,program comprehension;software engineering;software maintenance;software system evolution;static analysis;quality assessment;dynamic analysis;tool demonstration;cognitive approaches;program traceability;programming languages,,,,,,,,IEEE,IEEE Conferences
18th IEEE International Conference on Program Comprehension [Cover art],,,2010 IEEE 18th International Conference on Program Comprehension,,2010,,,C1,C1,Presents the cover of the 2010 IEEE 18th International Conference on Program Comprehension proceedings.,1092-8138;1092-8138,978-1-4244-7603-9978-1-4244-7604-6978-0-7695-4113,10.1109/ICPC.2010.56,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521784,,,,,,,,,,,,IEEE,IEEE Conferences
Proceedings: Fourth Workshop on Program Comprehension,,,WPC '96. 4th Workshop on Program Comprehension,,1996,,,i,,,1092-8138,0-8186-7283,10.1109/WPC.1996.501114,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501114,,,,,,,,,,,,IEEE,IEEE Conferences
14th IEEE International Conference on Program Comprehension - Table of Contents,,,14th IEEE International Conference on Program Comprehension (ICPC'06),,2006,,,v,vii,Presents the table of contets for the 14th IEEE International Conference on Program Comprehension (ICPC'06) proceedings.,1092-8138,0-7695-2601,10.1109/ICPC.2006.3,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631093,,,,,,,,,,,,IEEE,IEEE Conferences
Proceedings Fifth International Workshop on Program Comprehension. IWPC'97,,,Proceedings Fifth International Workshop on Program Comprehension. IWPC'97,,1997,,,iii,,,1092-8138,0-8186-7993,10.1109/WPC.1997.601255,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601255,,,reverse engineering;software engineering,software comprehension;automated program understanding;program analysis;program comprehension;reusable assets;panel infrastructure;software reengineering;software tools,,,,,,,,IEEE,IEEE Conferences
Proceedings. 13th International Workshop on Program Comprehension,,,13th International Workshop on Program Comprehension (IWPC'05),,2005,,,,,The following topics are dealt with: program comprehension; program framework understanding; object-oriented programming; software tools; code refactoring; dynamic program analysis; software visualization; software clustering; software components; reverse engineering.,1092-8138,0-7695-2254,10.1109/WPC.2005.16,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421004,,,reverse engineering;software tools;system monitoring;object-oriented programming;systems re-engineering,program comprehension;program framework understanding;object-oriented programming;software tools;code refactoring;dynamic program analysis;software visualization;software clustering;software components;reverse engineering,,,,,,,,IEEE,IEEE Conferences
16th IEEE International Conference on Program Comprehension [Cover art],,,2008 16th IEEE International Conference on Program Comprehension,,2008,,,C1,C1,"The following topics are discussed: program comprehension; software evolution; dynamic analysis; domain terms; software metrics; cloning, slicing and parsing; and revision history analysis.",1092-8138,978-0-7695-3176,10.1109/ICPC.2008.48,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556101,,,configuration management;program compilers;program slicing;software maintenance;software metrics,program comprehension;software evolution;dynamic analysis;domain terms;software metrics;software cloning;software slicing;parsing;revision history analysis,,,,,,,,IEEE,IEEE Conferences
10th International Workshop on Program Comprehension,,,Proceedings 10th International Workshop on Program Comprehension,,2002,,,iii,vii,,1092-8138,0-7695-1495,10.1109/WPC.2002.1021302,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021302,,,,,,,,,,,,IEEE,IEEE Conferences
Proceedings 9th International Workshop on Program Comprehension. IWPC 2001,,,Proceedings 9th International Workshop on Program Comprehension. IWPC 2001,,2001,,,iii,,,1092-8138,0-7695-1131,10.1109/WPC.2001.921707,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921707,,,reverse engineering;software engineering,program comprehension;program visualization;program analysis;program understanding;software tools;design recovery;case studies;analysis tools;re-documentation,,,,,,,,IEEE,IEEE Conferences
Proceedings IWPC 2000. 8th International Workshop on Program Comprehension,,,Proceedings IWPC 2000. 8th International Workshop on Program Comprehension,,2000,,,i,,,1092-8138,0-7695-0656,10.1109/WPC.2000.852473,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852473,,,reverse engineering;software quality;software architecture;software maintenance;system recovery;software tools;program diagnostics;software metrics;pattern clustering,program comprehension;software quality analysis;architecture recovery;reverse engineering;tools;software metrics;slicing;clustering techniques;concept analysis,,,,,,,,IEEE,IEEE Conferences
Proceedings IEEE Second Workshop on Program Comprehension (Cat. No.93TH0551-2),,,[1993] IEEE Second Workshop on Program Comprehension,,1993,,,0_1,,,1092-8138,0-8186-4042,10.1109/WPC.1993.263913,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263913,,,software maintenance;software reusability;software tools,software maintenance;software reusability;program comprehension;program representations;documents;tools,,,,,,,,IEEE,IEEE Conferences
Proceedings Seventh International Workshop on Program Comprehension,,,Proceedings Seventh International Workshop on Program Comprehension,,1999,,,iii,,,1092-8138,0-7695-0180,10.1109/WPC.1999.777731,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=777731,,,reverse engineering;program slicing;software maintenance,parsing;visualization;architectures for understanding;comprehension strategies;integration frameworks;decomposition;empirical aspects;program analysis;composition,,,,,,,,IEEE,IEEE Conferences
Proceedings 12th International Workshop on Program Comprehension,,,"Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.",,2004,,,0_1,0_1,Presents the front cover or splash screen of the proceedings.,1092-8138,0-7695-2149,10.1109/WPC.2004.1311032,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311032,,,,,,,,,,,,IEEE,IEEE Conferences
15th IEEE International Conference on Program Comprehension - Title,,,15th IEEE International Conference on Program Comprehension (ICPC '07),,2007,,,i,iii,The following topics are dealt with: program comprehension; software engineering; formal concept analysis; object-oriented reverse engineering; UML; software repository mining; dynamic program analysis; conceptual model; static program analysis and program visualization.,1092-8138,0-7695-2860,10.1109/ICPC.2007.5,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268227,,,reverse engineering;system monitoring,program comprehension;software engineering;formal concept analysis;object-oriented reverse engineering;UML;software repository mining;dynamic program analysis;conceptual model;static program analysis;program visualization,,,,,,,,IEEE,IEEE Conferences
14th IEEE International Conference on Program Comprehension - Cover,,,14th IEEE International Conference on Program Comprehension (ICPC'06),,2006,,,c1,c1,Presents the cover of the 14th IEEE International Conference on Program Comprehension (ICPC'06) proceedings.,1092-8138,0-7695-2601,10.1109/ICPC.2006.2,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631090,,,,,,,,,,,,IEEE,IEEE Conferences
15th IEEE International Conference on Program Comprehension - Table of Contents,,,15th IEEE International Conference on Program Comprehension (ICPC '07),,2007,,,v,viii,Presents the table of contents for the 15th IEEE International Conference on Program Comprehension (ICPC '07).,1092-8138,0-7695-2860,10.1109/ICPC.2007.4,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268229,,,,,,,,,,,,IEEE,IEEE Conferences
14th IEEE International Conference on Program Comprehension - Copyright,,,14th IEEE International Conference on Program Comprehension (ICPC'06),,2006,,,iv,iv,"Copyright and Reprint Permissions: Abstracting is permitted with credit to the source. Libraries may photocopy beyond the limits of US copyright law, for private use of patrons, those articles in this volume that carry a code at the bottom of the first page, provided that the per-copy fee indicated in the code is paid through the Copyright Clearance Center. The papers in this book comprise the proceedings of the meeting mentioned on the cover and title page. They reflect the authors' opinions and, in the interests of timely dissemination, are published as presented and without change. Their inclusion in this publication does not necessarily constitute endorsement by the editors or the Institute of Electrical and Electronics Engineers, Inc.",1092-8138,0-7695-2601,10.1109/ICPC.2006.1,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631092,,,,,,,,,,,,IEEE,IEEE Conferences
Proceedings 1994 IEEE 3rd Workshop on Program Comprehension - WPC '94,,,Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94,,1994,,,0_1,,,1092-8138,0-8186-5647,10.1109/WPC.1994.341232,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341232,,,reverse engineering;program diagnostics;system documentation;object-oriented programming;parallel programming;database management systems;software tools,software tools;object oriented programming;program comprehension;methodology;reverse engineering;documentation;parallel programming;database management systems,,,,,,,,IEEE,IEEE Conferences
Evolving a Legacy Application Portfolio at Sallie Mae: Program Comprehension and Beyond,R. S. Autor,SLM Corporation,14th IEEE International Conference on Program Comprehension (ICPC'06),,2006,,,xiii,xiii,"Robert Autor is the executive vice president and chief information officer of SLM Corporation, where he leads the company’s information technology division, loan consolidation business and corporate procurement division.",1092-8138,0-7695-2601,10.1109/ICPC.2006.22,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631098,,,,,,,,,,,,IEEE,IEEE Conferences
"Theories, methods and tools in program comprehension: past, present and future",M. -. Storey,"Dept. of Comput. Sci., Victoria Univ., BC, Canada",13th International Workshop on Program Comprehension (IWPC'05),,2005,,,181,191,"Program comprehension research can be characterized by both the theories that provide rich explanations about how programmers comprehend software, as well as the tools that are used to assist in comprehension tasks. During this talk the author review some of the key cognitive theories of program comprehension that have emerged. Using these theories as a canvas, the author then explores how tools that are popular today have evolved to support program comprehension. Specifically, the author discusses how the theories and tools are related and reflect on the research methods that were used to construct the theories and evaluate the tools. The reviewed theories and tools will be further differentiated according to human characteristics, program characteristics, and the context for the various comprehension tasks. Finally, the author predicts how these characteristics will change in the future and speculate on how a number of important research directions could lead to improvements in program comprehension tools and methods.",1092-8138,0-7695-2254,10.1109/WPC.2005.38,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421034,,Programming profession;Software tools;Software engineering;Computer science;Electronic mail;Humans;Silver;Buildings;History;Conferences,software tools;cognition;reverse engineering,program comprehension tools;human characteristics;program characteristics,,54,49,,,,,IEEE,IEEE Conferences
The Influence of Different AOI Models in Source Code Comprehension Analysis,F. Deitelhoff; A. Harrer; A. Kienle,University of Applied Sciences and Arts Dortmund; University of Applied Sciences and Arts Dortmund; University of Applied Sciences and Arts Dortmund,2019 IEEE/ACM 6th International Workshop on Eye Movements in Programming (EMIP),,2019,,,10,17,"In source code comprehension, researchers frequently analyze eye movement data in order to find patterns to test hypotheses. For such an analysis, fixations are often assigned to objects of a stimulus, like tokens, code lines or code regions, through areas of interest (AOI). There are multiple ways to define an AOI which can have a broad impact on the analysis of the eye movement data. In this paper, we analyzed the impact of choosing two different AOI models, both as extreme points from a methodical point of view. We propose one AOI model and compare it to the AOI model from the EMIP dataset. Within the data, we found indications, that one AOI model captures less AOI transitions compared to the other model. A qualitative investigation showed, that some of these AOI transitions can be important for understanding the viewing and comprehension strategy of the participant. In conclusion, we argue, that every researcher should report the chosen AOI model and the particular AOI definitions used in a study, to understand their research. Additionally, we suggest a simple algorithm to test, which AOI model configuration will capture a majority of data points.",,,10.1109/EMIP.2019.00010,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8834701,program comprehension;source code comprehension;eye tracking;areas of interest;data fishing;signal detection;AOI-DNA;AOI-STG,Data models;Analytical models;Programming;Gaze tracking;Signal detection;Distributed databases;Conferences,eye;gaze tracking;program diagnostics,source code comprehension analysis;eye movement data;code lines;code regions;AOI model captures;AOI transitions;comprehension strategy;particular AOI definitions;AOI model configuration;data points;EMIP dataset,,,14,,,,,IEEE,IEEE Conferences
The effectiveness of control structure diagrams in source code comprehension activities,D. Hendrix; J. H. Cross; S. Maghsoodloo,"Dept. of Comput. Sci. & Software Eng., Auburn Univ., AL, USA; Dept. of Comput. Sci. & Software Eng., Auburn Univ., AL, USA; NA",IEEE Transactions on Software Engineering,,2002,28,5,463,477,"Recently, the first two in a series of planned comprehension experiments were performed to measure the effect of the control structure diagram (CSD) on program comprehensibility. Upper- and lower-division computer science and software engineering students were asked to respond to questions regarding the structure and execution of one source code module of a public domain graphics library. The time taken for each response and the correctness of each response was recorded. Statistical analysis of the data collected from these two experiments revealed that the CSD was highly significant in enhancing the subjects' performance in this program comprehension task. The results of these initial experiments promise to shed light on fundamental questions regarding the effect of software visualizations on program comprehensibility.",,,10.1109/TSE.2002.1000450,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1000450,,Performance evaluation;Computer science;Software engineering;Computer graphics;Software libraries;Statistical analysis;Data visualization,diagrams;reverse engineering;program visualisation;program control structures,control structure diagrams;source code comprehension;experiments;program comprehensibility;computer science students;software engineering students;public domain graphics library;statistical analysis;data analysis;software visualizations,,20,43,,,,,IEEE,IEEE Journals
COCONUT: COde COmprehension Nurturant Using Traceability,A. D. Lucia; M. D. Penta; R. Oliveto; F. Zurolo,"University of Salerno, Fisciano, Italy; University of Sannio, Benevento, Italy; University of Salerno, Fisciano, Italy; University of Salerno, Fisciano, Italy",2006 22nd IEEE International Conference on Software Maintenance,,2006,,,274,275,"In this paper we present an Eclipse plug-in, called COCONUT (COde COmprehension Nurturant Using Traceability), that shows the similarity level between the source code under development and high-level artefacts the source code should be traced onto. Also, the plug-in suggests candidate source code identifiers according to the domain terms contained into the corresponding high-level artefacts. Experiments showed that the plug-in helps to produce source code easier to be understood",,,10.1109/ICSM.2006.19,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4021349,,Visualization;Software maintenance;Programming profession;Java;Mathematics;Informatics;Automatic control;Unified modeling language;Uniform resource locators;Information retrieval,program diagnostics;reverse engineering;software tools,Eclipse plug-in;COde COmprehension Nurturant Using Traceability,,5,4,,,,,IEEE,IEEE Conferences
CRISTA: A tool to support code comprehension based on visualization and reading technique,D. Porto; M. Mendonca; S. Fabbri,Federal University of São Carlos - Brazil; University of Salvador - Brazil; Federal University of São Carlos - Brazil,2009 IEEE 17th International Conference on Program Comprehension,,2009,,,285,286,"This paper presents a tool named CRISTA that supports code comprehension through the application of stepwise abstraction. It uses a visual metaphor to represent the code and supports essential tasks for code reading, inspection and documentation. As code comprehension is time consuming, a tool can greatly improve such activity.",,,10.1109/ICPC.2009.5090060,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090060,,Visualization;Inspection;Documentation;Java;Reverse engineering;Switches;Software maintenance;Libraries;Software engineering;Programming profession,program testing;program visualisation;reverse engineering;software maintenance;system documentation,code comprehension;reading technique;visualization technique;stepwise abstraction;code inspection;code documentation;software maintenance,,1,4,,,,,IEEE,IEEE Conferences
From code comprehension model to tool capabilities,A. von Mayrhauser; A. M. Vans,"Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA; Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA",Proceedings of ICCI'93: 5th International Conference on Computing and Information,,1993,,,469,473,"A major portion of the maintenance effort is spent trying to understand existing software. If we can learn more about how programmers understand code successfully, we can build better tools to support this understanding process. An effective maintenance tool must help in code comprehension and support the code understanding process. We present an integrated comprehension model and a technique for developing detailed tool capability requirements.<>",,,10.1109/ICCI.1993.315327,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=315327,,Programming profession;Computer science;Buildings;Switches;Software maintenance;Cognition;Appropriate technology;Cognitive science;Sorting,software maintenance,code comprehension model;tool capabilities;software maintenance;integrated comprehension model,,1,10,,,,,IEEE,IEEE Conferences
Synchronized Analysis of Eye Movement and EEG during Program Comprehension,T. Ishida; H. Uwano,"National Institute of Technology, Nara College; National Institute of Technology, Nara College",2019 IEEE/ACM 6th International Workshop on Eye Movements in Programming (EMIP),,2019,,,26,32,"Appropriate support for program comprehension contributes to efficient software development. Several previous studies used bio-information such as brain activity to classify the inner-state of programmer without interruption. In this paper, we measure programmer's brain waves and eye movement simultaneously while they comprehend the source code. In the experiment, we analyze difference of time-series brain wave features between success/failure for source code comprehension task. The result of the experiment showed the participants who success source code comprehension significantly increased power spectrum of α wave with the time passage. Also the eye movements of the succeed participants shift their focus of fixation from specification to source code in early time. Synchronized analysis of failed programmer shows similar but slow pattern of EEG and eye movement changes compared with succeed programmer.",,,10.1109/EMIP.2019.00012,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8834699,"EEG, Eye movement, Synchronized analysis, Program comprehension",Electroencephalography;Task analysis;Electrodes;Synchronization;Atmospheric measurements;Particle measurements;Tools,bioelectric potentials;biomechanics;electroencephalography;eye;medical signal processing;neurophysiology;source coding,software development efficiency;EEG analysis;programmer's brain wave measurement;programmer's eye movement measurement;α wave;source code comprehension task;time-series brain wave features;bio-information;synchronized analysis,,,20,,,,,IEEE,IEEE Conferences
Eye Tracking and Program Comprehension,D. G. Feitelson,Hebrew University of Jerusalem,2019 IEEE/ACM 6th International Workshop on Eye Movements in Programming (EMIP),,2019,,,1,1,"Reading and comprehending code is different from reading regular text. And eye tracking, which measures where we look, for how long, and how much mental effort we exert, can provide crucial data. The talk will survey some achievements and suggest future directions.",,,10.1109/EMIP.2019.00008,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8834692,,Gaze tracking;Tools;Conferences;Software engineering;Computer science;Software;Measurement,gaze tracking;software metrics;text analysis;user interfaces,eye tracking;mental effort;program comprehension;regular text,,,0,,,,,IEEE,IEEE Conferences
Does the Documentation of Design Pattern Instances Impact on Source Code Comprehension? Results from Two Controlled Experiments,C. Gravino; M. Risi; G. Scanniello; G. Tortora,NA; NA; NA; NA,2011 18th Working Conference on Reverse Engineering,,2011,,,67,76,"We present the results of a controlled experiment and a differentiated replication that have been carried out to assess the effect of the documentation of design patterns on the comprehension of source code. The two experiments involved Master Students in Computer Science at the University of Basilicas a and at University of Salerno, respectively. The participants to the original experiment performed a comprehension task with and without graphically-documented design patterns. Textually documented design patterns were provided or not to the participants to perform a comprehension task within the replication. The data analysis revealed that participants employing graphically documented design patterns achieved significantly better performances than the participants provided with source code alone. Conversely, the effect of textually documented design patterns was not statistically significant. A further analysis revealed that the documentation type (textual and graphical) does not significantly affect the performance, when participants correctly recognize design pattern instances.",,,10.1109/WCRE.2011.18,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079776,Design Patterns;Controlled Experiment;Maintenance,Documentation;Unified modeling language;Educational institutions;Maintenance engineering;Software systems;Particle measurements,computer graphics;computer science education;data analysis;design of experiments;software engineering;source coding;system documentation,design pattern instances;source code comprehension;controlled experiment;differentiated replication;design patterns documentation;master students;computer science;University of Basilicas;University of Salerno;comprehension task;graphically-documented design patterns;textually documented design patterns;data analysis;documentation type,,4,21,,,,,IEEE,IEEE Conferences
Industrial experience with an integrated code comprehension model,A. von Mayrhauser; A. M. Vans,"Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA; Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA",Software Engineering Journal,,1995,10,5,171,182,"Maintenance frequently consumes more resources than new software development. A major portion of the maintenance effort is spent trying to understand existing software. If more can be learnt about how programmers understand code successfully, better tools to support this understanding process can be built. This contributes to higher quality and improved efficiency of maintenance tasks. Audio-taped 'think aloud' reports were used to investigate an integrated code comprehension model during a variety of industrial maintenance activities. The tapes were analysed for information needs during maintenance activities and used to derive useful tool capabilities.<>",,,10.1049/sej.1995.0023,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=469502,,Software maintenance;Software development management;Reverse engineering,software maintenance;software development management;reverse engineering,industrial experience;integrated code comprehension model;software development;software maintenance effort;maintenance tasks;audio-taped think aloud reports;industrial maintenance activities;information needs;maintenance activities;tool capabilities,,23,,,,,,IET,IET Journals
"Towards a Tool for Rigorous, Automated Code Comprehension Using Symbolic Execution and Semantic Analysis",M. E. M. Stewart,"QSS Group Inc. at NASA Glenn Research Center Brook Park, Ohio, USA",29th Annual IEEE/NASA Software Engineering Workshop,,2005,,,89,96,"This paper presents an implementation and critical analysis of a technique for automated, rigorous scientific program comprehension and error detection. The procedure involves taking a user's existing code, adding semantic declarations for some primitive variables, symbolically executing the user's code, and recognizing semantic concepts from the symbolic expressions generated. This analysis provides high-level, semantic information and detects errors in a user's code. Symbolic execution of a 5k line of code (LOC) scientific code demonstrates implementation of a practical symbolic execution/semantic analysis tool. Despite the promise of this technique, one key challenge is examined, namely ensuring reliability during the symbolic execution/semantic analysis procedure",,,10.1109/SEW.2005.46,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1521197,,Costs;NASA;Lab-on-a-chip;Programming;Software engineering;Software maintenance;Information analysis;Hardware;Manuals;Debugging,natural sciences computing;program debugging;program diagnostics;programming language semantics;symbol manipulation,automated code comprehension;symbolic execution tool;semantic analysis tool;automated rigorous scientific program comprehension;error detection,,4,14,,,,,IEEE,IEEE Conferences
A Replication Study on Code Comprehension and Expertise using Lightweight Biometric Sensors,D. Fucci; D. Girardi; N. Novielli; L. Quaranta; F. Lanubile,"University of Hamburg, Germany; University of Bari, Italy; University of Bari, Italy; University of Bari, Italy; University of Bari, Italy",2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC),,2019,,,311,322,"Code comprehension has been recently investigated from physiological and cognitive perspectives using medical imaging devices. Floyd et al. (i.e., the original study) used fMRI to classify the type of comprehension tasks performed by developers and relate their results to their expertise. We replicate the original study using lightweight biometrics sensors. Our study participants-28 undergrads in computer science-performed comprehension tasks on source code and natural language prose. We developed machine learning models to automatically identify what kind of tasks developers are working on leveraging their brain-, heart-, and skin-related signals. The best improvement over the original study performance is achieved using solely the heart signal obtained through a single device (BAC 87%vs. 79.1%). Differently from the original study, we did not observe a correlation between the participants' expertise and the classifier performance (τ= 0.16, p= 0.31). Our findings show that lightweight biometric sensors can be used to accurately recognize comprehension opening interesting scenarios for research and practice.",,,10.1109/ICPC.2019.00050,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813259,machine learning;software development tasks;biometric sensors,,biomedical MRI;biometrics (access control);brain;cardiology;cognition;learning (artificial intelligence);natural language processing;sensors;signal classification,performed comprehension task;heart signal;brain signal;fMRI;machine learning model;lightweight biometrics sensors;medical imaging devices;cognitive perspectives;physiological perspectives;code comprehension;replication study;lightweight biometric sensors;classifier performance;skin-related signals,,,48,,,,,IEEE,IEEE Conferences
An Early Investigation on the Contribution of Class and Sequence Diagrams in Source Code Comprehension,G. Scanniello; C. Gravino; G. Tortora,"Dipt. di Mat. e Inf., Univ. della Basilicata, Potenza, Italy; Dept. of Manage. & Inf. Technol., Univ. of Salerno, Salerno, Italy; Dept. of Manage. & Inf. Technol., Univ. of Salerno, Salerno, Italy",2013 17th European Conference on Software Maintenance and Reengineering,,2013,,,367,370,"We report the preliminary results of a controlled experiment conducted to analyze whether the combined use of UML class and sequence diagrams better supports source code comprehension with respect to the use of class and sequence diagrams alone. We also investigated which notation between class and sequence diagrams provides a better support in the execution of comprehension tasks on source code. The results suggest that it is better to use class and sequence diagrams together with respect to using either class or sequence diagrams alone. The difference in the source code comprehension is statistically significant with respect to the use of class diagrams alone, while is not statistically significant with respect to the sequence diagrams alone.",,,10.1109/CSMR.2013.51,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6498490,Comprehension;Controlled Experiment;UML,Unified modeling language;Object oriented modeling;Software engineering;Maintenance engineering;Software systems;Software maintenance,diagrams;Unified Modeling Language,UML class diagrams;sequence diagrams;source code comprehension,,4,15,,,,,IEEE,IEEE Conferences
Incremental Annotate-Generalize-Search Framework for Interactive Source Code Comprehension,K. Nakayama; S. Tano; T. Hashiyama; E. Sakai,NA; NA; NA; NA,2017 IEEE 41st Annual Computer Software and Applications Conference (COMPSAC),,2017,1,,311,316,"Understanding unfamiliar source code is inherently difficult for a software engineer, despite its importance. Thus, an experienced engineer prefers to guess the intended behavior, rather than to trace it line-by-line, by combining semantic chunks found in the source code. It is, however, still hard for a system to help in this activity, for lack of ways of both representing semantic chunks and of preparing a rich dictionary of chunks. In this paper, an integrated framework for annotating and searching source code is presented. Since the research is still in its early stage, this paper focuses on the framework itself, together with a brief description of our prototype implementation. In the framework, each engineer gathers (annotates) semantic chunks that have the same meaning and interactively generalizes them to get a search pattern. As a result, a dictionary of semantic chunks together with their search patterns is incrementally created through engineer collaboration. To realize this, two representations are used: a tuple of nodes of an abstract syntax tree (AST) for a semantic chunk and a classifier on generative attribute vectors for search patterns.",,,10.1109/COMPSAC.2017.147,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8029623,semantic chunk;abstract syntax tree,Semantics;Knowledge engineering;Syntactics;Natural languages;Software;Collaboration;Systems support,computational linguistics;software maintenance;source code (software);tree data structures,incremental annotate-generalize-search framework;interactive source code comprehension;unfamiliar source code understanding;semantic chunks;search pattern;abstract syntax tree;AST;generative attribute vectors,,,18,,,,,IEEE,IEEE Conferences
Practical Eye Tracking with iTrace,B. Sharif; C. Peterson; D. Guarnera; C. Bryant; Z. Buchanan; V. Zyrianov; J. Maletic,University of Nebraska - Lincoln; University of Nebraska - Lincoln; Kent State University; Kent State University; Kent State University; Kent State University; Kent State University,2019 IEEE/ACM 6th International Workshop on Eye Movements in Programming (EMIP),,2019,,,41,42,"The evolution and effort in designing and implementing iTrace, an infrastructure for integrating eye tracking into developer environments, is presented. The goal is to make eye tracking practical for various stakeholders in software engineering namely researchers, practitioners, and educators. An overview of iTrace and the general process involved in conducting an eye tracking study with human subjects using iTrace is presented in this tool demo paper. Upcoming features and ongoing plans for community involvement are also presented.",,,10.1109/EMIP.2019.00015,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8834693,"eye tracking, practical solution, integrated development environments, program comprehension, empirical studies",Gaze tracking;Tools;Software;Visualization;Software engineering;Computer bugs;Conferences,eye;gaze tracking;object tracking;software engineering,practical eye tracking;developer environments;iTrace;software engineering,,1,4,,,,,IEEE,IEEE Conferences
IoT End User Programming Models,S. Reiss,Brown University,2019 IEEE/ACM 1st International Workshop on Software Engineering Research & Practices for the Internet of Things (SERP4IoT),,2019,,,1,8,"The advent of smart devices and sensors (the Internet of Things or IoT) will create increasing demands for the automation of devices based on sensor, time, and other inputs. This is essentially a programming task with all the problems and difficulties that programming entails, for example, modularity, feature interaction, debugging, and understanding. Moreover, much of the programming for smart devices is going to be done not by professional programmers but by end users, often end users without any programming experience or computational literacy. Our research is aimed at exploring the programming space and the associated issues using a case study of a smart sign that can be controlled using a variety of sensors. We have developed a general system for programming smart devices and, in this paper, explore a variety of different user interfaces for programming this system for our smart sign.",,,10.1109/SERP4IoT.2019.00008,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8900747,Internet of thingws;end-user programming;debugging;program understanding,,,,,,51,,,,,IEEE,IEEE Conferences
Visually Analyzing Students' Gaze on C++ Code Snippets,C. S. Peterson; J. A. Saddler; T. Blascheck; B. Sharif,University of Nebraska - Lincoln; University of Nebraska - Lincoln; Inria; University of Nebraska - Lincoln,2019 IEEE/ACM 6th International Workshop on Eye Movements in Programming (EMIP),,2019,,,18,25,"The paper presents an eye tracking study with 17 students (12 novices, 5 non-novices) reading C++ methods. The novices were students who participated in the study during the last week of their semester learning C++. The non-novices were senior students who had been exposed to programming before. We report on the reading behavior of three C++ methods that use different language constructs. We analyze fixations at the line level of the code using visualizations to derive insights into code reading. Results show that most transitions were made to code lines that are close to the current line read. We observe that a large percentage of the total fixation duration is made on a small number of lines and that related lines are often viewed together in a series of short fixations.",,,10.1109/EMIP.2019.00011,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8834703,eye tracking;visual analysis;program comprehension;C++ source code;scanpaths;transitions,Data visualization;C++ languages;Gaze tracking;Programming;Tools;Task analysis;Visualization,computer science education;data visualisation;gaze tracking;human factors,code lines;C++ code;eye tracking study;senior students;reading behavior;code reading;language constructs;student gaze,,,14,,,,,IEEE,IEEE Conferences
Attention in Software Maintenance: An Eye Tracking Study,M. Ahrens; K. Schneider; M. Busch,Leibniz Universität Hannover; Leibniz Universität Hannover; Leibniz Universität Hannover,2019 IEEE/ACM 6th International Workshop on Eye Movements in Programming (EMIP),,2019,,,2,9,"In software projects, people often continue working on programs that others created. This is especially the case in agile development. Therefore, developers often need to understand unfamiliar code in order to expand, change, fix or review it. Navigating through code and searching for relevant information requires a lot of developer time. This paper introduces an approach to use eye tracking to record and transfer developers' attention during software maintenance. We visualize the recorded data with heatmaps and display switches between Java classes by coloring filenames. These attention representations aim to help developers finding and navigating to relevant code sections faster. We conducted an eye tracking experiment to investigate whether these attention visualizations help developers during software maintenance. The results show that both representations helped some of the participants for orientation and code finding purposes. The heatmaps slightly decreased the cognitive load as well. However, most participants, especially the more experienced ones, rated the attention visualizations as barely helpful or not helpful. Instead, the representations increased their visual effort, reduced the code's clarity and made the overall understanding of the program's functionality, as well as finding relevant areas, more difficult. By testing this specific implementation of the approach of attention transfer, we gained important lessons learned and provide several improvement suggestions.",,,10.1109/EMIP.2019.00009,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8834695,attention transfer;focused attention;eye tracking;software maintenance;program comprehension,Task analysis;Gaze tracking;Software maintenance;Data visualization;Heating systems;History,cognition;data visualisation;Java;learning (artificial intelligence);program debugging;software maintenance,software maintenance;eye tracking study;software projects;agile development;relevant code sections;attention visualizations;visual effort;programs functionality;Java classes;transfer developers attention,,,22,,,,,IEEE,IEEE Conferences
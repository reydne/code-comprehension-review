Document Title	Document Title - ajusted	DOI	PDF Link	Authors	Author Affiliations	Publication Title	Date Added To Xplore	Publication Year	Volume	Issue	Start Page	End Page	Abstract	ISSN	ISBNs	Funding Information	Author Keywords	IEEE Terms	INSPEC Controlled Terms	INSPEC Non-Controlled Terms	Mesh_Terms	Article Citation Count	Patent Citation Count	Reference Count	License	Online Date	Issue Date	Meeting Date	Publisher	Document Identifier
Recommending Code Understandability Improvements Based on Code Reviews	recommending code understandability improvements based on code reviews	10.1109/ASEW52652.2021.00035	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9680313	D. Oliveira	Federal University of Pernambuco, Recife, Brazil	2021 36th IEEE/ACM International Conference on Automated Software Engineering Workshops (ASEW)	24 jan. 2022	2021			131	132	Developers spend 70% of their time understanding code. Code that is easy to read can save time, while hard-to-read code can lead to the introduction of bugs. However, it is difficult to establish what makes code more understandable. Although there are guides and directives on improving code understandability, in some contexts, these practices can have a detrimental effect. Practical software development projects often employ code review to improve code quality, including understandability. Reviewers are often senior developers who have contributed extensively to projects and have an in-depth understanding of the impacts of different solutions on code understandability. This paper is an early research proposal to recommend code understandability improvements based on code reviewer knowledge. The core of the proposal comprises a dataset of code understandability improvements extracted from code reviews. This dataset will serve as a basis to train machine learning systems to recommend understandability improvements.	2151-0830	978-1-6654-3583-3	CAPES/Brazil(grant numbers:88887.582851/2020-0); 	code understandability;code readability;code review;mining repositories	Codes;Conferences;Computer bugs;Machine learning;Software;Proposals;Software engineering	learning (artificial intelligence);program testing;project management;software development management;software engineering;software maintenance;software quality	code understandability improvements;code review;practical software development projects;code quality;code reviewer knowledge				15	IEEE	24 jan. 2022			IEEE	IEEE Conferences
Evaluating Code Readability and Legibility: An Examination of Human-centric Studies	evaluating code readability and legibility an examination of humancentric studies	10.1109/ICSME46990.2020.00041	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9240710	D. Oliveira; R. Bruno; F. Madeiral; F. Castor	Federal University of Pernambuco, Recife, Brazil; Federal University of Pernambuco, Recife, Brazil; KTH Royal Institute of Technology, Stockholm, Sweden; Federal University of Pernambuco, Recife, Brazil	2020 IEEE International Conference on Software Maintenance and Evolution (ICSME)	2 nov. 2020	2020			348	359	Reading code is an essential activity in software maintenance and evolution. Several studies with human subjects have investigated how different factors, such as the employed programming constructs and naming conventions, can impact code readability, i.e., what makes a program easier or harder to read and apprehend by developers, and code legibility, i.e., what influences the ease of identifying elements of a program. These studies evaluate readability and legibility by means of different comprehension tasks and response variables. In this paper, we examine these tasks and variables in studies that compare programming constructs, coding idioms, naming conventions, and formatting guidelines, e.g., recursive vs. iterative code. To that end, we have conducted a systematic literature review where we found 54 relevant papers. Most of these studies evaluate code readability and legibility by measuring the correctness of the subjects' results (83.3%) or simply asking their opinions (55.6%). Some studies (16.7%) rely exclusively on the latter variable. There are still few studies that monitor subjects' physical signs, such as brain activation regions (5%). Moreover, our study shows that some variables are multi-faceted. For instance, correctness can be measured as the ability to predict the output of a program, answer questions about its behavior, or recall parts of it. These results make it clear that different evaluation approaches require different competencies from subjects, e.g., tracing the program vs. summarizing its goal vs. memorizing its text. To assist researchers in the design of new studies and improve our comprehension of existing ones, we model program comprehension as a learning activity by adapting a preexisting learning taxonomy. This adaptation indicates that some competencies, e.g., tracing, are often exercised in these evaluations whereas others, e.g., relating similar code snippets, are rarely targeted.	2576-3148	978-1-7281-5619-4		Code readability;code legibility;code understandability;code understanding;program comprehension	Software maintenance;Systematics;Bibliographies;Taxonomy;Programming;Task analysis;Software engineering	brain;computer aided instruction;computer science education;software maintenance	similar code snippets;code readability;human-centric studies;reading code;software maintenance;human subjects;programming constructs;naming conventions;code legibility;response variables;iterative code;brain activation regions;model program comprehension		6		80		2 nov. 2020			IEEE	IEEE Conferences
An Eye Tracking Perspective on How Developers Rate Source Code Readability Rules	an eye tracking perspective on how developers rate source code readability rules	10.1109/ASEW52652.2021.00037	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9680280	C. S. Peterson; K. -i. Park; I. Baysinger; B. Sharif	University of Nebraska - Lincoln, Lincoln, Nebraska, USA; University of Nebraska - Lincoln, Lincoln, Nebraska, USA; University of Nebraska - Lincoln, Lincoln, Nebraska, USA; University of Nebraska - Lincoln, Lincoln, Nebraska, USA	2021 36th IEEE/ACM International Conference on Automated Software Engineering Workshops (ASEW)	24 jan. 2022	2021			138	139	Writing readable source code is generally considered good practice because it reduces comprehension time for both the original developer and others that have to read and maintain it. We conducted a code readability rating study using eye tracking equipment as part of a larger project where we compared pairs of Java methods side by side. The methods were written such that one followed a readability rule and the other did not. The participants were tasked with rating which method they considered to be more readable. An explanation of the rating was also optionally provided. Eye tracking data was collected and analyzed during the rating process. We found that developers rated the snippet in the pair of methods that avoided nested if statements as more readable on average. There was no clear preference in the use of do-while statements. In addition, more developer fixation attention was on the snippet that avoided do while loops and the snippet pairs relating to nested if statements had more equal fixation attention across the snippets.	2151-0830	978-1-6654-3583-3		source code readability;program comprehension;eye tracking	Java;Codes;Conferences;Gaze tracking;Writing;Task analysis;Software engineering	gaze tracking;Java;software maintenance;source code (software);statistical analysis	readability rule;Java methods side;eye tracking equipment;code readability rating study;comprehension time;readable source code;source code readability rules;eye tracking perspective;snippet pairs;developer fixation attention;statements;rating process;eye tracking data				6	IEEE	24 jan. 2022			IEEE	IEEE Conferences
Using Eye Tracking Technology to Analyze the Impact of Stylistic Inconsistency on Code Readability	using eye tracking technology to analyze the impact of stylistic inconsistency on code readability	10.1109/QRS-C.2017.102	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8004381	Q. Mi; J. Keung; J. Huang; Y. Xiao	Department of Computer Science, City University of Hong Kong, Kowloon, Hong Kong; Department of Computer Science, City University of Hong Kong, Kowloon, Hong Kong; Department of Computer Science, City University of Hong Kong, Kowloon, Hong Kong; Department of Computer Science, City University of Hong Kong, Kowloon, Hong Kong	2017 IEEE International Conference on Software Quality, Reliability and Security Companion (QRS-C)	10 Aug 2017	2017			579	580	A number of research efforts have focused in the area of programming style. However, to the best of our knowledge, there is little sound and solid evidence of how and to what extent can stylistic inconsistency impact the readability and maintainability of the source code. To bridge the research gap, we design an empirical experiment in which eye tracking technology is introduced to quantitatively reflect developers' cog.nitive efforts and mental processes when encountering the inconsistency issue.		978-1-5386-2072-4		programming style;stylistic inconsistency;eye tracking technology;code readability;program comprehension	Gaze tracking;Visualization;Bridges;Software engineering;Indexes;Programming profession	software maintenance;source code (software)	eye tracking technology;stylistic inconsistency;code readability;programming style;source code;research gap;cognitive efforts;mental processes;inconsistency issue;maintainability				3		10 Aug 2017			IEEE	IEEE Conferences
A Method of Program Structure Division Based on Program Understanding	a method of program structure division based on program understanding	10.1109/ICCTD.2009.159	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5359691	Z. Youwei; W. Yonghong; L. Xiaochun	Institute of Surveying and Mapping, Information and Engineering University, Zhengzhou, China; Institute of Surveying and Mapping, Information and Engineering University, Zhengzhou, China; Institute of Surveying and Mapping, Information and Engineering University, Zhengzhou, China	2009 International Conference on Computer Technology and Development	28 Dec 2009	2009	1		363	366	A method of program structure division is introduced in the paper, which is on the basis of program dependence graph. It can divide complex assemble source program into a certain number of program blocks by analyzing the structure of source program, extract the relation of these blocks and show them in a graphic structure called program dependence graph. The result of the test shows that this method has a better commonality and efficiency while being applied to program static understanding analysis.		978-0-7695-3892-1		program block;program dependence graph;calling relation;multi-entry	Data structures;Algorithm design and analysis;Paper technology;Assembly;Data mining;Graphics;Testing;Hardware;Software systems;Costs	data structures;feature extraction;graph theory	program structure division;program dependence graph;complex assemble source program;graphic structure;program static understanding analysis				8	IEEE	28 Dec 2009			IEEE	IEEE Conferences
GitHub, Technical Debt, Code Formatting, and More	github, technical debt, code formatting, and more	10.1109/MS.2017.51	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888414	J. C. Carver; J. Cabot; R. Capilla; H. Muccini	University of Alabama; Interdisciplinary Internet Institute; Rey Juan Carlos University of Madrid; University of L'Aquila	IEEE Software	28 mar. 2017	2017	34	2	105	107	This issue's column reports on papers from the 19th International Conference on Model Driven Engineering Languages and Systems, the 2016 ACM SIGPLAN International Conference on Software Language Engineering, the 12th International ACM SIGSOFT Conference on the Quality of Software Architectures, and the 13th Working IEEE/IFIP Conference on Software Architecture. Topics discussed include GitHub and open source, technical debt in model-driven engineering, a universal code formatter, assuring architectural quality, and continuous architecting.	1937-4194			GitHub;open source;UML;technical debt;code smells;model-driven engineering;code formatting;machine learning;AQAF;Architecture Quality Assurance Framework;AADL;Architecture Analysis and Design Language;architectural quality;continuous architecting;CAFFEA;Continuous Architecture Framework for Embedded and Agile Software Development;software engineering;software development					3				28 mar. 2017			IEEE	IEEE Magazines
The Mind Is a Powerful Place: How Showing Code Comprehensibility Metrics Influences Code Understanding	the mind is a powerful place how showing code comprehensibility metrics influences code understanding	10.1109/ICSE43902.2021.00055	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9402040	M. Wyrich; A. Preikschat; D. Graziotin; S. Wagner	Institute of Software Engineering, University of Stuttgart, Stuttgart, Germany; Institute of Software Engineering, University of Stuttgart, Stuttgart, Germany; Institute of Software Engineering, University of Stuttgart, Stuttgart, Germany; Institute of Software Engineering, University of Stuttgart, Stuttgart, Germany	2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)	7 May 2021	2021			512	523	Static code analysis tools and integrated development environments present developers with quality-related software metrics, some of which describe the understandability of source code. Software metrics influence overarching strategic decisions that impact the future of companies and the prioritization of everyday software development tasks. Several software metrics, however, lack in validation: we just choose to trust that they reflect what they are supposed to measure. Some of them were even shown to not measure the quality aspects they intend to measure. Yet, they influence us through biases in our cognitive-driven actions. In particular, they might anchor us in our decisions. Whether the anchoring effect exists with software metrics has not been studied yet. We conducted a randomized and double-blind experiment to investigate the extent to which a displayed metric value for source code comprehensibility anchors developers in their subjective rating of source code comprehensibility, whether performance is affected by the anchoring effect when working on comprehension tasks, and which individual characteristics might play a role in the anchoring effect. We found that the displayed value of a comprehensibility metric has a significant and large anchoring effect on a developer's code comprehensibility rating. The effect does not seem to affect the time or correctness when working on comprehension questions related to the code snippets under study. Since the anchoring effect is one of the most robust cognitive biases, and we have limited understanding of the consequences of the demonstrated manipulation of developers by non-validated metrics, we call for an increased awareness of the responsibility in code quality reporting and for corresponding tools to be based on scientific evidence.	1558-1225	978-1-6654-0296-5		behavioral software engineering, code comprehension, placebo effect, cognitive bias, anchoring effect, metrics	Measurement;Software metrics;Atmospheric measurements;Tools;Particle measurements;Software;Task analysis	anchors;cognition;program diagnostics;software engineering;software maintenance;software metrics;software quality;software tools	code comprehensibility metrics influences code understanding;static code analysis tools;integrated development environments;quality-related software metrics;everyday software development tasks;anchoring effect;metric value;source code comprehensibility anchors developers;comprehension tasks;comprehensibility metric;developer;comprehension questions;code snippets;nonvalidated metrics;code quality		4		75		7 May 2021			IEEE	IEEE Conferences
Programmer Experience: A Systematic Mapping	programmer experience a systematic mapping	10.1109/TLA.2020.9099749	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9099749	J. Morales; C. Rusu; D. Quiñones	Facultad de Ingeniería, Universidad Autónoma de Chile, Talca, Chile; Pontificia Universidad Católica de Valparaíso, Valparaiso, Chile; Pontificia Universidad Católica de Valparaíso, Valparaiso, Chile	IEEE Latin America Transactions	25 May 2020	2020	18	6	1111	1118	User eXperience (UX) identifies the perceptions of people over of the use (or even the anticipated use) of a product, system or service. The programmers are users of specific systems, and several types of software development artifacts, such as programming environments and design documents. We performed a systematic mapping about Programmer eXperience (PX). In this work we consider the programmers as a particular type of users of particular artifacts. We therefore consider PX as a particular type of UX. The literature usually focuses on PX from a Software Engineering point of view. We analyzed PX mainly from a Human-Computer Interaction (HCI) perspective. We reviewed articles about PX, empirical studies related to aspects of PX, and studies addressing PX on programming environments. The results show that there is an interest on the PX, but the concept is not yet clearly defined. We found 40 articles published in the last ten years and established that the studies address usability and PX aspects focusing on four topics: (i) programming languages, (ii) programmers' interaction with the integrated development environment, (iii) application programming interfaces, and (iv) articles about programmers' behavior. It is a relatively small numbers of articles, compared with other Software Engineering or HCI areas. This represents a research opportunity for this systematic review and others that can be performed.	1548-0992			Programmer experience;Programming environments;Systematic mapping;Usability;User experience	Systematics;Programming environments;Human computer interaction;Usability;IEEE transactions	application program interfaces;human computer interaction;programming environments;software engineering;user experience;user interfaces	systematic mapping;user experience;programming environments;programmer experience;PX;UX;software engineering;HCI areas;integrated development environment;human-computer interaction;software development artifacts;application programming interfaces;design documents		1				25 May 2020			IEEE	IEEE Journals
Moving Towards Program Comprehension in Software Development: A Case Study	moving towards program comprehension in software development a case study	10.1109/ICCMC48092.2020.ICCMC-000122	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9076470	A. Fellah; A. Bandi; M. Yousef	School of Computer Science and Information Systems, Northwest Missouri State University, Maryville, MO, USA; School of Computer Science and Information Systems, Northwest Missouri State University, Maryville, MO, USA; Dept. of Mathematics and Computer Science, University of Central Missouri, Warrensburg, MO, USA	2020 Fourth International Conference on Computing Methodologies and Communication (ICCMC)	23 Apr 2020	2020			660	665	The goal of this paper aims at promoting program comprehension in computer science, in particular software engineering and object-oriented programming courses. The research methodology is evaluated through an empirical study which involves an active participation audience of undergraduate and graduate computer science students. With no previous knowledge on program comprehension, participants were explicitly instructed to use their computing skills and own strategies to comprehend a set of Java programs of different difficulty levels. We did not impose on the participants any specific paradigm to comprehend the source code. We conducted three case studies with two groups of students, and the results were promising, despite of the fact that students had no previous knowledge of program comprehension. The results of this study shows that participants identified four dimensions to comprehend the source code - namely input/output activities, visual scanning, computer science knowledge, and application domain. In addition, the results provided strong evidence for the validation of the hypotheses that we formulated earlier before conducting the case studies. Another factor worth mentioning is the indentation of the code which might play a role in debugging.		978-1-7281-4889-2		Program comprehension software engineering;program understanding;source code comprehension mental models	Computer science;Visualization;Java;Codes;Debugging;Software;Cognitive science	computer science education;educational courses;Java;object-oriented programming;software engineering	program comprehension;object-oriented programming courses;software engineering courses;undergraduate computer science students;computing skills;Java programs;software development				19		23 Apr 2020			IEEE	IEEE Conferences
The application reseach of mixed program structure based on client-server, browser-server and web service	the application reseach of mixed program structure based on clientserver, browserserver and web service	10.1109/ICBMEI.2011.5916905	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5916905	Jian-fei Tu; Rui-feng Guo	Faculty of Mechanical Engineering and Mechanics, Ningbo University, Ningbo, China; Faculty of Mechanical Engineering and Mechanics, Ningbo University, Ningbo, China	2011 International Conference on Business Management and Electronic Information	23 jun. 2011	2011	1		193	195	C_B/S mixed-mode is a new application program structure based on client-server, browser-server and Web Service mode. The mixed program structure has the advantages of the above three, including: higher application performance, ease of deployment and flexible client user interface, etc. And it also has some disadvantages, including: difficulties in upgrading the deployment, problems of data integrated between the client programs with browser component. This paper analyzes the two kinds of realization methods of C_B/S mixed-mode, that is, Webpage integrated and Web Service integrated. An application that used the above two realization methods and based on C_B/S mixed-mode is provided as an example.		978-1-61284-109-0		mixed-mode;program structure;web service;client-server;browser-server	Web services;Servers;Browsers;Security;Data preprocessing;Periodic structures;Analytical models	application program interfaces;client-server systems;Internet;online front-ends;user interfaces;Web services	mixed program structure;client server;browser server;Web service;client user interface;client program;browser component;realization method;integrated Webpage		2		8		23 jun. 2011			IEEE	IEEE Conferences
Program Structure Charts for Applicative Languages	program structure charts for applicative languages	10.1109/TSE.1987.233185	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1702240	F. G. Pagan	Department of Computer Science, California State University, Fullerton, CA, USA	IEEE Transactions on Software Engineering	18 Sep 2006	1987	SE-13	4	490	493	A framework for a system of charts compatible with the use of applicative programming languages is proposed and illustrated. The charts are similar in spirit to the structured flowcharts that have sometimes been used with algorithmic languages. They are based on a method of representing the structure of nested expressions of arbitrary complexity. This method is adaptable to the incorporation of graphical devices for the depiction of local identifier bindings, conditional expressions, recursive function definitions, and the various functional combining forms employed in the FP-style of applicative programming.	1939-3520			Applicative languages;functional programming;program design and documentation;program structure charts;structured flowcharts	Computer languages;Functional programming;Flowcharts;Documentation;Computer science;History;Diversity reception;Computer displays;Writing		Applicative languages;functional programming;program design and documentation;program structure charts;structured flowcharts		1		4		18 Sep 2006			IEEE	IEEE Journals
Cubic program structure for multi-device operation and its application in automatic double-electrode SAW	cubic program structure for multidevice operation and its application in automatic doubleelectrode saw	10.1109/WCICA.2008.4594558	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4594558	Chaoying Liu; Peng Huang	Faculty of Electronic Information & Mechantronic Engineering, Zhaoqing University, Zhaoqing, Guangdong, China; Faculty of Electronic Information & Mechantronic Engineering, Zhaoqing University, Zhaoqing, Guangdong, China	2008 7th World Congress on Intelligent Control and Automation	8 Aug 2008	2008			6041	6043	An automatic double-electrode submerged arc welding (SAW) system included two SAW sub-systems and one movement bogie, and each of the SAW sub-system was consisted of a power supply and a wire feeder. These devices were electrically isolated to prevent electrical and magnetic interference. A coordinate controller was needed to make these devices working coordinately and form a better welding seam. For the purpose of isolation and synchronization, a layer-row-line cubic program structure was introduced. Programs in different rows represented a specific operation of a welding procession, and programs in different layer represented different actions of these devices. Actions were synchronized in rows. A SAW welding procession was the sum of all actions. Programs were also easy to be composed and understood under this structure.		978-1-4244-2113-8		Cubic program structure;synchronization;multi-devices;automatic SAW	Welding;Surface acoustic waves;Wire;Power supplies;Synchronization;Metals;Weapons	arc welding	cubic program structure;multidevice operation;automatic double-electrode SAW;submerged arc welding;power supply;wire feeder;magnetic interference;layer-row-line cubic program structure				6		8 Aug 2008			IEEE	IEEE Conferences
Code Comprehension Confounders: A Study of Intelligence and Personality	code comprehension confounders a study of intelligence and personality	10.1109/TSE.2021.3127131	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9611030	S. Wagner; M. Wyrich	Institute of Software Engineering, University of Stuttgart, 9149 Stuttgart, Baden-Wrttemberg, Germany, (e-mail: stefan.wagner@informatik.uni-stuttgart.de); Institute of Software Engineering, University of Stuttgart, 9149 Stuttgart, Baden-Wrttemberg, Germany, (e-mail: marvin.wyrich@iste.uni-stuttgart.de)	IEEE Transactions on Software Engineering		2021	PP	99	1	1	Program comprehension is a cognitive psychological process. Accordingly, literature and intuition suggest that a developer's intelligence and personality have an impact on their performance in comprehending source code. Some researchers have made this suggestion in the past when discussing threats to validity of their study results. However, the lack of studies investigating the relationship of intelligence and personality to performance in code comprehension makes scientifically sound reasoning about their influence difficult. We conduct the first large-scale empirical evaluation, a correlational study with undergraduates, to investigate the correlation of intelligence and personality with performance in code comprehension, that is, in this context, with correctness in answering comprehension questions on code snippets. We found that personality traits are unlikely to impact code comprehension performance, at least not when their influence is considered in isolation. Conscientiousness, in combination with other factors, however, explains some of the variance in code comprehension performance. For intelligence, significant small to moderate positive effects on code comprehension performance were found for three of four factors measured, i.e., fluid intelligence, visual perception, and cognitive speed. Crystallized intelligence has a positive but statistically insignificant effect on code comprehension performance. According to our results, several intelligence facets as well as the personality trait conscientiousness are potential confounders that should not be neglected in code comprehension studies of individual performance and should be controlled for via an appropriate study design. We call for the conduct of further studies on the relationship between intelligence and personality with code comprehension, in part because code comprehension involves more facets than we can measure in a single study and because our regression model explains only a small portion of the variance in code comprehension performance.	1939-3520			code comprehension;intelligence;personality;human factors;confounding parameters;empirical study	Codes;Particle measurements;Atmospheric measurements;Software engineering;Time measurement;Psychology;Guidelines							CCBY	10 nov. 2021			IEEE	IEEE Early Access Articles
"Automatically Assessing Code Understandability" Reanalyzed: Combined Metrics Matter	automatically assessing code understandability reanalyzed combined metrics matter		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8595214	A. Trockman; K. Cates; M. Mozina; T. Nguyen; C. Kästner; B. Vasilescu	University of Evansville, USA; University of Evansville, USA; University of Evansville, USA; University of Evansville, USA; Carnegie Mellon University, USA; Carnegie Mellon University, USA	2018 IEEE/ACM 15th International Conference on Mining Software Repositories (MSR)	30 Dec 2018	2018			314	318	Previous research shows that developers spend most of their time understanding code. Despite the importance of code understandability for maintenance-related activities, an objective measure of it remains an elusive goal. Recently, Scalabrino et al. reported on an experiment with 46 Java developers designed to evaluate metrics for code understandability. The authors collected and analyzed data on more than a hundred features describing the code snippets, the developers' experience, and the developers' performance on a quiz designed to assess understanding. They concluded that none of the metrics considered can individually capture understandability. Expecting that understandability is better captured by a combination of multiple features, we present a reanalysis of the data from the Scalabrino et al. study, in which we use different statistical modeling techniques. Our models suggest that some computed features of code, such as those arising from syntactic structure and documentation, have a small but significant correlation with understandability. Further, we construct a binary classifier of understandability based on various interpretable code features, which has a small amount of discriminating power. Our encouraging results, based on a small data set, suggest that a useful metric of understandability could feasibly be created, but more data is needed.	2574-3864	978-1-4503-5716-6		code understandability;metric;reanalysis;statistical modeling;readability;classification;replication;program comprehension	Measurement;Java;Documentation;Principal component analysis;Data models;Computational modeling;Predictive models	Java;software maintenance;software metrics;statistical analysis	code snippets;interpretable code features;Java developers;metrics matter combination;assessing code understandability;statistical modeling techniques;syntactic structure;syntactic documentation;binary classifier				22		30 Dec 2018			IEEE	IEEE Conferences
Linking Code Readability, Structure, and Comprehension Among Novices: It's Complicated	linking code readability, structure, and comprehension among novices its complicated	10.1109/ICSE-SEET.2019.00017	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8802116	E. S. Wiese; A. N. Rafferty; A. Fox	University of Utah; Carleton College; University of California, Berkeley	2019 IEEE/ACM 41st International Conference on Software Engineering: Software Engineering Education and Training (ICSE-SEET)	15 Aug 2019	2019			84	94	Novices' functionally-correct code is often redundant, verbose, or un-idiomatic. Such code could indicate shallow understanding of the programming language, or unfamiliarity with experts' preferences for code structure. Understanding why novices write poorly is important for designing instruction and tools to help novices write elegantly. 231 novices judged style and readability for sets of code snippets targeting seven topics. Within each set, functionality was the same, but the writing followed either common novice patterns or a more elegant, "expert" pattern. Overall, 76% of novices thought the "expert" snippets had the best style, but only 64% said those snippets were most readable. However, comprehension was similar for both "expert" and novice patterns, regardless of readability preferences. This suggests that students who prefer novice patterns do not necessarily have deep misunderstandings about the programming language. One topic included a code-writing task, and students' readability preferences were predictive of their code-writing patterns, suggesting that readability preferences reflect writing choices rather than comprehension. Thus, novices may benefit from lightweight tools that identify common patterns and suggest an "expert" solution, while helping them see that the "expert" solution is more readable than they think.		978-1-7281-1000-4		computer science education;code readability;novice code comprehension	Tools;Encoding;Education;Writing;Programming;Task analysis;Measurement	computer science education;programming languages	code readability;functionally-correct code;programming language;code structure;code snippets;expert pattern;expert snippets;code-writing task;code-writing patterns;student readability preferences		7		28		15 Aug 2019			IEEE	IEEE Conferences
Towards an e-assessment approach of algorithmic problem-solving skills using plan-based program understanding approach	towards an eassessment approach of algorithmic problemsolving skills using planbased program understanding approach	10.1109/ICEELI.2012.6360666	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6360666	A. Bey; T. Bensebaa	Laboratoire de Recherche en Informatique-LRI Department of Computer Science, Badji Mokhtar-Annaba University, Annaba, Algeria; Laboratoire de Recherche en Informatique-LRI Department of Computer Science, Badji Mokhtar-Annaba University, Annaba, Algeria	International Conference on Education and e-Learning Innovations	24 nov. 2012	2012			1	4	The majority of the students of Computer Science often start directly writing a program code when they have been asked to resolve a problem in algorithms. Although, what is way more important is the algorithm the code has to represent. Learning how to design an algorithm which resolves a given problem it is not easy. In this paper, we propose a formative-diagnostic assessment approach which helps students on acquiring problem-solving skills that enable them to cope with problems and to design more efficient and elegant solutions. Aside from the fact that this approach brings a solution for delicate problem of e-assessment of algorithmic skills, in addition it is formative aiming at strengthening algorithmic competencies. Drawing inspiration from the basic principles of the algorithms field itself, it is based on using known components called: Basic Operations which are organized in a library. For modeling, solutions of each problem are regrouped in a bunch and each solution is represented by a plan which is the canonical representation of a program in an approach of program understanding. The purpose of this approach is to provide a formative and diagnostic assessment in order to empower the learner to acquire algorithmic problem-solving skills. Even if it has been conceived for algorithmic competencies assessment, this approach can easily be adapted to any field to assess its know-how.		978-1-4673-2225-6		Learning Environment;Diagnostic assessment;formative assessment;program understanding approach;algorithmic problem-solving skills	Educational institutions;Abstracts;Algorithm design and analysis;Problem-solving;Libraries;Programming	computer aided instruction;computer science education;problem solving	e-assessment approach;algorithmic problem solving skills;plan-based program understanding;computer science;program code;learning;formative-diagnostic assessment		3		13		24 nov. 2012			IEEE	IEEE Conferences
Influence of Synchronized Domain Visualizations on Program Comprehension	influence of synchronized domain visualizations on program comprehension	10.1109/ICPC.2010.21	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521744	N. Oliveira; M. J. V. Pereira; D. da Cruz; M. Berón	University of Minho, Braga, Portugal; Polythecnic Institute of Bragança, Bragaçn, Portugal; University of Minho, Braga, Portugal; National University of San Luis, San Luis, Argentina	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			192	195	An effective program comprehension is reached when it is possible to view and relate what happens when the program is executed, synchronized with its effects in the real world concepts. This enables the interconnection of program’s meaning at both problem and program domains. To sustain this statement we need (i) to develop a tool which provides and synchronizes views at both domains, and (ii) to perform an experiment to measure the actual impact of this approach. So, in this working session we aim at discussing the benefits of providing synchronized domain visualizations. We also envisage to discuss the preparation and conduction of appropriate experiments that will test that benefits. A case study will be used and the discussion will be supported by experimental material specially prepared for the occasion, but adapted from material already used in previous experiments.	1092-8138	978-1-4244-7603-9		DSL comprehension;Program comprehension experiments;Program comprehension tools;Synchronized program visualizations	Visualization;Testing;DSL;Conducting materials;Animation;Performance evaluation;Cause effect analysis;Data mining;Humans;Graphics	data visualisation;synchronisation	synchronized domain visualizations;effective program comprehension				11		26 jul. 2010			IEEE	IEEE Conferences
An Empirical Study Assessing Source Code Readability in Comprehension	an empirical study assessing source code readability in comprehension	10.1109/ICSME.2019.00085	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8918951	J. Johnson; S. Lubo; N. Yedla; J. Aponte; B. Sharif	Department of Computer Science and Engineering, University of Nebraska-Lincoln, Lincoln, NE, USA; Dept. de Ingenieria de Sistemas e Industrial, Universidad Nacional de Colombia, Bogota, Colombia; Department of CSIS, Youngstown State University, Youngstown, Ohio, USA; Dept. de Ingenieria de Sistemas e Industrial, Universidad Nacional de Colombia, Bogota, Colombia; Department of Computer Science and Engineering, University of Nebraska-Lincoln, Lincoln, Nebraska, USA	2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)	5 Dec 2019	2019			513	523	Software developers spend a significant amount of time reading source code. If code is not written with readability in mind, it impacts the time required to maintain it. In order to alleviate the time taken to read and understand code, it is important to consider how readable the code is. The general consensus is that source code should be written to minimize the time it takes for others to read and understand it. In this paper, we conduct a controlled experiment to assess two code readability rules: nesting and looping. We test 32 Java methods in four categories: ones that follow/do not follow the readability rule and that are correct/incorrect. The study was conducted online with 275 participants. The results indicate that minimizing nesting decreases the time a developer spends reading and understanding source code, increases confidence about the developer's understanding of the code, and also suggests that it improves their ability to find bugs. The results also show that avoiding the do-while statement had no significant impact on level of understanding, time spent reading and understanding, confidence in understanding, or ease of finding bugs. It was also found that the better knowledge of English a participant had, the more their readability and comprehension confidence ratings were affected by the minimize nesting rule. We discuss the implications of these findings for code readability and comprehension.	2576-3148	978-1-7281-3094-1		program comprehension;source code readability rules;correctness;controlled experiment	Encoding;Java;Measurement;Computer bugs;Programming;Image color analysis;Software	Java;program control structures;program debugging;software maintenance;source code (software)	readability rule;minimized nesting rule;source code readability rules;Java methods;nesting rule;looping rule		3		30		5 Dec 2019			IEEE	IEEE Conferences
Source code comprehension analysis in software maintenance	source code comprehension analysis in software maintenance	10.1109/CCOMS.2017.8075175	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8075175	N. A. Al-Saiyd	Computer Science Department, Applied Science Private University, Amman, Jordan	2017 2nd International Conference on Computer and Communication Systems (ICCCS)	23 Oct 2017	2017			1	5	Source code comprehension is considered as an essential part of the software maintenance process. It is considered as one of the most critical and time-consuming task during software maintenance process. The difficulties of source code comprehension is analyzed. A static Bottom-up code comprehension model is used. The code is partitioned into functional-based blocks and their data and control dependencies that preserve the functionality of the program are analyzed. The data-flow and control-flow graphs reflects the dependencies and assist in refactoring process. The proposed strategy helps in improving the readability of the program code, increase maintainer productivity, and reducing the time and effort of code comprehension. It helps maintainers to locate the required lines of code that constitute the functional area that the maintainers are searching for in their maintenance work.		978-1-5386-0539-4		source code comprehension;code comprehension;models;refactoring;effort estimation;source line of code (SLOC)	Maintenance engineering;Computer languages;Software maintenance;Documentation;Software systems	data flow graphs;software maintenance;source code (software)	source code comprehension analysis;software maintenance process;functional-based blocks;control dependencies;control-flow graphs;refactoring process;program code;maintenance work;data-flow graph;static bottom-up code comprehension model;code partitioning		3		18		23 Oct 2017			IEEE	IEEE Conferences
The Influence of Different AOI Models in Source Code Comprehension Analysis	the influence of different aoi models in source code comprehension analysis	10.1109/EMIP.2019.00010	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8834701	F. Deitelhoff; A. Harrer; A. Kienle	Faculty of Computer Science, University of Applied Sciences and Arts, Dortmund, Germany; Faculty of Computer Science, University of Applied Sciences and Arts, Dortmund, Germany; Faculty of Computer Science, University of Applied Sciences and Arts, Dortmund, Germany	2019 IEEE/ACM 6th International Workshop on Eye Movements in Programming (EMIP)	12 Sep 2019	2019			10	17	In source code comprehension, researchers frequently analyze eye movement data in order to find patterns to test hypotheses. For such an analysis, fixations are often assigned to objects of a stimulus, like tokens, code lines or code regions, through areas of interest (AOI). There are multiple ways to define an AOI which can have a broad impact on the analysis of the eye movement data. In this paper, we analyzed the impact of choosing two different AOI models, both as extreme points from a methodical point of view. We propose one AOI model and compare it to the AOI model from the EMIP dataset. Within the data, we found indications, that one AOI model captures less AOI transitions compared to the other model. A qualitative investigation showed, that some of these AOI transitions can be important for understanding the viewing and comprehension strategy of the participant. In conclusion, we argue, that every researcher should report the chosen AOI model and the particular AOI definitions used in a study, to understand their research. Additionally, we suggest a simple algorithm to test, which AOI model configuration will capture a majority of data points.		978-1-7281-2243-4		program comprehension;source code comprehension;eye tracking;areas of interest;data fishing;signal detection;AOI-DNA;AOI-STG	Data models;Analytical models;Programming;Gaze tracking;Signal detection;Distributed databases;Conferences	eye;gaze tracking;program diagnostics	source code comprehension analysis;eye movement data;code lines;code regions;AOI model captures;AOI transitions;comprehension strategy;particular AOI definitions;AOI model configuration;data points;EMIP dataset		5		14		12 Sep 2019			IEEE	IEEE Conferences
Toward Understanding the Impact of Refactoring on Program Comprehension	toward understanding the impact of refactoring on program comprehension	10.1109/SANER53432.2022.00090	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9825885	G. Sellitto; E. Iannone; Z. Codabux; V. Lenarduzzi; A. De Lucia; F. Palomba; F. Ferrucci	Department of Computer Science, Software Engineering (SeSa) Lab, University of Salerno, Italy; Department of Computer Science, Software Engineering (SeSa) Lab, University of Salerno, Italy; University of Saskatchewan, Canada; University of Oulu, Finland; Department of Computer Science, Software Engineering (SeSa) Lab, University of Salerno, Italy; Department of Computer Science, Software Engineering (SeSa) Lab, University of Salerno, Italy; Department of Computer Science, Software Engineering (SeSa) Lab, University of Salerno, Italy	2022 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)	21 jul. 2022	2022			731	742	Software refactoring is the activity associated with developers changing the internal structure of source code without modifying its external behavior. The literature argues that refactoring might have beneficial and harmful implications for software maintainability, primarily when performed without the support of automated tools. This paper continues the narrative on the effects of refactoring by exploring the dimension of program comprehension, namely the property that describes how easy it is for developers to understand source code. We start our investigation by assessing the basic unit of program comprehension, namely program readability. Next, we set up a large-scale empirical investigation – conducted on 156 open-source projects – to quantify the impact of refactoring on program readability. First, we mine refactoring data and, for each commit involving a refactoring, we compute (i) the amount and type(s) of refactoring actions performed and (ii) eight state-of-the-art program comprehension metrics. Afterwards, we build statistical models relating the various refactoring operations to each of the readability metrics considered to quantify the extent to which each refactoring impacts the metrics in either a positive or negative manner. The key results are that refactoring has a notable impact on most of the readability metrics considered.	1534-5351	978-1-6654-3786-8	Natural Sciences and Engineering Research Council of Canada(grant numbers:RGPIN-2021-04232,DGECR-2021-00283); Swiss National Science Foundation(grant numbers:PZ00P2 186090 (TED)); 	Software Refactoring;Program Comprehension;Program Readability;Empirical Software Engineering	Measurement;Codes;Conferences;Computational modeling;Readability metrics;Behavioral sciences;Data mining	public domain software;software maintenance;software metrics;software quality;statistical analysis	readability metrics;software refactoring;source code;program readability;open-source projects;refactoring data;refactoring actions;refactoring operations;program comprehension metrics;statistical models				83	IEEE	21 jul. 2022			IEEE	IEEE Conferences
Supporting program comprehension with source code summarization	supporting program comprehension with source code summarization	10.1145/1810295.1810335	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6062165	S. Haiduc; J. Aponte; A. Marcus	Department of Computer Science, Wayne State University, Detroit, MI, USA; Department de Ing. de Sistemas e Industrial, Universidad Nacional de Colombia, Bogota, Colombia; Department of Computer Science, Wayne State University, Detroit, MI, USA	2010 ACM/IEEE 32nd International Conference on Software Engineering	27 Oct 2011	2010	2		223	226	One of the main challenges faced by today's developers is keeping up with the staggering amount of source code that needs to be read and understood. In order to help developers with this problem and reduce the costs associated with it, one solution is to use simple textual descriptions of source code entities that developers can grasp easily, while capturing the code semantics precisely. We propose an approach to automatically determine such descriptions, based on automated text summarization technology.	1558-1225	978-1-60558-719-6		program comprehension;summary;text summarization	Semantics;Natural languages;Large scale integration;Software engineering;Tagging;Software systems	reverse engineering;software cost estimation;software maintenance	program comprehension;source code summarization;cost reduction;textual description;code semantics;automated text summarization;software maintenance		37		12		27 Oct 2011			IEEE	IEEE Conferences
Case studies of optimized sequence diagram for program comprehension	case studies of optimized sequence diagram for program comprehension	10.1109/ICPC.2016.7503734	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7503734	M. Srinivasan; Jeong Yang; Young Lee	Electrical Engineering and Computer Science, Texas A&M University-Kingsville, Kingsville, TX, USA; Electrical Engineering and Computer Science, Texas A&M University-Kingsville, Kingsville, TX, USA; Electrical Engineering and Computer Science, Texas A&M University-Kingsville, Kingsville, TX, USA	2016 IEEE 24th International Conference on Program Comprehension (ICPC)	7 jul. 2016	2016			1	4	In large project, source code becomes increasing complex and lengthy so program comprehension plays an important and significant role for developers. Sequence diagram generated using static source code or dynamic only approach provides limited execution coverage, additionally contains redundant, dead and fault driven methods, which increase the size of the diagram and complexity. In this paper, to address the problems, optimized sequence diagrams were developed by combining static source code and dynamic only approach, also incorporating various levels of abstraction in order to reduce complexity and provide complete behavior of the system. Case studies determined from the sequence diagram for three systems generated based on source code only and fully dynamic approach proved that the proposed optimized sequence diagrams were less complex and provided more detailed description of the functionality of the system.		978-1-5090-1428-6		sequence diagram;polymorphism;object-oriented;visualization;program comprehension	Animals;Visualization;Measurement;Java;Complexity theory;Conferences;Reverse engineering	object-oriented methods;source code (software)	program comprehension;static source code;fault driven methods;complexity;optimized sequence diagrams		9		14		7 jul. 2016			IEEE	IEEE Conferences
Experimental Settings in Program Comprehension: Challenges and Open Issues	experimental settings in program comprehension challenges and open issues	10.1109/ICPC.2006.23	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631125	G. A. Di Lucca; M. Di Penta	RCOST-Research Centre on Software Technology, University of Sannio, Benevento, Italy; RCOST-Research Centre on Software Technology, University of Sannio, Benevento, Italy	14th IEEE International Conference on Program Comprehension (ICPC'06)	26 jun. 2006	2006			229	234	Several approaches to program comprehension have been proposed along the years, ranging from fact extraction to sophisticated visualization tools. In order to effectively assess the benefits of each approach, or to properly compare different techniques, it is necessary to carry out a proper, well-defined experimentation. This work session aims to discuss the main issues in preparing experimental settings related to the evaluation of approaches and tools supporting program comprehension, as well as to promote networking aiming to carry on collaborative experimentations	1092-8138	0-7695-2601-2		Empirical studies;program comprehension	Software tools;Visualization;Collaborative tools;Collaborative work;Human factors;Software maintenance;Instruments;Software systems;Performance evaluation;Packaging	program visualisation;reverse engineering;software maintenance	program comprehension;program visualization tool		5		11		26 jun. 2006			IEEE	IEEE Conferences
Measuring Program Comprehension: A Large-Scale Field Study with Professionals	measuring program comprehension a largescale field study with professionals	10.1145/3180155.3182538	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453126	X. Xia; L. Bao; D. Lo; Z. Xing; A. E. Hassan; S. Li	Monash University, Clayton, VIC, AU; Zhejiang University, Hangzhou, Zhejiang, CN; Singapore Management University, Singapore, Singapore, SG; Australian National University, Canberra, ACT, AU; Queen's University Faculty of Health Sciences, Kingston, ON, CA; Zhejiang University, Hangzhou, Zhejiang, CN	2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)	2 Sep 2018	2018			584	584	This paper is published in IEEE Transaction on Software Engineering (DOI: 10.1109/TSE.2017.2734091). Comparing with previous programming comprehension studies that are usually in controlled settings or have a small number of participants, we perform a more realistic investigation of program comprehension activities. To do this, we extend our ActivitySpace framework to collect and analyze Human-Computer Interaction (HCI) data across many applications (not just the IDEs). We collect 3,148 working hour data from 78 professional developers in a field study. We follow Minelli et al.'s approach to assign developers' activities into four categories: navigation, editing, comprehension, and other. Then we measure comprehension time by calculating the time that developers spend on program comprehension. We find that on average developers spend ~58% of their time on program comprehension activities, and that they frequently use web browsers and document editors to perform program comprehension activities. We also investigate the impact of programming language, developers' experience, and project phase on the time that is spent on program comprehension.	1558-1225	978-1-4503-5638-1		Program Comprehension;Field Study;Inference Model	Computer science;Software;Software engineering;Australia;Conferences;Software measurement;Information technology	online front-ends;reverse engineering;software engineering;software maintenance	large-scale field study;program comprehension activities;measure comprehension time;professional developers;program comprehension measurement		4				2 Sep 2018			IEEE	IEEE Conferences
Scalable Program Comprehension for Analyzing Complex Defects	scalable program comprehension for analyzing complex defects	10.1109/ICPC.2008.44	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556111	S. C. Kothari	Electrical & Computer Engineering Department, EnSoft Corporation, Iowa State University, USA	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			3	4	We describe the query-model-refine (QMR) approach for retrieving and modeling information for program comprehension. The QMR approach allows the flexibility to design and execute application-specific problem-solving strategies to suit particular program comprehension goals. The QMR approach has been used for building a number of program comprehension tools for different applications: interactive automatic parallelization, business rule analysis, auditing safety-critical control software, and defect analysis. This presentation will be about a program comprehension tool called Atlas and we will show its use for analyzing complex defects.	1092-8138	978-0-7695-3176-2		Scalable;Program Comprehension;Complex Defects	Humans;Software tools;Information retrieval;Application software;Software safety;Information analysis;Artificial intelligence;Aerospace electronics;Space technology;Operating systems	program debugging;program diagnostics;query processing	scalable program comprehension;query-model-refine approach;problem-solving strategy;interactive automatic parallelization;business rule analysis;safety-critical control software;Atlas		2		5		2 jul. 2008			IEEE	IEEE Conferences
Context and Vision: Studying Two Factors Impacting Program Comprehension	context and vision studying two factors impacting program comprehension	10.1109/ICPC.2011.37	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970176	Z. Soh	DGIGL-Ptidej Team, SOCCER Laboratory, École Polytechnique de Montréal, QUE, Canada	2011 IEEE 19th International Conference on Program Comprehension	1 Aug 2011	2011			258	261	Linguistic information derived from identifiers and comments has a paramount role in program comprehension. Indeed, very often, program documentation is scarce and when available, it is almost always outdated. Previous research works showed that program comprehension is often solely grounded on identifiers and comments and that, ultimately, it is the quality of comments and identifiers that impact the accuracy and efficiency of program comprehension. Previous works also investigated the factors influencing program comprehension. However, they are limited by the available tools used to establish relations between cognitive processes and program comprehension. The goal of our research work is to foster our understanding of program comprehension by better understanding its implied underlying cognitive processes. We plan to study vision as the fundamental mean used by developers to understand a code in the context of a given program. Vision is indeed the trigger mechanism starting any cognitive process, in particular in program comprehension. We want to provide supporting evidence that context guides the cognitive process toward program comprehension. Therefore, we will perform a series of empirical studies to collect observations related to the use of context and vision in program comprehension. Then, we will propose laws and then derive a theory to explain the observable facts and predict new facts. The theory could be used in future empirical studies and will provide the relation between program comprehension and cognitive processes.	1092-8138	978-0-7695-4398-7		Program comprehension;cognitive process;vision science;program context	Context;Conferences;Visualization;Software;Software engineering;Maintenance engineering;Computers	software development management;system documentation	program comprehension;linguistic information;program documentation;cognitive processes		2		25		1 Aug 2011			IEEE	IEEE Conferences
Structural Knowledge and Language Notational Properties in Program Comprehension	structural knowledge and language notational properties in program comprehension	10.1109/VLHCC.2004.50	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1372324	P. Romero; B. du Boulay	Human Centred Technology Group, University of Sussex, Falmer, UK; Human Centred Technology Group, University of Sussex, Falmer, UK	2004 IEEE Symposium on Visual Languages - Human Centric Computing	27 Dec 2004	2004			223	225	Several accounts of program comprehension have taken the theory of text comprehension by Kinstch as a starting point to model the mental representations built when programmers understand a computer program. A crucial point that these accounts try to explain is how these mental representations are organised. According to Kintsch's theory, the mental representations built as a product of the text comprehension process are interrelated propositional networks whose organisation is determined by the main idea of the text. In program comprehension, this main idea has been understood in terms of functionality. This paper contends this notion, proposing that in program understanding programmer's mental representations are multifaceted and organised through several criteria. Which of these is the most important one depends on the programming language employed among other factors. The fact that functional information appeared as crucial might have been because most of the empirical research that has been undertaken has employed procedural languages. This claim is tested empirically by analysing the mental representations of programmers in Prolog, a declarative programming language. The results support our claim by showing that in this case data structure information is more important than function		0-7803-8696-5		knowledge representation;program debugging;program comprehension	Programming profession;Computer languages;Humans;Data structures;Testing;Knowledge representation;Debugging	data structures;PROLOG;reverse engineering	structural knowledge;language notational property;program comprehension;text comprehension;mental representations;programmers;computer program;Kintsch theory;propositional networks;programming language;procedural languages;Prolog;data structure information		1		17		27 Dec 2004			IEEE	IEEE Conferences
[Journal First] A Comparison of Program Comprehension Strategies by Blind and Sighted Programmers	[journal first] a comparison of program comprehension strategies by blind and sighted programmers	10.1145/3180155.3182544	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453151	A. Armaly; P. Rodeghero; C. McMillan	University of Notre Dame, Notre Dame, IN, US; University of Notre Dame, Notre Dame, IN, US; University of Notre Dame, Notre Dame, IN, US	2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)	2 Sep 2018	2018			788	788	Programmers who are blind use a screen reader to speak source code one word at a time, as though the code were text. This process of reading is in stark contrast to sighted programmers, who skim source code rapidly with their eyes. At present, it is not known whether the difference in these processes has effects on the program comprehension gained from reading code. These effects are important because they could reduce both the usefulness of accessibility tools and the generalizability of software engineering studies to persons with low vision. In this paper, we present an empirical study comparing the program comprehension of blind and sighted programmers. We found that both blind and sighted programmers prioritize reading method signatures over other areas of code. Both groups obtained an equal and high degree of comprehension, despite the different reading processes.	1558-1225	978-1-4503-5638-1		Program comprehension;accessibility technology;blindness	Software engineering;Tools;Java;Measurement;Software maintenance;Visualization	handicapped aids;programming environments;public domain software;software engineering	program comprehension strategies;sighted programmers;source code;reading processes		1				2 Sep 2018			IEEE	IEEE Conferences
Infusing Topic Modeling into Interactive Program Comprehension: An Empirical Study	infusing topic modeling into interactive program comprehension an empirical study	10.1109/COMPSAC.2017.151	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8029929	T. Wang; Y. Liu	School of Software Engineering, Tongji University, Shanghai, China; School of Software Engineering, Tongji University, Shanghai, China	2017 IEEE 41st Annual Computer Software and Applications Conference (COMPSAC)	11 Sep 2017	2017	2		260	261	Automatic and semi-automatic approaches supporting program comprehension are sought by researchers and practitioners to facilitate software engineering tasks, such as development, maintenance, extension and so on. Using topic modeling is a promising way to automatically discover feature and structure from textual software assets. However, there are gaps between knowing and doing when applying topic modeling to software engineering practice. In this paper, we explored how to infuse topic modeling into understanding Java programs in a generic level, and summarized the whole procedure as a methodology called MAT. MAT utilizes essential information automatically generated from Java projects to establish a project overview and to bring search capability for software engineers. Experiments on two open source Java projects suggest that MAT can support program comprehension for Java software engineers during carrying on software maintenance and extension tasks.	0730-3157	978-1-5386-0367-3		Mining software assets;Java program comprehension;Topic models	Software;Java;Software engineering;Computational modeling;Maintenance engineering;Analytical models;Semantics	data mining;document handling;Java;project management;public domain software;software maintenance;software management	topic modeling;interactive program comprehension;software engineering tasks;feature discovery;textual software assets;Java programs;MAT;open source Java projects;software maintenance;document collection		1		7		11 Sep 2017			IEEE	IEEE Conferences
Workshop on Program Comprehension Through Dynamic Analysis (PCODA'08)	workshop on program comprehension through dynamic analysis (pcoda08)	10.1109/WCRE.2008.21	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656435	A. Zaidman; A. Hamou-Lhadj; O. Greevy; D. Röthlisberger	Delft University of Technnology, Netherlands; Concordia University, Montreal, QUE, Canada; Sw-Eng Software Engineering GmbH, Switzerland; University of Bern, Switzerland	2008 15th Working Conference on Reverse Engineering	24 Oct 2008	2008			345	346	Applying program comprehension techniques may render software maintenance and evolution easier. Understanding a software system typically requires a combination of static and dynamic analysis techniques. The aim of this workshop is to bring together researchers and practitioners working in the area of program comprehension with an emphasis on dynamic analysis. We are interested in investigating how dynamic analysis techniques are used or canbe used to enable better comprehension of a software system. The objective is to compare existing techniques, identify common case studies and possible symbioses for existing solutions. Building upon three previous editions of the workshop, we aim to set up a forum for exchanging experiences, discussing solutions, and exploring new ideas.	2375-5369	978-0-7695-3429-9		dynamic analysis;program comprehension	Conferences;Performance analysis;Reverse engineering;Software;Evolution (biology);Software maintenance;Special issues and sections	program diagnostics;software maintenance	program comprehension techniques;dynamic analysis techniques;software maintenance;software evolution;software system;static analysis techniques		1		3		24 Oct 2008			IEEE	IEEE Conferences
Applying Code Analysis and 3D Design Pattern Grouping to Facilitate Program Comprehension	applying code analysis and 3d design pattern grouping to facilitate program comprehension	10.1109/VISSOF.2005.1684320	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1684320	J. Rilling; V. Nguyen	Department of Computer Science and Software Engineering, Concordia University, Montreal, QUE, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, QUE, Canada	3rd IEEE International Workshop on Visualizing Software for Understanding and Analysis	9 Oct 2006	2005			1	2	The increasing size and complexity of software systems introduces new challenges in comprehending the overall structure of programs. Modeling languages and notations were introduced to provide abstractions from existing source code during forward engineering. However, these same modeling techniques and notations fail during source code reverse engineering due to: (1) Information overload; and (2) the existence of a conceptual gap between the abstractions derived during forward and reverse engineered. Our tool uses a 3D representation for UML in combination with source code analysis to facilitate the comprehension process. We also address issues of crosscutting, navigation, and the use of animation to visualize design patterns		0-7803-9540-9		3D visualization;program comprehension;design patterns	Pattern analysis;Data visualization;Unified modeling language;Algorithm design and analysis;Bridges;Reverse engineering;Pattern recognition;Concrete;Production facilities;Computer science	data flow analysis;object-oriented programming;program visualisation;Unified Modeling Language	3D design pattern grouping;program comprehension;software systems;source code abstractions;forward engineering;source code reverse engineering;information overload;3D representation;UML;source code analysis;design pattern visualization		1		6		9 Oct 2006			IEEE	IEEE Conferences
Trend analysis on the metadata of program comprehension papers	trend analysis on the metadata of program comprehension papers	10.1109/EMES.2015.7158425	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7158425	M. Sulír; J. Porubän	Department of Computers and Informatics, Technical University of Košice; Department of Computers and Informatics, Technical University of Košice	2015 13th International Conference on Engineering of Modern Electric Systems (EMES)	16 jul. 2015	2015			1	4	As program comprehension is a vast research area, it is necessary to get an overview of its rising and falling trends. We performed an n-gram frequency analysis on titles, abstracts and keywords of 1885 articles about program comprehension from the years 2000-2014. According to this analysis, the most rising trends are feature location and open source systems, the most falling ones are program slicing and legacy systems.		978-1-4799-7650-8		Program comprehension;bibliography;trends;n-grams	Market research;Software;IEEE Xplore;Bibliographies;Software engineering;Visualization	meta data;program slicing;software maintenance	trend analysis;meta data;program comprehension;n-gram frequency analysis;program slicing;legacy systems				12		16 jul. 2015			IEEE	IEEE Conferences
Industrial Realities of Program Comprehension (IRPC 2008)	industrial realities of program comprehension (irpc 2008)	10.1109/ICPC.2008.43	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556145	T. Dean; J. Visser	Queen's University, Canada; Software Improvement Group, Netherlands	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			283	284	In the working session on Industrial Realities of Program Comprehension (IRPC 2008), experience and ideas are shared regarding the challenges and opportunities of industrial application of program comprehension techniques. Participants work together to formulate a set of useful guidelines for introducing new program comprehension techniques into industrial practice as well as consolidating and increasing their use.	1092-8138	978-0-7695-3176-2		Program comprehension;working session	Computer industry;Guidelines;Packaging;Business;Application software;Environmental economics;Testing;Quality assessment;Companies;Licenses	business data processing;software engineering	industrial realities;program comprehension techniques;industrial practice				2		2 jul. 2008			IEEE	IEEE Conferences
Program comprehension: A method of generating visualized UML class diagram	program comprehension a method of generating visualized uml class diagram	10.1109/ICISE.2010.5690312	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5690312	GuHui; WangHui	College of Computer Science and Technology, Zhejiang University of Technology, Hangzhou, China; College of Computer Science and Technology, Zhejiang University of Technology, Hangzhou, China	The 2nd International Conference on Information Science and Engineering	17 jan. 2011	2010			6775	6776	Program comprehension is an important research content of software engineering. This paper presents a Program comprehension visualization method of using UML class diagram. This method has two parts, first, The program source code is abstracted into database table, the form used to summarize and express program structure and key information, Then, the table was transformed into UML class diagrams, The class diagram can be effective to help understanding program structure and other key information.	2160-1291	978-1-4244-7618-3		program comprehension;table abstract;UML class diagram;visualization	Unified modeling language;Visualization;Software engineering;Educational institutions;Software maintenance								17 jan. 2011			IEEE	IEEE Conferences
A study on the impact of emotional quotient on program comprehension	a study on the impact of emotional quotient on program comprehension		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5738757	A. Savarimuthu; L. Arockiam; A. Aloysius	Human Resource Management, Saint Joseph's College, Tiruchirapalli, India; Computer Science, Saint Joseph's College, Tiruchirapalli, India; Computer Science, Saint Joseph's College, Tiruchirapalli, India	2010 International Conference on Communication and Computational Intelligence (INCOCCI)	24 mar. 2011	2010			357	361	Emotional Quotient (aka. Emotional Intelligence Quotient (EIQ)) can be described as the capacity for recognizing our own feelings and those of others, for motivating ourselves, and for managing emotions well in us and in our relationships. The primary objective of this work is to study the impact of EQ on the primary cognitive processes namely comprehension in Object oriented Systems. Comprehension is an understanding of the program code. The PG students were involved in all the experiments conducted. Java programs with various features of OO programming were given for comprehension. From the experiments that were conducted to find the relation between the program comprehension ability and the EQ values, it is identified that the EQ values have an impact on the program comprehension in the various OO features such as Inheritance and Polymorphism. The results of the experiments conducted may be used by the recruiter to carefully select the candidates for OO software development.		978-81-8371-369-6		Emotional Quotient (aka. Emotional Intelligence Quotient (EIQ));Program Comprehension;OO Systems	Programming profession;Humans;Educational institutions;Psychology;Training;Debugging	cognition;human computer interaction;Java;object-oriented methods;object-oriented programming;software engineering	emotional quotient;program comprehension;emotional intelligence quotient;primary cognitive process;object oriented system;Java program;OO programming;program comprehension ability;polymorphism;OO software development				26		24 mar. 2011			IEEE	IEEE Conferences
A retrospective view on: The role of concepts in program comprehension: (MIP award)	a retrospective view on the role of concepts in program comprehension (mip award)	10.1109/ICPC.2012.6240480	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240480	V. Rajlich; N. Wilde	Department of Computer Science, University of West Florida, Pensacola, FL, USA; Department of Computer Science, University of West Florida, Pensacola, FL, USA	2012 20th IEEE International Conference on Program Comprehension (ICPC)	16 jul. 2012	2012			12	13	This retrospective briefly recapitulates highlights of the original paper that was published at IWPC 2002. Then it overviews research directions of the last 10 years: research in tools and techniques of concept location a that aim to support software developer, research of integrated model of software change, creation of software engineering course that emphasizes the role of software developer in iterative and agile software processes, and further basic research into the role and properties of concepts.	1092-8138	978-1-4673-1216-5		partial program comprehension;as needed comprehension;concepts and features;concept location;software as repository of knowledge;constructivist learning	Software engineering;Pragmatics;Software tools;Education;Ontologies	iterative methods;software engineering	retrospective view;program comprehension;MIP award;concept location;software developer;integrated model;software change;software engineering course;agile software processes;iterative processes				12		16 jul. 2012			IEEE	IEEE Conferences
Overview of Program Comprehension	overview of program comprehension	10.1109/ICCSEE.2012.285	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6187918	W. Kechao; W. Tiantian; S. Xiaohong; M. Peijun	Department of Computer Science, Harbin Institute of Technology, Harbin, China; Department of Computer Science, Harbin Institute of Technology, Harbin, China; Department of Computer Science, Harbin Institute of Technology, Harbin, China; Department of Computer Science, Harbin Institute of Technology, Harbin, China	2012 International Conference on Computer Science and Electronics Engineering	23 Apr 2012	2012	1		601	605	With the increasing of software requirements, software is becoming larger and larger. It becomes an important problem to maintain the software. Thus understanding the program exactly, rapidly and comprehensively plays an important role. This paper has presented the related research of program comprehension, summarized six typical program comprehension strategies and compared these strategies.		978-0-7695-4647-6		software maintenance;program comprehension	Educational institutions;Knowledge based systems;Semantics;Programming;Software maintenance;Conferences	formal specification;reverse engineering;software maintenance	program comprehension overview;software requirements;software maintenance;program comprehension strategies				15		23 Apr 2012			IEEE	IEEE Conferences
SymAnalyzer: A Symbolic Analysis Tool for Program Comprehension	symanalyzer a symbolic analysis tool for program comprehension	10.1109/CSMR.2009.56	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812787	E. Laitila	Jyväskylä University, Jyvaskyla, Finland	2009 13th European Conference on Software Maintenance and Reengineering	10 Apr 2009	2009			325	326	In this paper, we present a program comprehension tool, called SymAnalyzer, which uses symbolic analysis as its main mechanism to help software engineers understand symbolic flows of the the most relevant sequences. Captured information is useful in troubleshooting and familiarization.	1534-5351	978-0-7695-3589-0		Program comprehension;symbolic analysis	Software maintenance;Information analysis;Space technology;Analytical models;Computational modeling;Logic programming;Tin;Software tools;Software systems;Data mining	program diagnostics;software tools	SymAnalyzer;symbolic analysis tool;program comprehension tool;software engineering				2		10 Apr 2009			IEEE	IEEE Conferences
Poster: Knowledge Transfer from Research to Industry: A Survey on Program Comprehension	poster knowledge transfer from research to industry a survey on program comprehension		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449549	I. von Nostitz-Wallwitz; J. Krüger; J. Siegmund; T. Leich	Otto von Guericke Universitat Magdeburg, Magdeburg, Sachsen-Anhalt, DE; Otto von Guericke Universitat Magdeburg, Magdeburg, Sachsen-Anhalt, DE; Universitat Passau, Passau, Bayern, DE; Harz Univ., Wernigerode, Germany	2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion)	30 Aug 2018	2018			300	301	The number of scientific publications is continuously increasing, with most publications describing research that is also interesting for industrial software engineers. Program comprehension in particular is an essential and time consuming task in industry, but new approaches are rarely adopted.We conducted a survey with 89 participants from research and industry to investigate this problem. Our results indicate that researchers have to integrate other ways to communicate their work and make evaluations more practical.	2574-1934	978-1-4503-5663-3		Program comprehension;survey;knowledge transfer	Tools;Knowledge transfer;Task analysis;Industries;Jacobian matrices;Software engineering;Programming	knowledge management;program diagnostics;software engineering	knowledge transfer;program comprehension;industrial software engineers						30 Aug 2018			IEEE	IEEE Conferences
Studying Onboarding to Improve Program Comprehension Tool Support	studying onboarding to improve program comprehension tool support	10.1109/VLHCC.2010.47	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5635249	R. Yates	Lero, University of Limerick, Ireland	2010 IEEE Symposium on Visual Languages and Human-Centric Computing	11 nov. 2010	2010			257	258	Gaining an understanding of unfamiliar software systems is hard. Existing support tools are based on studies of the information sought by software developers, but often the developers themselves do not know what to look for. Here an alternative is proposed: by studying the information `pushed' from software experts to new developers during onboarding, the information provided by the experts can be analysed and compared to the information `pulled' by the new developers. The content and presentation of this data will inform tool design for onboarding support.	1943-6106	978-1-4244-8485-0		onboarding;program comprehension	Software;Programming;Conferences;Data visualization;USA Councils;Companies;Computational modeling	software tools	program comprehension tool support;software system;software developer;tool design				11		11 nov. 2010			IEEE	IEEE Conferences
Code Comprehensibility Evaluation for Java Class based on LDA Topic Model	code comprehensibility evaluation for java class based on lda topic model	10.1109/DSA52907.2021.00073	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9622959	Y. Shao; J. Ai	School of Reliability and System Engineering, Beihang University, Beijing, China; School of Reliability and System Engineering, Beihang University, Beijing, China	2021 8th International Conference on Dependable Systems and Their Applications (DSA)	1 Dec 2021	2021			491	498	The rapid development of the current software industry has produced a large amount of software, to evaluate the quality of a software code is difficult, which is also not conducive to software maintenance and iteration. Among them, software comprehensibility is one of the most important factors for software maintainability, and it is one of the indispensable elements for software quality evaluation. However, most of the existing software quality evaluation only stay in the concept level, lack of corresponding evaluation methods. From the perspective of java class code, this paper constructs a comprehensibility evaluation method for java class code based on LDA topic modeling, implements the software class code intelligibility evaluation, and quantifies the experimental results using clustering algorithm and WordNet similarity calculation method. Experiments show that the proposed method can clearly distinguish the comprehensibility of class code and obtain reliable evaluation results of software class code intelligibility.	2767-6684	978-1-6654-4391-3		Code Comprehensibility;Software quality evaluation;LDA topic modeling;K-means clustering	Industries;Java;Software maintenance;Codes;Software algorithms;Clustering algorithms;Software quality	DP industry;Java;pattern clustering;software maintenance;software quality	LDA topic modeling;software class code intelligibility evaluation;code comprehensibility evaluation;software code quality;software maintenance;software comprehensibility;software maintainability;Java class code;software industry;clustering algorithm;WordNet similarity calculation method				15	IEEE	1 Dec 2021			IEEE	IEEE Conferences
Quantifying Program Comprehension with Interaction Data	quantifying program comprehension with interaction data	10.1109/QSIC.2014.11	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6958415	R. Minelli; A. Mocci; M. Lanza; T. Kobayashi	REVEAL @ Faculty of Informatics, University of Lugano, Switzerland; REVEAL @ Faculty of Informatics, University of Lugano, Switzerland; REVEAL @ Faculty of Informatics, University of Lugano, Switzerland; Department of Computer Science-Tokyo, Institute of Technology, Japan	2014 14th International Conference on Quality Software	20 nov. 2014	2014			276	285	It is common knowledge that program comprehension takes up a substantial part of software development. This "urban legend" is based on work that dates back decades, which throws up the question whether the advances in software development tools, techniques, and methodologies that have emerged since then may invalidate or confirm the claim. We present an empirical investigation which goal is to confirm or reject the claim, based on interaction data which captures the user interface activities of developers. We use interaction data to empirically quantify the distribution of different developer activities during software development: In particular, we focus on estimating the role of program comprehension. In addition, we investigate if and how different developers and session types influence the duration of such activities. We analyze interaction data from two different contexts: One comes from the ECLIPSE IDE on Java source code development, while the other comes from the PHARO IDE on Smalltalk source code development. We found evidence that code navigation and editing occupies only a small fraction of the time of developers, while the vast majority of the time is spent on reading & understanding source code. In essence, the importance of program comprehension was significantly underestimated by previous research.	2332-662X	978-1-4799-7198-5		Program Comprehension;Program Understanding;Quantification;Interaction data;IDE	Navigation;History;Java;Inspection;Software;Browsers;Maintenance engineering	human computer interaction;Java;Smalltalk;software engineering;source code (software);user interfaces	program comprehension;interaction data;software development tools;software development techniques;software developer user interface activities;ECLIPSE IDE;Java source code development;PHARO IDE;Smalltalk source code development;code navigation;code editing		17		24		20 nov. 2014			IEEE	IEEE Conferences
Programmer eXperience: A Systematic Literature Review	programmer experience a systematic literature review	10.1109/ACCESS.2019.2920124	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8727527	J. Morales; C. Rusu; F. Botella; D. Quiñones	Facultad de Ingeniería, Universidad Autónoma de Chile, Providencia, Chile; Escuela de Ingeniería Informática, Pontificia Universidad Católica de Valparaíso, Valparaíso, Chile; Instituto CIO, Universidad Miguel Hernández de Elche, Elche, Spain; Escuela de Ingeniería Informática, Pontificia Universidad Católica de Valparaíso, Valparaíso, Chile	IEEE Access	10 jun. 2019	2019	7		71079	71094	Programmers use various software development artifacts in their work, such as programming environments, design documents, and programming codes. These software artifacts can be studied and improved based on usability and User eXperience (UX) factors. In this paper, we consider programmers to be a specific case of users and analyze different elements that influence their experience in this specific context. We conducted a systematic literature review of papers published over the last ten years related to 1) the definition of the Programmer eXperience (PX); 2) the PX, UX, and usability factors regarding the programming environments, design documents, and programming codes; and 3) sets of heuristics to evaluate the software development artifacts mentioned before. We analyzed 73 articles, and the results obtained show that: 1) the important elements that influence the PX are the motivation of programmers and the choice of tools they use in their work, such as programming environments; 2) most of the identified studies (59%) aimed to evaluate the influence of the PX, UX, and usability on programming environments; 3) the majority of the studies (70%) used methods such as usability tests and/or heuristic evaluation methods; and 4) four sets of heuristics are used to evaluate software development artifacts in relation to programming environments, programming languages, and application programming interfaces. The results suggest that further research in this area is necessary to better understand and evaluate the concept of the PX.	2169-3536		INF-PUCV Doctoral Scholarship; 	Heuristic evaluation;Programmer eXperience;systematic literature review;User eXperience;usability	Usability;Programming environments;Programming;User experience;Systematics;Bibliographies	application program interfaces;data analysis;human factors;software engineering;user interfaces	software development artifacts;programming environments;design documents;programming codes;software artifacts;PX;usability factors;application programming interfaces;programmer experience		6		102	OAPA	31 May 2019			IEEE	IEEE Journals
Programmer Experience: – An HCI Prespective	programmer experience – an hci prespective	10.1109/ComTech52583.2021.9616689	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9616689	U. F. Khan; T. Rana	Computer Software Engineering Department, Military College of Signals, NUST, Rawalpindi, Pakistan; Computer Software Engineering Department, MCS, National University of Science and Technology, Islamabad, Pakistan	2021 International Conference on Communication Technologies (ComTech)	24 nov. 2021	2021			44	48	User experience (abbreviated as UX) is how a user feels when interacting with a particular system. Not only does it include user’s direct interactions with the system, but also how it helps the user in the overall satisfactory completion of a particular task. Software programmers are also users of a specific systems, and several types of artifacts related to software development lifecycle. We performed a systematic mapping about Programmer eXperience (PX). In this paper we considered the programmers as a type of users of an IDE and different programming and system related artifacts. After studying different research articles about programmer experiences related to different programming languages, tools and environments, we analyzed that most of the currently available literature focuses on PX from a Computer Software Engineering perspective, also it has been felt that there is an increasing interest in the PX topic, but still the main concept is not clearly defined and understood. Thus, we have tried to focus our main research work on programmer’s experience from a Human-Computer-Interaction (HCI) perspective. Most of current literature and research work focuses on the usability and PX aspects focusing on four topics: (i) programming languages, (ii) programmers’ interaction with integrated development environment, (iii) application programming interfaces, and (iv) programmers’ behavior. This represents a research opportunity for this systematic review and others that can be performed.		978-1-6654-1901-7		Programmer experience;Programming;HCI;User Experience;Usability	Human computer interaction;Computer languages;Systematics;Focusing;Programming;Tools;Software	application program interfaces;human computer interaction;software engineering;user experience	user experience;software programmers;software development lifecycle;PX;programmer experiences;human-computer-interaction perspective;HCI;users direct interactions;computer software engineering perspective;programming languages				42	IEEE	24 nov. 2021			IEEE	IEEE Conferences
An approach to understanding program comprehensibility using spatial complexity, concept assignment and typographical style	an approach to understanding program comprehensibility using spatial complexity, concept assignment and typographical style	10.1109/ICSM.2004.1357872	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1357872	A. Mohan; N. Gold; P. Layzell	Information Systems Group, Department of Computation, UMIST (University of Manchester Institute of Science and Technology), UK; Information Systems Group, Department of Computation, UMIST (University of Manchester Institute of Science and Technology), UK; Information Systems Group, Department of Computation, UMIST (University of Manchester Institute of Science and Technology), UK	20th IEEE International Conference on Software Maintenance, 2004. Proceedings.	22 nov. 2004	2004			530		This paper has briefly presented an approach to identifying the comprehensibility of a program and initial results from its application. The results obtained so far, indicate that this approach is useful in modelling the comprehensibility of a program as it evolves. However further work is required to calibrate this approach to more accurately reflect comprehensibility and to identify at what point corrective action should be undertaken to maintain the quality of the program.	1063-6773	0-7695-2213-0			Software maintenance;Gold;Costs;Information systems;Software systems;Programming profession;Cognitive science;Software measurement;Man machine systems	reverse engineering;software maintenance;software metrics	spatial complexity;concept assignment;typographical style;program comprehensibility modelling;program quality				5		22 nov. 2004			IEEE	IEEE Conferences
Automatically assessing code understandability: How far are we?	automatically assessing code understandability how far are we	10.1109/ASE.2017.8115654	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115654	S. Scalabrino; G. Bavota; C. Vendome; M. Linares-Vásquez; D. Poshyvanyk; R. Oliveto	University of Molise, Italy; University of Molise, Italy; Università della Svizzera italiana (USI), Switzerland; The College of William and Mary, USA; The College of William and Mary, USA; Universidad de los Andes, Colombia	2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)	23 nov. 2017	2017			417	427	Program understanding plays a pivotal role in software maintenance and evolution: a deep understanding of code is the stepping stone for most software-related activities, such as bug fixing or testing. Being able to measure the understandability of a piece of code might help in estimating the effort required for a maintenance activity, in comparing the quality of alternative implementations, or even in predicting bugs. Unfortunately, there are no existing metrics specifically designed to assess the understandability of a given code snippet. In this paper, we perform a first step in this direction, by studying the extent to which several types of metrics computed on code, documentation, and developers correlate with code understandability. To perform such an investigation we ran a study with 46 participants who were asked to understand eight code snippets each. We collected a total of 324 evaluations aiming at assessing the perceived understandability, the actual level of understanding, and the time needed to understand a code snippet. Our results demonstrate that none of the (existing and new) metrics we considered is able to capture code understandability, not even the ones assumed to assess quality attributes strongly related with it, such as code readability and complexity.		978-1-5386-2684-9		Software metrics;Code understandability;Empirical study;Negative result	Measurement;Complexity theory;Software;Computer bugs;Correlation;Maintenance engineering;Documentation	program debugging;public domain software;software maintenance;software metrics;software quality	program understanding;software maintenance;software-related activities;perceived understandability;code readability;code snippet;code complexity;automatic code understandability assessibility;quality attributes		37		37		23 nov. 2017			IEEE	IEEE Conferences
Automatically Assessing Code Understandability	automatically assessing code understandability	10.1109/TSE.2019.2901468	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8651396	S. Scalabrino; G. Bavota; C. Vendome; M. Linares-Vásquez; D. Poshyvanyk; R. Oliveto	University of Molise, Campobasso, CB, Italy; Università della Svizzera italiana(USI), Lugano, Switzerland; Miami University, Oxford, OH, USA; Universidad de los Andes, Bogota, Colombia; College of William & Mary, Williamsburg, VA, USA; University of Molise, Campobasso, CB, Italy	IEEE Transactions on Software Engineering	16 mar. 2021	2021	47	3	595	613	Understanding software is an inherent requirement for many maintenance and evolution tasks. Without a thorough understanding of the code, developers would not be able to fix bugs or add new features timely. Measuring code understandability might be useful to guide developers in writing better code, and could also help in estimating the effort required to modify code components. Unfortunately, there are no metrics designed to assess the understandability of code snippets. In this work, we perform an extensive evaluation of 121 existing as well as new code-related, documentation-related, and developer-related metrics. We try to (i) correlate each metric with understandability and (ii) build models combining metrics to assess understandability. To do this, we use 444 human evaluations from 63 developers and we obtained a bold negative result: none of the 121 experimented metrics is able to capture code understandability, not even the ones assumed to assess quality attributes apparently related, such as code readability and complexity. While we observed some improvements while combining metrics in models, their effectiveness is still far from making them suitable for practical applications. Finally, we conducted interviews with five professional developers to understand the factors that influence their ability to understand code snippets, aiming at identifying possible new metrics.	1939-3520		SNF project JITRA(grant numbers:172479); National Science Foundation(grant numbers:CCF-1525902); 	Software metrics;code understandability;empirical study;negative result	Complexity theory;Software;Computer bugs;Readability metrics;Software measurement;Indexes	program debugging;software maintenance;software metrics;software quality	code-related;code components;measuring code understandability;evolution tasks;maintenance;inherent requirement;understanding software;assessing code understandability;code snippets;professional developers;code readability;121 experimented metrics;444 human evaluations;developer-related metrics;documentation-related		14		55	IEEE	24 Feb 2019			IEEE	IEEE Journals
Style-Analyzer: Fixing Code Style Inconsistencies with Interpretable Unsupervised Algorithms	styleanalyzer fixing code style inconsistencies with interpretable unsupervised algorithms	10.1109/MSR.2019.00073	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8816753	V. Markovtsev; W. Long; H. Mougard; K. Slavnov; E. Bulychev	source{d}, Madrid, Spain; source{d}, Madrid, Spain; source{d}, Madrid, Spain; source{d}, Madrid, Spain; source{d}, Madrid, Spain	2019 IEEE/ACM 16th International Conference on Mining Software Repositories (MSR)	29 Aug 2019	2019			468	478	Source code reviews are manual, time-consuming, and expensive. Human involvement should be focused on analyzing the most relevant aspects of the program, such as logic and maintainability, rather than amending style, syntax, or formatting defects. Some tools with linting capabilities can format code automatically and report various stylistic violations for supported programming languages. They are based on rules written by domain experts, hence, their configuration is often tedious, and it is impractical for the given set of rules to cover all possible corner cases. Some machine learning-based solutions exist, but they remain uninterpretable black boxes. This paper introduces style-analyzer, a new open source tool to automatically fix code formatting violations using the decision tree forest model which adapts to each codebase and is fully unsupervised. style-analyzer is built on top of our novel assisted code review framework, Lookout. It accurately mines the formatting style of each analyzed Git repository and expresses the found format patterns with compact human-readable rules. style-analyzer can then suggest style inconsistency fixes in the form of code review comments. We evaluate the output quality and practical relevance of style-analyzer by demonstrating that it can reproduce the original style with high precision, measured on 19 popular JavaScript projects, and by showing that it yields promising results in fixing real style mistakes. style-analyzer includes a web application to visualize how the rules are triggered. We release style-analyzer as a reusable and extendable open source software package on GitHub for the benefit of the community.	2574-3864	978-1-7281-3412-3		assisted code review, code style, decision tree forest, interpretable machine learning	Decision trees;Feature extraction;Tools;Machine learning;Forestry;Syntactics;Training	data mining;decision trees;program debugging;program diagnostics;public domain software;software maintenance;software packages;source code (software);unsupervised learning	code formatting violations;style-analyzer;formatting style;code style inconsistencies;source code reviews;open source tool;decision tree forest model;Git repository		2		23		29 Aug 2019			IEEE	IEEE Conferences
Code style analytics for the automatic setting of formatting rules in IDEs: A solution to the Tabs vs. Spaces Debate	code style analytics for the automatic setting of formatting rules in ides a solution to the tabs vs. spaces debate	10.1109/ICDIM.2017.8244675	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8244675	E. Torunski; M. O. Shafiq; A. Whitehead	School of Computer Science, Carleton University, Ottawa, Ontario; School of Information Technology, Carleton University, Ottawa, Ontario; School of Information Technology, Carleton University, Ottawa, Ontario	2017 Twelfth International Conference on Digital Information Management (ICDIM)	4 jan. 2018	2017			6	14	The use of code style is very important since it conveys meaning as well as intent of source code. Developers are used to reading code according to their preferred style but those guidelines of proper style vary among software teams, and even different companies. Code style decisions are typically made by managers of software developers, but we would like to investigate how common the different variations of code style are. There are also automated tools to convert code style in a file, however the tools must be configured manually. In this paper, we present a tool for the collection and analysis of code style metrics. We demonstrate the feasibility of scanning existing source code to automatically generate the code style rules for existing tools. We also look at the results of our data mining to look at trends in source code. We perform a quantitative analysis on source code for questions like: How many functions are in a class, on average? How many lines of code are in a method, on average? We also present graphs of the distribution of these data, as well look at special cases of outliers.		978-1-5386-0664-3		soft-ware prototyping;code style;analytics;software metrics;static code tools	Tools;Software;Companies;Visualization;Computer languages;Computer bugs;Image color analysis	data mining;software maintenance;software quality;software tools	code style decisions;code style metrics;code style rules;code style analytics;preferred style;proper style;source code;IDEs;software developers				18		4 jan. 2018			IEEE	IEEE Conferences
LabVIEW's code style and optimization	labviews code style and optimization	10.1109/MIC.2013.6758239	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6758239	Hongmin Wang; Kongqi Li; Dandan Li	Harbin University of Science and Technology, Optic&Electronic Engineering Research Center, Harbin, China; Harbin University of Science and Technology, Optic&Electronic Engineering Research Center, Harbin, China; Harbin University of Science and Technology, Optic&Electronic Engineering Research Center, Harbin, China	Proceedings of 2013 2nd International Conference on Measurement, Information and Control	6 mar. 2014	2013	2		1483	1486	LabVIEW has a unique style of code, this is one of the main features distinguish it from other programming languages, in this paper, we mainly elaborate two key aspects from the LabVIEW code style to code optimization, both better together, after understanding of the LabVIEW's unique style code, we can better optimize the program, this will bring many convenient to programmers.		978-1-4799-1392-3		style;features;Optimization;Labview;code	Computer languages;Programming;Algorithm design and analysis;Optimization;Educational institutions;Presses;Arrays	programming languages;virtual instrumentation	LabVIEW code style;programming languages;code optimization				10		6 mar. 2014			IEEE	IEEE Conferences
Anchoring Code Understandability Evaluations Through Task Descriptions	anchoring code understandability evaluations through task descriptions	10.1145/3524610.3527904	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796301	M. Wyrich; L. Merz; D. Graziotin	University of Stuttgart, Stuttgart, Germany; University of Stuttgart, Stuttgart, Germany; University of Stuttgart, Stuttgart, Germany	2022 IEEE/ACM 30th International Conference on Program Comprehension (ICPC)	22 jun. 2022	2022			133	140	In code comprehension experiments, participants are usually told at the beginning what kind of code comprehension task to expect. Describing experiment scenarios and experimental tasks will influence participants in ways that are sometimes hard to predict and control. In particular, describing or even mentioning the difficulty of a code comprehension task might anchor participants and their perception of the task itself. In this study, we investigated in a randomized, controlled experiment with 256 participants (50 software professionals and 206 computer science students) whether a hint about the difficulty of the code to be understood in a task description anchors participants in their own code comprehensibility ratings. Subjective code evaluations are a commonly used measure for how well a developer in a code comprehension study understood code. Accordingly, it is important to understand how robust these measures are to cognitive biases such as the anchoring effect. Our results show that participants are significantly influenced by the initial scenario description in their assessment of code com-prehensibility. An initial hint of hard to understand code leads participants to assess the code as harder to understand than partic-ipants who received no hint or a hint of easy to understand code. This affects students and professionals alike. We discuss examples of design decisions and contextual factors in the conduct of code comprehension experiments that can induce an anchoring effect, and recommend the use of more robust comprehension measures in code comprehension studies to enhance the validity of results.	2643-7171	978-1-4503-9298-3		code comprehension;anchoring effect;empirical study design;soft-ware metrics	Computer science;Codes;Atmospheric measurements;Particle measurements;Time measurement;Software;Task analysis	cognition;computer aided instruction;computer science education;decision making;man-machine systems;natural language processing;software development management;software maintenance;software metrics;text analysis;Web sites	experimental tasks;code comprehension task;randomized controlled experiment;hint;task description anchors participants;code comprehensibility ratings;subjective code evaluations;code comprehension study;anchoring effect;initial scenario description;code comprehension experiments;robust comprehension measures;anchoring code;task descriptions;experiment scenarios				33		22 jun. 2022			IEEE	IEEE Conferences
A Gamification Technique for Motivating Students to Learn Code Readability in Software Engineering	a gamification technique for motivating students to learn code readability in software engineering	10.1109/ISET.2018.00062	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8456230	Q. Mi; J. Keung; X. Mei; Y. Xiao; W. K. Chan	Department of Computer Science, City University of Hong Kong, Hong Kong; Department of Computer Science, City University of Hong Kong, Hong Kong; Department of Computer Science, City University of Hong Kong, Hong Kong; Department of Computer Science, City University of Hong Kong, Hong Kong; Department of Computer Science, City University of Hong Kong, Hong Kong	2018 International Symposium on Educational Technology (ISET)	6 Sep 2018	2018			250	254	Code readability is one of the important software quality attributes that computer science students need to learn in their programming classes, unfortunately most of the students do not have the necessary work experience or background to appreciate the importance of code readability. Traditional methods of learning code readability tend to be less than interactive and practical in the classroom environment. With the advent of gamification technique, this study introduced a new interactive teaching method and implemented as GamiCRS, an online platform for students to learn code readability. The focus was on incorporating game-based mechanisms to enable students with positive attitudes towards a more interesting learning process. A complete incentive and reward model is proposed in the study together with a combination of both intrinsic and extrinsic motivators identified. To ensure its dynamic efficacy, a field experiment was carried out to compare GamiCRS with its non-gamified counterparts and to evaluate learning outcomes. The empirical results show a positive effect towards the application of GamiCRS in the classroom environment. As many learning activities in software engineering are typically challenging and seldom amusing, gamification can thus be applied as a compelling addition to supporting a wider variety of teaching tactics.		978-1-5386-7209-9		Code Readability;Gamification;Education;Crowdsourcing;Motivation;Technology Acceptance Model	Crowdsourcing;Education;Task analysis;Software engineering;Computer science;Urban areas;Software	computer aided instruction;computer games;computer science education;human factors;software engineering;software quality;teaching	gamification technique;code readability;software engineering;computer science students;student motivation;software quality attributes;interactive teaching method;GamiCRS;reward model;incentive model		7		14		6 Sep 2018			IEEE	IEEE Conferences
Measurement of Source Code Readability Using Word Concreteness and Memory Retention of Variable Names	measurement of source code readability using word concreteness and memory retention of variable names	10.1109/COMPSAC.2017.166	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8029587	W. Xu; D. Xu; L. Deng	Department of Computer Science, Bowie State University, Bowie, MD, USA; Department of Computer Scienc, Boise State University, Boise, ID, USA; Department of Computer & Info Science, Towosn University, Towosn, MD, USA	2017 IEEE 41st Annual Computer Software and Applications Conference (COMPSAC)	11 Sep 2017	2017	1		33	38	Source code readability is critical to software quality assurance and maintenance. In this paper, we present a novel approach to the automated measurement of source code readability based on Word Concreteness and Memory Retention (WCMR) of variable names. The approach considers programming and maintenance as processes of organizing variables and their operations to describe solutions to specific problems. The overall readability of given source code is calculated from the readability of all variables contained in the source code. The readability of each variable is determined by how easily its meaning is memorized (i.e., word concreteness) and how quickly they are forgotten over time (i.e., memory retention). Our empirical study has used 14 open source applications with over a half-million lines of code and 10,000 warning defects. The result shows that the WCMR-based source code readability negatively correlates strongly with overall warning defect rates, and particularly with such warning as bad programming practices, code vulnerability, and correctness bug warning.	0730-3157	978-1-5386-0367-3		Code Readability;Variable Definitions and References;Word Concreteness;Memory Retention	Programming;Dictionaries;Maintenance engineering;Semantics;Software quality	program debugging;public domain software;software fault tolerance;software maintenance;software quality;source code (software)	variable names;code vulnerability;software quality assurance;open source applications;software maintenance;source code readability measurement;word concreteness and memory retention;WCMR;warning defects;correctness bug warning		1		22	IEEE	11 Sep 2017			IEEE	IEEE Conferences
An initial approach to assessing program comprehensibility using spatial complexity, number of concepts and typographical style	an initial approach to assessing program comprehensibility using spatial complexity, number of concepts and typographical style	10.1109/WCRE.2004.11	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1374324	A. Mohan; N. Gold; P. Layzell	Information Systems Group, Department of Computation, UMIST (University of Manchester Institute of Science and Technology), UK; Information Systems Group, Department of Computation, UMIST (University of Manchester Institute of Science and Technology), UK; Information Systems Group, Department of Computation, UMIST (University of Manchester Institute of Science and Technology), UK	11th Working Conference on Reverse Engineering	17 jan. 2005	2004			246	255	Software evolution can result in making a program harder to maintain, as it becomes more difficult to comprehend. This difficulty is related to the way the source code is formatted, the complexity of the code, and the amount of information contained within it. This work presents an initial approach that uses measures of typographical style, spatial complexity and concept assignment to measure these factors, and to model the comprehensibility of an evolving program. The ultimate aim of which is to identify when a program becomes more difficult to comprehend, triggering a corrective action to be taken to prevent this. We present initial findings from applying this approach. These findings show that this approach, through measuring these three factors, can model the change in comprehensibility of an evolving program. Our findings support the well-known claim that programs become more complex as they evolve, explaining this increase in complexity in terms of layout changes, conceptual coherence, spatial relationships between source code elements, and the relationship between these factors. This in turn can then be used to understand how maintenance affects program comprehensibility and to ultimately reduce its burden on software maintenance.	1095-1350	0-7695-2243-2		software evolution;software maintenance;program comprehension;software quality	Software maintenance;Costs;Software quality;Gold;Information systems;Coherence;Software systems;Maintenance engineering;Guidelines;Monitoring	software maintenance;software quality;reverse engineering;computational complexity	software evolution;software maintenance;program comprehension;software quality;spatial complexity;typographical style;source code;concept assignment;layout changes;conceptual coherence;spatial relationships		3		29		17 jan. 2005			IEEE	IEEE Conferences
Basic Code Understanding Challenges for Elementary School Children	basic code understanding challenges for elementary school children	10.1109/RESPECT49803.2020.9272421	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9272421	O. M. Nche; R. Boulware; S. M. Che; E. T. Kraemer; M. Sitaraman; V. B. Zordan	School of Computing, Clemson University; Business Development, Claflin University; College of Education, Clemson University; School of Computing, Clemson University; School of Computing, Clemson University; School of Computing, Clemson University	2020 Research on Equity and Sustained Participation in Engineering, Computing, and Technology (RESPECT)	4 Dec 2020	2020	1		1	2	We describe a research study aimed at understanding the basic code reasoning challenges of elementary school children. The research targets third to fifth grade African American students as a step towards making computer science accessible to all children. The study was conducted in a summer camp with 40 students and replicated with 20 new students the following summer. Also participating in the second summer camp were 19 returning students. For data collection, the study uses code-tracing activities involving concepts such as variables, assignments, operators, and sequencing. Performance data is automatically collected in the background as children engage in the activities incorporated in a video game and also through think-aloud sessions. Results include common code understanding challenges for all children.		978-1-7281-7172-2		Broadening participation;K-12 education;coding;game;summer camp;coding concepts	Games;Encoding;Sequential analysis;Education;Faces;Cognition;Writing	computer aided instruction;computer science education;serious games (computing)	returning students;basic code understanding challenges;common code understanding challenges;code-tracing activities;data collection;summer camp;computer science;fifth grade African American students;elementary school children;basic code reasoning challenges				10		4 Dec 2020			IEEE	IEEE Conferences
Pitekün: An Experimental Visual Tool to Assist Code Navigation and Code Understanding	pitekün an experimental visual tool to assist code navigation and code understanding	10.1109/SCCC.2014.31	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7559691	J. Kubelka; A. Bergel; R. Robbes	Department of Computer Science (DCC), University of Chile jkubelka, abergel; Department of Computer Science (DCC), University of Chile jkubelka, abergel; Department of Computer Science (DCC), University of Chile jkubelka, abergel	2014 33rd International Conference of the Chilean Computer Science Society (SCCC)	5 Sep 2016	2014			135	137	Studies show that software developers spend significantly more time navigating and understanding a codebase than actually writing code. Oddly, code navigation and comprehension are poorly supported by current programming environments. We present the main lines of the Pitekϋn programming environment to mitigate the gap between developer information needs and the current tool support. Pitekun uses three techniques to address the gap: (i) a spatial representation of the codebase, (ii) visual cues, and (iii) polymetric views. We conjecture that Pitekun improves navigation in the codebase and in answering the questions developers ask when learning the codebase.	1522-4902	978-1-5090-0421-8		software engineering;development tool;code navigation	Visualization;Navigation;Context;Software;Maintenance engineering;Programming environments;Computer science	programming environments;reverse engineering;source code (software);visual programming	experimental visual tool;code navigation;code understanding;code comprehension;Pitekϋn programming environment;codebase spatial representation;visual cues;polymetric views						5 Sep 2016			IEEE	IEEE Conferences
Learning a Metric for Code Readability	learning a metric for code readability	10.1109/TSE.2009.70	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5332232	R. P. L. Buse; W. R. Weimer	University of Virginia, Charlottesville, VA, USA; University of Virginia, Charlottesville, VA, USA	IEEE Transactions on Software Engineering	29 jul. 2010	2010	36	4	546	558	In this paper, we explore the concept of code readability and investigate its relation to software quality. With data collected from 120 human annotators, we derive associations between a simple set of local code features and human notions of readability. Using those features, we construct an automated readability measure and show that it can be 80 percent effective and better than a human, on average, at predicting readability judgments. Furthermore, we show that this metric correlates strongly with three measures of software quality: code changes, automated defect reports, and defect log messages. We measure these correlations on over 2.2 million lines of code, as well as longitudinally, over many releases of selected projects. Finally, we discuss the implications of this study on programming language design and engineering practice. For example, our data suggest that comments, in and of themselves, are less important than simple blank lines to local judgments of readability.	1939-3520			Software readability;program understanding;machine learning;software maintenance;code metrics;FindBugs.	Software quality;Humans;Software maintenance;Readability metrics;Documentation;Software measurement;Computer languages;Design engineering;Machine learning;Costs	human factors;software quality	code readability;software quality;local code features;human notions;code changes;automated defect reports;defect log messages;programming language design		175		41		13 nov. 2009			IEEE	IEEE Journals
Code Readability Metric for PHP	code readability metric for php	10.1109/GCCE46687.2019.9015229	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9015229	C. T. Mon; S. S. Hlaing; M. M. Tin; M. M. Khin; T. M. M. Lwin; K. M. Myo	Myanmar Institute of Information Technology, Mandalay, Maynmar; Myanmar Institute of Information Technology, Mandalay, Maynmar; Myanmar Institute of Information Technology, Mandalay, Maynmar; Myanmar Institute of Information Technology, Mandalay, Maynmar; Myanmar Institute of Information Technology, Mandalay, Maynmar; Central Institute of Civil Service, Upper Myanmar	2019 IEEE 8th Global Conference on Consumer Electronics (GCCE)	27 Feb 2020	2019			929	930	PHP is one of the most popular languages that millions of websites and web applications are developed every month using PHP. In this paper, software metric related to code readability is developed and suitable set of attributes are identified for the given system to establish a software quality observatory for PHP language. Correlation criterion was used to empirically validate the developed metric and to find out the nature of relationship between the metric and other well-known metric. Moreover, the other validation, such as validation by using PHP Mess Detector (PHPMD) tool was also evaluated in the system. According to these analysis results, the proposed metric is applicable and usable to the field of software engineering metrics by providing a practical summary of the metric validation criteria found in the academic literature.	2378-8143	978-1-7281-3575-5		software metric;readability;software quality;Correlation;PHP Mess Detector	Tools;Software quality;Correlation;Readability metrics;Software measurement	program verification;software metrics;software quality	code readability metric;Web applications;software quality;PHP language;correlation criterion;PHP Mess Detector tool;software engineering metrics		2		9		27 Feb 2020			IEEE	IEEE Conferences
EGAN: An Effective Code Readability Classification using Ensemble Generative Adversarial Networks	egan an effective code readability classification using ensemble generative adversarial networks	10.1109/ICCAKM46823.2020.9051555	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9051555	S. Sharma; S. Srivastava	Manipal University, Jaipur; Manipal University, Jaipur	2020 International Conference on Computation, Automation and Knowledge Management (ICCAKM)	2 Apr 2020	2020			312	316	Classification of code script readability (which corresponds to categorizing a source code as either readable or unreadable) has prompted severe concern in academia and industry. To construct accurate classification models, previous studies depended mainly upon handcrafted features. However, the manual feature engineering process is usually labor-intensive and can capture only partial information about the source code, which is likely to limit the model performance. To improve this, we propose the use of GAN's (Generative Adversarial Networks). First, we present a representation approach (with multiple granularities) to encode source codes as the input to GAN's into integer matrices. Then we propose an EGAN based on GAN's for the code readability classification. EGAN consists of three separate GANs with identical architectures that are trained on data preprocessed in different ways. We evaluate our approach against five state-of-the-art code readability models. The findings of the tests demonstrate that RGA can surpass previous approaches. The quality increase varies from 2% to 15%. EGAN offers reasonably improved performance by removing the need for manual interface design, demonstrating the usefulness of GAN's approaches in code readability classification tasks.		978-1-7281-0666-3				feature extraction;learning (artificial intelligence);matrix algebra;neural nets;pattern classification;software engineering;source code (software)	EGAN;code script readability;source code;code readability models;GAN approaches;code readability classification tasks;ensemble generative adversarial networks;integer matrices;RGA				14		2 Apr 2020			IEEE	IEEE Conferences
Evaluating the Reliability of Web Services Based on BPEL Code Structure Analysis and Run-Time Information Capture	evaluating the reliability of web services based on bpel code structure analysis and runtime information capture	10.1109/APSEC.2010.32	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5693196	B. Li; X. Fan; Y. Zhou; Z. Su	School of Computer Science and Engineering, South-East University, China; School of Engineering, Pennsylvania State University, USA; School of Computer Science and Engineering, South-East University, China; School of Computer Science and Engineering, South-East University, China	2010 Asia Pacific Software Engineering Conference	20 jan. 2011	2010			206	215	In this article, an approach is proposed to evaluate the reliability of Web services, where three kinds of Web services are discussed, they are atomic service without the structural information, structural activity based composite service which is composed from other services by using a structural activity mechanism, and BPEL flow process based composite service which composes all kinds of atomic services and activity based composite services using BPEL language in an orchestration style. Firstly, the reliability of atomic service is evaluated based on an extended UDDI model, then, the reliability of activity based composite services is evaluated using BPEL code structure analysis, the reliability of atomic service, and function transition probability, finally, the reliability of BPEL flow process based composite web service was evaluated by a recursive algorithm. Case study and experimental results show the significance of the approach.	1530-1362	978-1-4244-8831-5		Web service;Reliability;Code structure analysis	Reliability;Web services;Mathematical model;Data models;Equations;Switches;Analytical models	recursive functions;service-oriented architecture;software reliability;specification languages;Web services	Web services;reliability;BPEL code structure analysis;run-time information capture;atomic service;structural activity;BPEL flow process;activity based composite services;BPEL language;orchestration style;extended UDDI model;function transition probability;recursive algorithm		8		18		20 jan. 2011			IEEE	IEEE Conferences
Bug Localization Approach Using Source Code Structure with Different Structure Fields	bug localization approach using source code structure with different structure fields	10.1109/SERA.2018.8477206	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8477206	K. E. E. Swe; H. M. Oo	University of Computer Studies, Mandalay, Mandalay, Myanmar; University of Computer Studies, Mandalay, Mandalay, Myanmar	2018 IEEE 16th International Conference on Software Engineering Research, Management and Applications (SERA)	30 Sep 2018	2018			159	164	In bug localization approach, the information of the bug was used by developer to modify the source code where the errors occurred. To fix the source code that need to be correct is a problem for developer. Numerous automatic bug localization approaches by using information retrieval have been proposed. In this paper, we propose bug localization approach by combining structure of source code with different structure fields, similarity of bugs and stack-trace. It recommends relevance bug files to fix according to their highest scores. We additionally propose bug localization to consider the source code with three difference structure fields. In recent approaches source code files are consider as a single units. It may cause many noises when the source code file is large. We implement our approach on four open source projects (AspectJ, Eclipse and SWT). We then compute our approach in term of top-N rank, mean average precision (MAP) and mean reciprocal rank (MRR) evaluation metrics. The results show that the proposed system achieves significant results.		978-1-5386-5886-4		bug localization;code structure;stack-trace;information retrieval	Computer bugs;Software;Information retrieval;Semantics;Analytical models;Indexing;Standards	information retrieval;program debugging;public domain software;source code (software)	source code file;open source projects;bug localization approach;source code structure;bug files;structure fields;information retrieval;MAP;AspectJ;Eclipse;SWT;MRR;mean reciprocal rank evaluation metrics;mean average precision evaluation metrics;top-N rank evaluation metrics		1		18		30 Sep 2018			IEEE	IEEE Conferences
The signal code structure selection in the communication channels in the wireless sensor networks	the signal code structure selection in the communication channels in the wireless sensor networks	10.1109/MWENT.2018.8337290	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8337290	V. V. Fedorenko; D. V. Aldushchenko; N. V. Listova; I. V. Samoylenko; V. V. Samoylenko	North-Caucasus Federal University, Stavropol, Russia; North-Caucasus Federal University, Stavropol, Russia; North-Caucasus Federal University, Stavropol, Russia; North-Caucasus Federal University, Stavropol, Russia; Stavropol State Agrarian University, Stavropol, Russia	2018 Moscow Workshop on Electronic and Networking Technologies (MWENT)	16 Apr 2018	2018			1	4	The algorithm of the signal code structure selection is proposed. The structure is optimum for the minimum criterion of the erroneous message transfer probability method under the conditions of the concentrated interferences in the channel and equipment signal distortions. The branch-and-bound method is realized. The effectiveness of this algorithm in computational complexity reduction in comparison with the methods of sequential sorting is shown for the parameters specific values of the distorted signal and interference.		978-1-5386-3498-1		Wireless Sensor Networks;Signal Distortion;Interference in the Communication Channel;Signals Correlation Indices;Signals Code Structure;Branch-and-Bound Method	Distortion;Interference;Wireless sensor networks;Linear matrix inequalities;Conferences;Communication channels;Harmonic analysis	computational complexity;radiofrequency interference;telecommunication channels;wireless sensor networks	signal code structure selection;communication channels;wireless sensor networks;erroneous message transfer probability method;equipment signal distortions;distorted signal;concentrated interferences;branch-and-bound method;computational complexity;sequential sorting;distorted interference		1		12		16 Apr 2018			IEEE	IEEE Conferences
Bug Localization Approach Based on Similar Bug Report, Stack Trace and Source Code Structure	bug localization approach based on similar bug report, stack trace and source code structure	10.1109/ICCTA43079.2017.9497154	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9497154	K. E. E. Swe; H. M. Oo	University of Computer Studies, Mandalay, Mandalay, Myanmar; University of Computer Studies, Mandalay, Mandalay, Myanmar	2017 27th International Conference on Computer Theory and Applications (ICCTA)	30 jul. 2021	2017			57	62	Bug localization helps software developers to track post-released faulty source files with the help of user's reported bug files. Bug localization gains high popularity in software maintenance since many recent years due to its essential role to fix unavoidable bugs encountered in software development process. In this paper, we propose bug localization approach for locating erroneous faulty source files. It recommends relevant faulty source files to fix according to their highest similarity scores. We additionally exploit information retrieval techniques to consider the source and bug files as documents so that we can retrieve the similar terms from the code structures with different levels, historical bug documents and stack-trace information of both of files. We implement the proposed system on the top of BugLocator equipped with our methods and contributions. We then perform the experiments and compare the results with proficient contemporary approaches: BugLocator and BLUiR in terms of top-N rank, mean average precision (MAP) and mean reciprocal rank (MRR) evaluation metrics. The results show that the proposed system achieves more significant results than other approaches.		978-1-5386-3794-4		Bug localization;Code structure;Stack-trace;Bug report;Information retrieval	Location awareness;Measurement;Software maintenance;Computer bugs;Information retrieval	information retrieval;natural language processing;program debugging;public domain software;software maintenance	bug localization approach;similar bug report;stack trace;source code structure;software developers;post-released faulty source files;user;bug localization gains high popularity;software maintenance;unavoidable bugs;software development process;erroneous faulty source files;relevant faulty source files;highest similarity scores;bug files;similar terms;code structures;historical bug documents;stack-trace information				15		30 jul. 2021			IEEE	IEEE Conferences
CodeSurveyor: Mapping large-scale software to aid in code comprehension	codesurveyor mapping largescale software to aid in code comprehension	10.1109/VISSOFT.2015.7332419	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7332419	N. Hawes; S. Marshall; C. Anslow	Oracle Labs, Brisbane, Australia; Victoria University of Wellington, Wellington, New Zealand; Middlesex University, London, UK	2015 IEEE 3rd Working Conference on Software Visualization (VISSOFT)	23 nov. 2015	2015			96	105	Large codebases - in the order of millions of lines of code (MLOC) - are incredibly complex. Whether fixing a fault, or implementing a new feature, changes to such systems often have unanticipated effects, as it is impossible for a developer to maintain a complete understanding of the code in their head. This paper presents CodeSurveyor, a spatial visualization technique that aims to support code comprehension in large codebases by allowing developers to view large-scale software at all levels of abstraction. It uses a cartographic metaphor to produce an interactive map of a codebase where users can zoom from a view of a system's high-level architectural components, represented as continents, down to the individual source files and the entities they define, shown as countries and states, respectively. The layout of the produced code map incorporates system dependency data and sizes regions according to a userconfigurable metric (line count by default), to create distinctive shapes and positions that serve as strong visual landmarks and keep users oriented. We detail the CodeSurveyor algorithm, show it generates code maps of the Linux kernel (1.4 MLOC) in 1.5 minutes, and evaluate the intuitiveness of the metaphor to software developers and its utility in navigation tasks. Results show the effectiveness of the approach with developers of varying experience levels.		978-1-4673-7526-9		software visualization;code comprehension	Layout;Visualization;Shape;Vocabulary;Measurement;Software systems	data visualisation;Linux;source code (software)	CodeSurveyor;large-scale software mapping;code comprehension;codebase;millions of lines of code;MLOC;spatial visualization technique;cartographic metaphor;interactive map;system high-level architectural components;source files;code map;system dependency data;user configurable metric;visual landmark;Linux kernel;navigation task;time 1.5 min		12		17		23 nov. 2015			IEEE	IEEE Conferences
Source code comprehension strategies and metrics to predict comprehension effort in software maintenance and evolution tasks - an empirical study with industry practitioners	source code comprehension strategies and metrics to predict comprehension effort in software maintenance and evolution tasks an empirical study with industry practitioners	10.1109/ICSM.2011.6080814	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6080814	K. Nishizono; S. Morisakl; R. Vivanco; K. Matsumoto	Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, NARA, JAPAN; Faculty of Informatics, Shizuoka University, 3-5-1 Johoku, Naka, Hamamatsu, 432-8011 JAPAN; Department of Computer Science, University of Manitoba, Winnipeg, Canada; Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, NARA, JAPAN	2011 27th IEEE International Conference on Software Maintenance (ICSM)	17 nov. 2011	2011			473	481	The goal of this research was to assess the consistency of source code comprehension strategies and comprehension effort estimation metrics, such as LOC, across different types of modification tasks in software maintenance and evolution. We conducted an empirical study with software development practitioners using source code from a small paint application written in Java, along with four semantics-preserving modification tasks (refactoring, defect correction) and four semantics-modifying modification tasks (enhancive and modification). Each task has a change specification and corresponding source code patch. The subjects were asked to comprehend the original source code and then judge whether each patch meets the corresponding change specification in the modification task. The subjects recorded the time to comprehend and described the comprehension strategies used and their reason for the patch judgments. The 24 subjects used similar comprehension strategies. The results show that the comprehension strategies and effort estimation metrics are not consistent across different types of modification tasks. The recorded descriptions indicate the subjects scanned through the original source code and the patches when trying to comprehend patches in the semantics-modifying tasks while the subjects only read the source code of the patches in semantics-preserving tasks. An important metric for estimating comprehension efforts of the semantics-modifying tasks is the Code Clone Subtracted from LOC(CCSLOC), while that of semantics-preserving tasks is the number of referred variables.	1063-6773	978-1-4577-0664-6		source code comprehension;comprehension effort estimation metrics;semantics-preserving;semantics-modifying;software maintenance and evolution	Analytical models;Measurement	software maintenance;software metrics	source code comprehension;software maintenance;evolution task;comprehension effort estimation metrics;software evolution;software development practitioner;semantics-preserving modification task;refactoring;defect correction;semantics-modifying modification task;source code patch;code clone subtracted from LOC		8		17		17 nov. 2011			IEEE	IEEE Conferences
On Using Tree Visualisation Techniques to Support Source Code Comprehension	on using tree visualisation techniques to support source code comprehension	10.1109/VISSOFT.2016.8	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780163	I. Bacher; B. M. Namee; J. D. Kelleher	Dublin Institute of Technology, Dublin, Ireland; University College Dublin, Dublin, Ireland; Dublin Institute of Technology, Dublin, Ireland	2016 IEEE Working Conference on Software Visualization (VISSOFT)	12 Dec 2016	2016			91	95	This paper presents a design study that investigates the use of compact tree visualisations to provide software developers with an overview of the static structure of a source code document within a code editor in order to facilitate source code understanding and navigation. A prototype is presented which utilises an icicle tree visualisation to encode the control structure hierarchy of a source code document, as well as a circular treemap visualisation to encode the scope hierarchy of a source code document. An overview of the prototype and its functionality is given as well as a detailed discussion on the design rationale behind the tool. Possible applications and future work plans are also discussed.		978-1-5090-3850-3		Software visualisation;Tree visualisations techniques;Source code comprehension	Visualization;Software;Prototypes;Context;Navigation;Aerospace electronics;Data visualization	data visualisation;program control structures;software engineering;source code (software);trees (mathematics)	static structure;source code document;code editor;source code understanding;source code navigation;icicle tree visualisation;control structure hierarchy;circular treemap visualisation;scope hierarchy;design rationale;software development		4		23		12 Dec 2016			IEEE	IEEE Conferences
Considerations and Pitfalls in Controlled Experiments on Code Comprehension	considerations and pitfalls in controlled experiments on code comprehension	10.1109/ICPC52881.2021.00019	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463032	D. G. Feitelson	Department of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel	2021 IEEE/ACM 29th International Conference on Program Comprehension (ICPC)	28 jun. 2021	2021			106	117	Understanding program code is a complicated endeavor. As such, myriad different factors can influence the outcome. Investigations of program comprehension, and in particular those using controlled experiments, have to take these factors into account. In order to promote the development and use of sound experimental methodology, we discuss potential problems with regard to the experimental subjects, the code they work on, the tasks they are asked to perform, and the metrics for their performance.	2643-7171	978-1-6654-1403-6		Code comprehension;experimental methodology	Measurement;Task analysis	software engineering	understanding program code;complicated endeavor;program comprehension;sound experimental methodology;code comprehension		3		96	IEEE	28 jun. 2021			IEEE	IEEE Conferences
Supporting Code Comprehension via Annotations: Right Information at the Right Time and Place	supporting code comprehension via annotations right information at the right time and place	10.1109/VL/HCC50065.2020.9127264	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9127264	M. Adeli; N. Nelson; S. Chattopadhyay; H. Coffey; A. Henley; A. Sarma	Oregon State University, Corvallis, OR, USA; Oregon State University, Corvallis, OR, USA; Oregon State University, Corvallis, OR, USA; University of Tennessee-Knoxville, Knoxville, TN, USA; University of Tennessee-Knoxville, Knoxville, TN, USA; Oregon State University, Corvallis, OR, USA	2020 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)	16 jul. 2020	2020			1	10	Code comprehension, especially understanding relationships across project elements (code, documentation, etc.), is non-trivial when information is spread across different interfaces and tools. Bringing the right amount of information, to the place where it is relevant and when it is needed can help reduce the costs of seeking information and creating mental models of the code relationships. While non-traditional IDEs have tried to mitigate these costs by allowing users to spatially place relevant information together, thus far, no study has examined the effects of these non-traditional interactions on code comprehension. Here, we present an empirical study to investigate how the right information at the right time and right place allows users—especially newcomers—to reduce the costs of code comprehension. We use a non-traditional IDE, called Synectic, and implement link-able annotations which provide affordances for the accuracy, time, and space dimensions. We conducted a between-subjects user study of 22 newcomers performing code comprehension tasks using either Synectic or a traditional IDE, Eclipse. We found that having the right information at the right time and place leads to increased accuracy and reduced cognitive load during code comprehension tasks, without sacrificing the usability of developer tools.	1943-6106	978-1-7281-6901-9		Code comprehension;annotation;information foraging;Integrated development environment (IDE);user study	Visualization;Codes;Costs;Annotations;Affordances;Documentation;Cognitive science	programming environments;reverse engineering	code comprehension;code relationships;mental models;IDE;annotations;Synectic;Eclipse;cognitive load;integrated development environment		2		55		16 jul. 2020			IEEE	IEEE Conferences
The Role of the Version Control Information in Code Comprehension	the role of the version control information in code comprehension	10.1109/Informatics47936.2019.9119278	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9119278	T. Brunner; Z. Porkoláb	Department of Programming Languages and Compilers, Eötvös Loránd University, Budapest, Hungary; Department of Programming Languages and Compilers, Eötvös Loránd University, Budapest, Hungary	2019 IEEE 15th International Scientific Conference on Informatics	17 jun. 2020	2019			219	224	Most software comprehension frameworks use the source code as the main resource for information retrieval. Advanced code comprehension process, however, requires the utilization of the full knowledge portfolio of the software system. In this paper we investigate how the version control information of the project can be utilized for extending our apprehension of large legacy systems providing a better understanding of the software under examination. We show that some of the hidden structural connections between the elements of the program can be revealed most easily by the development history of the system. A prototype implementation of the method using git version control information has been implemented as an open source extension of the CodeCompass software comprehension framework.		978-1-7281-3180-1		code comprehension;version control;git;software technology		information retrieval;public domain software;software fault tolerance;software maintenance;software metrics;source code (software)	source code;information retrieval;advanced code comprehension process;knowledge portfolio;software system;legacy systems;git version control information;CodeCompass software comprehension framework;open source extension		1		22		17 jun. 2020			IEEE	IEEE Conferences
Towards Generating Plausible Distractors for Code Comprehension Multiple-Choice Questions	towards generating plausible distractors for code comprehension multiplechoice questions	10.1109/T4E.2019.00012	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8983757	M. J. Srinivas; M. M. Roy; V. Kumar	Department of Computer Science and Engineering, PES University, Bangalore, India; Department of Computer Science and Engineering, PES University, Bangalore, India; Divecha Centre for Climate Change, Indian Institute of Science, Bangalore, India	2019 IEEE Tenth International Conference on Technology for Education (T4E)	6 Feb 2020	2019			19	22	Code comprehension is a critical skill that novice programmers must master. We develop a semi-automatic tool to help instructors rapidly create code comprehension Multiple-Choice Questions (MCQs). We conducted a preliminary survey with 10 MCQs and 10 respondents, and the results suggest that our tool can generate plausible distractors for these MCQs.		978-1-7281-4227-2		introductory programming, code comprehension, algorithmic abstraction, multiple choice questions	Tools;Databases;Programming profession;Writing;Semantics;Sorting	computer aided instruction;computer science education;educational administrative data processing;programming	plausible distractors;semiautomatic tool;code comprehension multiple-choice questions;novice programmer skill;code comprehension MCQs		1		14		6 Feb 2020			IEEE	IEEE Conferences
DiGen: Distractor Generator for Multiple Choice Questions in Code Comprehension	digen distractor generator for multiple choice questions in code comprehension	10.1109/TALE52509.2021.9678662	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9678662	A. Vimalaksha; A. Prekash; V. Kumar; G. Srinivasa	Department of Electrical and Electronics Engineering, PES Centre for Pattern Recognition, PES University, Bangaluru, India; Department of Mechanical Engineering, PES Centre for Pattern Recognition, PES University, Bangaluru, India; ACM India, Bengaluru, India; Department of Computer Science and Engineering, PES Centre for Pattern Recognition, PES University, Bengaluru, India	2021 IEEE International Conference on Engineering, Technology & Education (TALE)	24 jan. 2022	2021			1073	1078	We propose an automated tool to assess code comprehension using Multiple-Choice-Questions. The core of our tool, DiGen, is a Named Entity Recognition model and an instructor-created database of well-commented code (whole or partial programs). For each code entry $E$ in the database, DiGen creates a multiple-choice variant of an ‘Explain in Plain English’ (EiPE) question to assess learners' comprehension of code E. The correct choice is based on tags derived by the model from comments of E, and DiGen automatically generates distractors based on similar tags in the database, with pre-and post-processing routines to further improve distractor quality. To determine the efficacy of DiGen, we asked ten learners to compare the quality of the distractors generated by our tool against another tool that identifies distractors based on both comment similarity and code similarity. Our initial results suggest that our simpler approach leads to a slight improvement in distractor quality.	2470-6698	978-1-6654-3687-8		Natural Language Processing;Machine Learning;Assessments;Multiple Choice Questions;Code Comprehension;Named Entity Recognition	Codes;Databases;Natural languages;Education;Generators	computer aided instruction;natural language processing;text analysis	DiGen;distractor generator;automated tool;Named Entity Recognition model;instructor-created database;code entry $E;comment similarity;code comprehension assessment;multiple choice questions;Explain in Plain English question;distractor quality;named entity recognition model				13	IEEE	24 jan. 2022			IEEE	IEEE Conferences
Ontology-Based Software Graphs for Supporting Code Comprehension During Onboarding	ontologybased software graphs for supporting code comprehension during onboarding	10.1109/SEAA53835.2021.00028	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9582603	L. Nagel; O. Karras; J. Klünder	Software Engineering Group, Leibniz University Hannover, Hanover, Germany; Software Engineering Group, Leibniz University Hannover, Hanover, Germany; Software Engineering Group, Leibniz University Hannover, Hanover, Germany	2021 47th Euromicro Conference on Software Engineering and Advanced Applications (SEAA)	27 Oct 2021	2021			158	165	Software engineers in modern development settings often face the challenge of contributing to large existing projects. The comprehension of foreign software code presents a time consuming obstacle, especially in contexts like onboarding. New employees have little knowledge of the software project they are supposed to contribute to. Therefore, tools supporting developers with their code comprehension are desirable to help them contribute to the best of their ability as soon as possible. Such tools must be flexible enough to work with any software project, while offering means for adjustments to very specific tasks.In this paper, we present an approach to visualize source code as node-link diagrams, using expert-designed ontologies to group various source code elements such as classes or methods. We evaluate our approach with nine advanced computer science students simulating an onboarding in a software project consisting of almost 100k lines of code. The results show that our approach supports code comprehension by utilizing expert knowledge of the visualized project, while also pointing to other use cases such as legacy code migration.		978-1-6654-2705-0		onboarding;code comprehension;software projects;graph visualization;ontology	Visualization;Codes;Databases;Prototypes;Ontologies;Tools;Software	expert systems;graph theory;ontologies (artificial intelligence);program visualisation;software engineering	ontology-based software graphs;code comprehension;software engineers;modern development settings;foreign software code;onboarding;software project;source code elements;visualized project;legacy code migration;expert knowledge				20	IEEE	27 Oct 2021			IEEE	IEEE Conferences
Coding™: Development Task Visualization for SW Code Comprehension	coding™ development task visualization for sw code comprehension	10.1109/VISSOFT52517.2021.00012	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9604827	T. Kim; S. Kim; D. Ryu	Dept. of Software Engineering, Jeonbuk National University, Jeonju-si, Republic of Korea; Dept. of Software Engineering, Jeonbuk National University, Jeonju-si, Republic of Korea; Dept. of Software Engineering, Jeonbuk National University, Jeonju-si, Republic of Korea	2021 Working Conference on Software Visualization (VISSOFT)	11 nov. 2021	2021			23	32	In a software development project, a developer tends to use the ‘diff’ view of the version control system (VCS) to understand development tasks such as fixing bugs, adding new features, and refactoring. However, the view only shows the difference of resources between the recent and previous versions in a commit, without providing any information about associated updates for completing a specific task. This causes a developer to spend a lot of time understanding development tasks, especially in the project where source code should be shared throughout team members. In order to handle this issue, we propose a novel tool Coding Time-Machine, in short Coding™, that automatically identifies and visualizes development tasks and their associated task elements (e.g., class and method). Coding™ extracts development tasks composed of task elements and causal relationships between them in a commit and facilitates one to compare the recent version of a code to the previous for each task. In addition, it allows one to navigate tasks of all commits in the code repository so that a developer feels like carrying out the time-travel of the coding activities in the software development project. For the evaluation, we measured the performance of tasks extracted from Coding™ for eight open-source Java projects, and obtained 0.87 of precision and 0.88 of recall. Also, we surveyed the usefulness of our tool for 20 participants, 80% of participants thought that showing tasks and their associated elements in a commit helps one to comprehend source code, and all participants responded that showing tasks in a chronicle way facilitates one to understand coding activities.		978-1-6654-3144-6		SW code comprehension;Commit History;Development Task	Visualization;Java;Codes;Navigation;Tools;Particle measurements;Control systems	configuration management;Java;program debugging;public domain software;software engineering;software maintenance;source code (software);user interfaces	previous versions;time understanding development tasks;source code;novel tool Coding;short Coding;associated task elements;extracts development tasks;recent version;code repository;coding activities;software development project;open-source Java projects;showing tasks;development task visualization;SW code comprehension;diff view;version control system;recent versions				13		11 nov. 2021			IEEE	IEEE Conferences
Does Code Structure Affect Comprehension? On Using and Naming Intermediate Variables	does code structure affect comprehension on using and naming intermediate variables	10.1109/ICPC52881.2021.00020	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9462958	R. Cates; N. Yunik; D. G. Feitelson	Department of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel; Department of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel; Department of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel	2021 IEEE/ACM 29th International Conference on Program Comprehension (ICPC)	28 jun. 2021	2021			118	126	Intermediate variables can be used to break complex expressions into more manageable smaller expressions, which may be easier to understand. But it is unclear when and whether this actually helps. We conducted an experiment in which subjects read 6 mathematical functions and were supposed to give them meaningful names. 113 subjects participated, of which 58% had 3 or more years of programming work experience. Each function had 3 versions: using a compound expression, using intermediate variables with meaningless names, or using intermediate variables with meaningful names. The results were that in only one case there was a significant difference between the two extreme versions, in favor of the one with intermediate variables with meaningful names. This case was the function that was the hardest to understand to begin with. In two additional cases using intermediate variables with meaningless names appears to have caused a slight decrease in understanding. In all other cases the code structure did not make much of a difference. As it is hard to anticipate what others will find difficult to understand, the conclusion is that using intermediate variables is generally desirable. However, this recommendation hinges on giving them good names.	2643-7171	978-1-6654-1403-6		Code comprehension;extract variable;inline variable	Programming;Fasteners;Encoding;Compounds	mathematics computing;software maintenance	code structure;compound expression;meaningless names;meaningful names;intermediate variables;naming intermediate		1		22		28 jun. 2021			IEEE	IEEE Conferences
Gaze as a Proxy for Cognition and Communication	gaze as a proxy for cognition and communication	10.1109/ICALT.2018.00043	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8433480	P. Jermann; K. Sharma	Department of Computer Science, Norwegian University of Science and Technology, Trondheim, Norway; Center for Digital Education, Ecole Polytechnique Federale de Lausanne, Lausanne, Switzerland	2018 IEEE 18th International Conference on Advanced Learning Technologies (ICALT)	13 Aug 2018	2018			152	154	We investigate the potential of gaze as a predictor for the quality of dialogue and the level of understanding in collaborative problem-solving. We unveil a triangular relation among collaborators' dialogue, their gaze pattern, and their performance in the context of a pair programming task. Pairs of participants were asked to understand a JAVA program while their gaze was synchronously recorded. The performance was measured as the level of understanding attained by the pair at the end of the program comprehension task. Gaze patterns were analyzed based on probabilistic hit based areas of interest called gaze tokens. A novel dialogue coding scheme was developed to capture the program description as well as collaboration management aspect of pair program understanding. Both the areas of interest and the dialogue codes reflect top-down and bottom-up program comprehension strategies. Results show that it is possible to relate gaze to the level of abstraction in dialogue and to the level of understanding.	2161-377X	978-1-5386-6049-2		Dual eye-tracking, program comprehension, program understanding, dialogue coding	Programming;Task analysis;Collaboration;Encoding;Synchronization;Java;Games	cognition;groupware;Java;probability;problem solving;reverse engineering	collaborative problem-solving;triangular relation;gaze pattern;pair programming task;JAVA program;program comprehension task;probabilistic hit based areas;collaboration management aspect;pair program understanding;dialogue codes;program comprehension strategies;Cognition;gaze tokens;dialogue coding scheme;gaze pattern analysis		2		10		13 Aug 2018			IEEE	IEEE Conferences
Recognizing Algorithms Using Language Constructs; Software Metrics and Roles of Variables: An Experiment with Sorting Algorithms	recognizing algorithms using language constructs; software metrics and roles of variables an experiment with sorting algorithms	10.1093/comjnl/bxq049	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8130420	A. Taherkhani; A. Korhonen; L. Malmi	NA; NA; NA	The Computer Journal	18 jan. 2018	2011	54	7	1049	1066	Program comprehension (PC) is a research field that has been extensively studied from different points of view, including human program understanding and mental models, automated program understanding, etc. In this paper, we discuss algorithm recognition (AR) as a subfield of PC and explain their relationship. We present a method for automatic AR from Java source code. The method is based on static analysis of program code including various statistics of language constructs, software metrics, as well as analysis of roles of variables in the target program. In the first phase of the method, a number of different implementations of the supported algorithms are analyzed and stored in the knowledge base of the system as learning data, and in the second phase, previously unseen algorithms are recognized using this information. We have developed a prototype and successfully applied the method for recognition of sorting algorithms. This process is explained in the paper along with the experiment we have conducted to evaluate the performance of the method. Although the method, at its current state, is still sensitive to changes made to target algorithms, the encouraging results of the experiment demonstrate that it can be further developed to be used as a PC method in various applications, as an example, in automatic assessment tools to check the algorithms used by students, the functionality that is currently missing from these tools.	1460-2067			algorithm recognition;program comprehension;program understanding;static program analysis;roles of variables					2				18 jan. 2018			OUP	OUP Journals
Program structure based on a concurrent object model for switching systems	program structure based on a concurrent object model for switching systems		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=41843	J. Kai; K. Maruyama; K. Koyanagi	NTT Communication Switching Laboratories, Japan; NTT Communication Switching Laboratories, Japan; NTT Communication Switching Laboratories, Japan	Seventh International Conference on Software Engineering for Telecommunication Switching Systems, 1989. SETSS 89.	6 Aug 2002	1989			34	38	A switching system program is a large, real-time, long-lived and frequently modified system. The following features are required: good maintainability; rapid introduction of new services; adaptability to enhanced services; and flexibility to increase capacity. A well-structured program is a key factor in meeting these requirements. A new program structure based on the concurrent object oriented model where objects run concurrently, which produces well-structured switching programs is proposed.<>		0-85296-381-5			Electronic switching systems;Object oriented programming;Structured programming	electronic switching systems;object-oriented programming;structured programming	switching system program;program structure;concurrent object oriented model		3				6 Aug 2002			IET	IET Conferences
Control program structure of humanoid robot	control program structure of humanoid robot	10.1109/IECON.2002.1185243	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1185243	S. Aramaki; H. Shirouzu; K. Kurashige	Faculty of Engineering Fukuoka University; Kyushu Matsusita Electric Co., LTD.; Faculty of Engineering Fukuoka University	IEEE 2002 28th Annual Conference of the Industrial Electronics Society. IECON 02	20 mar. 2003	2002	3		1796	1800 vol.3	In this paper, the new control program structure for humanoid robot which consists of multi-CPU, multi-OS and multi-task is described. The method for planning action from multiple sensor information by using the production system is also described. Task program has hierarchical structure like as human being has conscious action and unconscious action. Our design concept is generality of task. We want to make a control program independently on the architecture of a robot and other tasks. We also want to make software architecture simple. Task program is divided into three levels. Tasks must communicate each other. However, if one task can communicate another task at random, the amount of communication increases exponentially. Therefore, we made a rule of task in order to make the amount of communication linearly increase. On the other hand, a robot must determine next action from multiple sensor information. We introduced the reasoning mechanism of production system for determining next action. It becomes easy to determine next action from multiple sensor input by using this method. We could make a robot grasp a block by using this method and simulator, and we confirmed the effectiveness of methods mentioned above.		0-7803-7474-6			Humanoid robots;Robot sensing systems;Production systems;Production planning;Sensor phenomena and characterization;Sensor systems;Humans;Communication system control;Computer architecture;Software architecture	robot programming	humanoid robot;control program structure;multi-CPU;multi-OS;multi-task;planning action;multiple sensor information;production system;hierarchical structure;reasoning mechanism;multiple sensor input		2		7		20 mar. 2003			IEEE	IEEE Conferences
An algorithm of program structure adjustment base on interactive disassembly	an algorithm of program structure adjustment base on interactive disassembly	10.1109/ICSESS.2011.5982476	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5982476	F. Tian; Y. Zhang; D. Ma	Information and Engineering University, Zhengzhou, Henan, China; Information and Engineering University, Zhengzhou, Henan, China; Information and Engineering University, Zhengzhou, Henan, China	2011 IEEE 2nd International Conference on Software Engineering and Service Science	11 Aug 2011	2011			860	863	In the process of program reverse analyzing, anti-track instruction and indirect jump instruction is common to see and difficult to be automatic disassembly analyzed. This article gives a kind of algorithm to adjust program structure, which is based on interactive disassembly, describes theory and detail design of mutual transformation of command section and program section, experiments the average recognition of the algorithm, analyzes and assess the experimental result.	2327-0594	978-1-4244-9698-3		flow chart;instruction section;data section;basic block;data structure	Algorithm design and analysis;Flow graphs;Process control;Data mining;Software;Interference;Complexity theory	data structures;flowcharting;program control structures	program structure adjustment;interactive disassembly;program reverse analyzing process;anti-track instruction;indirect jump instruction;describes theory;detail design;command section;program section;data structure;flow chart				8		11 Aug 2011			IEEE	IEEE Conferences
Integrating data/program structure and their visual expressions in the visual programming system	integrating data/program structure and their visual expressions in the visual programming system	10.1109/APCHI.1998.704486	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=704486	H. Endoh; J. Tanaka	NA; NA	Proceedings. 3rd Asia Pacific Computer Human Interaction (Cat. No.98EX110)	6 Aug 2002	1998			453	458	"Direct manipulation" has already become a popular keyword in the field of visual programming. In many visual programming systems (VPS), the user can manipulate the program from its visual expression in the editor subsystem, but the execution process is still displayed in another window and users have to move the mouse cursor frequently. The authors recognised the importance of the manipulation interface with which user can carry out necessary operations for programming in one field. They have implemented a prototype of such a VPS using the IntelligentPad architecture. The elements of the data/program structures are expressed as pads. When a user manipulates them, the program is also changed and is automatically evaluated.		0-8186-8347-3			Mice;Switches;Data visualization;Animation;Data structures;Read only memory;Prototypes;Computer languages;Watches;Debugging	visual programming;visual programming;data structures;data visualisation;user interfaces	data structure;program structure;visual expressions;visual programming system;direct manipulation;program manipulation;editor subsystem;manipulation interface;IntelligentPad architecture				11		6 Aug 2002			IEEE	IEEE Conferences
A Program Structure Analyzer	a program structure analyzer	10.1109/SSST.1991.138528	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=138528	T. L. Crawford	Computer Science, Canisius College, Buffalo, NY, USA	[1991 Proceedings] The Twenty-Third Southeastern Symposium on System Theory	6 Aug 2002	1991			120	122	PSA (program structure analyzer) is a tool for visually displaying a C program. PSA displays the call graph of a program. The user selectively controls which portions of the graph to display and may enhance the appearance of nodes which meet specified criteria. Access to other syntactical information about the program is available from a menu interface.<>	0094-2898	0-8186-2190-7			Hardware;Costs;Bridges;Software systems;Displays;Cities and towns;Structural panels;Human factors;Logic programming;Milling machines	C language;software packages;software tools	X Windows based interface;program structure analyzer;C program;call graph;syntactical information;menu interface				5		6 Aug 2002			IEEE	IEEE Conferences
MetropolJS: Visualizing and Debugging Large-Scale JavaScript Program Structure with Treemaps	metropoljs visualizing and debugging largescale javascript program structure with treemaps		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8973076	J. D. Scarsbrook; R. K. L. Ko; B. Rogers; D. Bainbridge	University of Waikato; University of Waikato; University of Waikato; University of Waikato	2018 IEEE/ACM 26th International Conference on Program Comprehension (ICPC)	30 jan. 2020	2018			389	3893	As a result of the large scale and diverse composition of modern compiled JavaScript applications, comprehending overall program structure for debugging is challenging. In this paper we present our solution: MetropolJS. By using a Treemap-based visualization it is possible to get a high level view within limited screen real estate. Previous approaches to Treemaps lacked the fine detail and interactive features to be useful as a debugging tool. This paper introduces an optimized approach for visualizing complex program structure that enables new debugging techniques where the execution of programs can be displayed in real time from a bird's-eye view. The approach facilitates highlighting and visualizing method calls and distinctive code patterns on top of code segments without a high overhead for navigation. Using this approach enables fast analysis of previously difficult-to-comprehend code bases.	2643-7171	978-1-4503-5714-2		JavaScript;Treemaps;Debugging		data visualisation;Java;program debugging;tree data structures	MetropolJS;JavaScript applications;Treemap-based visualization;JavaScript program structure debugging				12		30 jan. 2020			IEEE	IEEE Conferences
The "category" of program structure and its applications in parallelization	the category of program structure and its applications in parallelization	10.1109/HPC.2000.843590	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=843590	Pan Feng	R & D Center for Parallel Software Institute of Software, Chinese Academy and Sciences, Beijing, China	Proceedings Fourth International Conference/Exhibition on High Performance Computing in the Asia-Pacific Region	6 Aug 2002	2000	2		1007	1009 vol.2	We consider the parallelization of large numerical software. First, we introduce the concept of category of program structure and its features. Second, we concentrate on the category's roles in the parallelization of large numerical software. Finally we apply ideas of the category (and tag-array) to the programming of PRIS-1.0, a parallel reservoir numerical simulator, and give results of one million grid-data problems from the Daqing field with PRIS-1.0 on distributed memory PC-clusters (16 cpu PIII500) of R&DCPS. We cost no more than 60 hours on 16 PIII500s solving 1160 thousand grid-data, matching the 31 year history problem.		0-7695-0590-2			Reservoirs;Numerical simulation;Central Processing Unit;Computational modeling;History;Computer simulation;Concurrent computing;Application software;Costs;Grid computing	parallel programming;mathematics computing;distributed memory systems;workstation clusters	program structure;program parallelization;numerical software;tag-array;category;parallel programming;PRIS;parallel reservoir numerical simulator;grid-data problems;Daqing field;distributed memory PC-clusters				3		6 Aug 2002			IEEE	IEEE Conferences
A service logic program structure of UPT service in intelligent networks	a service logic program structure of upt service in intelligent networks	10.1109/ICUPC.1993.528503	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=528503	T. Sugiyama; K. Ishikawa; H. Itoh	NTT Communication Switching Laboratories, Musashino, Tokyo, Japan; NTT Communication Switching Laboratories, Musashino, Tokyo, Japan; NTT Communication Switching Laboratories, Musashino, Tokyo, Japan	Proceedings of 2nd IEEE International Conference on Universal Personal Communications	6 Aug 2002	1993	2		870	874 vol.2	A single SLP may be a solution for UPT services. However, the authors propose a strategy of building UPT services with multiple SLPs which can be triggered independently. They also discuss a structure that treats these SLPs as a single SLP. These structures make it easy to enhance UPT services, because additional SLPs may introduce new UPT features independently. Furthermore, the relationship is clarified between personal mobility and UPT service's SLP triggering, the cooperation of adjacent UPT service SLPs, and the required functions to support SLP cooperation.		0-7803-1396-8			Intelligent networks;Logic;Authentication;Communication switching;Laboratories;Buildings;Telecommunications;ISDN	intelligent networks;personal communication networks;logic programming;structured programming	universal personal telecommunications;service logic program structure;intelligent networks;UPT services;strategy;cooperation			1	6		6 Aug 2002			IEEE	IEEE Conferences
The effectiveness of control structure diagrams in source code comprehension activities	the effectiveness of control structure diagrams in source code comprehension activities	10.1109/TSE.2002.1000450	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1000450	D. Hendrix; J. H. Cross; S. Maghsoodloo	Computer Science and Software Engineer Department, Aubum University, AL, USA; Computer Science and Software Engineer Department, Aubum University, AL, USA; Systems Engineering Department, Aubum University, AL, USA	IEEE Transactions on Software Engineering	7 Aug 2002	2002	28	5	463	477	Recently, the first two in a series of planned comprehension experiments were performed to measure the effect of the control structure diagram (CSD) on program comprehensibility. Upper- and lower-division computer science and software engineering students were asked to respond to questions regarding the structure and execution of one source code module of a public domain graphics library. The time taken for each response and the correctness of each response was recorded. Statistical analysis of the data collected from these two experiments revealed that the CSD was highly significant in enhancing the subjects' performance in this program comprehension task. The results of these initial experiments promise to shed light on fundamental questions regarding the effect of software visualizations on program comprehensibility.	1939-3520				Performance evaluation;Computer science;Software engineering;Computer graphics;Software libraries;Statistical analysis;Data visualization	diagrams;reverse engineering;program visualisation;program control structures	control structure diagrams;source code comprehension;experiments;program comprehensibility;computer science students;software engineering students;public domain graphics library;statistical analysis;data analysis;software visualizations		27		43	IEEE	7 Aug 2002			IEEE	IEEE Journals
COCONUT: COde COmprehension Nurturant Using Traceability	coconut code comprehension nurturant using traceability	10.1109/ICSM.2006.19	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4021349	A. De Lucia; M. Di Penta; R. Oliveto; F. Zurolo	Universita degli Studi di Salerno, Fisciano, Campania, IT; RCOST — Research Centre on Software Technology, University of Sannio, Benevento, Italy; Department of Mathematics and Informatics, University of Salerno, Fisciano, Italy; Department of Mathematics and Informatics, University of Salerno, Fisciano, Italy	2006 22nd IEEE International Conference on Software Maintenance	11 Dec 2006	2006			274	275	In this paper we present an Eclipse plug-in, called COCONUT (COde COmprehension Nurturant Using Traceability), that shows the similarity level between the source code under development and high-level artefacts the source code should be traced onto. Also, the plug-in suggests candidate source code identifiers according to the domain terms contained into the corresponding high-level artefacts. Experiments showed that the plug-in helps to produce source code easier to be understood	1063-6773	0-7695-2354-4			Visualization;Software maintenance;Programming profession;Java;Mathematics;Informatics;Automatic control;Unified modeling language;Uniform resource locators;Information retrieval	program diagnostics;reverse engineering;software tools	Eclipse plug-in;COde COmprehension Nurturant Using Traceability		5		4		11 Dec 2006			IEEE	IEEE Conferences
CRISTA: A tool to support code comprehension based on visualization and reading technique	crista a tool to support code comprehension based on visualization and reading technique	10.1109/ICPC.2009.5090060	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090060	D. Porto; M. Mendonca; S. Fabbri	Federal University of São Carlos, Sao Carlos, Brazil; University of Salvador, Salvador, Brazil; Federal University of São Carlos, Sao Carlos, Brazil	2009 IEEE 17th International Conference on Program Comprehension	19 jun. 2009	2009			285	286	This paper presents a tool named CRISTA that supports code comprehension through the application of stepwise abstraction. It uses a visual metaphor to represent the code and supports essential tasks for code reading, inspection and documentation. As code comprehension is time consuming, a tool can greatly improve such activity.	1092-8138	978-1-4244-3998-0			Visualization;Inspection;Documentation;Java;Reverse engineering;Switches;Software maintenance;Libraries;Software engineering;Programming profession	program testing;program visualisation;reverse engineering;software maintenance;system documentation	code comprehension;reading technique;visualization technique;stepwise abstraction;code inspection;code documentation;software maintenance		2		4		19 jun. 2009			IEEE	IEEE Conferences
From code comprehension model to tool capabilities	from code comprehension model to tool capabilities	10.1109/ICCI.1993.315327	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=315327	A. von Mayrhauser; A. M. Vans	Department of Computer Science, Colorado State University, Fort Collins, CO, USA; Department of Computer Science, Colorado State University, Fort Collins, CO, USA	Proceedings of ICCI'93: 5th International Conference on Computing and Information	6 Aug 2002	1993			469	473	A major portion of the maintenance effort is spent trying to understand existing software. If we can learn more about how programmers understand code successfully, we can build better tools to support this understanding process. An effective maintenance tool must help in code comprehension and support the code understanding process. We present an integrated comprehension model and a technique for developing detailed tool capability requirements.<>		0-8186-4212-2			Programming profession;Computer science;Buildings;Switches;Software maintenance;Cognition;Appropriate technology;Cognitive science;Sorting	software maintenance	code comprehension model;tool capabilities;software maintenance;integrated comprehension model		1		10		6 Aug 2002			IEEE	IEEE Conferences
PROUST: Knowledge-Based Program Understanding	proust knowledgebased program understanding	10.1109/TSE.1985.232210	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1702003	W. L. Johnson; E. Soloway	Department of Computer Science, Yale University, New Heaven, CT, USA; Department of Computer Science, Yale University, New Heaven, CT, USA	IEEE Transactions on Software Engineering	18 Sep 2006	1985	SE-11	3	267	275	This paper describes a program called PROUST which does on-line analysis and understanding of Pascal written by novice programmers. PROUST takes as input a program and a nonalgorithmic description of the program requirements, and finds the most likely mapping between the requirements and the code. This mapping is in essence a reconstruction of the design and implementation steps that the programmer went through in writing the program. A knowledge base of programming plans and strategies, together with common bugs associated with them, is used in constructing this mapping. Bugs are discovered in the process of relating plans to the code; PROUST can therefore give deep explanations of program bugs by relating the buggy code to its underlying intentions.	1939-3520			Artificial inteiligence;program debugging;programmer training;program understanding	Programming profession;Computer bugs;Writing;Debugging;Personnel;Psychology;Computer science;Machinery;Reactive power		Artificial inteiligence;program debugging;programmer training;program understanding		162		20		18 Sep 2006			IEEE	IEEE Journals
Abstracting runtime heaps for program understanding	abstracting runtime heaps for program understanding	10.1109/TSE.2012.69	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6331492	M. Marron; C. Sanchez; Z. Su; M. Fahndrich	Imdea Software Institute, Madrid, FA, Spain; Imdea Software Institute, Madrid, FA, Spain; Department of Computer Science, University of California, Davis, CA, USA; Microsoft Research, Redmond, WA, USA	IEEE Transactions on Software Engineering	23 May 2013	2013	39	6	774	786	Modern programming environments provide extensive support for inspecting, analyzing, and testing programs based on the algorithmic structure of a program. Unfortunately, support for inspecting and understanding runtime data structures during execution is typically much more limited. This paper provides a general purpose technique for abstracting and summarizing entire runtime heaps. We describe the abstract heap model and the associated algorithms for transforming a concrete heap dump into the corresponding abstract model as well as algorithms for merging, comparing, and computing changes between abstract models. The abstract model is designed to emphasize high-level concepts about heap-based data structures, such as shape and size, as well as relationships between heap structures, such as sharing and connectivity. We demonstrate the utility and computational tractability of the abstract heap model by building a memory profiler. We use this tool to identify, pinpoint, and correct sources of memory bloat for programs from DaCapo.	1939-3520			Heap structure;runtime analysis;memory profiling;program understanding	Abstracts;Concrete;Shape;Runtime;Arrays;Computational modeling	data structures;merging;program diagnostics;program testing	program testing;program analysis;program inspection;program algorithmic structure;runtime data structure relationships;runtime heap abstracting;runtime heap summarization;concrete heap dump;program merging;program comparison;program computing;high-level concepts;heap structure sharing;heap structure connectivity;abstract heap model utility;abstract heap model computational tractability;memory profiler;memory bloat;DaCapo		17		37	IEEE	16 Oct 2012			IEEE	IEEE Journals
JTourBus: Simplifying Program Understanding by Documentation that Provides Tours Through the Source Code	jtourbus simplifying program understanding by documentation that provides tours through the source code	10.1109/ICSM.2007.4362619	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362619	C. Oezbek; L. Prechelt	Institut für Informatik, Freie Universität Berlin, Berlin, Germany; Institut für Informatik, Freie Universität Berlin, Berlin, Germany	2007 IEEE International Conference on Software Maintenance	22 Oct 2007	2007			64	73	Many small and medium-sized systems have little or no design documentation, which makes program understanding during maintenance enormously more difficult when performed by outsiders. Thus, if only minimal design documentation is available, which form should it take to maximize its usefulness? We suggest that it is helpful if the documentation describes a tour through the source code, leading the user directly to relevant details. This work reports an evaluation of this conceptual idea in the form of a controlled experiment with 59 student subjects working on a difficult program understanding task in the context of the 27 KLOC JHotDraw graphics framework. One group received a plain text documentation, the other received tour-structured documentation which they navigated by using an Eclipse plugin called JTourBus that we constructed for the experiment. The results indicate that program understanding can be achieved somewhat faster (albeit not more correctly) with JTourBus than with a plain text document.	1063-6773	978-1-4244-1255-6		program understanding;design documentation;delocalized concern	Documentation;Programming profession;Graphics;Navigation;Computer aided software engineering;Natural languages;Reverse engineering;Process design;Software design;Computer architecture	reverse engineering;system documentation	program understanding;source code;KLOC JHotDraw graphics framework;plain text documentation;tour-structured documentation;Eclipse plugin;JTourBus framework		10	1	14		22 Oct 2007			IEEE	IEEE Conferences
Visualizing serverless cloud application logs for program understanding	visualizing serverless cloud application logs for program understanding	10.1109/VLHCC.2017.8103476	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8103476	K. S. -P. Chang; S. J. Fink	IBM Research, Yorktown Heights, NY; IBM Watson, Yorktown Heights, NY	2017 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)	13 nov. 2017	2017			261	265	A cloud platform records a wealth of information regarding program execution. Most cloud service providers offer dashboard monitoring tools that visualize resource usage and billing information, and support debugging. In this paper, we present a tool that visualizes cloud execution logs for a different goal - to facilitate program understanding and generate documentations for an application using runtime data. Our tool introduces a new timeline visualization, a new method and user interface to summarize multiple JSON objects and present the result, and interaction techniques that facilitate navigating among functions. Together, these features explain a serverless cloud application's composition, performance, dataflow and data schema. We report some initial user feedback from several expert developers that were involved in the tool's design and development process.	1943-6106	978-1-5386-0443-4		serverless computing;function as a service;program understanding;log visualization;cloud computing	Tools;Cloud computing;Data visualization;Unified modeling language;Bars;Computational modeling;Visualization	cloud computing;data flow analysis;data visualisation;program debugging;resource allocation;system monitoring;user interfaces	program understanding;runtime data;timeline visualization;user interface;serverless cloud application;cloud service providers;resource usage;billing information;debugging;cloud platform;program execution;dashboard monitoring tools;cloud execution logs;JSON objects		1		21		13 nov. 2017			IEEE	IEEE Conferences
Supporting Program Understanding by Automatic Indexing of Functionalities in Source Code	supporting program understanding by automatic indexing of functionalities in source code	10.1109/SERA.2019.8886802	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8886802	M. Nishimoto; K. Nishiyama; H. Kawabata; T. Hironaka	Graduate School of Information Sciences, Hiroshima City University, Hiroshima, Japan; Graduate School of Information Sciences, Hiroshima City University, Hiroshima, Japan; Graduate School of Information Sciences, Hiroshima City University, Hiroshima, Japan; Graduate School of Information Sciences, Hiroshima City University, Hiroshima, Japan	2019 IEEE 17th International Conference on Software Engineering Research, Management and Applications (SERA)	31 Oct 2019	2019			13	18	Programs in the event-driven style that are typical of mobile and/or web applications are becoming complex and hard to maintain. For the purpose of reducing the burden put on software developers while reading source code to understand its details, we propose a tool for supporting program understanding, named SAIFU. SAIFU automatically extracts implemented functionalities from source code and puts annotations, which we call summaries, to them. SAIFU lets the user focus on the statements of source code and check the implementation details corresponding to each functionality. SAIFU helps the user grasp the behavior and the structure of a whole program by showing a clickable list of the summaries of functionalities. The results of preliminary experiments based on the prototype implementation of SAIFU confirm that the tool is effective for finding out important statements from existing application programs.		978-1-7281-0798-1		program understanding;dataflow graph;tag cloud;event-driven programming	Tag clouds;Tools;Generators;Software;Browsers;Prototypes;Data mining	Internet;mobile computing;reverse engineering;source code (software)	program understanding;automatic indexing;source code;event-driven style;mobile Web applications;application programs;SAIFU		1		12		31 Oct 2019			IEEE	IEEE Conferences
Improving decoder and code structure of parallel concatenated recursive systematic (turbo) codes	improving decoder and code structure of parallel concatenated recursive systematic (turbo) codes	10.1109/ICUPC.1994.383050	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=383050	P. Robertson	Institute for Communications Technology, German Aerospace Research Establishment (DLR), Wessling, Germany	Proceedings of 1994 3rd IEEE International Conference on Universal Personal Communications	6 Aug 2002	1994			183	187	Recently, a coding scheme (turbo-codes) was proposed, that achieves almost reliable data communication at signal-to-noise ratios very close to the Shannon-limit. In this paper we show that the associated iterative decoder can be formulated in a simpler fashion by passing information from one decoder to the next using log-likelihood ratios as opposed to channel values that need to be normalized. This is in accordance with the MAP derivation of the component decoders. A drawback of the codes has been discovered: the BER curves show a flattening at higher signal-to-noise ratios, this is due to the small minimum distance of the whole code. By analyzing the interleaver used in the encoder we can calculate approximations to the BER at high SNRs. Finally, by careful interleaver manipulation the minimum distance of the code can be increased and the error-coefficient for the remaining small distance events can be further reduced. Furthermore, we have investigated the influence of the interleaver length on the SNR needed to achieve a certain BER; short lengths might be encountered in mobile and personal communications systems (e.g. voice transmission). Simulations confirm both the analytical approximation to the BER as well as the method for interleaver design which yields a marked improvement at higher SNR.<>		0-7803-1823-4			Concatenated codes;Iterative decoding;Bit error rate;Turbo codes;Communications technology;Data communication;Signal to noise ratio;Analytical models;Design methodology;Multidimensional systems	decoding;iterative methods;interleaved codes;personal communication networks;error correction codes;concatenated codes;convolutional codes;channel coding;trellis codes;land mobile radio	decoder;code structure;parallel concatenated recursive systematic codes;turbo-codes;data communication;signal-to-noise ratios;Shannon-limit;iterative decoder;log-likelihood ratios;channel values;MAP derivation;BER curves;encoder;high SNRs;error-coefficient;small distance events;interleaver length;personal communications systems;mobile communications;voice transmission;analytical approximation		17	9	7		6 Aug 2002			IEEE	IEEE Conferences
Use of a sequential decoder to analyze convolutional code structure (Corresp.)	use of a sequential decoder to analyze convolutional code structure (corresp.)	10.1109/TIT.1970.1054539	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1054539	G. Forney	NA	IEEE Transactions on Information Theory	6 jan. 2003	1970	16	6	793	795	An existing sequential decoding program can be easily modified to enumerate the number of low-weight codewords in a convolutional code, where weight is defined either over a decoding constraint length or "free." We tabulated several good rate one-half constraint-length 49 systematic codes that were obtained quickly with this procedure.	1557-9654						Convolutional codes;Sequential decoding		16	1	4	IEEE	6 jan. 2003			IEEE	IEEE Journals
New Code Structure for Enhanced Double Weight (EDW) Code for Spectral Amplitude Coding OCDMA System	new code structure for enhanced double weight (edw) code for spectral amplitude coding ocdma system	10.1109/ICFCC.2009.26	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5189865	A. Z. G. Zahid; F. N. Hasoon; S. Shaari	Photonics Technology Laboratory, Institute of Micro Engineering and Nanoelectronics (IMEN), Universiti Kebangsaan Malaysia, Bangi, Selangor Darul Ehsan, Malaysia; Faculty of Engineering Jalan Multimedia, Multimedia University, Malacca, Malaysia; Photonics Technology Laboratory, Institute of Micro Engineering and Nanoelectronics (IMEN), Universiti Kebangsaan Malaysia, Bangi, Selangor Darul Ehsan, Malaysia	2009 International Conference on Future Computer and Communication	4 Aug 2009	2009			658	661	This paper presents a new structure for spectral amplitude coding optical code division multiple access systems based on the enhanced double weight (EDW) code. The new structure is based on mathematical model and step sequences. The reconstruction is carried for higher weighted code to build the code matrix by rules which will make high level weight inspection automatic sequenced and mathematically formed. Some simulation results are shown with comparison on performance.		978-0-7695-3591-3		Optical CDMA;Enhanced double weight (EDW);Double weight (DW)	Multiaccess communication;Paper technology;Niobium;Equations;Photonics;Laboratories;Nanoelectronics;Mathematical model;Inspection;Optical computing	code division multiple access;codes;matrix algebra	code structure;enhanced double weight code;spectral amplitude coding OCDMA system;optical code division multiple access system;mathematical model;step sequence		10		8		4 Aug 2009			IEEE	IEEE Conferences
The canonical signed digit code structure for FIR filters	the canonical signed digit code structure for fir filters	10.1109/TASSP.1980.1163450	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1163450	R. Seegal	Raytheon Company, Portsmouth, RI, USA	IEEE Transactions on Acoustics, Speech, and Signal Processing	29 jan. 2003	1980	28	5	590	592	This correspondence introduces a new computational structure for FIR filters that combines the advantages of canonical signed digit code (CSC) with the efficiency of the partial sum organization. An example shows how microcode for a microprocessor implementation may be developed directly from the filter coefficients.	0096-3518				Finite impulse response filter;Speech processing;Acoustic signal processing;Microprocessors;Bars;Matrix converters;Arithmetic				5	2	6		29 jan. 2003			IEEE	IEEE Journals
A fast-decodable code structure for linear dispersion codes	a fastdecodable code structure for linear dispersion codes	10.1109/TWC.2009.080841	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5285158	X. G. Dai; S. W. Cheung; T. I. Yuk	Department of Electrical and Electronics Engineering, University of Hong Kong, Hong Kong, China; Department of Electrical and Electronics Engineering, University of Hong Kong, Hong Kong, China; Department of Electrical and Electronics Engineering, University of Hong Kong, Hong Kong, China	IEEE Transactions on Wireless Communications	13 Oct 2009	2009	8	9	4417	4420	This paper proposes the design of a new family of fast-decodable, full-rank, flexible-rate linear dispersion codes (LDCs) for MIMO systems with arbitrary numbers of transmit and receive antennas. The codewords of LDCs can be expressed as a linear combination of certain dispersion matrices and, in this new family of LDCs, we propose to have orthogonal rows in as many dispersion matrices as possible. We show that, with the proposed code, the number of levels in the tree search and hence the complexity of the sphere decoder (SD) at the receiver can be substantially reduced. Monte Carlo computer simulation has shown that the LDCs with and without the orthogonal structure have nearly identical bit-error-rate (BER) performances. However, the complexity of the SD used for decoding the proposed family of LDCs is substantially reduced.	1558-2248			Linear dispersion code;complexity of sphere decoding;MIMO system;fast-decodable code	Maximum likelihood decoding;MIMO;Transmitting antennas;Block codes;Diversity methods;Receiving antennas;Monte Carlo methods;Computer simulation;Bit error rate	decoding;error statistics;linear codes;MIMO communication;Monte Carlo methods;receiving antennas;transmitting antennas	linear dispersion codes;fast decodable code structure;MIMO systems;transmit antennas;receive antennas;dispersion matrices;sphere decoder;Monte Carlo computer simulation;bit error rate		3		16		13 Oct 2009			IEEE	IEEE Journals
Spectrally Efficient Alamouti Code Structure in Asynchronous Cooperative Systems	spectrally efficient alamouti code structure in asynchronous cooperative systems	10.1109/LSP.2014.2308296	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6747969	M. Rahmati; T. M. Duman	School of Electrical, Computer and Energy Engineering (ECEE) of Arizona State University, Tempe, AZ, USA; Department of Electrical and Electronics Engineering, Bilkent University, Bilkent, Ankara, Turkey	IEEE Signal Processing Letters	11 mar. 2014	2014	21	5	545	549	A relay communication system with two amplify and forward (AF) relays under flat fading channel conditions is considered where the signals received from the relays are not necessarily time aligned. We propose a new time-reversal (TR)-based scheme providing an Alamouti code structure which needs a smaller overhead in transmitting every pair of data blocks in comparison with the existing schemes and, as a result, increases the transmission rate significantly (as much as 20%) in exchange for a small performance loss. The scheme is particularly useful when the delay between the two relay signals is large, e.g., in typical underwater acoustic (UWA) channels.	1558-2361		Qatar National Research Fund(grant numbers:09-242-2-099); 	Alamouti scheme;asynchronous communications;cooperative systems	Relays;Cooperative systems;Delays;Educational institutions;Detectors;OFDM;Communication systems	amplify and forward communication;channel coding;cooperative communication;fading channels;relay networks (telecommunication)	spectrally efficient Alamouti code structure;asynchronous cooperative systems;relay communication system;amplify and forward relays;AF relays;flat fading channel conditions;time-reversal-based scheme;TR;relay signals;underwater acoustic channels;UWA channels		3		10	IEEE	25 Feb 2014			IEEE	IEEE Journals
Design and Decoding of a Serial Concatenated Code Structure based on Quasi-Cyclic LDPC Codes	design and decoding of a serial concatenated code structure based on quasicyclic ldpc codes		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5755955	J. Dore; M. Hamon; P. Penard	France Telecom, Research and Development Division, 4 rue du clos courtel, 35512 Cesson-Sévigné, France; France Telecom, Research and Development Division, 4 rue du clos courtel, 35512 Cesson-Sévigné, France; France Telecom, Research and Development Division, 4 rue du clos courtel, 35512 Cesson-Sévigné, France	4th International Symposium on Turbo Codes & Related Topics; 6th International ITG-Conference on Source and Channel Coding	1 jun. 2011	2006			1	6	In this paper, we introduce a new serially concatenated code structure, based on Quasi-Cyclic (QC) codes. This structure can be viewed as LDPC codes, and benefits from the advantages of structured QC LDPC codes: simple characterization, good performance for moderate code length and efficient implementation. These codes enable different types of decoding algorithms, from classical Belief Propagation to Turbo-Like decoding algorithms. A joint analysis, in terms of complexity, convergence and performance, has been performed to determine the best decoding choice.		978-3-8007-2947-0			Turbo codes;Bismuth;Processor scheduling;Digital video broadcasting;Quantum cascade lasers				2	8			1 jun. 2011			VDE	VDE Conferences
Storage and transmission of information using grey level QR (quick-response) code structure	storage and transmission of information using grey level qr (quickresponse) code structure	10.1109/CASP.2016.7746204	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7746204	A. H. Tank; M. M. Unde; B. J. Patel; P. Raskar	Smt. Kashibai Navale College of Engineering, Pune, India; Smt. Kashibai Navale College of Engineering, Pune, India; Smt. Kashibai Navale College of Engineering, Pune, India; Smt. Kashibai Navale College of Engineering, Pune, India	2016 Conference on Advances in Signal Processing (CASP)	17 nov. 2016	2016			402	405	Paper proposes a new way for storage and transmission of information using a grey level QR-Code structure has been proposed in this paper. Instead of using only black and white modules, the proposed code is designed to employ different grey levels which enables larger storage capacity compared to traditional binary QR-Codes. This results in increase in the data capacity as compared to the data capacity of the current QR-Code scheme. Also a scheme is proposed to determine different grey levels accurately reducing the error produced due to effect of environmental lightning conditions. Such scheme has been made possible by the capacity of cameras to recognize image that is beyond black and white and there adaption as a device to scan and decode QR-Codes in daily life.		978-1-5090-0849-0		QR-Code;Barcode	Image color analysis;Encoding;Cameras;Multiplexing;Image recognition;IEC Standards	grey systems;QR codes	information transmission;information storage;quick-response code structure;grey level QR-code structure;data capacity;environmental lightning conditions		2		6		17 nov. 2016			IEEE	IEEE Conferences
The Viterbi Decoding Algorithm of Differential Frequency Hopping System with Equivalent Convolutional Code Structure	the viterbi decoding algorithm of differential frequency hopping system with equivalent convolutional code structure	10.1109/ICCCAS.2006.284843	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4064084	Y. Baofeng; S. Yuehong	Anti-jamming Laboratory, Nanjing Institute of Communications Engineering, Nanjing, Jiangsu, China; Anti-jamming Laboratory, Nanjing Institute of Communications Engineering, Nanjing, Jiangsu, China	2006 International Conference on Communications, Circuits and Systems	15 jan. 2007	2006	2		1117	1119	In AWGN channel, the differential frequency hopping (DFH) system had a bad performance especially with low SNR. It firstly proved the DFH had the equivalent convolutional code structure, then analyzed and simulated the performance of Viterbi decoding algorithm in AWGN channel. Computer simulations indicate that the novel method could greatly improve the performance of DFH system in AWGN channel		0-7803-9584-0			Viterbi algorithm;Decoding;Frequency;Convolutional codes;AWGN channels;Performance analysis;Algorithm design and analysis;Computational modeling;Analytical models;Computer simulation	AWGN channels;channel coding;convolutional codes;frequency hop communication;Viterbi decoding	viterbi decoding algorithm;differential frequency hopping system;DFH;equivalent convolutional code structure;AWGN channel;additive white Gaussian noise		1		9		15 jan. 2007			IEEE	IEEE Conferences
RFID code structure and tag data structure for mobile RFID services in Korea	rfid code structure and tag data structure for mobile rfid services in korea	10.1109/ICACT.2006.206153	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1625758	Jun Seob Lee; Hyoung Jun Kim	Protocol Engineering Center, Electronics and Telecommunications Research Institute, South Korea; Protocol Engineering Center, Electronics and Telecommunications Research Institute, South Korea	2006 8th International Conference Advanced Communication Technology	8 May 2006	2006	2		3 pp.	1055	Korea has recently been witnessing the ongoing standardization of mobile RFID services for the purpose of providing new services by loading RFID readers in mobile telecommunications terminals. Unlike logistics-based RFID codes, the codes of these mobile RFID services provide the necessary information for searching the location of online content of relevant codes. This paper discusses the design of a code system for mobile RFID services and defines a tag data structure that enables mobile RFID services to operate normally under an environment where other RFID systems configured with different code systems coexist; thus preventing conflicts. It also explains the URI search procedure for the desired online content through code resolution using the proposed code system.		89-5519-129-4		Mobile RFID;mCode;micro-mCode;RFID	Radiofrequency identification;Technical Activities Guide -TAG;Data structures;Standardization;Uniform resource locators;RFID tags;Cellular phones;ISO standards;Protocols;Proposals	radiofrequency identification;data structures;mobile radio;telecommunication services;codes	RFID code structure;tag data structure;mobile RFID services;Korea;mobile telecommunications terminals;uniform resource identifier		1	1	4		8 May 2006			IEEE	IEEE Conferences
An Efficient Code Structure of Block Coded Modulations with Iterative Viterbi Decoding Algorithm	an efficient code structure of block coded modulations with iterative viterbi decoding algorithm	10.1109/ISWCS.2006.4362391	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362391	H. -B. Li; R. Kohno	National Institute of Information and Communications Technology, Yokosuka, Japan; NICT, Yokosuka, Japan	2006 3rd International Symposium on Wireless Communication Systems	22 Oct 2007	2006			699	703	Block coded modulations (BCM) with iterative Viterbi decoding algorithm can provide both high transmission throughput and small error probability. In this paper, a new code structure is proposed to further improve the performance. The strategy of the new code is to add parity check codes at corresponding coding levels of BCM to increase the Hamming distances among codewords. Decoding trellis of Viterbi decoding to support the new code structure is also developed. It is shown that the proposed code structure can not only guarantee the Euclidean distance of BCM but also mitigate the burden of iterative decoding. As a result, the proposed code structure can provide better transmission rates than the old one with identical or less decoding complexity. Computer simulation shows that the proposed code structure is also beyond the old one in bit error rate performance.	2154-0225	978-1-4244-0397-4		Block coded modulation;Viterbi decoding;Iterative decoding;coding gains	Modulation coding;Viterbi algorithm;Iterative decoding;Iterative algorithms;Throughput;Error probability;Parity check codes;Euclidean distance;Computer simulation;Bit error rate	block codes;error statistics;Hamming codes;iterative decoding;parity check codes;trellis coded modulation;Viterbi decoding	code structure;block coded modulations;iterative Viterbi decoding algorithm;transmission throughput;error probability;parity check codes;Hamming distances;trellis codes;decoding complexity;bit error rate performance				10		22 Oct 2007			IEEE	IEEE Conferences
Dependable medical network based on 4G cellular mobile standard with external channel code in concatenated code structure	dependable medical network based on 4g cellular mobile standard with external channel code in concatenated code structure		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6979812	E. A. Talha; R. Kohno	Division of Physics, Yokohama National University, Yokohama, Japan; Division of Physics, Yokohama National University, Yokohama, Japan	2014 International Symposium on Information Theory and its Applications	11 Dec 2014	2014			105	109	This paper come as a proposal to achieve modification on the latest standard of mobile communications that is Long Term Evolution. The paper first studies the error control coding in the standard, which is based on the turbo code for high data rate and convolution code for low data rate. Following that, the paper adopted medical network channel code through the channel code of the fourth generation standard. The proposal is based on concatenated codes structure designed by adding extra channel code using convolution code to the fourth generation standard code. In order to transmit medical data in uplink channel by high level of reliability the concatenated structure are proposed. The enhancement of error probability performances have been proven and investigated using computer simulation under different noise channels such as Additive White Gaussian Noise and Rayleigh Fading. The paper has been optimized the Bit Error Rate for the proposal equal to the level of medical transmission requirement with lower signal to noise ratio as a comparison with the long term evolution error performance.		978-4-8855-2292-5			Standards;Convolution;Decoding;Proposals;Turbo codes;Mobile communication	4G mobile communication;AWGN;biomedical communication;channel coding;concatenated codes;convolutional codes;error correction codes;error statistics;fading channels;Long Term Evolution;turbo codes	bit error rate;Rayleigh fading;additive white Gaussian noise;noise channels;error probability;medical network channel code;convolution code;turbo code;error control coding;long term evolution;mobile communications;concatenated code structure;4G cellular mobile standard				6		11 Dec 2014			IEEE	IEEE Conferences
Convolutional code structure and the performance of the Viterbi algorithm (Ph.D. Thesis abstr.)	convolutional code structure and the performance of the viterbi algorithm (ph.d. thesis abstr.)	10.1109/TIT.1978.1055869	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1055869	F. Hemmati	NA	IEEE Transactions on Information Theory	6 jan. 2003	1978	24	2	276	277		1557-9654						Convolutional codes;Viterbi decoding						6 jan. 2003			IEEE	IEEE Journals
Improved decoding of woven convolutional codes via hierarchical near-EEP code structure	improved decoding of woven convolutional codes via hierarchical neareep code structure	10.1109/GLOCOM.2001.965636	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=965636	S. Huettinger; J. Huber	Telecommunications Institute II, University Erlangen-Nurnberg Cauerstr. 7, Erlangen, Germany; NA	GLOBECOM'01. IEEE Global Telecommunications Conference (Cat. No.01CH37270)	6 Aug 2002	2001	2		1068	1072 vol.2	A hierarchically designed channel coding scheme protects a few number of input data streams, so-called layers, with a decreasing amount of redundancy from layer 0 to layer L. Such a code design clearly leads to unequal error protection, but as shown by Huettinger and Huber (see Winter School on Coding and Information Theory, Reisensburg, December 2000) it can be superior in the average bit error rate compared to an equal error protection (EEP) design, if the protection of layers is not too different. This is due to the fact, that a near-EEP hierarchical design can match the properties of the iterative decoder. We extend the result to woven convolutional codes (WCC). Based on asymptotical analysis of the convergence of iterative decoding by means of EXIT charts we show that for an infinite interleaver size the hierarchical structure is superior. Furthermore, we show that even for practical block sizes used in modern communication systems a significant improvement is possible by the hierarchical design.		0-7803-7206-9			Convolutional codes;Iterative decoding;Maximum likelihood decoding;Error correction codes;Concatenated codes;Protection;Redundancy;Channel coding;Bit error rate;Convergence	convolutional codes;concatenated codes;iterative decoding;convergence of numerical methods;error statistics;turbo codes	woven convolutional codes;hierarchical near-EEP code structure;hierarchically designed channel coding;input data streams;redundancy;code design;unequal error protection;average bit error rate;equal error protection;layers protection;asymptotical analysis;BER;serially concatenated turbo codes;simulation results;iterative decoding convergence;EXIT charts;infinite interleaver size;block sizes;communication systems				12		6 Aug 2002			IEEE	IEEE Conferences
Design of woven coded CPFSK via hierarchical code structure	design of woven coded cpfsk via hierarchical code structure	10.1109/ISIT.2004.1365553	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1365553	S. Kempf; S. Shavgulidze; M. Bossert	Department of TAIT, University of Ulm (EBS), Ulm, Germany; Department Digital Communication Theory, Georgian Technical University, Tbilisi, GA, Georgia; Department of TAIT, University of Ulm (EBS), Ulm, Germany	International Symposium onInformation Theory, 2004. ISIT 2004. Proceedings.	10 jan. 2005	2004			516		This paper describes the hierarchical woven coded CPFSK (hWCCPFSK), is a serial concatenation of different outer convolutional codes and inner continuous phase frequency shift keying (CPFSK). Classical woven coded CPFSK (cWCCPFSK) has identical outer convolutional codes. We show that with a proper choice of the outer codes, hWCCPFSK has better decoding behaviour but cWCCPFSK has larger free distance. Hence, hWCCPFSK performes better in the waterfall region of the bit error rate curves, while cWCCPFSK is better in the error floor region.		0-7803-8280-3			Convolutional codes;Convergence;Mutual information;Demodulation;Iterative decoding;Bit error rate;Modulation coding;Transfer functions;Digital communication;Frequency shift keying	frequency shift keying;continuous phase modulation;concatenated codes;convolutional codes;decoding;error statistics;phase shift keying	hierarchical woven coded CPFSK;hWCCPFSK;continuous phase frequency shift keying;serial concatenation code;classical woven coded CPFSK;cWCCPFSK;convolutional code;decoding;free distance;waterfall region;bit error rate curve;error floor				2		10 jan. 2005			IEEE	IEEE Conferences
PVDC: A Binary Descriptor Using Pore-Valley Disk Code Structure for High-Resolution Partial Fingerprint Recognition	pvdc a binary descriptor using porevalley disk code structure for highresolution partial fingerprint recognition	10.1109/ICASSP.2018.8461885	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8461885	P. -Y. Chou; C. -T. Chiu	Institute of Information Systems and Applications, National Tsing-Hua University, Taiwan; Institute of Information Systems and Applications, National Tsing-Hua University, Taiwan	2018 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP)	13 Sep 2018	2018			1135	1139	Plenty of pores can solve the lack of feature points problem on high-resolution partial fingerprints. Pore-based features are similar, so the neighbor ridge features are also taken into account. However, lots of feature points cause heavy computation required. We propose a binary descriptor, Pore-Valley Disk Code (PVDC), which encodes the local structure of a center pore and its neighbor valleys with an eight-section disk. The proposed descriptor is rotational invariant since the first section always aligns to the center pore orientation. Instead of recording pixel by pixel, we find that the direction and distance of intersected valleys in each section can efficiently represent the ridge structure with reduced computation. With the proposed fixed-length binary code, the matching time can be significantly reduced. The proposed method has 160x speedup compared with the state-of-the-art pore-based Sparse Representation based Direct Pore (SRDP) method with reasonable EER in HRF DBI database.	2379-190X	978-1-5386-4658-8		Pore-Valley Disk Code;High-Resolution Fingerprint;Partial Fingerprint Recognition	Fingerprint recognition;Fingers;Image matching;Indexes;Mobile handsets;Computational efficiency	binary codes;feature extraction;fingerprint identification;image coding;image matching;image representation;image resolution	sparse representation based direct pore method;HRF DBI database;SRDP method;neighbor ridge features;Pore-based features;feature points problem;high-resolution partial fingerprint recognition;pore-valley disk code structure;binary descriptor;PVDC;Direct Pore method;fixed-length binary code;center pore orientation;neighbor valleys				20		13 Sep 2018			IEEE	IEEE Conferences
A Framework for Estimating Interest on Technical Debt by Monitoring Developer Activity Related to Code Comprehension	a framework for estimating interest on technical debt by monitoring developer activity related to code comprehension	10.1109/MTD.2014.16	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6974886	V. Singh; W. Snipes; N. A. Kraft	University of Delaware, Newark, DE, USA; ABB Corporate Research, Raleigh, NC, USA; ABB Corporate Research, Raleigh, NC, USA	2014 Sixth International Workshop on Managing Technical Debt	4 Dec 2014	2014			27	30	Evaluating technical debt related to code structure at a fine-grained level of detail is feasible using static code metrics to identify troublesome areas of a software code base. However, estimating the interest payments at a similar level of detail is a manual process relying on developers to submit their estimates as they encounter instances of technical debt. We propose a framework that continuously estimates interest payments using code comprehension metrics produced by a tool that monitors developer activities in the Integrated Development Environment. We describe the framework and demonstrate how it is used to evaluate the presence of technical debt and interest payments accumulated for code in an industrial software product.		978-1-4799-6791-9		Technical Debt;program comprehension;static analysis;software maintenance;code metrics;code smells	Conferences	program diagnostics;software maintenance;software tools	technical debt interest estimation;developer activity monitoring;code comprehension metrics;integrated development environment;industrial software product;code maintainability;static analysis		16		12		4 Dec 2014			IEEE	IEEE Conferences
Code Comprehension Activities in Undergraduate Software Engineering Course - A Case Study	code comprehension activities in undergraduate software engineering course a case study	10.1109/ASWEC.2015.18	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7365795	S. K. Sripada; Y. R. Reddy	International Institute of Information Technology, Hyderabad (IIIT-H), India; International Institute of Information Technology, Bangalore, Karnataka, IN	2015 24th Australasian Software Engineering Conference	28 Dec 2015	2015			68	77	In industry, inspections, reviews, and refactoring are considered as necessary software engineering activities for enhancing quality of code. In academia, such activities are rarely taught and practiced at Undergraduate level due to various reasons like limited skill set, limited knowledge of the available tools, time constraints, project setting, project client availability, flexibility with Syllabus, etc. However, we argue that such activities are an essential part of introductory software engineering courses and can result in improvement of coding skills, knowledge of coding standard and compliance to the same, and peer communication within teams. We have studied the use of such activities in a sophomore level Software Engineering course consisting of more than 200 students working in teams on projects from start-ups and present our experiences, findings and challenges. We present the results of quantitative evaluation of the impact of code comprehension activities before and after each iteration of the team projects.	1530-0803	978-1-4673-9390-4		Code Inspection;Code Reviews;Program Comprehension;Refactoring;Static Code Analysis;Textual Analysis	Measurement;Inspection;Software engineering;Software;Standards;Encoding;Writing	computer science education;educational courses;further education;software engineering	undergraduate software engineering course;code comprehension activities;introductory software engineering courses		4		23		28 Dec 2015			IEEE	IEEE Conferences
Users' Perception on the Use of MetricAttitude to Perform Source Code Comprehension Tasks: A Focus Group Study	users perception on the use of metricattitude to perform source code comprehension tasks a focus group study	10.1109/iV.2017.26	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8107941	R. Francese; M. Risi; G. Scanniello; G. Tortora	University of Salerno, Italy; University of Salerno, Italy; University of Basilicata, Italy; University of Salerno, Italy	2017 21st International Conference Information Visualisation (IV)	16 nov. 2017	2017			8	13	MetricAttitude [18] is a visualization approach implemented in an environment that provides a mental picture of an object-oriented software by means of polymetric views of classes. In this paper, we describe a qualitative investigation we have conducted with a focus group involving developers aiming at evaluating their viewpoint on the relevance of the support MetricAttitude provides to perform comprehension tasks on source code. This investigation also allowed us to gather information on the developers' opinion on the MetricAttitude features and its software visualization metaphors. The discussion was animated and participants provided a number of useful suggestions for improving the visualization. The tool was considered very useful, while some usability problems have to be addressed. Specifically, the information provided has to be further filtered to easier software comprehension tasks.	2375-0138	978-1-5386-0831-9		Polymetric Views;Software Visualization;Program Comprehension;Focus Group;User Study;Qualitative Evaluation	Software;Measurement;Visualization;Computer bugs;Tools;Concrete	ergonomics;human factors;object-oriented methods;object-oriented programming;program visualisation;source code (software)	focus group study;visualization approach;mental picture;software visualization metaphors;users perception;MetricAttitude;source code comprehension tasks;object-oriented software;usability problems		3		24		16 nov. 2017			IEEE	IEEE Conferences
An Empirical Study on Code Comprehension: Data Context Interaction Compared to Classical Object Oriented	an empirical study on code comprehension data context interaction compared to classical object oriented	10.1109/ICPC.2017.23	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961524	H. A. Valdecantos; K. Tarrit; M. Mirakhorli; J. O. Coplien	Departamento de Ciencias de la Computación, FACET, Argentina; Rochester Institute of Technology, USA; Rochester Institute of Technology, USA; Gertrud & Cope, Denmark	2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC)	29 jun. 2017	2017			275	285	Source code comprehension affects software development — especially its maintenance — where code reading is one of the most time-consuming activities. A programming language, together with the programming paradigm it supports, is a strong factor that profoundly impacts how programmers comprehend code. We conducted a human-subject controlled experiment to evaluate comprehension of code written using the Data Context Interaction (DCI) paradigm relative to code written with commonly used Object-Oriented (OO) programming. We used a new research-level language called Trygve which implements DCI concepts, and Java, a pervasive OO language in the industry. DCI revisits lost roots of the OO paradigm to address problems that are inherent to Java and most other contemporary OO languages. We observed correctness, time consumption, and locality of reference during reading comprehension tasks. We present a method which relies on the Eigenvector Centrality metric from Social Network Analysis to study the locality of reference in programmers by inspecting their sequencing of reading language element declarations and their permanence time in the code. Results indicate that DCI code in Trygve supports more comprehensible code regarding correctness and improves the locality of reference, reducing context switching during the software discovery process. Regarding reading time consumption, we found no statistically significant differences between both approaches.		978-1-5386-0535-6		Program comprehension;Controlled experiment;Human subjects;Programming languages;Programming paradigms;Data Context Interaction;Object-Oriented	Context;Java;Programming profession;Software;Sequential analysis	eigenvalues and eigenfunctions;Java;object-oriented languages;object-oriented programming;social networking (online);software engineering	data context interaction;source code comprehension;software development;programming language;object-oriented programming;OO language;research-level language;Trygve;Java;DCI concepts;Social Network Analysis;eigenvector centrality metric;software discovery process		1		39		29 jun. 2017			IEEE	IEEE Conferences
Descriptive Compound Identifier Names Improve Source Code Comprehension	descriptive compound identifier names improve source code comprehension		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8973056	A. Schankin; A. Berger; D. V. Holt; J. C. Hofmeister; T. Riedel; M. Beigl	Karlsruhe Institute of Technology, Karlsruhe, Germany; Karlsruhe Institute of Technology, Karlsruhe, Germany; Heidelberg University, Heidelberg, Germany; University of Passau, Passau, Germany; Karlsruhe Institute of Technology, Karlsruhe, Germany; Karlsruhe Institute of Technology, Karlsruhe, Germany	2018 IEEE/ACM 26th International Conference on Program Comprehension (ICPC)	30 jan. 2020	2018			31	3109	Reading and understanding source code is a major task in software development. Code comprehension depends on the quality of code, which is impacted by code structure and identifier naming. In this paper we empirically investigated whether longer but more descriptive identifier names improve code comprehension compared to short names, as they represent useful information in more detail. In a web-based study 88 Java developers were asked to locate a semantic defect in source code snippets. With descriptive identifier names, developers spent more time in the lines of code before the actual defect occurred and changed their reading direction less often, finding the semantic defect about 14% faster than with shorter but less descriptive identifier names. These effects disappeared when developers searched for a syntax error, i.e., when no in-depth understanding of the code was required. Interestingly, the style of identifier names had a clear impact on program comprehension for more experienced developers but not for less experienced developers.	2643-7171	978-1-4503-5714-2		Program Comprehension;Identifier Names;Java Developers;Software Quality		Java;software maintenance;source code (software)	software development;code structure;identifier naming;descriptive identifier names;semantic defect;source code snippets;descriptive compound identifier names;source code comprehension;code quality;Java developers;syntax error;program comprehension				26		30 jan. 2020			IEEE	IEEE Conferences
Code structure visualization using 3D-flythrough	code structure visualization using 3dflythrough	10.1109/ICCSE.2016.7581608	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7581608	R. Oberhauser; C. Silfang; C. Lecon	Department of Computer Science, Aalen University, Aalen, Germany; Department of Computer Science, Aalen University, Aalen, Germany; Department of Computer Science, Aalen University, Aalen, Germany	2016 11th International Conference on Computer Science & Education (ICCSE)	6 Oct 2016	2016			365	370	As software structures grow, it becomes increasingly difficult for those new to any software source code to conceptualize the mostly invisible structure. Historically program structures have been challenging to visualize. This paper contributes a 3D flythrough approach called FlyThruCode for visualizing facets of program structure. A prototype demonstrates its viability, and an empirical study investigates its effectiveness, efficiency, and motivational factors, showing promise for motivating the exploration of larger software structures.		978-1-5090-2218-2		Software engineering;engineering training;computer education;software visualization;program comprehension	Three-dimensional displays;Unified modeling language;Visualization;Software;Measurement;Two dimensional displays;Object oriented modeling	data visualisation;source code (software)	code structure visualization;3D flythrough approach;FlyThruCode;software structures;historically program structures;motivational factors;facets visualization;software source code		2		19		6 Oct 2016			IEEE	IEEE Conferences
Program understanding behavior during adaptation of large scale software	program understanding behavior during adaptation of large scale software	10.1109/WPC.1998.693345	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=693345	A. von Mayrhauser; A. M. Vans	Computer Science Department, Colorado State University, Fort Collins, CO, USA; Computer Science Department, Colorado State University, Fort Collins, CO, USA	Proceedings. 6th International Workshop on Program Comprehension. IWPC'98 (Cat. No.98TB100242)	6 Aug 2002	1998			164	172	We report on a software understanding study during adaptation, of large-scale software. Participants were professional software maintenance engineers. The paper reports on the general understanding process, the types of actions programmers preferred during the adaptation task, and the level of abstraction, at which they were working. The results of the observation are also interpreted in terms of the information needs of these software engineers.	1092-8138	0-8186-8560-3			Large-scale systems;Programming profession;Software maintenance;Computer science;Database systems;Computer bugs;Software systems;Design for experiments;Computer industry;Shafts	reverse engineering;software maintenance	program understanding behavior;large-scale software adaptation;software maintenance;general understanding process;adaptation task;abstraction;information needs		23		23		6 Aug 2002			IEEE	IEEE Conferences
An architecture for interoperable program understanding tools	an architecture for interoperable program understanding tools	10.1109/WPC.1998.693285	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=693285	S. Woods; L. O'Brien; T. Lin; K. Gallagher; A. Quilici	Software Engineering Institute, Carnegie Mellon University, Pittsburgh, PA, USA; CSIRO Mathematical and Information Sciences, Canberra, Australia; CSIRO Mathematical and Information Sciences, Canberra, Australia; CSIRO Mathematical and Information Sciences, Canberra, Australia; Department of Electrical Engineering, University of Hawaii, Manoa, Honolulu, HI, USA	Proceedings. 6th International Workshop on Program Comprehension. IWPC'98 (Cat. No.98TB100242)	6 Aug 2002	1998			54	63	Program understanding tools are currently not interoperable, leading researchers to waste significant resources reinventing already existing tools. Even commercial environments that have been designed to support the construction of program understanding tools have serious flaws in this regard. This paper discusses CORUM (Common Object-based Re-engineering Unified Model), an architecture to support interoperability between program understanding tools, and it provides several examples of CORUM's use in the construction of new tools for concept recognition and program visualization.	1092-8138	0-8186-8560-3			Computer architecture;Data visualization;Software tools;Software engineering;Data mining;Decoding;Educational institutions;Data flow computing;Wheels;Control systems	reverse engineering;software tools;open systems;object-oriented programming;systems re-engineering;data visualisation	interoperable program understanding tools;commercial environments;CORUM;Common Object-based Re-engineering Unified Model;concept recognition;program visualization		18	1	54		6 Aug 2002			IEEE	IEEE Conferences
Atomic architectural component recovery for program understanding and evolution	atomic architectural component recovery for program understanding and evolution	10.1109/ICSM.2002.1167807	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1167807	R. Koschke	University of Stuttgart, Stuttgart, Germany	International Conference on Software Maintenance, 2002. Proceedings.	29 jan. 2003	2002			478	481	Component recovery and remodularization is a means to get back control on large and complex legacy systems suffering from ad-hoc changes by recovering logical components and restructuring the physical components accordingly to decrease coupling among components and increase cohesion of components. This thesis is on unifying, quantitatively and qualitatively evaluating, improving, and integrating automatic and semi-automatic methods for component recovery.	1063-6773	0-7695-1819-2			Control systems;Automatic control;Costs;Software architecture;Computer architecture;Packaging;History;Manuals;Software maintenance;Humans	software architecture;software reusability;object-oriented programming;software maintenance;reverse engineering	atomic architectural component recovery;program understanding;program evolution;remodularization;complex legacy systems;logical components;software component restructuring;automatic methods;software maintenance;software reuse		17		32		29 jan. 2003			IEEE	IEEE Conferences
Do class comments aid Java program understanding?	do class comments aid java program understanding	10.1109/FIE.2003.1263332	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1263332	E. Nurvitadhi; Wing Wah Leung; C. Cook	Oregon State University, Corvallis, OR, USA; Oregon State University, Corvallis, OR, USA; Oregon State University, Corvallis, OR, USA	33rd Annual Frontiers in Education, 2003. FIE 2003.	19 Feb 2004	2003	1		T3C	T3C	This paper describes an experiment that investigates the effects of class and method comments on Java program understanding among beginning programmers. Each of the 103 students from CS1 class at Oregon Slate University was given one of four versions (no comments, only method comments, only class comments, and both method and class comments) of a Java database program and answered questions about the program. The results indicated that method comments do increase low-level program understanding, while class comments did not increase high-level understanding. This raises questions about the role of class comments in object-oriented programs, as well as the kind of commenting guidelines that should be used in teaching CS1 classes.	0190-5848	0-7803-7961-6			Java;Guidelines;Programming profession;Databases;Books;Testing;Debugging	Java;computer science education	Java program;database program;program understanding;object-oriented programs;class comments;method comments		12		12		19 Feb 2004			IEEE	IEEE Conferences
Understanding program understanding	understanding program understanding	10.1109/WPC.2000.852501	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852501	F. Balmas; H. Wertz; J. Singer	Department Informatique, Université Paris 8, Denison, USA; Department Informatique, Université Paris 8, Denison, USA; Institute for Information Technology, National Research Council, Ottawa, Canada	Proceedings IWPC 2000. 8th International Workshop on Program Comprehension	6 Aug 2002	2000			256	256		1092-8138	0-7695-0656-9			US Department of Transportation;Information technology;Software engineering;Data mining;Guidelines				5				6 Aug 2002			IEEE	IEEE Conferences
On selecting software visualization tools for program understanding in an industrial context	on selecting software visualization tools for program understanding in an industrial context	10.1109/WPC.2002.1021350	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021350	S. Tilley; Shihong Huang	Department of Computer Science, University of California, Riverside, USA; Department of Computer Science, University of California, Riverside, USA	Proceedings 10th International Workshop on Program Comprehension	10 Dec 2002	2002			285	288	Discusses issues related to selecting software visualization tools for program understanding in an industrial context. Visualization tools are often advocated as an effective means of aiding program understanding by creating graphical representations of the subject system through reverse engineering. However, there are numerous practical considerations related to tool selection for large, real-world projects that are unaddressed. For example, the choices are often limited to commercial tools that are widely available, that have a low cost of deployment and training, and that easily integrate into existing software engineering processes. To illustrate some of these unique issues, two types of constraints imposed on the process of software visualization tool selection to support program understanding in the domain of embedded, real-time control systems are described.	1092-8138	0-7695-1495-2			Software tools;Visualization;Computer industry;Documentation;Costs;Computer science;Software systems;Reverse engineering;Software engineering;Embedded software	reverse engineering;program visualisation;data visualisation;software selection;embedded systems;industrial control	software visualization tools;program understanding;graphical representations;reverse engineering;embedded real-time control systems		3		8		10 Dec 2002			IEEE	IEEE Conferences
An experiment in scientific program understanding	an experiment in scientific program understanding	10.1109/ASE.2000.873678	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=873678	M. E. M. Stewart	DYNACS Engineering Company, Inc., Cleveland, OH, USA	Proceedings ASE 2000. Fifteenth IEEE International Conference on Automated Software Engineering	6 Aug 2002	2000			281	284	This paper concerns automated analysis of the meaning or semantics of scientific and engineering code. The procedure involves taking a user's existing code, adding semantic declarations for some primitive variables, and automatically identifying formulae. Parsers encode domain knowledge and recognize formulae in different disciplines including physics, numerical methods, mathematics, and geometry. The parsers will automatically recognize and document some static, semantic concepts and help locate some program semantic errors. Results are shown for three intensively studied codes and seven blind test cases; all test cases are state of the art scientific codes. These techniques may apply to a wider range of scientific codes. If so, the techniques could reduce the time, risk, and effort required to develop and modify scientific codes.	1938-4300	0-7695-0710-7			Testing;Acceleration;Physics;Object oriented programming;Software performance;Knowledge representation;Equations;Documentation;Manuals;Investments	reverse engineering;natural sciences computing;grammars	scientific program understanding;automated analysis;meaning;semantics;scientific code;engineering code;semantic declarations;primitive variables;parsers;domain knowledge encoding;formulae recognition;physics;numerical methods;mathematics;geometry;program semantic errors		2		17		6 Aug 2002			IEEE	IEEE Conferences
Program understanding-does it offer hope for aging software?	program understandingdoes it offer hope for aging software	10.1109/KBSE.1992.252917	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=252917	L. Miller; L. Johnson; J. Q. Ning; A. Quilici; P. Devanbu	Aerospace Corp., Los Angeles, CA, USA; NA; NA; NA; NA	Proceedings of the Seventh Knowledge-Based Software Engineering Conference	6 Aug 2002	1992			238	242	Two questions are examined: what does it mean to understand a program? What solutions to the aging software crisis does program understanding offer? One view is that the aging software problem is a form of support for program maintenance. Another view is that the problem of applying program understanding techniques to aging software is one of both extending the life of existing relics, and mining them for valuable components. Yet another view is that domain specific cliches are necessary in program understanding and that program understanding support for software is how programmers can come to understand a program through cooperative interaction with a knowledge base. The work focuses on the flexibility provided by natural language interaction.<>	1068-3062	0-8186-2880-4			Aging;Programming profession;Automatic testing;Libraries;Knowledge representation;Reverse engineering;Software maintenance	human factors;knowledge based systems;natural language interfaces;programming;software maintenance;software reusability	aging software crisis;aging software problem;program maintenance;existing relics;domain specific cliches;program understanding support;cooperative interaction;knowledge base;natural language interaction		2				6 Aug 2002			IEEE	IEEE Conferences
Workshop on graphical documentation for programmers: assessing the efficacy of UML diagrams for program understanding	workshop on graphical documentation for programmers assessing the efficacy of uml diagrams for program understanding	10.1109/WPC.2003.1199213	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199213	Shihong Huang; S. Tilley	Department of Computer Science, University of California, Riverside, USA; Department of Computer Sciences, Florida Institute of Technology, USA	11th IEEE International Workshop on Program Comprehension, 2003.	21 May 2003	2003			281	282	Programmers often use graphical forms of documentation that rely on software visualization techniques to make complicated information easier to understand. However, it is an open question exactly which types of graphical documentation are most suitable for which types of program understanding tasks (and in which specific usage contexts). The Unified Modeling Language (UML) is the de facto standard for modeling modern software applications. This paper focuses on discussing techniques for the efficacy of UML diagrams in aid of program understanding. The majority of the workshop will involve participants analyzing a series of UML diagrams and answering a detailed questionnaire concerning a hypothetical software system.	1092-8138	0-7695-1883-4			Reverse engineering;Specification languages;Visualization;Computer graphics	reverse engineering;specification languages;data visualisation;computer graphics	graphical documentation;UML diagrams;program understanding;graphical forms;software visualization;Unified Modeling Language		2		4		21 May 2003			IEEE	IEEE Conferences
Program understanding using program slivers-an experience report	program understanding using program sliversan experience report	10.1109/ICSM.1997.624232	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5726936	A. Gupta	Weyerhaeuser Flint River Operations, Oglethorpe, Georgia	1997 Proceedings International Conference on Software Maintenance	15 Oct 2012	1997			66	71	A large amount of legacy software is written in languages such as FORTRAN and COBOL. Hard-copy and inline documentation for this software is often inadequate to perform maintenance or re-implementation. These tasks are further hampered by legacy structures and programming style such as the use of “goto”. This paper describes our experience using simple pattern matching tools to obtain “slivers” from legacy process information systems. These slivers provided information that assisted in recovering program design. These slivers also helped in identifying segments which could cause problems with two-digit year fields at the turn of the century	1063-6773	0-8186-8013-X				COBOL;FORTRAN;data integrity;information systems;pattern matching;program control structures;reverse engineering;software maintenance;software reusability;software tools;system documentation	COBOL;FORTRAN;Year 2000 problem;goto;hard-copy documentation;inline documentation;legacy process information systems;legacy software;pattern matching tools;program design recovery;program slivers;program understanding;programming style;software maintenance;software re-implementation;two-digit year fields		1		12		15 Oct 2012			IEEE	IEEE Conferences
Designing self-explanation environment for multilayer understanding. In case of program understanding	designing selfexplanation environment for multilayer understanding. in case of program understanding	10.1109/MMEE.1996.570244	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=570244	M. Soga; A. Kashihari; J. . -I. Toyoda	Department of Social Systems Design, Faculty of Economics, Wakayama University, Wakayama, Japan; NA; NA	1996 IEEE International Conference on Multi Media Engineering Education. Conference Proceedings	6 Aug 2002	1996			49	57	This paper describes self-explanation for the objects, adopting program understanding as an example of the domain that has multiple aspects of understanding. Also, this paper describes how to use multimedia effectively to design a system that supports self-explanation environment.		0-7803-3173-7			Nonhomogeneous media;Computer aided software engineering;Grain size;Multimedia systems;Environmental economics;Uniform resource locators;Toy industry;Layout;Educational programs;Electromagnetics	reverse engineering;multimedia systems;computer aided instruction	self-explanation environment;multilayer understanding;program understanding;multimedia		1		4		6 Aug 2002			IEEE	IEEE Conferences
Structural and behavioral code representation for program understanding	structural and behavioral code representation for program understanding	10.1109/CASE.1992.200136	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=200136	E. Merlo; K. Kontogiannis; J. F. Girard	Centre de Recherche informatique de Montreal, Inc., Montreal, Canada; Centre de Recherche informatique de Montreal, Inc., Montreal, Canada; Centre de Recherche informatique de Montreal, Inc., Montreal, Canada	[1992] Proceedings of the Fifth International Workshop on Computer-Aided Software Engineering	6 Aug 2002	1992			106	108	Methodologies which could assist the software maintainer are reported, with emphasis on an approach which combines structural and behavioral representation of the code. Structural representation occurs at lower levels of abstraction and uses compiler technology techniques, graph parsing, abstract syntax trees, and control and data flow. Behavioral representation can be achieved at higher levels of abstraction by using some formal representation of source code semantics, such as process algebra, lambda calculus, or denotational semantics. The complexity, concurrency, and interaction levels of the system are good indicators of the best formalism to be chosen. Artificial intelligence techniques can be used to define semantic distances between different behavioral representation plans in order to achieve a full or partial match of the source code to the underlying specifications.<>		0-8186-2960-6			Tree graphs;Flow graphs;Performance analysis;Algebra;Calculus;Concurrent computing;Artificial intelligence;Hardware;Maintenance engineering;Data engineering	computational complexity;grammars;program compilers;software maintenance;tree data structures	structural code representation;artificial intelligence;behavioral code representation;program understanding;software maintainer;behavioral representation;compiler;graph parsing;abstract syntax trees;formal representation;source code semantics;process algebra;lambda calculus;denotational semantics;complexity;concurrency;interaction levels		1	2	8		6 Aug 2002			IEEE	IEEE Conferences
Object-oriented codes representation of program understanding system	objectoriented codes representation of program understanding system	10.1109/ITSIM.2008.4631595	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4631595	N. F. M. Sani; A. M. Zin; S. Idris	Faculty of Computer Science and Information Technology, Universiti Putra Malaysia, Serdang, Selangor Darul Ehsan, Malaysia; Faculty of Computer Science and Information Technology, Universiti Kebangsaan슠Malaysia, Bangi, Selangor Darul Ehsan, Malaysia; Faculty of Computer Science and Information Technology, Universiti Kebangsaan슠Malaysia, Bangi, Selangor Darul Ehsan, Malaysia	2008 International Symposium on Information Technology	26 Sep 2008	2008	1		1	5	The purpose of this paper is to present and describe the representation of an object-oriented programming code in the program understanding system. The program’s representation that has been used and will be discussed is an Object-oriented Control Flow Graph (OO-CFG). OO-CFG was an added version on the notation of the traditional control flow graph (CFG). This new OO-CFG has been created since from the literature there are no researches specifically focus on the problem in presenting the communications between objects. Usually the communication between objects in object-oriented program code is by a process of message passing. In this paper, we are introducing the OO-CFG representation and also example on the usage.	2155-899X	978-1-4244-2327-9			Programming;Message passing;Flow graphs;Java;Debugging;Software;Algorithm design and analysis				1		8		26 Sep 2008			IEEE	IEEE Conferences
Answering program understanding questions on demand with task-specific runtime information	answering program understanding questions on demand with taskspecific runtime information	10.1109/VLHCC.2013.6645268	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6645268	B. Burg	Computer Science & Engineering, University of Washington, USA	2013 IEEE Symposium on Visual Languages and Human Centric Computing	24 Oct 2013	2013			167	168	When debugging or otherwise understanding software, developers frequently ask questions such as “how did this function get called?” and “where did this value come from?”. Runtime data is a valuable yet underused resource for answering these questions. There are at least four major barriers to answering questions with runtime data: 1) Deciding what runtime data should be collected 2) Deciding how to collect relevant runtime data 3) Aggregating and summarizing collected data 4) Interpreting the results to make conclusions.	1943-6106	978-1-4799-0369-6			Runtime;Debugging;Context;Probes;Aerospace electronics;Manuals	program debugging;program diagnostics	runtime data;underused resource;software debugging;task-specific runtime information;program understanding questions		1		5		24 Oct 2013			IEEE	IEEE Conferences
Use of a program understanding taxonomy at Hewlett-Packard	use of a program understanding taxonomy at hewlettpackard	10.1109/WPC.1993.263905	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263905	A. Padula	Corporate Engineering, Hewlett Packard Company, Palo Alto, CA, USA	[1993] IEEE Second Workshop on Program Comprehension	6 Aug 2002	1993			66	70	Summarizes the use of a program understanding taxonomy developed at Hewlett-Packard. The primary use of the taxonomy has been in the creation of a company internal document called the Software Tools Report. The Software Tools Report is a selection and evaluation guide to software tools that addresses key company software engineering areas which include program understanding. A description of the Report, how it was created, and how it is used is given.<>	1092-8138	0-8186-4042-1			Taxonomy;Software maintenance;Software tools;Software systems;Maintenance engineering;Software engineering;Investments;Data engineering;Engineering management;Computer industry	software maintenance	program understanding taxonomy;Hewlett-Packard;Software Tools Report;software engineering areas		1		5		6 Aug 2002			IEEE	IEEE Conferences
A static analysis for program understanding and debugging	a static analysis for program understanding and debugging	10.1109/ASE.1997.632853	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=632853	R. Gaugne	IRISA/INRIA, Rennes, France	Proceedings 12th IEEE International Conference Automated Software Engineering	6 Aug 2002	1997			297	298	The paper presents a static pointer analysis technique for a subset of C. The tool supports user-defined assertions inserted in the body of the program. Assertions are of two kinds: static assertions automatically verified by the analyser, and hypothetical assertions treated as assumptions by the analyser. The technique deals with recursive data structures and it is accurate enough to handle circular structures.		0-8186-7961-1			Debugging;Data structures;Computer bugs;Logic;Computer languages;Programming profession;Mechanical factors;Testing;Costs;Tail	reverse engineering;program debugging;system monitoring;data structures;program verification;program verification	program understanding;program debugging;static pointer analysis technique;C subset;user-defined assertions;static assertions;automatic verification;hypothetical assertions;assumptions;recursive data structures;circular structures		1		7		6 Aug 2002			IEEE	IEEE Conferences
Method of software testing based on program understanding	method of software testing based on program understanding	10.1109/ICCAE.2010.5451817	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5451817	Heping Tang; Shuguang Huang; Lei Bao; Yongliang Li	Department of Network engineering, HeFei Electronic Engineering Institute, Hefei, Anhui, China; Department of Network engineering, HeFei Electronic Engineering Institute, Hefei, Anhui, China; Department of Network engineering, HeFei Electronic Engineering Institute, Hefei, Anhui, China; Department of Network engineering, HeFei Electronic Engineering Institute, Hefei, Anhui, China	2010 The 2nd International Conference on Computer and Automation Engineering (ICCAE)	19 Apr 2010	2010	2		811	814	The large scale software system requires computational management techniques in engineering designs, implementations and maintains urgently. This paper discusses an approach of program understanding with mathematical foundations for computation of software behavior. Computational analyses automatically figure out possible behavior and security attributes of software components both for source files and binary executes. The results of program understanding in formula and concurrent assignments forms augment human intelligence in program analysis, testing and evaluation. Program understanding transforms specification verification, software product and security attribute into computational procedure that would achieve intelligent management in next generation Software Engineering.		978-1-4244-5586-7		Computational Function Language;Concurrent Assignment Form;Expression Propagation;Software Testing;Security Evaluation	Software testing;Engineering management;Security;Computational intelligence;Large-scale systems;Software systems;Maintenance engineering;Design engineering;Humans;Software engineering	formal specification;formal verification;program diagnostics;program testing;reverse engineering	software testing method;program understanding;computational management;program analysis				7		19 Apr 2010			IEEE	IEEE Conferences
Dynamic Object Process Graph Extraction for Program Understanding and Protocol Recovery	dynamic object process graph extraction for program understanding and protocol recovery	10.1109/CSMR.2007.21	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4145059	J. Quante	University of Brethemen, Germany	11th European Conference on Software Maintenance and Reengineering (CSMR'07)	2 Apr 2007	2007			345	348	An object process graph (OPG) is a view on the control flow graph from the perspective of a single object. Such a graph can be extracted using static or dynamic program analysis. Similar to program slicing, OPG extraction is an enabling technique with applications in many reverse engineering tasks. This Ph.D. thesis is about dynamic extraction of such OPGs and their application for program understanding and protocol recovery. In a first step, the author introduced methods for online and offline construction of dynamic OPGs, supporting different languages. The second step is the further transformation and application of the resulting graphs. The goal of this thesis is to show how they can be used for program comprehension and protocol recovery, and that these two approaches are really beneficial	1534-5351	0-7695-2802-3			Protocols;Flow graphs;Reverse engineering;Application software;Visualization;Data mining;Instruments;Java;Software systems;Learning automata	flow graphs;program slicing;protocols;reverse engineering	dynamic object process graph extraction;program understanding;protocol recovery;control flow graph;static program analysis;dynamic program analysis;program slicing;reverse engineering;program comprehension				18		2 Apr 2007			IEEE	IEEE Conferences
Structure-behavior-function program understanding	structurebehaviorfunction program understanding	10.1109/WPC.2001.921723	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921723	E. Stroulia; T. Systa	Department of Computer Science, University of Alberta, Edmonton, AB, Canada; Software System Laboratory, Tampere University of Technology, Tampere, Finland	Proceedings 9th International Workshop on Program Comprehension. IWPC 2001	7 Aug 2002	2001			120	120		1092-8138	0-7695-1131-7			Reverse engineering;Object oriented modeling;Documentation;Software systems;Runtime environment;Computer science;Protocols;Radio access networks;Computer languages;Web sites								7 Aug 2002			IEEE	IEEE Conferences
Do Dynamic Object Process Graphs Support Program Understanding? - A Controlled Experiment.	do dynamic object process graphs support program understanding a controlled experiment.	10.1109/ICPC.2008.15	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556119	J. Quante	University of Brethemen, Germany	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			73	82	Using automatic program analysis techniques for extracting architectural information and its visualization is widely considered useful for program understanding. However, it has to be empirically validated if a given technique is beneficial in practice. This is usually done by performing a set of case studies. To find out for sure whether a technique really has any effect, controlled experiments have to be conducted. Dynamic object process graphs are one such technique. These graphs describe the control flow of an application from the perspective of a single object. In previous research, we conducted case studies which indicated that they may be useful for program understanding, but this assumption has not been validated so far. We report on a controlled experiment which investigated this question: Does the availability of such graphs support program understanding or not? We describe the research questions that were investigated, the hypotheses, experimental setup, conduction, and discuss the results and lessons learned.	1092-8138	978-0-7695-3176-2		controlled experiment;program comprehension;dynamic analysis;software maintenance	Software maintenance;Visualization;Flow graphs;Automatic control;Information analysis;Data mining;Programming;Unified modeling language;Sockets;Application software	program diagnostics;reverse engineering;software architecture;software maintenance	dynamic object process graphs;automatic program analysis techniques;architectural information;program understanding		27		8		2 jul. 2008			IEEE	IEEE Conferences
Deploying Smart Program Understanding on a Large Code Base	deploying smart program understanding on a large code base	10.1109/AITest.2019.000-4	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8718219	C. Ieva; A. Gotlieb; S. Kaci; N. Lazaar	Simula Research Laboratory, Oslo, Norway; Simula Research Laboratory, Oslo, Norway; LIRMM, University of Montpellier, CNRS, Montpellier, France; LIRMM, University of Montpellier, CNRS, Montpellier, France	2019 IEEE International Conference On Artificial Intelligence Testing (AITest)	20 May 2019	2019			73	80	Program understanding aims at discovering human-readable properties of a software project from the analysis of its source code. Recently, we proposed a smart approach based on hierarchical agglomerative clustering that extracts so-called program topoi from source code. These topoi are high-level observable properties of the project. Based on textual and structural representations of the source code, our multi-steps approach clusters program topoi in an effective and efficient way. In this paper, we depict novel exploitation tasks of this program understanding approach and report on its application to Software Heritage. Software Heritage is an ambitious project which aims at collecting and archiving the biggest corpus of publicly available software source code. One of the project goals is to provide a new scientific instrument for computer scientists to evaluate advanced machine learning and software engineering methods on a very large source code repository. Our in-depth experiments reveal that unsupervised learning is the appropriate tool to mine and understand the biggest corpus of software source code ever produced.		978-1-7281-0492-8		Program topoi;Software Heritage;Software Clustering;Program comprehension	Software;Semantics;Feature extraction;Coherence;Task analysis;Machine learning;Tools	pattern clustering;program diagnostics;reverse engineering;software maintenance;unsupervised learning	publicly available software source code;project goals;software engineering methods;source code repository;software heritage;ambitious project;program understanding approach;clusters program topoi;structural representations;textual representations;high-level observable properties;hierarchical agglomerative clustering;smart approach;software project;human-readable properties;code base;smart program understanding				18		20 May 2019			IEEE	IEEE Conferences
A Systematic Survey of Program Comprehension through Dynamic Analysis	a systematic survey of program comprehension through dynamic analysis	10.1109/TSE.2009.28	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4815280	B. Cornelissen; A. Zaidman; A. van Deursen; L. Moonen; R. Koschke	Faculty of Electrical Engineering, Mathematics and Computer Science, Delft University of Technnology, Delft, Netherlands; Faculty of Electrical Engineering, Mathematics and Computer Science, Delft University of Technnology, Delft, Netherlands; Faculty of Electrical Engineering, Mathematics and Computer Science, Delft University of Technnology, Delft, Netherlands; Simula Research Laboratory, Lysaker, Norway; Arbeitsgruppe Softwaretechnik, Universität Bremen, Bremen, Germany	IEEE Transactions on Software Engineering	2 Oct 2009	2009	35	5	684	702	Program comprehension is an important activity in software maintenance, as software must be sufficiently understood before it can be properly modified. The study of a program's execution, known as dynamic analysis, has become a common technique in this respect and has received substantial attention from the research community, particularly over the last decade. These efforts have resulted in a large research body of which currently there exists no comprehensive overview. This paper reports on a systematic literature survey aimed at the identification and structuring of research on program comprehension through dynamic analysis. From a research body consisting of 4,795 articles published in 14 relevant venues between July 1999 and June 2008 and the references therein, we have systematically selected 176 articles and characterized them in terms of four main facets: activity, target, method, and evaluation. The resulting overview offers insight in what constitutes the main contributions of the field, supports the task of identifying gaps and opportunities, and has motivated our discussion of several important research directions that merit additional consideration in the near future.	1939-3520			Survey;program comprehension;dynamic analysis.	Computer Society;Software maintenance;Software systems;Documentation;Software engineering;Data analysis;Information analysis;Availability;Runtime;Virtual machining	reverse engineering;software maintenance;system monitoring	program comprehension;dynamic analysis;software maintenance;systematic literature survey		252	1	154		17 Apr 2009			IEEE	IEEE Journals
An Empirical Study of the Impact of Two Antipatterns, Blob and Spaghetti Code, on Program Comprehension	an empirical study of the impact of two antipatterns, blob and spaghetti code, on program comprehension	10.1109/CSMR.2011.24	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5741260	M. Abbes; F. Khomh; Y. -G. Guéhéneuc; G. Antoniol	Dépt. d'Informatique et de Recherche Opérationnelle, Université de Montréal, Montréal, Canada; Dept. of Elec. and Comp. Engineering, Queen's University, Kingston, Ontario, Canada; Ptidej Team, SOCCER Lab, DGIGL, Canada; Ptidej Team, SOCCER Lab, DGIGL, Canada	2011 15th European Conference on Software Maintenance and Reengineering	5 Apr 2011	2011			181	190	Antipatterns are "poor" solutions to recurring design problems which are conjectured in the literature to make object-oriented systems harder to maintain. However, little quantitative evidence exists to support this conjecture. We performed an empirical study to investigate whether the occurrence of antipatterns does indeed affect the understandability of systems by developers during comprehension and maintenance tasks. We designed and conducted three experiments, with 24 subjects each, to collect data on the performance of developers on basic tasks related to program comprehension and assessed the impact of two antipatterns and of their combinations: Blob and Spaghetti Code. We measured the developers' performance with: (1) the NASA task load index for their effort, (2) the time that they spent performing their tasks, and, (3) their percentages of correct answers. Collected data show that the occurrence of one antipattern does not significantly decrease developers' performance while the combination of two antipatterns impedes significantly developers. We conclude that developers can cope with one antipattern but that combinations of antipatterns should be avoided possibly through detection and refactorings.	1534-5351	978-1-61284-259-2		Antipatterns;Blob;Spaghetti Code;Program Comprehension;Program Maintenance;Empirical Software Engineering	Maintenance engineering;Programming;Analysis of variance;Java;Indexes;NASA;Time measurement	object-oriented programming;software maintenance	antipatterns;blob;spaghetti code;program comprehension;recurring design problems;object-oriented systems;maintenance tasks;NASA task load index		157		37		5 Apr 2011			IEEE	IEEE Conferences
A Controlled Experiment for Program Comprehension through Trace Visualization	a controlled experiment for program comprehension through trace visualization	10.1109/TSE.2010.47	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5441291	B. Cornelissen; A. Zaidman; A. van Deursen	Software Improvement Group, Amsterdam, Netherlands; Faculty of Electrical Engineering, Mathematics and Computer Science, Delft University of Technnology, Delft, Netherlands; Faculty of Electrical Engineering, Mathematics and Computer Science, Delft University of Technnology, Delft, Netherlands	IEEE Transactions on Software Engineering	27 May 2011	2011	37	3	341	355	Software maintenance activities require a sufficient level of understanding of the software at hand that unfortunately is not always readily available. Execution trace visualization is a common approach in gaining this understanding, and among our own efforts in this context is Extravis, a tool for the visualization of large traces. While many such tools have been evaluated through case studies, there have been no quantitative evaluations to the present day. This paper reports on the first controlled experiment to quantitatively measure the added value of trace visualization for program comprehension. We designed eight typical tasks aimed at gaining an understanding of a representative subject system, and measured how a control group (using the Eclipse IDE) and an experimental group (using both Eclipse and Extravis) performed these tasks in terms of time spent and solution correctness. The results are statistically significant in both regards, showing a 22 percent decrease in time requirements and a 43 percent increase in correctness for the group using trace visualization.	1939-3520			Program comprehension;dynamic analysis;controlled experiment.	Visualization;Computer Society;Time measurement;Programming;Documentation;Scalability;Software maintenance;Gain measurement;Control systems;Performance evaluation	data visualisation;software maintenance	program comprehension;software maintenance;execution trace visualization		81		56		1 Apr 2010			IEEE	IEEE Journals
Measuring Program Comprehension: A Large-Scale Field Study with Professionals	measuring program comprehension a largescale field study with professionals	10.1109/TSE.2017.2734091	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7997917	X. Xia; L. Bao; D. Lo; Z. Xing; A. E. Hassan; S. Li	College of Computer Science and Technology, Zhejiang University, Hangzhou, China; College of Computer Science and Technology, Zhejiang University, Hangzhou, China; School of Information Systems, Singapore Management University, Singapore; Research School of Computer Science, Australian National University, Canberra, ACT, Australia; School of Computing, Queen’s University, Kingston, ON, Canada; College of Computer Science and Technology, Zhejiang University, Hangzhou, China	IEEE Transactions on Software Engineering	14 Oct 2018	2018	44	10	951	976	During software development and maintenance, developers spend a considerable amount of time on program comprehension activities. Previous studies show that program comprehension takes up as much as half of a developer's time. However, most of these studies are performed in a controlled setting, or with a small number of participants, and investigate the program comprehension activities only within the IDEs. However, developers' program comprehension activities go well beyond their IDE interactions. In this paper, we extend our ActivitySpace framework to collect and analyze Human-Computer Interaction (HCI) data across many applications (not just the IDEs). We follow Minelli et al.'s approach to assign developers' activities into four categories: navigation, editing, comprehension, and other. We then measure the comprehension time by calculating the time that developers spend on program comprehension, e.g., inspecting console and breakpoints in IDE, or reading and understanding tutorials in web browsers. Using this approach, we can perform a more realistic investigation of program comprehension activities, through a field study of program comprehension in practice across a total of seven real projects, on 78 professional developers, and amounting to 3,148 working hours. Our study leverages interaction data that is collected across many applications by the developers. Our study finds that on average developers spend ~58 percent of their time on program comprehension activities, and that they frequently use web browsers and document editors to perform program comprehension activities. We also investigate the impact of programming language, developers' experience, and project phase on the time that is spent on program comprehension, and we find senior developers spend significantly less percentages of time on program comprehension than junior developers. Our study also highlights the importance of several research directions needed to reduce program comprehension time, e.g., building automatic detection and improvement of low quality code and documentation, construction of software-engineering-specific search engines, designing better IDEs that help developers navigate code and browse information more efficiently, etc.	1939-3520		National Natural Science Foundation of China(grant numbers:61602403,61572426); National Key Technology R&D Program; Ministry of Science and Technology of China(grant numbers:2015BAH17F01); 	Program comprehension;field study;inference model	Navigation;Software;Time measurement;Browsers;Maintenance engineering;Programming;Debugging	human computer interaction;Internet;program compilers;reverse engineering;search engines;software maintenance	program comprehension activities;program comprehension time;developers time;software development;software maintenance;IDE interactions;ActivitySpace framework;human computer interaction;Web browsers;programming language;project phase;software-engineering;search engines		66		63	IEEE	31 jul. 2017			IEEE	IEEE Journals
Program Comprehension: Past, Present, and Future	program comprehension past, present, and future	10.1109/SANER.2016.35	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7476769	J. Siegmund	University of Passau	2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)	23 May 2016	2016	5		13	20	Program comprehension is the main activity of the software developers. Although there has been substantial research to support the programmer, the high amount of time developers need to understand source code remained constant over thirty years. Beside more complex software, what might be the reason? In this paper, I explore the past of program-comprehension research, discuss the current state, and outline what future research on program comprehension might bring.		978-1-5090-1855-0		Program comprehension;empirical software engineering	Programming;Software;Computer languages;Protocols;Time factors;Atmospheric measurements;Particle measurements	software engineering;source code (software)	program comprehension research;source code;time developers;programmer;software developers		34		41		23 May 2016			IEEE	IEEE Conferences
Applying Webmining techniques to execution traces to support the program comprehension process	applying webmining techniques to execution traces to support the program comprehension process	10.1109/CSMR.2005.12	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1402122	A. Zaidman; T. Calders; S. Demeyer; J. Paredaens	Department of Mathematics and Computer Science, University of Antwerp, Antwerp, Belgium; Department of Mathematics and Computer Science, University of Antwerp, Antwerp, Belgium; Department of Mathematics and Computer Science, University of Antwerp, Antwerp, Belgium; Department of Mathematics and Computer Science, University of Antwerp, Antwerp, Belgium	Ninth European Conference on Software Maintenance and Reengineering	4 Apr 2005	2005			134	142	Well-designed object-oriented programs typically consist of a few key classes that work tightly together to provide the bulk of the functionality. As such, these key classes are excellent starting points for the program comprehension process. We propose a technique that uses Webmining principles on execution traces to discover these important and tightly interacting classes. Based on two medium-scale case studies - Apache Ant and Jakarta JMeter - and detailed architectural information from its developers, we show that our heuristic does in fact find a sizeable number of the classes deemed important by the developers.	1534-5351	0-7695-2304-8		Reverse engineering;dynamic analysis;web-mining;program comprehension	Object oriented modeling;Programming profession;Reverse engineering;Software performance;Cognitive science;Software maintenance;Cognition;Application software;Object oriented databases;Mathematical model	reverse engineering;object-oriented programming;Internet;data mining;software maintenance;program diagnostics	Webmining techniques;program comprehension process;object-oriented program;execution traces;reverse engineering;dynamic analysis		32	1	29		4 Apr 2005			IEEE	IEEE Conferences
An Approach for Detecting Execution Phases of a System for the Purpose of Program Comprehension	an approach for detecting execution phases of a system for the purpose of program comprehension	10.1109/SERA.2010.34	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5489832	H. Pirzadeh; A. Agarwal; A. Hamou-Lhadj	Department of Electrical and Computer Engineering, Concordia University, Montreal, QUE, Canada; Department of Electrical and Computer Engineering, Concordia University, Montreal, QUE, Canada; Department of Electrical and Computer Engineering, Concordia University, Montreal, QUE, Canada	2010 Eighth ACIS International Conference on Software Engineering Research, Management and Applications	21 jun. 2010	2010			207	214	Understanding the behavioural aspects of a software system is an important activity in many software engineering activities including program comprehension and reverse engineering. The behaviour of software is typically represented in the form of execution traces. Traces, however, tend to be considerably large which makes analyzing their content a complex task. There is a need for trace simplification techniques that can help software engineers make sense of the content of a trace despite the trace being massive. In this paper, we present a novel algorithm that aims to simplify the analysis of a large trace by detecting the execution phases that compose it. An example of a phase could be an initialization phase, a specific computation, etc. Our algorithm processes a trace generated from running the program under study and divides it into phases that can be later used by software engineers to understand where and why a particular computation appears. We also show the effectiveness of our approach through a case study.		978-1-4244-7337-3		Program comprehension;dynamic analysis;trace analysis;trace phase detection	Phase detection;Software maintenance;Software engineering;Reverse engineering;Algorithm design and analysis;Software algorithms;Runtime;Information analysis;Conference management;Engineering management	program diagnostics;reverse engineering;software engineering	execution phases detection;program comprehension;behavioural aspects;software engineering activities;reverse engineering;execution traces;trace simplification techniques		18		14		21 jun. 2010			IEEE	IEEE Conferences
A Novel Approach Based on Gestalt Psychology for Abstracting the Content of Large Execution Traces for Program Comprehension	a novel approach based on gestalt psychology for abstracting the content of large execution traces for program comprehension	10.1109/ICECCS.2011.29	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5773396	H. Pirzadeh; A. Hamou-Lhadj	Software Behaviour Analysis Lab, Department of Electrical and Computer Engineering, Concordia University, Montreal, QUE, Canada; Software Behaviour Analysis Lab, Department of Electrical and Computer Engineering, Concordia University, Montreal, QUE, Canada	2011 16th IEEE International Conference on Engineering of Complex Computer Systems	27 May 2011	2011			221	230	The analysis of execution traces can reveal important information about the behavioral aspects of complex software systems, hence reducing the time and effort it takes to understand and maintain them. Traces, however, tend to be considerably large which hinders their effective analysis. Existing traces analysis tools rely on some sort of visualization techniques to help software engineers make sense of trace content. Many of these techniques have been studied and found to be limited in many ways. In this paper, we present a novel trace analysis technique that automatically divides the content of a large trace into meaningful segments that correspond to the program's main execution phases such as initializing variables, performing a specific computation, etc. These phases can simplify significantly the exploration of large traces by allowing software engineers to first understand the content of a trace at a high-level before they decide to dig into the details. Our phase detection method is inspired by Gestalt laws that characterize the proximity, similarity, and continuity of the elements of a data space. We model these concepts in the context of execution traces and show how they can be used as gravitational forces that yield the formation of dense groups of trace elements, which indicate candidate phases. We applied our approach to two software systems. The results are very promising.		978-0-7695-4381-9		Trace Analysis;Program Comprehension;Software Maintenance;Software Engineering	Gravity;Phase detection;Software;Complexity theory;Visualization;Context;Psychology	data visualisation;program diagnostics;psychology;reverse engineering;software maintenance	Gestalt psychology;large execution trace content analysis;program comprehension;complex software system;visualization technique;software engineers;phase detection method;software maintenance		17		29		27 May 2011			IEEE	IEEE Conferences
Developing Application Specific Ontology for Program Comprehension by Combining Domain Ontology with Code Ontology	developing application specific ontology for program comprehension by combining domain ontology with code ontology	10.1109/QSIC.2008.31	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4601548	H. Zhou; F. Chen; H. Yang	Software Technology Research Laboratory, De Montfort University, Leicester, UK; Software Technology Research Laboratory, De Montfort University, Leicester, UK; Software Technology Research Laboratory, De Montfort University, Leicester, UK	2008 The Eighth International Conference on Quality Software	19 Aug 2008	2008			225	234	This paper proposes a novel approach to generating an ontological perspective for software system. This ontology is a combination of two other ontologies: domain ontology and class diagram ontology. Domain ontology is domain vocabulary which is built by domain experts, while class diagram ontology is automatically populated from source code to represent the knowledge in the code. Combining these two ontologies will generate a third ontology which is used in program comprehension. Firstly, the motivation and related work are introduced. Secondly, method of class diagram to ontology transformation and algorithm of ontology combination are presented. Thirdly, program comprehension from an ontological point of view is discussed. Fourthly, a case study is demonstrated by understanding a point of sale terminal (POST) system. Finally, the conclusion is drawn and further research directions are speculated.	2332-662X	978-0-7695-3312-4		Ontology;Program Comprehension;Class Diagram;Domain knowledge;Concepts;Relations	Ontologies;Software;Software systems;Knowledge representation;Software engineering;Object oriented modeling;Security	ontologies (artificial intelligence);point of sale systems;reverse engineering	application specific ontology;program comprehension;domain ontology;code ontology;software system;class diagram ontology;domain vocabulary;point of sale terminal system		16		23		19 Aug 2008			IEEE	IEEE Conferences
Exploring Software Measures to Assess Program Comprehension	exploring software measures to assess program comprehension	10.1109/ESEM.2011.21	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6092561	J. Feigenspan; S. Apel; J. Liebig; C. Kastner	University of Magdeburg, Germany; University of Passau, Germany; University of Passau, Germany; Philipps University of Marburg, Germany	2011 International Symposium on Empirical Software Engineering and Measurement	1 Dec 2011	2011			127	136	Software measures are often used to assess program comprehension, although their applicability is discussed controversially. Often, their application is based on plausibility arguments, which, however, is not sufficient to decide whether software measures are good predictors for program comprehension. Our goal is to evaluate whether and how software measures and program comprehension correlate. To this end, we carefully designed an experiment. We used four different measures that are often used to judge the quality of source code: complexity, lines of code, concern attributes, and concern operations. We measured how subjects understood two comparable software systems that differ in their implementation, such that one implementation promised considerable benefits in terms of better software measures. We did not observe a difference in program comprehension of our subjects as the software measures suggested it. To explore how software measures and program comprehension could correlate, we used several variants of computing the software measures. This brought them closer to our observed result, however, not as close as to confirm a relationship between software measures and program comprehension. Having failed to establish a relationship, we present our findings as an open issue to the community and initiate a discussion on the role of software measures as comprehensibility predictors.	1949-3789	978-1-4577-2203-5		Software measures;Program comprehension	Software measurement;Software;Java;Programming;Complexity theory;Size measurement;Time factors	software quality	software measurement;program comprehension assess;program comprehension;plausibility arguments;source code quality;code line;concern attributes;concern operations;software systems		16		40		1 Dec 2011			IEEE	IEEE Conferences
Comparing Trace Visualizations for Program Comprehension through Controlled Experiments	comparing trace visualizations for program comprehension through controlled experiments	10.1109/ICPC.2015.37	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181455	F. Fittkau; S. Finke; W. Hasselbring; J. Waller	Software Engineering Group, Kiel University, Kiel, Germany; Software Engineering Group, Kiel University, Kiel, Germany; Software Engineering Group, Kiel University, Kiel, Germany; Software Engineering Group, Kiel University, Kiel, Germany	2015 IEEE 23rd International Conference on Program Comprehension	7 Sep 2015	2015			266	276	For efficient and effective program comprehension, it is essential to provide software engineers with appropriate visualizations of the program's execution traces. Empirical studies, such as controlled experiments, are required to assess the effectiveness and efficiency of proposed visualization techniques. We present controlled experiments to compare the trace visualization tools Extravis and Explor Viz in typical program comprehension tasks. We replicate the first controlled experiment with a second one targeting a differently sized software system. In addition to a thorough analysis of the strategies chosen by the participants, we report on common challenges comparing trace visualization techniques. Besides our own replication of the first experiment, we provide a package containing all our experimental data to facilitate the verifiability, reproducibility and further extensibility of our presented results. Although subjects spent similar time on program comprehension tasks with both tools for a small-sized system, analyzing a larger software system resulted in a significant efficiency advantage of 28 percent less time spent by using Explor Viz. Concerning the effectiveness (correct solutions for program comprehension tasks), we observed a significant improvement of correctness for both object system sizes of 39 and 61 percent with Explor Viz.	1092-8138	978-1-4673-8159-8		Software Visualization;Controlled Experiment;Trace Visualization;Program Comprehension	Visualization;Context;Cities and towns;Color;Software systems;Data visualization	data visualisation;software engineering	trace visualizations;program comprehension;controlled experiments;software engineers;program execution traces;visualization techniques;trace visualization tools;small sized system		13		46		7 Sep 2015			IEEE	IEEE Conferences
RTFM (Read the Factual Mails) - Augmenting Program Comprehension with Remail	rtfm (read the factual mails) augmenting program comprehension with remail	10.1109/CSMR.2011.6	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5741255	A. Bacchelli; M. Lanza; V. Humpa	REVEAL, Faculty of Informatics, University of Lugano, Switzerland; REVEAL, Faculty of Informatics, University of Lugano, Switzerland; REVEAL, Faculty of Informatics, University of Lugano, Switzerland	2011 15th European Conference on Software Maintenance and Reengineering	5 Apr 2011	2011			15	24	The advent of globalization has led to the adoption of distributed software development as a common practice. One of its drawbacks-the absence of impromptu meetings - is tackled with other communication means, such as emails, instant messaging, or forums. Mailing lists have proven to be effective for enabling developers' collaboration and coordination: Being asynchronous, emails can evade time zone barriers, being public, mailing lists maintain developers' awareness, being recorded, email archives offer information on system evolution. Emails can provide information about a task, clarify implementation details, or reveal hidden connections among entities, always within the clear context of a discussion. As a result, we argue that emails might help program comprehension. We devised Remail, an Eclipse plug in to integrate email communication in the IDE. It allows developers to seamlessly handle code entities and emails concerning the source code. Discussions relevant to chosen entities can be retrieved easily, thus providing an updated and effective form of complementary documentation. We present design and implementation of Remail, and illustrate, through a number of scenarios, how it can augment program comprehension.	1534-5351	978-1-61284-259-2		email;program comprehension;remail;IDE plugin	Electronic mail;Databases;Context;Engines;Documentation;Programming;Joining processes	electronic mail;software maintenance	program comprehension;distributed software development;Remail plug-in;E-mail communication		12	1	24		5 Apr 2011			IEEE	IEEE Conferences
Normalizing source code vocabulary to support program comprehension and software quality	normalizing source code vocabulary to support program comprehension and software quality	10.1109/ICSE.2013.6606723	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6606723	L. Guerrouj	DGIGL-SOCCER Laboratory, Ptidej Team, Polytechnique de Montréal, QUE, Canada	2013 35th International Conference on Software Engineering (ICSE)	26 Sep 2013	2013			1385	1388	The literature reports that source code lexicon plays a paramount role in program comprehension, especially when software documentation is scarce, outdated or simply not available. In source code, a significant proportion of vocabulary can be either acronyms and-or abbreviations or concatenation of terms that can not be identified using consistent mechanisms such as naming conventions. It is, therefore, essential to disambiguate concepts conveyed by identifiers to support program comprehension and reap the full benefit of Information Retrieval-based techniques (e.g., feature location and traceability) whose linguistic information (i.e., source code identifiers and comments) used across all software artifacts (e.g., requirements, design, change requests, tests, and source code) must be consistent. To this aim, we propose source code vocabulary normalization approaches that exploit contextual information to align the vocabulary found in the source code with that found in other software artifacts. We were inspired in the choice of context levels by prior works and by our findings. Normalization consists of two tasks: splitting and expansion of source code identifiers. We also investigate the effect of source code vocabulary normalization approaches on software maintenance tasks. Results of our evaluation show that our contextual-aware techniques are accurate and efficient in terms of computation time than state of the art alternatives. In addition, our findings reveal that feature location techniques can benefit from vocabulary normalization when no dynamic information is available.	1558-1225	978-1-4673-3076-3		Source code linguistic analysis;information retrieval;program comprehension;software quality	Context;Vocabulary;Software quality;Software maintenance;Dictionaries	reverse engineering;software maintenance;software quality;system documentation;ubiquitous computing;vocabulary	software quality;source code lexicon;program comprehension;software documentation;information retrieval-based techniques;linguistic information;source code comments;software artifacts;source code vocabulary normalization approaches;contextual information;context levels;source code identifiers splitting;source code identifiers expansion;software maintenance tasks;contextual-aware techniques;feature location		12		26		26 Sep 2013			IEEE	IEEE Conferences
Indentation: Simply a Matter of Style or Support for Program Comprehension?	indentation simply a matter of style or support for program comprehension	10.1109/ICPC.2019.00033	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813302	J. Bauer; J. Siegmund; N. Peitek; J. C. Hofmeister; S. Apel	University of Passau, Passau, Germany; University of Passau, Passau, Germany; Leibniz Institute for Neurobiology, Magdeburg, Germany; University of Passau, Passau, Germany; University of Passau, Passau, Germany	2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC)	29 Aug 2019	2019			154	164	An early study showed that indentation is not a matter of style, but provides actual support for program comprehension. In this paper, we present a non-exact replication of this study. Our aim is to provide empirical evidence for the suggested level of indentation made by many style guides. Following Miara and others, we also included the perceived difficulty, and we extended the original design to gain additional insights into the influence of indentation on visual effort by employing an eye-tracker. In the course of our study, we asked 22 participants to calculate the output of Java code snippets with different levels of indentation, while we recorded their gaze behavior. We did not find any indication that the indentation levels affect program comprehension or visual effort, so we could not replicate the findings of Miara and others. Nevertheless, our modernization of the original experiment design is a promising starting point for future studies in this field.	2643-7171	978-1-7281-1519-1		Code Indentation, Program Comprehension, Visual Effort		gaze tracking;Java;reverse engineering	program comprehension;style guides;visual effort;indentation levels;gaze behavior;Java code snippets;Miara;eye tracker		8		40		29 Aug 2019			IEEE	IEEE Conferences
Evaluating software clustering algorithms in the context of program comprehension	evaluating software clustering algorithms in the context of program comprehension	10.1109/ICPC.2013.6613844	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613844	A. Mahmoud; Nan Niu	Computer Science and Engineering, Mississippi State University, Mississippi State, USA; Computer Science and Engineering, Mississippi State University, Mississippi State, USA	2013 21st International Conference on Program Comprehension (ICPC)	30 Sep 2013	2013			162	171	We propose a novel approach for evaluating software clustering algorithms in the context of program comprehension. Based on the assumption that program comprehension is a task-driven activity, our approach utilizes interaction logs from previous maintenance sessions to automatically devise multiple comprehension-aware and task-sensitive decompositions of software systems. These decompositions are then used as authoritative figures to evaluate the effectiveness of various clustering algorithms. Our approach addresses several challenges associated with evaluating clustering algorithms externally using expert-driven authoritative decompositions. Such limitations include the subjectivity of human experts, the availability of such authoritative figures, and the decaying structure of software systems. We conduct an experimental analysis using two datasets, including an open-source system and a proprietary system, to test the applicability of our approach and validate our research claims.	1092-8138	978-1-4673-3092-3		Program comprehension;maintenance;software clustering	Clustering algorithms;Software algorithms;Software systems;Algorithm design and analysis;Maintenance engineering;Partitioning algorithms	pattern clustering;software maintenance	software clustering algorithms;program comprehension;task-driven activity;interaction logs;software systems;task-sensitive decompositions;multiple comprehension-awareness;software maintenance;expert-driven authoritative decompositions;decaying structure;authoritative figures;open-source system;proprietary system		8		57	IEEE	30 Sep 2013			IEEE	IEEE Conferences
Analyzing Code Comments to Boost Program Comprehension	analyzing code comments to boost program comprehension	10.1109/APSEC.2018.00047	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8719486	Y. Shinyama; Y. Arahori; K. Gondow	Department of Computer Science, Tokyo Institute of Technology, Tokyo, Japan; Department of Computer Science, Tokyo Institute of Technology, Tokyo, Japan; Department of Computer Science, Tokyo Institute of Technology, Tokyo, Japan	2018 25th Asia-Pacific Software Engineering Conference (APSEC)	23 May 2019	2018			325	334	We are trying to find source code comments that help programmers understand a nontrivial part of source code. One of such examples would be explaining to assign a zero as a way to "clear" a buffer. Such comments are invaluable to programmers and identifying them correctly would be of great help. Toward this goal, we developed a method to discover explanatory code comments in a source code. We first propose 12 distinct categories of code comments. We then developed a decision-tree based classifier that can identify explanatory comments with 60% precision and 80% recall. We analyzed 2,000 GitHub projects that are written in two languages: Java and Python. This task is novel in that it focuses on a microscopic comment ("local comment") within a method or function, in contrast to the prior efforts that focused on API- or method-level comments. We also investigated how different category of comments is used in different projects. Our key finding is that there are two dominant types of comments: preconditional and postconditional. Our findings also suggest that many English code comments have a certain grammatical structure that are consistent across different projects.	2640-0715	978-1-7281-1970-0		Program Comprehension;Source code comments;Natural language processing;decision tree;java;python;github	Syntactics;Java;Python;Natural languages;Semantics	application program interfaces;decision trees;Java;pattern classification;Python;software maintenance;source code (software)	GitHub projects;code comments analysis;Java;Python;API;English code comments;method-level comments;microscopic comment;decision-tree based classifier;explanatory code comments;source code comments;boost program comprehension		8		26		23 May 2019			IEEE	IEEE Conferences
A Comment Analysis Approach for Program Comprehension	a comment analysis approach for program comprehension	10.1109/SEW.2012.8	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6479798	J. L. Freitas; D. da Cruz; P. R. Henriques	Departamento de Informatica, Universidade do Minho, Braga, Portugal; Departamento de Informatica, Universidade do Minho, Braga, Portugal; Departamento de Informatica, Universidade do Minho, Braga, Portugal	2012 35th Annual IEEE Software Engineering Workshop	18 mar. 2013	2012			11	20	Comments are interspersed by the Programmer among code lines, at software development phase, with two main purposes: to help himself during the development phase, to help other programmers later on, during the maintenance phase. The former are memos to help him remembering to do something, they are not useful for those willing to understand code. The latter are explanations about the ideas he has in mind when he wrote the code, they can be a relevant aid for others and should be taken into consideration as a first step in program comprehension. Comments are scattered all over the source code, sometimes wrapping a block of code (placed at the beginning or at its end), other times complementing a single statement. If comments are inserted to help in understanding the programmer ideas, they will contain for sure concepts associated with problem domain In this paper we discuss an approach to locate a relevant code chunk (one where the programmer should focus the attention for software maintenance), using information retrieval techniques to locate problem domain concepts within comments. In our approach, comments are isolated marking their type (inline, block or javadoc comment) and keeping their context (code lines to which they are associated). Picking up concepts from the ontology that describes the problem, it is possible to find all the comments that contain that concept (similar words) and rate them. Reading comments from the retrieved list, the programmer can select those that seem to him meaningful and dive directly into the associated chunk. In the paper, we also survey Comment Analysis techniques and describe an environment, Darius, that aims at automatizing the approach proposed. Moreover, Dariusprovides functionality to study comments frequency in the source files of a given project, to support the discussion weather it is worthwhile or not to apply this program comprehension step.	1550-6215	978-1-4673-5574-2		program comprehension;comment analysis;concept location;problem domain;program domain	Portable document format;Semantics;Standards;Software maintenance;Natural languages;Data mining	information retrieval;ontologies (artificial intelligence);software maintenance	comment analysis approach;software development phase;code lines;source code;code chunk;software maintenance;information retrieval techniques;problem domain concepts;block comment;javadoc comment;inline comment;ontology;Darius;source files;discussion weather;program comprehension step		7		34		18 mar. 2013			IEEE	IEEE Conferences
A Comparison of Program Comprehension Strategies by Blind and Sighted Programmers	a comparison of program comprehension strategies by blind and sighted programmers	10.1109/TSE.2017.2729548	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7987041	A. Armaly; P. Rodeghero; C. McMillan	Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN	IEEE Transactions on Software Engineering	13 Aug 2018	2018	44	8	712	724	Programmers who are blind use a screen reader to speak source code one word at a time, as though the code were text. This process of reading is in stark contrast to sighted programmers, who skim source code rapidly with their eyes. At present, it is not known whether the difference in these processes has effects on the program comprehension gained from reading code. These effects are important because they could reduce both the usefulness of accessibility tools and the generalizability of software engineering studies to persons with low vision. In this paper, we present an empirical study comparing the program comprehension of blind and sighted programmers. We found that both blind and sighted programmers prioritize reading method signatures over other areas of code. Both groups obtained an equal and high degree of comprehension, despite the different reading processes.	1939-3520		National Science Foundation Graduate Research Fellowship Program(grant numbers:DGE-1313583); US National Science Foundation(grant numbers:CCF-1452959,CNS-1510329); 	Program comprehension;accessibility technology;blindness	Tools;Software;Blindness;Navigation;Programming profession;Software engineering	programming environments;public domain software;software prototyping;source code (software)	source code;sighted programmers;program comprehension strategies;reading processes;stark;program comprehension;reading method signature		6		46	IEEE	20 jul. 2017			IEEE	IEEE Journals
Tasks that can improve novices' program comprehension	tasks that can improve novices program comprehension	10.1109/IC3e.2015.7403482	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7403482	A. Shargabi; S. A. Aljunid; M. Annamalai; S. M. Shuhidan; A. M. Zin	Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Information Science and Technology, Universiti Kebangsaan Malaysia, Bangi, Malaysia	2015 IEEE Conference on e-Learning, e-Management and e-Services (IC3e)	11 Feb 2016	2015			32	37	This study aims at identifying tasks that can effectively promote novices' program comprehension. Based on literature of program comprehension and computer science education, we identified 14 tasks and classified them into homogeneous categories based on the Revised Bloom Taxonomy. We conducted a survey to rank these tasks within each Bloom category based on their potential effectiveness in developing the novices' program comprehension. The survey respondents were 154 programming and software engineering instructors from 13 universities. The results of the survey indicated that: a) for the remember category, recall received higher ranking than line documentation; b) for the understand category, representation received higher ranking than summarization; c) for the analyze category, the tasks ordered from the highest to the lowest rank are: tracing, debugging, search and reordering; d) for the create category, the tasks ordered from the highest to the lowest rank are: modification, extension, reuse and restructuring. The apply and evaluate categories contain one task each; and thus were not ranked. The outcomes indicated that tasks that were more commonly applied in teaching were received higher rankings. For example, tracing and representation received higher ranking as compared to other less common teaching tasks such as summarization and searching respectively. The findings of this study recommend that program comprehension skills can be improved through exercises on the different types of tasks identified in this survey. The next step is to conduct experiments of these novices in universities to validate the results of the conducted survey.		978-1-4673-9437-6		program comprehension;task;novices;Revised Bloom taxonomy	Taxonomy;Documentation;Debugging;Programming;Conferences;Electronic learning	computer science education;software engineering	novices program comprehension;program comprehension;computer science education;revised bloom taxonomy;software engineering instructors;remember category;line category;understand category;tracing;debugging;search;reordering;modification;extension;reuse;restructuring		6		36		11 Feb 2016			IEEE	IEEE Conferences
Program Comprehension and Code Complexity Metrics: An fMRI Study	program comprehension and code complexity metrics an fmri study	10.1109/ICSE43902.2021.00056	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9402005	N. Peitek; S. Apel; C. Parnin; A. Brechmann; J. Siegmund	Leibniz Institute for Neurobiology, Magdeburg, Germany; Saarland Informatics Campus, Saarland University, Saarbrücken, Germany; NC State University, Raleigh, North Carolina, USA; Leibniz Institute for Neurobiology, Magdeburg, Germany; Chemnitz University of Technology, Chemnitz, Germany	2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)	7 May 2021	2021			524	536	Background: Researchers and practitioners have been using code complexity metrics for decades to predict how developers comprehend a program. While it is plausible and tempting to use code metrics for this purpose, their validity is debated, since they rely on simple code properties and rarely consider particularities of human cognition. Aims: We investigate whether and how code complexity metrics reflect difficulty of program comprehension. Method: We have conducted a functional magnetic resonance imaging (fMRI) study with 19 participants observing program comprehension of short code snippets at varying complexity levels. We dissected four classes of code complexity metrics and their relationship to neuronal, behavioral, and subjective correlates of program comprehension, overall analyzing more than 41 metrics. Results: While our data corroborate that complexity metrics can-to a limited degree-explain programmers' cognition in program comprehension, fMRI allowed us to gain insights into why some code properties are difficult to process. In particular, a code's textual size drives programmers' attention, and vocabulary size burdens programmers' working memory. Conclusion: Our results provide neuro-scientific evidence supporting warnings of prior research questioning the validity of code complexity metrics and pin down factors relevant to program comprehension. Future Work: We outline several follow-up experiments investigating fine-grained effects of code complexity and describe possible refinements to code complexity metrics.	1558-1225	978-1-6654-0296-5	National Science Foundation; 	program comprehension;code complexity metrics;cognitive load;functional magnetic resonance imaging	Measurement;Vocabulary;Correlation;Functional magnetic resonance imaging;Cognition;Complexity theory;Time factors	biomedical MRI;brain;cognition;medical image processing;neurophysiology;software metrics	program comprehension;code complexity metrics;code metrics		5		83		7 May 2021			IEEE	IEEE Conferences
A case study of program comprehension effort and technical debt estimations	a case study of program comprehension effort and technical debt estimations	10.1109/ICPC.2016.7503710	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7503710	V. Singh; L. L. Pollock; W. Snipes; N. A. Kraft	University of Delaware, Newark, DE, USA; University of Delaware, Newark, DE, USA; ABB Corporate Research, Raleigh, NC, USA; ABB Corporate Research, Raleigh, NC, USA	2016 IEEE 24th International Conference on Program Comprehension (ICPC)	7 jul. 2016	2016			1	9	This paper describes a case study of using developer activity logs as indicators of a program comprehension effort by analyzing temporal sequences of developer actions (e.g., navigation and edit actions). We analyze developer activity data spanning 109,065 events and 69 hours of work on a medium-sized industrial application. We examine potential correlations between different measures of developer activity, code change metrics and code smells to gain insight into questions that could direct future technical debt interest estimation. To gain more insights into the data, we follow our analysis with commit message analysis and a developer interview. Our results indicate that developer activity as an estimate of program comprehension effort is correlated with both change proneness and static metrics for code smells.		978-1-5090-1428-6		program comprehension effort;technical debt interest;developer activity logging;code smells	Measurement;Couplings;Navigation;Software;Maintenance engineering;Correlation;History	program diagnostics;software metrics;source code (software)	developer activity logs;program comprehension effort;temporal sequence analysis;developer activity data analysis;medium-sized industrial application;code change metrics;code smells;technical debt interest estimation;commit message analysis;change proneness;static metrics		5		24		7 jul. 2016			IEEE	IEEE Conferences
CodersMUSE: Multi-Modal Data Exploration of Program-Comprehension Experiments	codersmuse multimodal data exploration of programcomprehension experiments	10.1109/ICPC.2019.00027	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813268	N. Peitek; S. Apel; A. Brechmann; C. Parnin; J. Siegmund	Leibniz Institute for Neurobiology, Magdeburg, Germany; University of Passau, Passau, Germany; Leibniz Institute for Neurobiology, Magdeburg, Germany; NC State University, Raleigh, North Carolina, USA; University of Passau, Passau, Germany	2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC)	29 Aug 2019	2019			126	129	Program comprehension is a central cognitive process in programming. It has been in the focus of researchers for decades, but is still not thoroughly unraveled. Multi-modal psycho-physiological and neurobiological measurement methods have proved successful to gain a more holistic understanding of program comprehension. However, there is no proper tool support that lets researchers explore synchronized, conjoint multi-modal data, specifically designed for the needs in program-comprehension research. In this paper, we present CodersMUSE, a prototype implementation that aims to satisfy this crucial need.	2643-7171	978-1-7281-1519-1		program comprehension, data exploration, functional magnetic resonance imaging		cognition;data analysis;neurophysiology;reverse engineering;source code (software)	CodersMUSE;multimodal data exploration;program-comprehension experiments;central cognitive process;neurobiological measurement methods;multimodal psycho-physiological measurement methods		4		16		29 Aug 2019			IEEE	IEEE Conferences
SMARTKT: A Search Framework to Assist Program Comprehension using Smart Knowledge Transfer	smartkt a search framework to assist program comprehension using smart knowledge transfer	10.1109/QRS.2019.00026	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8854703	S. Majumdar; S. Papdeja; P. P. Das; S. K. Ghosh	Advanced Technology Development Centre, Indian Institute of Technology, Kharagpur; Department of Computer Science and Engineering, Indian Institute of Technology, Kharagpur; Department of Computer Science and Engineering, Indian Institute of Technology, Kharagpur; Department of Computer Science and Engineering, Indian Institute of Technology, Kharagpur	2019 IEEE 19th International Conference on Software Quality, Reliability and Security (QRS)	3 Oct 2019	2019			97	108	Regardless of attempts to extract knowledge from code bases to aid in program comprehension, there is an absence of a framework to extract and integrate knowledge to provide a near-complete multifaceted understanding of a program. To bridge this gap, we propose SMARTKT (Smart Knowledge Transfer) to extract and transfer knowledge related to software development and application-specific characteristics and their interrelationships in form of a knowledge graph. For an application, the knowledge graph provides an overall understanding of the design and implementation and can be used by an intelligent natural language query system to convert the process of knowledge transfer into a developer-friendly Google-like search. For validation, we develop an analyzer to discover concurrency-related design aspects from runtime traces in a machine learning framework and obtain a precision and recall of around 97% and 95% respectively. We extract application-specific knowledge from code comments and obtain 72% match against human-annotated ground truth.		978-1-7281-3927-2		Knowledge Transfer, Program Comprehension, Knowledge Graph, Machine Learning, Natural Language Processing	Software;Runtime;Knowledge transfer;Instruments;Reliability;Data mining;Computer bugs	learning (artificial intelligence);ontologies (artificial intelligence);query processing;software maintenance	Smart Knowledge Transfer;application-specific characteristics;knowledge graph;intelligent natural language query system;developer-friendly Google-like search;concurrency-related design aspects;machine learning framework;application-specific knowledge;SMARTKT;search framework;near-complete multifaceted understanding;program comprehension;software development		4		80		3 Oct 2019			IEEE	IEEE Conferences
Supporting Program Comprehension in Agile with Links to User Stories	supporting program comprehension in agile with links to user stories	10.1109/AGILE.2009.66	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5261112	S. Ratanotayanon; S. E. Sim; R. Gallardo-Valencia	Department of Informatics, University of California, Irvine, USA; Department of Informatics, University of California, Irvine, USA; Department of Informatics, University of California, Irvine, USA	2009 Agile Conference	25 Sep 2009	2009			26	32	Agile software development involves continuously making iterative and incremental changes to source code. When making changes, developers quickly focus on parts of code that they consider to be important, and sometimes miss other relevant parts. Therefore, tool support is needed to help developers locate conceptually related sections of code. In this paper, we present Zelda, a tool designed to work with Agile practices that captures and maintains links between high-level information and source code. We evaluated Zelda with a pilot study where subjects were required to make a change to a small web application (10 KLOCs). They were given a task description either on paper or in Zelda. We found that the Zelda Group made more accurate changes, were less likely to become disoriented, and were more willing to access additional information.		978-0-7695-3768-9		user stories;program comprehension;link evolution;traceability links	Testing;Informatics;Programming;Light scattering;Java;Visualization;Software architecture;Software tools;Cognitive science;Writing	software tools	program comprehension;user stories;agile software development;Zelda;Web application		4		23		25 Sep 2009			IEEE	IEEE Conferences
Program comprehension with four-layered mental model	program comprehension with fourlayered mental model	10.1109/EMES.2015.7158420	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7158420	M. Nosál'; J. Porubän	Department of Computers and Informatics, Technical University of Košice, Košice, Slovakia; Department of Computers and Informatics, Technical University of Košice, Košice, Slovakia	2015 13th International Conference on Engineering of Modern Electric Systems (EMES)	16 jul. 2015	2015			1	4	Program comprehension deals with an important problem of recreating mental model of the software system from the source code. This process is needed every time a new programmer joins the development team, or the old one forgets about the code. We designed the four-layered model of the developer's mental model that provides a deeper understanding of the mental model and of the program comprehension in general. The described model was verified by an observatory study with 3 subjects. This paper concludes with our findings and conclusions.		978-1-4799-7650-8		Program comprehension;comprehension model;mental model;study	Cognitive science;Object oriented modeling;Computational modeling;Computers;Java;Software systems;Programming	reverse engineering;software engineering	program comprehension;four-layered mental model;software system mental model;source code;developer mental model		4		10		16 jul. 2015			IEEE	IEEE Conferences
Two User Perspectives in Program Comprehension: End Users and Developer Users	two user perspectives in program comprehension end users and developer users	10.1109/ICPC.2015.22	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181440	T. Roehm	Technische Universität München Munich, Germany	2015 IEEE 23rd International Conference on Program Comprehension	7 Sep 2015	2015			129	139	Recent empirical studies identified an interest of software developers in high-level usage information, i.e. Why and how end users employ a software application. Furthermore, recent empirical work found that developers of interactive applications put themselves in the role of users by interacting with the user interface during program comprehension. This paper presents an exploratory case study investigating these two user perspectives in detail. The study focuses on information needs regarding software usage and developers in the role of users during program comprehension. 21 developers from six software companies were observed during program comprehension tasks and interviewed. The resulting observation protocols and interview minutes were analyzed using coding. We found that developers are interested in information about use cases and user behavior, user goals and user needs, failure reproduction steps, and application domain concepts. But such information is rarely available to them during program comprehension. This mismatch indicates a potential to improve program comprehension practices by capturing such information and providing it to developers. Furthermore, we found that developers interact with the user interface of an interactive application to reproduce failures, to find relevant source code, to test changes, to trigger the debugger, and to familiarize with an unknown part of the application. Also, developers conceptually map elements of the user interface to source code, data structures, and algorithms. We call this behavior "UI-based comprehension" and argue that it is part of a broader comprehension strategy together with comprehension activities like reading source code or debugging.	1092-8138	978-1-4673-8159-8		program comprehension;information needs;software usage;comprehension strategy;user interface (UI) comprehension;empirical study;case study;software maintenance;software evolution	Software;Interviews;Companies;User interfaces;Protocols;Observers;Java	data structures;program debugging;software engineering;source code (software);user interfaces	program comprehension;end users;developer users;software developers;user interface;coding;source code;data structures;debugging		4		29		7 Sep 2015			IEEE	IEEE Conferences
Synchronized Analysis of Eye Movement and EEG during Program Comprehension	synchronized analysis of eye movement and eeg during program comprehension	10.1109/EMIP.2019.00012	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8834699	T. Ishida; H. Uwano	dept. Advanced Information Engineering, National Institute of Technology, Nara College, Nara, Japan; dept. Information Engineering, National Institute of Technology, Nara College, Nara, Japan	2019 IEEE/ACM 6th International Workshop on Eye Movements in Programming (EMIP)	12 Sep 2019	2019			26	32	Appropriate support for program comprehension contributes to efficient software development. Several previous studies used bio-information such as brain activity to classify the inner-state of programmer without interruption. In this paper, we measure programmer's brain waves and eye movement simultaneously while they comprehend the source code. In the experiment, we analyze difference of time-series brain wave features between success/failure for source code comprehension task. The result of the experiment showed the participants who success source code comprehension significantly increased power spectrum of α wave with the time passage. Also the eye movements of the succeed participants shift their focus of fixation from specification to source code in early time. Synchronized analysis of failed programmer shows similar but slow pattern of EEG and eye movement changes compared with succeed programmer.		978-1-7281-2243-4		EEG, Eye movement, Synchronized analysis, Program comprehension	Electroencephalography;Task analysis;Electrodes;Synchronization;Atmospheric measurements;Particle measurements;Tools	bioelectric potentials;biomechanics;electroencephalography;eye;medical signal processing;neurophysiology;source coding	software development efficiency;EEG analysis;programmer's brain wave measurement;programmer's eye movement measurement;α wave;source code comprehension task;time-series brain wave features;bio-information;synchronized analysis		4		20		12 Sep 2019			IEEE	IEEE Conferences
Integrative Levels of Program Comprehension	integrative levels of program comprehension	10.1109/WCRE.2008.57	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656404	R. Schauer; R. K. Keller	Université de Montreal, Montreal, Canada; Université de Montreal, Canada	2008 15th Working Conference on Reverse Engineering	24 Oct 2008	2008			145	154	Integrative levels of program comprehension describe the evolution of our knowledge about a program from low-level program elements through successive and higher orders of knowledge integration. In this paper, we motivate, define, and illustrate integrative levels as a technique to organize the knowledge that we acquire in the course of program maintenance. We differentiate between understanding in extension and understanding in intension. We define five intensional integrative levels of program comprehension, the element level, the percept level, the concept level, the subject level, and the domain level. The intensional units that make up these levels emerge and evolve in an iterative comprehension process that is active at each level. The iterations of this process comprise the four phases of lower level unit organization, unit integration, upper level unit organization, and unit validation. We demonstrate integrative levels of program comprehension using the object-oriented testing framework jUnit as a case study.	2375-5369	978-0-7695-3429-9		Intensional Program Comprehension;Integrative Levels	Organizations;Maintenance engineering;Psychology;Humans;Aggregates;Assembly;Graphics	knowledge acquisition;software engineering	program comprehension;integrative levels;knowledge integration;iterative comprehension process;object-oriented testing framework		4		19		24 Oct 2008			IEEE	IEEE Conferences
A Multiple View Interactive Environment to Support MATLAB and GNU/Octave Program Comprehension	a multiple view interactive environment to support matlab and gnu/octave program comprehension	10.1109/ITNG.2015.93	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7113531	I. d. M. Lessa; G. d. F. Carneiro; M. J. T. P. Monteiro; F. Brito E Abreu	Universidade Salvador, Salvador, BA, BR; Universidade Salvador, Salvador, BA, BR; New University of Lisbon (UNL), Lisbon, Portugal; Lisbon Univ. Inst. (ISCTE-IUL), Portugal	2015 12th International Conference on Information Technology - New Generations	1 jun. 2015	2015			552	557	Program comprehension plays an important role in Software Engineering. In fact, many of the software lifecycle activities depend on program comprehension. Despite the importance of MATLAB and Octave programing languages in the Engineering and Statistical communities, little attention has been paid to the conception, implementation and characterization of tools and techniques for the comprehension of programs written in these languages. Considering this scenario, this paper presents a Multiple View Interactive Environment (MVIE) called Oct Miner that supports the comprehension of programs developed in the aforementioned languages. Oct Miner provides a set of coordinated visual metaphors that can be adjusted in accordance with the comprehension goals. An example is presented to illustrate the main functionalities of Oct Miner in a real scenario of program comprehension.		978-1-4799-8828-0		Program Comprehension;Software Visualization;MATLAB;Octave;Crosscutting Concerns	MATLAB;Visualization;Mathematical model;Image color analysis;Computer languages;Shape	interactive programming;mathematics computing;program visualisation;programming languages;software maintenance;Unix	software visualization;OctMiner;coordinated visual metaphors;MVIE;statistical communities;engineering communities;Octave programing languages;software lifecycle activities;software engineering;Octave program comprehension;GNU program comprehension;MATLAB;multiple view interactive environment		3		15		1 jun. 2015			IEEE	IEEE Conferences
#ifdef Directives and Program Comprehension: The Dilemma between Correctness and Preference	#ifdef directives and program comprehension the dilemma between correctness and preference	10.1109/ICSME46990.2020.00033	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9240651	W. Fenske; J. Krüger; M. Kanyshkova; S. Schulze	pure-systems GmbH, Magdeburg, Germany; Otto-von-Guericke University Magdeburg, Magdeburg, Germany; Otto-von-Guericke University Magdeburg, Magdeburg, Germany; Otto-von-Guericke University Magdeburg, Magdeburg, Germany	2020 IEEE International Conference on Software Maintenance and Evolution (ICSME)	2 nov. 2020	2020			255	266	Many organizations and open-source projects use the C preprocessor (CPP) to implement configurability in their software systems. Despite extensive research, existing studies on the effects of CPP use on program comprehension are still limited to experiences, opinions, and empirical studies with narrow scopes. So, it is unclear whether the CPP actually leads to what is sometimes referred to as "#ifdef hell." In this paper, we expand the existing evidence on program comprehension in the presence of CPP directives, but we also highlight a surprising dilemma. We conducted an empirical study, including an experiment and a questionnaire, on the impact of refactoring CPP directives with 521 experienced software developers. The results indicate that, in contrast to previous findings, comprehension performance slightly worsened in terms of correctness when our participants worked on code with refactored CPP directives. However, in alignment with previous findings, they preferred the refactored code, considering it more comprehensible and easier to work with. This dilemma of objective performance versus subjective preference is a surprising outcome that has not been found before. We argue that our work motivates the need for more studies to understand this dilemma-which may significantly impact common beliefs in research and practice.	2576-3148	978-1-7281-5619-4		Configurable Systems;Preprocessors;Program Comprehension;Refactoring;Empirical Study	Software maintenance;Organizations;Programming;Software systems;Particle measurements;Task analysis;Open source software	public domain software;software maintenance	program comprehension;organizations;open-source projects;software systems;software developers;refactored CPP directives;#ifdef directives		3		41		2 nov. 2020			IEEE	IEEE Conferences
Ontology-based Program Comprehension Tool Supporting Website Architectural Evolution	ontologybased program comprehension tool supporting website architectural evolution	10.1109/WSE.2006.15	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4027205	Y. Zhang; R. Witte; J. Rilling; V. Haarslev	Department of Computer Science and Software Engineering, Concordia University, Montreal, QUE, Canada; Institute for Program Structures and Data Organization (IPD), Universität Karlsruhe, Germany; Department of Computer Science and Software Engineering, Concordia University, Montreal, QUE, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, QUE, Canada	2006 Eighth IEEE International Symposium on Web Site Evolution (WSE'06)	11 Dec 2006	2006			41	49	A challenge of existing program comprehension approaches is to provide consistent and flexible representations for software systems. Maintainers have to match their mental models with the different representations these tools provide. In this paper, we present a novel approach that addresses this issue by providing a consistent ontological representation for both source code and documentation. The ontological representation unifies information from various sources, and therefore reduces the maintainers' comprehension efforts. In addition, representing software artifacts in a formal ontology enables maintainers to formulate hypotheses about various properties of software systems. These hypotheses can be validated through an iterative exploration of information derived by our ontology inference engine. The implementation of our approach is presented in detail, and a case study is provided to demonstrate the applicability of our approach during the architectural evolution of a Web site content management system	1550-4441	0-7695-2696-9		Program Comprehension;Software Evolution;Ontology;Automated Reasoning	Ontologies;Cognitive science;Software systems;Software maintenance;Documentation;Software tools;Content management;Computer science;Software engineering;Engines	inference mechanisms;Internet;ontologies (artificial intelligence);reverse engineering;software architecture;software prototyping;Web sites	ontology-based program comprehension;Web site architectural evolution;ontological representation;software artifacts;formal ontology;iterative exploration;ontology inference engine;Web site content management system;software evolution;automated reasoning		3		23		11 Dec 2006			IEEE	IEEE Conferences
Automatic Hierarchical Clustering of Static Call Graphs for Program Comprehension	automatic hierarchical clustering of static call graphs for program comprehension	10.1109/BigData.2018.8622426	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8622426	G. Gharibi; R. Alanazi; Y. Lee	School of Computing and Enigeering, University of Missouri-Kansas City, Kansas City, USA; School of Computing and Enigeering, University of Missouri-Kansas City, Kansas City, USA; School of Computing and Enigeering, University of Missouri-Kansas City, Kansas City, USA	2018 IEEE International Conference on Big Data (Big Data)	24 jan. 2019	2018			4016	4025	Program comprehension is an imperative and indispensable prerequisite for several software tasks, including testing, maintenance, and evolution. In practice, understanding the software system requires investigating the high-level system functionality and mapping it to its low-level implementation, i. e. source code. The implementation of a software system can be captured using a call graph. A call graph represents the system's functions and their interactions at a single level of granularity. While call graphs can facilitate understanding the inner system functionality, developers are still required to manually map the high-level system functionality to its call graph. This manual mapping process is expensive, time-consuming and creates a cognitive gap between the system's highly-level functionality and its implementation. In this paper, we present an innovative approach that can automatically (1) construct and visualize the static call graph for a system written in Python, (2) cluster the execution paths of the call graph into hierarchal abstractions, and (3) label the clusters according to their major functional behaviors. The goal is to bridge the cognitive gap between the high-level system functionality and its call graph, which can further facilitate system comprehension. To validate our approach, we conducted four case studies including code2graph, Detectron, Flask, and Keras. The results demonstrated that our approach is feasible to construct call graphs and hierarchically cluster them into abstraction levels with proper labels.		978-1-5386-5035-6		static call graph;static analysis;clustering;topic modeling;program comprehension;Python	Tools;Python;Software systems;Task analysis;Visualization;Maintenance engineering	medical computing;pattern clustering;software maintenance	automatic hierarchical clustering;static call graph;program comprehension;software system;high-level system functionality;low-level implementation;call graphs;inner system functionality;system comprehension;code2graph		3		41		24 jan. 2019			IEEE	IEEE Conferences
Semantic-based extraction approach for generating source code summary towards program comprehension	semanticbased extraction approach for generating source code summary towards program comprehension	10.1109/MySEC.2015.7475208	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7475208	R. Kadar; S. M. Syed-Mohamad; N. Abdul Rashid	School of Computer Sciences, Universiti Sains Malaysia, Penang, MALAYSIA; School of Computer Sciences, Universiti Sains Malaysia, Penang, MALAYSIA; School of Computer Sciences, Universiti Sains Malaysia, Penang, MALAYSIA	2015 9th Malaysian Software Engineering Conference (MySEC)	23 May 2016	2015			129	134	Program comprehension is a vital process that involves much effort in software maintenance. A key challenge for the developers is to comprehend a software system to be maintained since it is difficult and time consuming. Nowadays, software systems have grown in size causing the increased of developers' tasks in exploring and understanding source code. Source code is a crucial resource for developers to become familiar with a software system since some system documentation is often unavailable or outdated. Although many researchers have discussed different strategies and techniques to overcome the program comprehension problem, there are still many challenges that they have not yet discovered when trying to understand a software system through reading source code. Therefore, this study attempts to overcome the problem of source code comprehension by suggesting a suitable comprehension technique. We propose a semantic-based extraction approach of source code and generating it as a summary. This work aims to explain the concepts and relationships of program by integrating utilization of ontology and UML class-based modeling approaches. It will be easier for maintainer to understand source code as well as create a better way for improving program comprehension.		978-1-4673-8227-4		program comprehension;information extraction;semantic relationship;graphical representation;visualization	Unified modeling language;Ontologies;Semantics;Software systems;Natural languages;Java;Object oriented modeling	ontologies (artificial intelligence);software maintenance;source code (software);Unified Modeling Language	UML class-based modeling;ontology;software systems;software maintenance;program comprehension;source code summary;semantic-based extraction		2	1	26		23 May 2016			IEEE	IEEE Conferences
Program comprehension levels of abstraction for novices	program comprehension levels of abstraction for novices	10.1109/I4CT.2015.7219568	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7219568	A. Shargabi; S. A. Aljunid; M. Annamalai; S. Mohamed Shuhidan; A. Mohd Zin	Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Information Science and Technology, Universiti Kebangsaan Malaysia, Bangi, Malaysia	2015 International Conference on Computer, Communications, and Control Technology (I4CT)	27 Aug 2015	2015			211	215	Although various program comprehension models exist, their levels of abstraction and the related terminologies do not fit the programming pedagogy perspective. In this study, we proposed five abstraction levels for novice's program comprehension: statement, block, module, program and domain. The expansion and the terminologies of the proposed abstraction levels are inspired by the application of decomposition concept in programming pedagogy. To comprehend a program, novices understand decomposed parts (i.e. statements, blocks, and modules) of that program and chunk those parts into a meaningful whole (i.e. program) within a specific domain. We supported our revised abstraction levels with a user study. The revised abstraction levels are able to describe hierarchical levels of novices' program comprehension that map appropriately with their mental model. The proposed abstraction levels can be applied in designing empirical studies of novices' program comprehension that distinctly capture their different abstraction levels.		978-1-4799-7952-3		program comprehension;mental model;abstraction level;novices;programming pedagogy	Error analysis;Adaptation models;Context;Education;Data models;Programming profession	computer science education;object-oriented methods	program comprehension levels;novice abstraction;program comprehension models;programming pedagogy perspective;novice program comprehension;decomposition concept		2		16		27 Aug 2015			IEEE	IEEE Conferences
Synchronized UML diagrams for object-oriented program comprehension	synchronized uml diagrams for objectoriented program comprehension	10.1109/ICCSE.2017.8085455	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8085455	J. Yang; Y. Lee; D. Gandhi; S. G. Valli	Dept. of Computing and Cyber Security, Texas A&M University-San Antonio, San Antonio, U.S.A.; Dept. of Electrical Engineering and Computer Science, Texas A&M University-Kingsville, Kingsville, U.S.A.; Dept. of Electrical Engineering and Computer Science, Texas A&M University-Kingsville, Kingsville, U.S.A.; Dept. of Electrical Engineering and Computer Science, Texas A&M University-Kingsville, Kingsville, U.S.A.	2017 12th International Conference on Computer Science and Education (ICCSE)	30 Oct 2017	2017			12	17	We propose a novel approach for visualizing reverse-engineered Unified Modeling Language (UML) diagrams (class, object, and sequence) to improve Object-Oriented Program (OOP) comprehension on a web-based programming environment, JaguarCode. It aims to help students better understand static structure and dynamic behavior of Java programs and object-oriented programming concepts. This paper presents an evaluation of JaguarCode, supporting those UML diagrams to investigate its effectiveness and user satisfaction. The results of the experimental study revealed having synchronized UML diagrams positively impacted students' understanding of program execution. It was also observed that students were satisfied with the aspects of the synchronized visualizations of UML diagrams with source code.	2473-9464	978-1-5090-2508-4		Program Comprehension;Object-Oriented Programming;UML Diagrams;Reverse Engineering	Java;Unified modeling language;Synchronization;Data visualization;Visualization;Programming;Runtime	computer science education;Internet;Java;object-oriented programming;program diagnostics;program visualisation;reverse engineering;Unified Modeling Language	synchronized UML diagrams;Java programs;program execution;synchronized visualizations;object-oriented program comprehension;reverse-engineered Unified Modeling Language diagram visualization;OOP comprehension;Web-based programming environment;static structure;dynamic behavior;JaguarCode evaluation;user satisfaction;source code		1		19	IEEE	30 Oct 2017			IEEE	IEEE Conferences
InputTracer: A Data-Flow Analysis Tool for Manual Program Comprehension of x86 Binaries	inputtracer a dataflow analysis tool for manual program comprehension of x86 binaries	10.1109/SCAM.2012.16	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6392112	U. Kargén; N. Shahmehri	Department of Computer and Information Science, Linköping University, Linkoping, Sweden; Department of Computer and Information Science, Linköping University, Linkoping, Sweden	2012 IEEE 12th International Working Conference on Source Code Analysis and Manipulation	24 Dec 2012	2012			138	143	Third-party security analysis of closed-source programs has become an important part of a defense-in-depth approach to software security for many companies. In the absence of efficient tools, the analysis has generally been performed through manual reverse engineering of the machine code. As reverse engineering is an extremely time-consuming and costly task, much research has been performed to develop more powerful methods for analysis of program binaries. One such popular method is dynamic taint analysis (DTA), which is a type of runtime data-flow analysis, where certain input data is marked as tainted. By tracking the flow of tainted data, DTA can, for instance, be used to determine which computations in a program are affected by a certain part of the input. In this paper we present Input Tracer, a tool that utilizes DTA for aiding in manual program comprehension and analysis of unmodified x86 executables running in Linux. A brief overview of dynamic taint analysis is given, followed by a description of the tool and its implementation. We also demonstrate the tool's ability to provide exact information on the origin of tainted data through a detailed use case, where the tool is used to find the root cause of a memory corruption bug.		978-0-7695-4783-1		dynamic taint analysis;binary analysis;x86;program comprehension;Valgrind	Computer crashes;Security;Manuals;Performance analysis;Runtime;Instruments;Software	data flow analysis;Linux;program compilers;reverse engineering;security of data	InputTracer;data flow analysis tool;manual program comprehension;x86 binaries;security analysis;closed source programs;software security;reverse engineering;machine code;dynamic taint analysis;DTA;program comprehension;program analysis;Linux;memory corruption bug		1	1	21		24 Dec 2012			IEEE	IEEE Conferences
Language-Independent Information Flow Tracking Engine for Program Comprehension Tools	languageindependent information flow tracking engine for program comprehension tools	10.1109/ICPC.2017.5	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961535	M. R. Azadmanesh; M. L. Van De Vanter; M. Hauswirth	Università della Svizzera italiana Lugano, Switzerland; Università della Svizzera italiana Lugano, Switzerland; Oracle Labs	2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC)	29 jun. 2017	2017			346	355	Program comprehension tools are often developed for a specific programming language. Developing such a tool from scratch requires significant effort. In this paper, we report on our experience developing a language-independent framework that enables the creation of program comprehension tools, specifically tools gathering insight from deep dynamic analysis, with little effort. Our framework is language independent, because it is built on top of Truffle, an open-source platform, developed in Oracle Labs, for implementing dynamic languages in the form of AST interpreters. Our framework supports the creation of a diverse variety of program comprehension techniques, such as query, program slicing, and back-in-time debugging, because it is centered around a powerful information-flow tracking engine. Tools developed with our framework get access to the information-flow through a program execution. While it is possible to develop similarly powerful tools without our framework, for example by tracking information-flow through bytecode instrumentation, our approach leads to information that is closer to source code constructs, thus more comprehensible by the user. To demonstrate the effectiveness of our framework, we applied it to two of Truffle-based languages namely Simple Language and TruffleRuby, and we distill our experience into guidelines for developers of other Truffle-based languages who want to develop program comprehension tools for their language.		978-1-5386-0535-6		Information flow;AST interpreter;Language-independent;Program comprehension;Tool;Dependency	Tools;Java;Runtime;Instruments;Program processors;Debugging;Libraries	program diagnostics;programming languages	language-independent information flow tracking engine;program comprehension tool;programming language;language-independent framework;deep dynamic analysis;Truffle open-source platform;Oracle Labs;AST interpreters;program execution;bytecode instrumentation;simple language;TruffleRuby		1		25		29 jun. 2017			IEEE	IEEE Conferences
Program Comprehension for User-Assisted Test Oracle Generation	program comprehension for userassisted test oracle generation	10.1109/ICSEA.2009.26	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5298488	T. Kanstren	VTT Technical Research Center of Finland, Oulu, Finland	2009 Fourth International Conference on Software Engineering Advances	30 Oct 2009	2009			118	127	Software testing requires a test oracle that makes an assessment of the correctness of the tested program behaviour, based on a priori created model. While test automation is a popular research topic, there is only a limited amount of work in the subject of automating the process of creating test oracles. This lack of test oracle automation greatly limits the usefulness of automated testing techniques. One reason for this is the difficulty to automatically determine the correctness of previously unknown software. Instead the task of coming up with a useful oracle is often left to the user as a manual task. Program comprehension techniques are focused on supporting the building of human understanding for a previously un-known program, and as such are good candidates to assist in the test oracle creation process. This paper addresses the lack of automated support for test oracle creation by providing a framework for using program comprehension techniques to provide automated assistance to the user in creating test oracles. Based on analysis of existing work and theoretical background, the basic concept for this process is defined. A case example demonstrates the practical application of this concept with the generation of a model, including a test oracle, for model-based testing. From the existing approaches and the presented case example, a framework for this type of process is presented in order to provide a basis for providing more powerful techniques for user-assisted test oracle generation.		978-1-4244-4779-4		test oracle;program comprehension;test automation	Automatic testing;Software testing;System testing;Humans;Software engineering;Electronic mail;Power generation;Design automation;Software tools;Costs	automatic test software;program testing	user-assisted test oracle generation;software testing;automated testing techniques;program comprehension techniques;model-based testing		1		29		30 Oct 2009			IEEE	IEEE Conferences
Towards a Fine-grained Analysis of Cognitive Load During Program Comprehension	towards a finegrained analysis of cognitive load during program comprehension	10.1109/SANER53432.2022.00092	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9825808	T. Sorg; A. Abbad-Andaloussi; B. Weber	Institute of Computer Science, University of St. Gallen, St. Gallen, Switzerland; Institute of Computer Science, University of St. Gallen, St. Gallen, Switzerland; Institute of Computer Science, University of St. Gallen, St. Gallen, Switzerland	2022 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)	21 jul. 2022	2022			748	752	Program comprehension is inherent to all software development activities. This task may require a high mental effort (or so-called “cognitive load”), which in turn can hinder the performance of developers. In the literature, several authors have investigated the ability of biosignals to estimate developers' cognitive load during program comprehension. While the majority of these studies provide estimates at the task level, we aim for a more fine-grained level of analysis allowing to pinpoint the critical parts of code that could be associated with cognitive load. We infer these critical parts solely from eye fixation features and investigate qualitatively their relationship with those perceived as challenging by users. Being able to pinpoint critical parts in the source-code, is a first stride towards a very handy approach providing targeted support to developers to prevent them from committing errors. Furthermore, such a lightweight approach can be adapted in online settings.	1534-5351	978-1-6654-3786-8		Program comprehension;Eye-tracking;Cognitive load;Fine-grained analysis	Codes;Conferences;Software;Task analysis	cognition;software maintenance;source code (software)	program comprehension;software development activities;high mental effort;task level;fine-grained analysis;developers cognitive load;source-code				22	IEEE	21 jul. 2022			IEEE	IEEE Conferences
A Neuro-Cognitive Perspective of Program Comprehension	a neurocognitive perspective of program comprehension		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449636	N. Peitek	Leibniz-Institut fur Neurobiologie, Magdeburg, Sachsen-Anhalt, DE	2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion)	30 Aug 2018	2018			496	499	Program comprehension is the cognitive process of understanding code. Researchers have proposed several models to describe program comprehension. However, because program comprehension is an internal process and difficult to measure, the accuracy of the existing models are limited. Neuro-imaging methods, such as functional magnetic resonance imaging (fMRI), provide a novel neuro-cognitive perspective to program-comprehension research. With my thesis work, we aim at establishing fMRI as a new tool for program-comprehension and software-engineering studies. Furthermore, we seek to refine our existing framework for conducting fMRI studies by extending it with eye tracking and improved control conditions. We describe how we will apply our upgraded framework to extend our understanding of program comprehension. In the long-run, we would like to contribute insights from our fMRI studies into software-engineering practices by providing code-styling guidelines and programming tools, which reduce the required cognitive effort to comprehend code.	2574-1934	978-1-4503-5663-3		program comprehension;top down comprehension;functional magnetic resonance imaging;eye tracking	Functional magnetic resonance imaging;Brain;Gaze tracking;Cognition;Task analysis;Tools;Electroencephalography	biomedical MRI;cognition;neurophysiology;software engineering	neuro-cognitive perspective;functional magnetic resonance imaging;fMRI;eye tracking;software-engineering practices;programming tools;code-styling guidelines;program-comprehension research						30 Aug 2018			IEEE	IEEE Conferences
Symbolic Reductionist Model for Program Comprehension	symbolic reductionist model for program comprehension	10.1109/MICAI.2007.7	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4659326	E. Laitila; S. Legrand	University of Jyväskylä, Finland; University of Jyväskylä, Finland	2007 Sixth Mexican International Conference on Artificial Intelligence, Special Session (MICAI)	28 Oct 2008	2007			363	372	This article presents the main features of a novel construction, symbolic analysis, for automatic source code processing. The method is superior to the known methods, because it uses a semiotic, interpretative approach. Its most important processes and characteristics are considered here. We describe symbolic information retrieval and the process of analysis in which it can be used in order to obtain pragmatic information. This, in turn, is useful in understanding a current Java program version when developing a new version.		978-0-7695-3124-3		symbolic analysis;program comprehension;reverse engineering	Object oriented modeling;Java;Reverse engineering;Object oriented programming;Information retrieval;Information analysis;Turing machines;Information systems;Unified modeling language;Artificial intelligence	configuration management;Java;object-oriented programming;program diagnostics;reverse engineering;symbol manipulation	symbolic reductionist model;program comprehension;symbolic analysis;automatic source code processing;semiotic-interpretative approach;symbolic information retrieval;pragmatic information;Java program				17		28 Oct 2008			IEEE	IEEE Conferences
Reverse Engineering UML Sequence Diagrams for Program Comprehension Activities	reverse engineering uml sequence diagrams for program comprehension activities	10.1109/CITISIA50690.2020.9371851	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9371851	H. Cheers; Y. Lin	School of Electrical Engineering & Computing, The University of Newcastle, Newcastle, Australia; School of Electrical Engineering & Computing, The University of Newcastle, Newcastle, Australia	2020 5th International Conference on Innovative Technologies in Intelligent Systems and Industrial Applications (CITISIA)	9 mar. 2021	2020			1	10	Program comprehension is a required activity for many software development and maintenance tasks. A common means of understanding software is though UML diagrams. UML diagrams model the design and implementation of an application, describing both its structure and behaviour. However with rapid software development life cycles, UML diagrams often become inconsistent with the implementation of an application. This limits their effectiveness in program comprehension activities. This paper presents a program analysis framework to reverse engineer sequence diagrams from application source code. Part of this framework is the ability to filter out irrelevant operations from a sequence diagram in order to simplify the representation of an application. This is achieved by identifying important data, and following its use in the application. The purpose of this framework is to aid in program comprehension activities by providing up to date representations of an application; while also enabling developers to identify the logical operation of a program without interference from irrelevant or supporting operations.		978-1-7281-9437-0		UML reverse engineering;program analysis;program comprehension;control flow	Unified modeling language;Reverse engineering;Interference;Maintenance engineering;Software;Task analysis;Intelligent systems	formal specification;object-oriented programming;program diagnostics;reverse engineering;software engineering;software maintenance;Unified Modeling Language	reverse engineering UML sequence diagrams;program comprehension activities;required activity;maintenance tasks;understanding software;UML diagrams model;rapid software development life cycles;program analysis framework;engineer sequence diagrams;application source code;sequence diagram				23		9 mar. 2021			IEEE	IEEE Conferences
Facilitating Scenario-Based Program Comprehension with Topic Models	facilitating scenariobased program comprehension with topic models	10.1109/APSEC.2017.78	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8305995	T. Wang; Y. Liu	School of Software Engineering, Tongji University, Shanghai, China; School of Software Engineering, Tongji University, Shanghai, China	2017 24th Asia-Pacific Software Engineering Conference (APSEC)	5 mar. 2018	2017			642	647	Researchers and practitioners have been seeking automatic and semi-automatic approaches to support program comprehension. However, not too much attention has been given to the discussion about program comprehension scenarios and further exploration based on scenarios. In this paper, we explored program comprehension from the perspective of developers, analyzed the demands of developers, refined two program comprehension scenarios (Program Users Scenario and Program Owners Scenario), and mainly researched on the latter. In the Program Users Scenario, where developers need help to quickly understand a program and be able to use it fast, we found that topic modeling provides a promising way to facilitate program comprehension. Using topic modeling, features and structures can be discovered automatically from textual software assets. We also developed JSEA, a tool that provides semi-automatic program comprehension assistance. JSEA utilizes essential information automatically generated from Java projects to construct a project overview and give developers search capability. Experiments with 12 volunteers on two open source Java projects suggest that JSEA can support Java developers in comprehending programs in the Program Users Scenario.		978-1-5386-3681-7		Mining software assets;Java program comprehension;Topic models	Java;Tools;Analytical models;Maintenance engineering;Task analysis;Software maintenance	Java;public domain software;reverse engineering;software maintenance	scenario-based program comprehension;program user scenario;program owner scenario;textual software assets;JSEA tool;open source Java projects;semiautomatic program comprehension assistance;topic modeling				22		5 mar. 2018			IEEE	IEEE Conferences
Program Comprehension and Implications of Human Navigational Approaches	program comprehension and implications of human navigational approaches	10.1109/ICSEng.2011.41	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6041560	S. Moorthy; M. H. Samadzadeh	Computer Science Department, Oklahoma State University, Stillwater, OK, USA; Computer Science Department, Oklahoma State University, Stillwater, OK, USA	2011 21st International Conference on Systems Engineering	13 Oct 2011	2011			189	193	Cognitive scientists, psychologists, and other researchers have endeavored over the past three decades to identify the cognitive functions underpinning human navigation and its possible correlations with other characteristics. The answer to the basic question of how/why some people are good at following directions and some people are not, is yet to be determined conclusively. The scope of this research work included both theoretical and empirical studies of human direction sensitivity and the cognitive tests that attempt to test hypotheses about individual differences in spatial/temporal attention spans as well as a set of program comprehension questionnaire-based tests about the debugging/testing of computer programs and program comprehension. This work was done in the context of the relevant cognitive-based perceptual and spatial tests. The test results obtained suggest that programmers' directional detection skills appear to have some correlations with their program comprehension abilities.		978-1-4577-1078-0		navigation;program comprehension;perceptual and spatial tests	Navigation;Visualization;Humans;Correlation;Educational institutions;Particle measurements;Atmospheric measurements	cognition;navigation;program debugging;program testing;psychology	program comprehension;human navigational approach;human cognitive function;human direction sensitivity;cognitive test;spatial-temporal attention span;computer program debugging;computer program testing;cognitive-based perceptual test;cognitive-based spatial test;programmer directional detection skills				17		13 Oct 2011			IEEE	IEEE Conferences
Hierarchical Abstraction of Execution Traces for Program Comprehension	hierarchical abstraction of execution traces for program comprehension		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8973063	Y. Feng; K. Dreef; J. Jones; A. van Deursen	University of California, Irvine, Irvine, CA, USA; University of California, Irvine, Irvine, CA, USA; University of California, Irvine, Irvine, CA, USA; Delft University of Technology, Delft, Netherlands	2018 IEEE/ACM 26th International Conference on Program Comprehension (ICPC)	30 jan. 2020	2018			86	8610	Understanding the dynamic behavior of a software system is one of the most important and time-consuming tasks for today's software maintainers. In practice, understanding the inner workings of software requires studying the source code and documentation and inserting logging code in order to map high-level descriptions of the program behavior with low-level implementation, i.e., the source code. Unfortunately, for large codebases and large log files, such cognitive mapping can be quite challenging. To bridge the cognitive gap between the source code and detailed models of program behavior, we propose a fully automatic approach to present a semantic abstraction with different levels of functional granularity from full execution traces. Our approach builds multi-level abstractions and identifies frequent behaviors at each level based on a number of execution traces, and then, it labels phases within individual execution traces according to the identified major functional behaviors of the system. To validate our approach, we conducted a case study on a large-scale subject program, Javac, to demonstrate the effectiveness of the mining result. Furthermore, the results of a user study demonstrate that our approach is capable of presenting users a high-level comprehensible abstraction of execution behavior. Based on a real world subject program the participants in our user study were able to achieve a mean accuracy of 70%.	2643-7171	978-1-4503-5714-2		Dynamic Analysis;Execution trace understanding;Program comprehension;multi level abstraction		software maintenance;source code (software);system monitoring	source code;program behavior;semantic abstraction;execution traces;multilevel abstractions;large-scale subject program;high-level comprehensible abstraction;execution behavior;hierarchical abstraction;program comprehension;dynamic behavior;software maintainers;logging code;log files;cognitive mapping;Javac				42		30 jan. 2020			IEEE	IEEE Conferences
The impact of tools supported in integrated-development environments on program comprehension	the impact of tools supported in integrateddevelopment environments on program comprehension		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5974091	T. Kosar; M. Mernik; J. C. Carver	Faculty of Electrical Engineering and Computer Science, University of Maribor, Maribor, Slovenia; Faculty of Electrical Engineering and Computer Science, University of Maribor, Maribor, Slovenia; Department of Computer Science, University of Alabama, Tuscaloosa, AL, USA	Proceedings of the ITI 2011, 33rd International Conference on Information Technology Interfaces	4 Aug 2011	2011			603	608	Program comprehension is a cognitive task done by a software programmer. Task is usually done manually, but in some cases tool support inside integrated development environment can facilitate the hard work. In order to test those tools, a study between manual program comprehension and program comprehension with tool support is presented in this paper. An empirical study that faces the alternatives has been done. In experiment, the same test has been used twice (with and without tools) and results have been compared and statistically analyzed in terms of test correctness and efficiency. The results regarding program comprehension with students confirm significant benefits in terms of correctness when using tools for program comprehension.	1330-1012	978-1-61284-897-6		program comprehension tools;integrated-development environments;controlled experiments	Manuals;Programming;Visualization;Atmospheric measurements;Software;Particle measurements	human factors;reverse engineering;software engineering	integrated-development environments;program comprehension tools;cognitive task				11		4 Aug 2011			IEEE	IEEE Conferences
Overcoming Language Dichotomies: Toward Effective Program Comprehension for Mobile App Development	overcoming language dichotomies toward effective program comprehension for mobile app development		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8973034	K. Moran; C. Bernal-Cárdenas; M. Linares-Vásquez; D. Poshyvanyk	College of William & Mary; College of William & Mary; Universidad de los Andes; College of William & Mary	2018 IEEE/ACM 26th International Conference on Program Comprehension (ICPC)	30 jan. 2020	2018			7	711	Mobile devices and platforms have become an established target for modern software developers due to performant hardware and a large and growing user base numbering in the billions. Despite their popularity, the software development process for mobile apps comes with a set of unique, domain-specific challenges rooted in program comprehension. Many of these challenges stem from developer difficulties in reasoning about different representations of a program, a phenomenon we define as a "language dichotomy". In this paper, we reflect upon the various language dichotomies that contribute to open problems in program comprehension and development for mobile apps. Furthermore, to help guide the research community towards effective solutions for these problems, we provide a roadmap of directions for future work.	2643-7171	978-1-4503-5714-2		Program Comprehension;Mobile;Android;Natural Language;Code		mobile computing;natural languages;software engineering	user base numbering;software development process;mobile apps;language dichotomy;program comprehension;mobile app development;modern software developers;language dichotomies				132		30 jan. 2020			IEEE	IEEE Conferences
User evaluation of a domain specific program comprehension tool	user evaluation of a domain specific program comprehension tool	10.1109/USER.2012.6226583	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6226583	L. Moonen	Simula Research Laboratory, Lysaker, Norway	2012 First International Workshop on User Evaluation for Software Engineering Researchers (USER)	28 jun. 2012	2012			45	48	The user evaluation in this paper concerns a domain-specific tool to support the comprehension of large safety-critical component-based software systems for the maritime sector. We discuss the context and motivation of our research, and present the user-specific details of our tool, called FlowTracker. We include a walk-through of the system and present the profiles of our prospective users. Next, we discuss the design of an exploratory qualitative study that we have conducted to evaluate the usability and effectiveness of our tool. We conclude with a summary of lessons learned and challenges that we see for user evaluation of such domain-specific program comprehension tools.		978-1-4673-1859-4		user evaluation;domain specific tooling;program comprehension;software visualization	Actuators;Safety;Software;Navigation;Visualization;Sensor systems	marine engineering;object-oriented programming;reverse engineering;safety-critical software;software tools	user evaluation;domain specific program comprehension tool;large safety-critical component-based software system;maritime sector;FlowTracker;tool usability;tool effectiveness				13		28 jun. 2012			IEEE	IEEE Conferences
Using cognitive easiness metric for program comprehension	using cognitive easiness metric for program comprehension		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5542938	M. Yin; B. Li; C. Tao	School of Computer Science and Engineering, South-East University, Nanjing, China; School of Computer Science and Engineering, South-East University, Nanjing, China; School of Computer Science and Engineering, South-East University, Nanjing, China	The 2nd International Conference on Software Engineering and Data Mining	9 Aug 2010	2010			134	139	Program comprehension is one of the most critical phases in software maintenance. During program designing, the codes having related function and behavior are often scattered in different parts of program, which increases the difficulty of understanding program, and further obfuscates programmers. In this paper, we propose an approach to assisting comprehension process using cognitive easiness metric, which can predicate the easiness degree of a method to understand in various comprehension phases. The approach uses coarse-grained call graph slicing technique and intra-procedural coarse-grained slicing technique to compute the cognitive easiness of non-understood methods based on those understood methods in the program. It can not only guide programmers to investigate the non-understood codes in the program from the easier parts to the harder parts, but also support different guidance for different programmers. Finally, we evaluate the effectiveness and practicability of our approach by applying to a case study.		978-89-88678-22-0		Cognitive Easiness Metric;Program Comprehension;Program Slicing;Call Graph Slice	Programming profession;Software maintenance;Software systems;Large-scale systems;Data mining;Computer science;Scattering;Aging;Humans;Research and development	program slicing;software maintenance;software metrics	cognitive easiness metric;program comprehension;software maintenance;assisting comprehension process;coarse grained call graph slicing technique;intraprocedural coarse grained slicing technique				21		9 Aug 2010			IEEE	IEEE Conferences
TRIADE A Three-Factor Trace Segmentation Method to Support Program Comprehension	triade a threefactor trace segmentation method to support program comprehension	10.1109/ISSREW.2019.00103	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8990309	R. Khoury; A. Hamou-Lhadj; M. I. Rahim; S. Hallé; F. Petrillo	Département d'Informatique et de Mathématique, Université du Québec à Chicoutimi, Saguenay, QC, Canada; Department of Electrical and Computer Engineering, Concordia University, Montreal, Canada; Département d’informatique et de mathématique, Université du Québec à Chicoutimi, Canada, Saguenay, Canada; Département d'Informatique et de Mathématique, Université du Québec à Chicoutimi, Saguenay, QC, Canada; Département d’informatique et de mathématique, Université du Québec à Chicoutimi, Canada, Saguenay, Canada	2019 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)	13 Feb 2020	2019			406	413	Trace analysis allows software engineers to gain insights into the behavior of the systems they maintain, and thus serves as an essential tool to aid in multiple tasks that require an understanding of complex systems, including security analysis, debugging and maintenance. However, the considerable size of execution traces can hinder the effectiveness of trace analysis. There exist techniques that extract higher level abstractions from a lengthy trace by automatically segmenting a trace into a number of cohesive segments, allowing software engineers to focus only on the segments of interest. In this paper, we improve on related work on segmenting traces of method calls by considering three factors: method names, method calling relationship, and method parameters. We show experimentally that this approach is more effective for the purpose of dividing a trace in a manner concordant with the underlying behavior of the program than existing algorithms. We also examine the issue of key element extraction from a trace, and again demonstrate experimentally that traces segmented using our method can more readily be subjected to this analysis.		978-1-7281-5138-0		trace segmentation;program comprehension;key element extraction		data mining;program debugging;program diagnostics;program visualisation;reverse engineering;software maintenance	cohesive segments;method calls;method names;trace analysis;execution traces;lengthy trace;three-factor trace segmentation method;TRIADE				22		13 Feb 2020			IEEE	IEEE Conferences
The effectiveness of Zoom Visual Flow (ZViF) technique in program comprehension activities	the effectiveness of zoom visual flow (zvif) technique in program comprehension activities	10.1109/ITSIM.2010.5561292	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5561292	R. Kadar; S. Sulaiman	Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Penang, Malaysia; School of Computer Sciences, Universiti Sains Islam Malaysia, Penang, Malaysia	2010 International Symposium on Information Technology	2 Sep 2010	2010	1		1	6	Many techniques and tools have been developed to improve program comprehension but most tools are unsuitable for novices. Some tools are not user friendly, some designs are more suitable to expert programmers and some integrated development environments (IDEs) are very simple and fail to support program comprehension needs among the users. These factors hinder the learning process and may become obstacles to users who have no programming background. This paper attempts to improve program comprehension by using Zoom Visual Flow (ZViF) technique that represents source code in graphical views. It also gives some insights on how to improve visual presentation method in a program editor or an IDE. A lab experiment was conducted to determine the effectiveness of the technique. The respondents were asked to determine their preference between ZViF technique and Control Structured Diagram (CSD). CSD is one of the best techniques that uses graphic to visualize a program. The result shows that users prefer the proposed technique compared to CSD as the ZViF helps to improve program comprehension among novices.	2155-899X	978-1-4244-6718-1		program comprehension;program visualization;integrated development environment	Visualization;Color;Shape;Software;Programming;Switches;Computer languages	data visualisation;program visualisation	zoom visual flow technique;program comprehension activity;integrated development environments;learning process;source code;program editor;lab experiment;ZViF technique;control structured diagram;program visualization;visual presentation method;computer graphics				14		2 Sep 2010			IEEE	IEEE Conferences
Supporting program comprehension by generating abstract code summary tree	supporting program comprehension by generating abstract code summary tree	10.1145/3510455.3512793	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9793515	A. Bhattacharjee; B. Roy; K. A. Schneider	University of Saskatchewan, Canada; University of Saskatchewan, Canada; University of Saskatchewan, Canada	2022 IEEE/ACM 44th International Conference on Software Engineering: New Ideas and Emerging Results (ICSE-NIER)	13 jun. 2022	2022			81	85	Reading through code, finding relevant methods, classes and files takes a significant portion of software development time. Having good tool support for this code browsing activity can reduce human effort and increase overall developer productivity. To help with program comprehension activities, building an abstract code summary of a software system from its call graph is an active research area. A call graph is a visual representation of the caller-callee relationships between different methods of a software system. Call graphs can be difficult to comprehend for a large code-base. Previous work by Gharibi et al. on abstract code summarizing suggested using the Agglomerative Hierarchical Clustering (AHC) tree for understanding the codebase. Each node in the tree is associated with the top five method names. When we replicated the previous approach, we observed that the number of nodes in the AHC tree is burdensome for developers to explore. We also noticed only five method names for each node is not sufficient to comprehend an abstract node. We propose a technique to transform the AHC tree using cluster flattening for natural grouping and reduced nodes. We also generate a natural text summary for each abstract node derived from method comments. In order to evaluate our proposed approach, we collected developers’ opinions about the abstract code summary tree based on their codebase. The evaluation results confirm that our approach can not only help developers get an overview of their codebases but also could assist them in doing specific software maintenance tasks.		978-1-6654-9596-7	Natural Sciences and Engineering Research Council of Canada; Canada First Research Excellence Fund; 	Program comprehension;Static call graph;Information retrieval;Abstract Code Summary Tree;Hierarchical Abstraction Tree	Productivity;Visualization;Software maintenance;Codes;Buildings;Transforms;Software systems	pattern clustering;program diagnostics;software maintenance;source code (software);text analysis;trees (mathematics);visual programming	code browsing activity;program comprehension;software system;AHC tree;abstract node;natural text summary;software development time;agglomerative hierarchical clustering tree;software maintenance;abstract code summary tree generation;call graph;visual representation				29		13 jun. 2022			IEEE	IEEE Conferences
Trace Visualization within the Software City Metaphor: A Controlled Experiment on Program Comprehension	trace visualization within the software city metaphor a controlled experiment on program comprehension	10.1109/VISSOFT52517.2021.00015	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9604832	V. Dashuber; M. Philippsen	QAware GmbH, Munich, Germany; Programming Systems Group, Friedrich-Alexander University Erlangen-Nürnberg (FAU), Erlangen, Germany	2021 Working Conference on Software Visualization (VISSOFT)	11 nov. 2021	2021			55	64	Especially with the rise of microservice architectures, software is hard to understand when just the static dependencies are known. The reason is that the actual call paths and the dynamic behavior of the application is hidden behind network communication. To comprehend what is going on in the software the vast amount of runtime data (traces) needs to be reduced and visualized.DynaCity uses the city metaphor for visualization. Its novel trace visualization displays dynamic dependencies as arcs atop the city. To reduce the number of traces, DynaCity aggregates all requests between the same two components into one arc whose brightness reflects both the number and the total duration of the requests. DynaCity also encodes dynamic trace data in a heatmap that it uses to light up the building: the brighter a building is, the more active it is, i.e., the more and the longer the requests are that it receives and/or spawns.In a controlled experiment, we compare our approach with a traditional trace visualization built into the same Software City but showing all dependencies (without aggregation) as individual arcs and also disabling the heatmap. The study shows that professional software developers can solve typical software comprehension tasks faster (5.84%) and more correctly (11.7%) with the help of DynaCity and that they prefer our approach over the more traditional dynamic trace visualization.		978-1-6654-3144-6		trace visualization;software city;program comprehension;aggregation;heatmap	Heating systems;Runtime;Aggregates;Urban areas;Brightness;Data visualization;Computer architecture	data visualisation;program diagnostics;program visualisation;reverse engineering;software maintenance	controlled experiment;program comprehension;microservice architectures;network communication;runtime data;dynamic trace data;heatmap;trace visualization;professional software developers;Software City metaphor;DynaCity				25	IEEE	11 nov. 2021			IEEE	IEEE Conferences
Finding the right needles in hay helping program comprehension of large software systems	finding the right needles in hay helping program comprehension of large software systems		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7320345	I. Şora	Department of Computer and Software Engineering, University Politehnica of Timisoara, Timisoara, Romania	2015 International Conference on Evaluation of Novel Approaches to Software Engineering (ENASE)	5 nov. 2015	2015			129	140	Maintenance of complex software systems can be done by software engineers only after they understand well the existing code. Program comprehension is supported by documentation - either developer documentation or reverse engineered. What is most often missing is a short document providing the new user with useful information to start with - an executive summary. In this work we propose a tool to automatically extract such a summary, by identifying the most important classes of a system. Our approach relies on techniques of static analysis of dependencies and graph-based ranking. Experiments on a set of real systems show good results.		978-989-758-143-4		Reverse Engineering;Program Comprehension;Recommender System;Key Classes	Software systems;Documentation;Software algorithms;Libraries;Software engineering;Reverse engineering	graph theory;reverse engineering;software maintenance	helping program comprehension;large-software systems;complex software system maintenance;static dependency analysis;graph-based ranking				17		5 nov. 2015			IEEE	IEEE Conferences
JRipples: a tool for program comprehension during incremental change	jripples a tool for program comprehension during incremental change	10.1109/WPC.2005.22	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421025	J. Buckner; J. Buchta; M. Petrenko; V. Rajlich	Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA	13th International Workshop on Program Comprehension (IWPC'05)	23 May 2005	2005			149	152	Incremental software change adds new functionality to software. It is the foundation of software evolution, maintenance, iterative development, agile development, and other software processes. Highly interactive tool JRipples provides the programmer with the organizational support that makes the incremental change process easier and more systematic. JRipples supports impact analysis and change propagation, the two most difficult activities of the incremental change.	1092-8138	0-7695-2254-8			Programming profession;Software maintenance;Databases;Software tools;Java;Displays;Computer science;Software engineering;Humans;Error analysis	software tools;software maintenance	JRipples tool;program comprehension;incremental change process;software evolution;software maintenance;iterative development;agile development		51	1	24		23 May 2005			IEEE	IEEE Conferences
Hidden dependencies in program comprehension and change propagation	hidden dependencies in program comprehension and change propagation	10.1109/WPC.2001.921739	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921739	Zhifeng Yu; V. Rajlich	Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA	Proceedings 9th International Workshop on Program Comprehension. IWPC 2001	7 Aug 2002	2001			293	299	Large software systems are difficult to understand and maintain. Program dependency analysis plays a key role in both understanding and maintenance. This paper discusses hidden dependencies among software components that make both understanding and maintenance hard. A hidden dependency is a relationship between two seemingly independent components, and it is caused by the data flow in a third software component. The paper uses abstract system dependency graphs to define hidden dependencies. It discusses the impact of hidden dependencies on the process of change propagation and also discusses an algorithm that warns about the possible presence of hidden dependencies.	1092-8138	0-7695-1131-7			Software maintenance;Computer science;Software systems;Independent component analysis;Object oriented modeling;Programming profession;Variable speed drives;Java;Collaborative work;Protocols	reverse engineering;software maintenance;graphs;subroutines;data flow analysis	hidden dependencies;program comprehension;software change propagation;large software systems;program dependency analysis;program understanding;software maintenance;software components;independent components;data flow;abstract system dependency graphs;warning algorithm		18	1	25		7 Aug 2002			IEEE	IEEE Conferences
Towards standard for experiments in program comprehension	towards standard for experiments in program comprehension	10.1109/WPC.1997.601284	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601284	V. Rajlich; G. S. Cowan	Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA	Proceedings Fifth International Workshop on Program Comprehension. IWPC'97	6 Aug 2002	1997			160	161	Program comprehension can make a unique contribution to the field of software engineering because it is feasible to validate its claims with inexpensive experiments. To fully realize this unique position, program comprehension researchers need to develop standards that will guide them in designing experiments and allow them to judge the strength of an experiment in supporting a claim. To begin the discussion leading to such standards, we propose that program comprehension experiments always measure and interpret the following dependent variables: accuracy, accurate response time, and inaccurate response time.	1092-8138	0-8186-7993-X			Software engineering;Delay;Costs;Time measurement;Programming profession;Standards development;Software systems;Computer science;Measurement standards;Humans	reverse engineering;software standards;software metrics	program comprehension;software engineering;software standards;dependent variables;accurate response time;inaccurate response time;reverse engineering		14		5		6 Aug 2002			IEEE	IEEE Conferences
Scalability solutions for program comprehension through dynamic analysis	scalability solutions for program comprehension through dynamic analysis	10.1109/CSMR.2006.46	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1602389	A. Zaidman	Department of Mathematics and Computer Science, Laboratory on REngineering LORE, University of Antwerp, Belgium	Conference on Software Maintenance and Reengineering (CSMR'06)	10 Apr 2006	2006			4 pp.	330	Dynamic analysis has long been a subject of study in the context of (compiler) optimization, program comprehension, test coverage, etc. Ever-since, the scale of the event trace has been an important issue. This scalability issue finds its limits on the computational front, where time and/or space complexity of algorithms become too large to be handled by a computer, but also on the cognitive front, where the results presented to the user become too large to be easily understood. This research focuses on delivering a number of program comprehension solutions that help software engineers to focus on the software system during their initial program exploration and comprehension phases. The key concepts we use in our techniques are "frequency of execution" and runtime "coupling". To validate our techniques we used a number of open-source software systems, as well as an industrial legacy application	1534-5351	0-7695-2536-9			Scalability;Open source software;Software systems;Program processors;Optimizing compilers;Testing;Frequency;Runtime;Computer industry;Application software	reverse engineering;software maintenance;system monitoring	program comprehension;dynamic analysis;event trace;time complexity;space complexity;software engineering;program exploration;open-source software systems;industrial legacy application		14		13		10 Apr 2006			IEEE	IEEE Conferences
CodeCrawler - an information visualization tool for program comprehension	codecrawler an information visualization tool for program comprehension	10.1109/ICSE.2005.1553647	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1553647	M. Lanza; S. Ducasse; H. Gall; M. Pinzger	Faculty of Informatics, University of Lugano, Switzerland; Software Composition Group, University of Bern, Switzerland; Institute of Informatics, University of Zurich, South Korea; Institute of Informatics, University of Zurich, South Korea	Proceedings. 27th International Conference on Software Engineering, 2005. ICSE 2005.	19 Dec 2005	2005			672	673	CodeCrawler is a language independent, interactive, information visualization tool. It is mainly targeted at visualizing object-oriented software, and has been successfully validated in several industrial case studies over the past few years. CC adheres to lightweight principles: it implements and visualizes polymetric views, visualizations of software enriched with information such as software metrics and other source code semantics. CC is built on top of Moose, an extensible language independent reengineering environment that implements the FAMIX metamodel. In its last implementation, CC has become a general-purpose information visualization tool.	1558-1225	1-59593-963-2			Visualization;Informatics;Computer industry;Software metrics;Reverse engineering;Software tools;Data mining;Information analysis;Object oriented modeling;Java	program visualisation;reverse engineering	CodeCrawler;information visualization tool;program comprehension;object-oriented software;software visualization;Moose;extensible language independent reengineering environment;FAMIX metamodel		12		6		19 Dec 2005			IEEE	IEEE Conferences
Improving program comprehension by enhancing program constructs: An analysis of the Umple language	improving program comprehension by enhancing program constructs an analysis of the umple language	10.1109/ICPC.2009.5090073	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090073	A. Forward; T. C. Lethbridge; D. Brestovansky	School of Information Technology and Engineering (SITE), University of Ottawa, Canada; School of Information Technology and Engineering (SITE), University of Ottawa, Canada; School of Information Technology and Engineering (SITE), University of Ottawa, Canada	2009 IEEE 17th International Conference on Program Comprehension	19 jun. 2009	2009			311	312	Umple is a set of extensions to object-oriented languages that provides a concrete syntax for UML abstractions like associations. We argue that Umple will help increase program comprehension by allowing developers to describe a system at a more abstract level, and by reducing the volume of code.	1092-8138	978-1-4244-3998-0			Object oriented modeling;Unified modeling language;Computer languages;Investments;Information analysis;Information technology;Concrete;Risk analysis;Object oriented programming;Application software	object-oriented languages;programming languages;Unified Modeling Language	program comprehension;program constructs;language analysis;object-oriented languages;UML abstractions		10		8		19 jun. 2009			IEEE	IEEE Conferences
A structured demonstration of five program comprehension tools: lessons learnt	a structured demonstration of five program comprehension tools lessons learnt	10.1109/WCRE.2000.891471	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=891471	S. E. Sim; M. Storey; A. Winter	Department of Computer Science, University of Victoria, Victoria, BC, Canada; Institute for Software Technology, University of Koblenz and Landau, Koblenz, Germany; Department of Computer Science, University of Toronto, Toronto, ONT, Canada	Proceedings Seventh Working Conference on Reverse Engineering	6 Aug 2002	2000			210	212	The purpose of the article is to report on a structured demonstration for comparing program comprehension tools. Five teams of program comprehension tool designers applied their tools to a set of maintenance tasks on a common subject system. By applying a variety of reverse engineering techniques to a predefined set of tasks, the tools can be compared using a common playing field. A secondary topic of discussion will address the development of "guinea pig" systems and how to use them in a structured demonstration for evaluating software tools.	1095-1350	0-7695-0881-2			Software tools;Conferences;Computer science;Reverse engineering;Educational institutions;Computer industry;Industrial relations;Software systems;Data mining;Software architecture	reverse engineering;software maintenance;software tools;software performance evaluation;software selection	structured demonstration;program comprehension tool designers;maintenance tasks;common subject system;reverse engineering techniques;common playing field;guinea pig systems;software tool evaluation		8		3		6 Aug 2002			IEEE	IEEE Conferences
Software visualization for object-oriented program comprehension	software visualization for objectoriented program comprehension	10.1109/ICSE.2004.1317423	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1317423	M. J. Pacione	Department of Computer and Information Sciences, University of Strathclyde, UK	Proceedings. 26th International Conference on Software Engineering	26 jul. 2004	2004			63	65	Software visualisation is the process of modelling software systems for comprehension. The comprehension of software systems both during and after development is a crucial component of the software process. The complex interactions inherent in the object-oriented paradigm make visualisation a particularly appropriate comprehension technique, and the large volume of information typically generated during visualisation necessitates tool support. In order to address the disadvantages with current visualisation techniques, an approach is proposed that integrates abstraction, structural and behavioural perspectives, and statically and dynamically extracted information. The aim of this research is to improve the effectiveness of visualisation techniques for large-scale software understanding based on the use of abstraction. interrelated facets and the integration of statically and dynamically extracted information.	0270-5257	0-7695-2163-0			Visualization;Software systems;Data mining;Software tools;Reverse engineering;Large-scale systems;Object oriented modeling;Large scale integration;Software performance;Computer architecture	object-oriented programming;program visualisation;software engineering	software visualization;software modelling;software processes;object-oriented software;object-oriented program;information extraction		7		8		26 jul. 2004			IEEE	IEEE Conferences
VPLs and novice program comprehension: how do different languages compare?	vpls and novice program comprehension how do different languages compare	10.1109/VL.1999.795912	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=795912	J. Good	Human Communication Research Centre, University of Edinburgh, Edinburgh, UK	Proceedings 1999 IEEE Symposium on Visual Languages	6 Aug 2002	1999			262	269	This paper reports on an experiment which compared small control and data flow visual programming languages (VPLs). The study used a combination of the match-mismatch conjecture and the information types approach in order to investigate the effect of language style on comprehension. Results showed that the control flow VPL is associated with faster task performance, regardless of the match between language and task. However, accuracy scores showed some evidence of a match-mismatch effect. These results were supported by program summary data, which showed that the data flow VPL was associated with abstract, functional accounts of the program, while the control flow language led to low-level, procedural descriptions. This suggests that specific properties of VPLs lead to differences in program comprehension.	1049-2615	0-7695-0216-4			Computer languages	visual languages;parallel languages	VPLs;program comprehension;data flow visual programming languages;match-mismatch conjecture;information types approach;program summary data		7		15		6 Aug 2002			IEEE	IEEE Conferences
IMMV: An interactive multi-matrix visualization for program comprehension	immv an interactive multimatrix visualization for program comprehension	10.1109/VISSOFT.2013.6650549	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6650549	A. Abuthawabeh; D. Zeckzer	TU Kaiserslautern, Germany; TU Kaiserslautern, Germany	2013 First IEEE Working Conference on Software Visualization (VISSOFT)	31 Oct 2013	2013			1	4	Many visualization techniques are used by software engineers to understand and to analyze the static structure of software systems, with the static structure being extracted from the source code. However, the need for scalable visualizations, which take into account the increasing number of code entities (classes and interfaces) and different types of code couplings (relations between them) in software systems, is still not sufficiently fulfilled. In this paper, we extend the design of an existing multi-matrix visualization approach to represent the static structure of software systems in a scalable way. First, we extended the data model and the algorithms. Second, we added more visualization and interaction elements. Finally, we incorporated the folding (collapsing) and the unfolding (expanding) of the package hierarchy, which have quadratic time complexity and quadratic space complexity in the number of nodes. This extended approach can be applied to support program comprehension and to analyze the static structure of software systems.		978-1-4799-1457-9			Visualization;Software systems;Couplings;Algorithm design and analysis;Color;Complexity theory	computational complexity;data visualisation;matrix algebra;program diagnostics	IMMV;interactive multimatrix visualization;program comprehension;visualization techniques;software engineers;source code;scalable visualizations;code entities;code couplings;static software systems structure;interaction elements;visualization elements;package hierarchy;quadratic time complexity;quadratic space complexity		6		13		31 Oct 2013			IEEE	IEEE Conferences
SFAC, a tool for program comprehension by specialization	sfac, a tool for program comprehension by specialization	10.1109/WPC.1994.341266	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341266	S. Blazy; P. Facon	CEDRIC IIE, Evry, France; CEDRIC IIE, Evry, France	Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94	6 Aug 2002	1994			162	167	This paper describes a tool for facilitating the comprehension of general programs using automatic specialization. The goal of this approach was to assist in the maintenance of old programs, which have become very complex due to numerous extensions. This paper explains why this approach was chosen, how the tool's architecture was set up, and how the correctness of the specialization has been proved. Then, it discusses the results obtained by using this tool, and the future evolutions.<>	1092-8138	0-8186-5647-6			Input variables;Geometry;Switches;Software maintenance;Application software;Computer applications;Natural languages;Optimizing compilers;Program processors;Solid modeling	reverse engineering;software tools;program diagnostics	program comprehension;specialization;SFAC;software tool;automatic specialization;program maintenance		6		14		6 Aug 2002			IEEE	IEEE Conferences
Managing a multi-file, multi-language software repository for program comprehension tools: a generic approach	managing a multifile, multilanguage software repository for program comprehension tools a generic approach	10.1109/WPC.1998.693287	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=693287	M. Kamp	Institute for Software Technology, University of Koblenz and Landau, Koblenz, Germany	Proceedings. 6th International Workshop on Program Comprehension. IWPC'98 (Cat. No.98TB100242)	6 Aug 2002	1998			64	71	Software repositories that provide a basis for software comprehension or reengineering tools usually have to represent a huge number of documents of different types bound into a web of many kinds of relationships. The flexibility and the structural properties of a software repository are crucial for its use. This paper presents a repository approach that allows to set up, fill and update a software repository where the documents are represented as a highly integrated structure. The repository schema is described by a user defined, object based conceptual model. The integration of new documents into the existing repository is described by declarative rules. The repository was implemented as part of the GUPRO project.	1092-8138	0-8186-8560-3			Software tools;Electrical capacitance tomography;Software systems;Databases;Visualization;Technology management;Hip;Data mining;Computer languages;Operating systems	software libraries;software reusability;reverse engineering;software tools;systems re-engineering;object-oriented programming	multi-file multi-language software repository;program comprehension tools;reengineering tools;documents;repository schema;object based conceptual model;declarative rules;GUPRO project		6		17		6 Aug 2002			IEEE	IEEE Conferences
Concept Location and Program Comprehension in Service-Oriented Software	concept location and program comprehension in serviceoriented software	10.1109/ICSM.2007.4362676	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362676	O. Panchenko	Hasso-Plattner Institute of Software Systems Engineering, Potsdam, Germany	2007 IEEE International Conference on Software Maintenance	22 Oct 2007	2007			513	514	The maintenance process of service-oriented software might be different from the maintenance of software built using established technologies. This research aims at an investigation of existing maintenance methods for concept location and program comprehension and their applicability to new service-oriented environments as well as development of new appropriate methods. This paper outlines the goals and shortly discusses how these can be achieved.	1063-6773	978-1-4244-1255-6			Software maintenance;Acceleration;Service oriented architecture;Computer architecture;Semiconductor optical amplifiers;Object oriented modeling;Iterative methods;Costs;Software design;Software systems	reverse engineering;software maintenance	concept location;program comprehension;service-oriented software;maintenance process		5		12		22 Oct 2007			IEEE	IEEE Conferences
Constructivism and program comprehension strategies	constructivism and program comprehension strategies	10.1109/WPC.2002.1021349	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021349	C. Exton	University of Limerick, Ireland	Proceedings 10th International Workshop on Program Comprehension	10 Dec 2002	2002			281	284	Program comprehension strategies and learning theories are difficult topics in themselves, and the combination of both can provide some interesting observations. Constructivism differs from the traditional learning theories which suggest knowledge exists as something independent of the individual in several ways. One major premise of constructivism is that we actively construct our knowledge rather than simply absorbing it through repeated practice or predefined steps. Constructivism asserts that there is no knowledge independent of that constructed by the learner, and its construction is a unique experience for each individual. This paper provides an overview of existing program comprehension strategies and contrasts them in relation to the learning theory of constructivism.	1092-8138	0-7695-1495-2			Programming profession;Educational institutions;Conferences;Cultural differences	reverse engineering;software engineering;learning (artificial intelligence)	program comprehension strategies;learning theories;constructivism;knowledge construction		5		7		10 Dec 2002			IEEE	IEEE Conferences
Experiences in teaching software evolution and program comprehension	experiences in teaching software evolution and program comprehension	10.1109/WPC.2003.1199214	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199214	A. van Deursen; J. . -M. Favre; R. Koschke; J. Rilling	CWI, Delft University슠of슠Technology, Netherlands; University of Grenoble, France; University of Stuttgart, Germany; Concordia University, Canada	11th IEEE International Workshop on Program Comprehension, 2003.	21 May 2003	2003			283	284	A large amount of research is devoted to software evolution and program understanding, but these topics are often neglected in software engineering curricula. The CCSE initiative from IEEE/ACM proposes guidelines for the future. At the ICSM'02 conference, a panel was held to establish what should be taught in the future. This working session focuses on what is being taught and what will be taught in the near future. The goals include (1) to share experiences in teaching software evolution and program understanding, (2) to establish the state of the practice and (3) to identify future directions.	1092-8138	0-7695-1883-4			Education;Software engineering;Software tools;Guidelines;Software maintenance;Computer industry;Reverse engineering;Seminars;Conferences;Computer architecture	teaching;reverse engineering;computer science education	teaching;software evolution;program comprehension;software engineering curricula;CCSE initiative;IEEE/ACM;ICSM'02 conference;program understanding;future directions		4		4		21 May 2003			IEEE	IEEE Conferences
A Synergistic Approach to Program Comprehension	a synergistic approach to program comprehension	10.1109/ICPC.2006.7	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631106	B. L. Vinz; L. H. Etzkorn	Computer Science Department, University of Alabama, Huntsville, USA; Computer Science Department, University of Alabama, Huntsville, USA	14th IEEE International Conference on Program Comprehension (ICPC'06)	26 jun. 2006	2006			69	73	Program comprehension involves the process of extracting properties from a program in order to achieve a better understanding of the software system. The most common approaches are code-based with focus primarily on the program code. More attention needs to be given to information encoded in comments and identifiers and the valuable clues they may provide. This paper describes a technique that combines a code-based program understanding approach with a comment understanding approach. The goal is to match the comments and identifiers to the code in order to obtain a comprehensive understanding of the software under analysis. The method has application to software development and maintenance. It can also be used as an instructional tool for software students	1092-8138	0-7695-2601-2			Programming;Software maintenance;Software tools;Computer science;Data mining;Software systems;Application software;Scattering;Education;Inference algorithms	program diagnostics;reverse engineering;software maintenance	program comprehension;software system development;code-based program understanding approach;comment understanding approach;program identifiers;software maintenance;instructional tool		4		7		26 jun. 2006			IEEE	IEEE Conferences
gccXfront: exploiting gcc as a front end for program comprehension tools via XML/XSLT	gccxfront exploiting gcc as a front end for program comprehension tools via xml/xslt	10.1109/WPC.2003.1199222	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199222	M. Hennessy; B. A. Malloy; J. F. Power	Computer Science Department, National University of Ireland Maynooth Company, Kildare, Ireland; Computer Science Department, Clemson University, Clemson, SC, USA; Computer Science Department, National University of Ireland, Kildare, Ireland	11th IEEE International Workshop on Program Comprehension, 2003.	21 May 2003	2003			298	299	Parsing programming languages is an essential component of the front end of most program comprehension tools. Languages such as C++ can be difficult to parse and so it can prove useful to re-use existing front ends such as those from the GNU compiler collection, gcc. We have modified gcc to provide syntactic tags in XML format around the source code which can greatly enhance our comprehension of the program structure. Further, by using XML transformation stylesheets, the XML outputted by our modified gcc can be translated into a more readable format. Our tool, gccXfront leverages the power and portability of the gcc suite, since any C, C++, Objective C or Java program can be processed using gcc. Our tool can thus act as a bridge between gcc and other program comprehension tools that accept XML formatted input.	1092-8138	0-7695-1883-4			XML;Java;Computer science;Computer languages;Graphical user interfaces;Bridges;Style sheet languages;Humans;Navigation;Visualization	XML;reverse engineering;software tools;C++ language;program compilers;computational linguistics;software portability;Java	gccXfront;front end;program comprehension tools;XML/XSLT;programming language parsing;C++ languages;GNU compiler collection;syntactic tags;XML transformation stylesheets;portability;C program;Objective C program;Java program		3		5		21 May 2003			IEEE	IEEE Conferences
Industrial Program Comprehension Challenge 2011: Archeology and Anthropology of Embedded Control Systems	industrial program comprehension challenge 2011 archeology and anthropology of embedded control systems	10.1109/ICPC.2011.50	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970193	A. Begel; J. Quante	Microsoft Research Limited, Redmond, WA, USA; Corporate Research, Robert Bosch GmbH, Stuttgart, Germany	2011 IEEE 19th International Conference on Program Comprehension	1 Aug 2011	2011			227	229	The Industrial Program Comprehension Challenge is a two-year-old track of the International Conference on Program Comprehension that provides a venue for researchers and industrial practitioners to communicate about new research directions that can help address real world problems. This year, 2011, a scenario-based challenge was created to inspire researchers to apply the best "archaeological" techniques for understanding the complexity of industrial software, and foster appreciation for the delicate "anthropological" scenario which drives the behavior of the software engineers, management, and customers. Participants had two months to work on the challenge and submit write-ups of their solutions. Acceptable submissions were exhibited as posters, while the best solutions were presented during the Industrial Challenge conference session. This new challenge format gives researchers the opportunity to present their novel techniques, tools and ideas to the community.	1092-8138	978-0-7695-4398-7			Software;Leg;Legged locomotion;Computer bugs;Electronic mail;Companies	embedded systems;production engineering computing;software engineering	archeology;anthropology;embedded control systems;Industrial Program Comprehension Challenge;industrial software		3		1		1 Aug 2011			IEEE	IEEE Conferences
A brief summary of cognitive patterns for program comprehension	a brief summary of cognitive patterns for program comprehension	10.1109/WCRE.2004.5	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1374334	A. Murray; T. C. Lethbridge	SITE, University of Ottawa, Ottawa, ONT, Canada; SITE, University of Ottawa, Ottawa, ONT, Canada	11th Working Conference on Reverse Engineering	17 jan. 2005	2004			304	305	A cognitive pattern is a solution to a recurring mental problem. We focus on those relevant to program comprehension. We expand one pattern, Temporal Details, which is also a pattern language since it decomposes into sub-patterns. Tool designers can use cognitive patterns to grasp how tool users may think.	1095-1350	0-7695-2243-2			Navigation;Humans;Software systems;Cultural differences;Reverse engineering;Software tools;Vocabulary;Object oriented modeling;Unified modeling language;Time factors	reverse engineering;software tools;object-oriented programming	cognitive patterns;program comprehension;mental problem;temporal details;pattern language;tool designer;software tool		3				17 jan. 2005			IEEE	IEEE Conferences
Working session: Using eye-tracking to understand program comprehension	working session using eyetracking to understand program comprehension	10.1109/ICPC.2009.5090057	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090057	Y. -G. Gueheneuc; H. Kagdi; J. I. Maletic	Ptidej Team-DGIGL, École Polytechnique de Montréal, Montreal, QUE, Canada; Department of Computer Science, Missouri University of Science and Technology, Rolla, MO, USA; Department of Computer Science, Kent University, Kent, OH, USA	2009 IEEE 17th International Conference on Program Comprehension	19 jun. 2009	2009			278	279	The working session focuses on the use of eye-tracking technology to assess, understand, and evaluate tools and techniques for program comprehension. An introduction to the technology and tools of eye-tracking will be presented. A discussion of how these tools augment existing evaluation mechanism in the context of program comprehension will follow. Research directions and open problems will be a main topic.	1092-8138	978-1-4244-3998-0			Humans;Computer science;Software engineering;Unified modeling language;Tracking;Physiology;Time measurement;Cameras;Psychology;Cognitive science	reverse engineering;software tools	program comprehension understanding;working session;eye-tracking technology;program tools		3		9		19 jun. 2009			IEEE	IEEE Conferences
Recursion Removal/Introduction by Formal Transformation: An Aid to Program Development and Program Comprehension	recursion removal/introduction by formal transformation an aid to program development and program comprehension	10.1093/comjnl/42.8.650	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8129741	M. P. Ward; K. H. Bennett	NA; NA	The Computer Journal	18 jan. 2018	1999	42	8	650	673	The transformation of a recursive program to an iterative equivalent is a fundamental operation in computer science. In the reverse direction, the task of reverse engineering (analysing a given program in order to determine its specification) can be greatly ameliorated if the program can be re-expressed in a suitable recursive form. However, the existing recursion removal transformations, such as the techniques discussed by Knuth [1] and Bird [2], can only be applied in the reverse direction if the source program happens to match the structure produced by a particular recursion removal operation. In this paper we describe a much more powerful recursion removal and introduction operation which describes its source and target in the form of an action system (a collection of labels and calls to labels). A simple, mechanical restructuring operation can be applied to a great many iterative programs, which will put them in a suitable form for recursion introduction. Our transformation generates strictly more iterative versions than the standard methods, including those of Knuth and Bird [1, 2]. With the aid of this theorem we prove a (somewhat counterintuitive) result for programs that contain sequences of two or more recursive calls: under a reasonable commutativity condition, ‘depth-first’ execution is more general than ‘breadth-first’ execution. In ‘depth-first’ execution, the execution of each recursive call is completed, including all sub-calls, before execution of the next call is started. In ‘breadth-first’ execution, each recursive call in the sequence is partially executed but any sub-calls are temporarily postponed. This result means that any breadth-first program can be reimplemented as a corresponding depth-first program, but the converse does not hold. We also treat the case of ‘random-first’ execution, where the execution order is implementation dependent. For the more restricted domain of tree searching we show that a ‘breadth-first’ search is the most general form. We also give two examples of recursion introduction as an aid to formal reverse engineering.	1460-2067								2				18 jan. 2018			OUP	OUP Journals
From Program Comprehension to People Comprehension	from program comprehension to people comprehension	10.1109/ICPC.2010.42	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521747	A. Begel	Microsoft Research Limited, Redmond, WA, USA	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			190	191	Large-scale software engineering requires many teams to collaborate together to create software products. The problems these teams suffer trying to coordinate their joint work can be addressed through tools inspired by social networking. Social networking tools help people to more easily discover and more efficiently maintain relationships than is feasible using one-to-one or face-to-face interactions. Applying these ideas to the software domain requires new kinds and combinations of software program and process analyses that overcome intrinsic limitations in the accuracy of the underlying data sources and the ambiguity inherent in human relationships.	1092-8138	978-1-4244-7603-9		software process;human aspects	Collaborative software;Humans;Software engineering;Collaborative work;Social network services;Computer bugs;Software testing;Data engineering;Data mining;USA Councils	social aspects of automation;social networking (online);software engineering	program comprehension;people comprehension;social networking tools;software program;software products;human aspects		2		9		26 jul. 2010			IEEE	IEEE Conferences
A Visualization Tool for 3D Graphics Program Comprehension and Debugging	a visualization tool for 3d graphics program comprehension and debugging	10.1109/VISSOFT.2016.23	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780167	S. Podila; Y. Zhu	Department of Computer Science, Georgia State University, Atlanta, USA; Department of Computer Science, Georgia State University, Atlanta, USA	2016 IEEE Working Conference on Software Visualization (VISSOFT)	12 Dec 2016	2016			111	115	Real-time 3D graphics programs are based on a 3D pipeline structure. In a 3D pipeline, data is loaded, prepared, transferred from CPU to GPU, and then processed on GPU to create images. Regular debuggers and special graphics debuggers primarily focus on displaying data but do not show how data is transferred from CPU to GPU. If there is an error in data transfer, programmers usually need to locate the error by reading the source code, which many of our students find difficult. We have developed a tool to visualize data flow between CPU and GPU in a 3D pipeline. The visualization helps students understand 3D graphics programs, especially some of the implicit data connections in 3D graphics APIs. It also helps students quickly locate bugs related to data transfer in a 3D pipeline. We demonstrate our tool with an example that shows how a subtle error can be quickly detected in our visualization.		978-1-5090-3850-3		software visualization;software comprehension;debugging;3D graphics program	Three-dimensional displays;Pipelines;Graphics processing units;Data visualization;Debugging;Engines;Data transfer	application program interfaces;graphics processing units;microprocessor chips;pipeline processing;program debugging;program visualisation	3D graphic API;data flow visualization;GPU;CPU;3D pipeline structure;3D graphic program debugging;3D graphic program comprehension;visualization tool		2	1	13		12 Dec 2016			IEEE	IEEE Conferences
Layered Program Auralization: Using Music to Increase Runtime Program Comprehension and Debugging Effectiveness	layered program auralization using music to increase runtime program comprehension and debugging effectiveness	10.1109/ICPC.2006.33	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631110	A. Stefik; K. Fitz; R. Alexander	School of Electrical Engineering and Computer Science, Washington State University, Pullman, WA, USA; School of Electrical Engineering and Computer Science, Washington State University, Pullman, WA, USA; School of Electrical Engineering and Computer Science, Washington State University, Pullman, WA, USA	14th IEEE International Conference on Program Comprehension (ICPC'06)	26 jun. 2006	2006			89	93	Layered program auralization uses music for debugging computer code. Layers of musical structure represent the state and behavior of a computer program while it is running, taking advantage of metaphorical relationships between musical structure and programming constructs. This paper makes three contributions to the debugging and program auralization literature. We use cadences, recognizable patterns of chords that usually dictate an ending, to metaphorically represent nesting depth and hierarchical control structures. Auralizations, in our system, use more than one perceptual mapping at a time. Further, we decompose our auralizations into units, which we call layers. This decomposition is similar to using classes in object oriented programming. We see debugging as a time consuming, difficult task, and present a solution where music is played to the programmer during program execution. Our goal is to increase debugging effectiveness and to improve a programmer's comprehension of the runtime behavior of computer programs	1092-8138	0-7695-2601-2		Fault detection;music;sonified debugging;testing;layered program auralization.	Multiple signal classification;Runtime;Debugging;Programming profession;Pattern recognition;Testing;Recycling;Computer science;Object oriented programming;Fault detection	music;program debugging;system monitoring	layered program auralization;music;runtime program comprehension;computer code debugging;metaphorical relationship;programming construct;cadence;recognizable chord pattern;hierarchical control structure;object oriented programming;program execution;fault detection		2		13		26 jun. 2006			IEEE	IEEE Conferences
Program comprehension as a learning process	program comprehension as a learning process	10.1109/COGINF.2002.1039316	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1039316	V. Rajich	Dept. of Comput. Sci., Wayne State Univ., Detroit, MI, USA	Proceedings First IEEE International Conference on Cognitive Informatics	10 Dec 2002	2002			343	347	The paper describes the process of program comprehension from the point of view of constructivist theory of learning. According to this view, program comprehension starts with existing knowledge and continues through processes of assimilation and adaptation. Assimilation means that the facts encountered in the program are either added to the knowledge or rejected. Adaptation means that the existing knowledge is reorganized in order to absorb new facts. These processes are illustrated by a case study where the knowledge of the program is represented by UML class diagrams.		0-7695-1724-2			Programming profession;Software maintenance;Computer science;Unified modeling language;Software engineering;Documentation;Data visualization;Insurance;Companies;Pattern recognition	reverse engineering;software engineering;specification languages	program comprehension;constructivist learning theory;assimilation;adaptation;UML class diagrams		2		16		10 Dec 2002			IEEE	IEEE Conferences
Workshop on Program Comprehension through Dynamic Analysis (PCODA ‘05)	workshop on program comprehension through dynamic analysis (pcoda ‘05)	10.1109/WCRE.2005.35	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1566163	O. Greevy; A. Hamou-Lhadj; A. Zaidman	Software Composition Group, University of Bern, Switzerland; Technology and Engineering, University of Ottawa, Canada; Laboratory On Re Engineering, University of Antwerp, Belgium	12th Working Conference on Reverse Engineering (WCRE'05)	3 jan. 2006	2005			232	232	Software maintenance and evolution can be made easier if program comprehension techniques are used. Understanding a software system would typically necessitate a combination of static and dynamic analysis techniques. The aim of this workshop is to gather researchers working in the area of program comprehension with an emphasis on dynamic analysis. We are interested in investigating how dynamic analysis techniques are used or can be used to enable better comprehension of a software system.	2375-5369	0-7695-2474-5							2		2		3 jan. 2006			IEEE	IEEE Conferences
Structure transition graphs: An ECG for program comprehension?	structure transition graphs an ecg for program comprehension	10.1109/ICPC.2009.5090069	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090069	S. E. Sim; S. Ratanotayanon; L. Cotran	Department of Informatics, University of California, Irvine, USA; Department of Informatics, University of California, Irvine, USA; Department of Informatics, University of California, Irvine, USA	2009 IEEE 17th International Conference on Program Comprehension	19 jun. 2009	2009			303	304	This paper presents an idea of using a structure traversal graph (STG) to characterize whether program comprehension is progressing smoothly. Inspired by electrocardiograms that are used to measure heart rhythms, STGs are an attempt to depict the rhythm of program navigation. STGs are created by abstracting navigation between files to the level of a conceptual architecture graph. We analyzed the navigation patterns of fifteen developers performing a modification task in the laboratory and found that the STG was a good organizing principle for program comprehension behavior.	1092-8138	978-1-4244-3998-0			Electrocardiography;Navigation;Heart;Rhythm;Informatics;Organizing;Java;XML;Computer languages;Service oriented architecture	electrocardiography;graph theory;medical computing	structure transition graphs;program comprehension behavior;electrocardiograms;heart rhythms;program navigation;conceptual architecture graph		1		2		19 jun. 2009			IEEE	IEEE Conferences
Eye Tracking and Program Comprehension	eye tracking and program comprehension	10.1109/EMIP.2019.00008	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8834692	D. G. Feitelson	School of Computer Science and Engineering, The Hebrew University of Jerusalem, 91904 Jerusalem, Israel	2019 IEEE/ACM 6th International Workshop on Eye Movements in Programming (EMIP)	12 Sep 2019	2019			1	1	Reading and comprehending code is different from reading regular text. And eye tracking, which measures where we look, for how long, and how much mental effort we exert, can provide crucial data. The talk will survey some achievements and suggest future directions.		978-1-7281-2243-4			Gaze tracking;Tools;Conferences;Software engineering;Computer science;Software;Measurement	gaze tracking;software metrics;text analysis;user interfaces	eye tracking;mental effort;program comprehension;regular text		1		0		12 Sep 2019			IEEE	IEEE Conferences
Program COmprehension through Dynamic Analysis	program comprehension through dynamic analysis	10.1109/WCRE.2006.45	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4024010	A. Zaidman; O. Greevy; A. Hamou-Lhadj	Delft University of Technnology, Netherlands; Software Composition Group, University of Bern, Switzerland; School of Information Technology and Engineering, University of Ottawa, Canada	2006 13th Working Conference on Reverse Engineering	11 Dec 2006	2006			315	315	Software maintenance and evolution can be made easier with program comprehension techniques. The aim of this workshop is to gather together researchers working in the area of program comprehension with an emphasis on dynamic analysis. We are interested in investigating how dynamic analysis techniques are or can be used to enable better comprehension of a software system. The objective is to find common case studies, compare existing techniques, and find possible symbioses for existing solutions. Building upon the previous edition of the workshop, PCODA 2005, we aim to set up a forum for exchanging experiences, discussing solutions, and exploring new ideas.	2375-5369	0-7695-2719-1			Information analysis;Software maintenance;Software systems;Information technology;Documentation;Maintenance engineering;Runtime;Programming profession;Reverse engineering				1	1	2		11 Dec 2006			IEEE	IEEE Conferences
Workshop on Program Comprehension through Dynamic Analysis (PCODA07)	workshop on program comprehension through dynamic analysis (pcoda07)	10.1109/WCRE.2007.53	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4400183	A. Hamou-Lhadj; A. Zaidman; O. Greevy	Concordia University, Montreal, QUE, Canada; Delft University of Technnology, Netherlands; University of Bern, Switzerland	14th Working Conference on Reverse Engineering (WCRE 2007)	10 Dec 2007	2007			298	298	Software maintenance and evolution can be made easier if program comprehension techniques are used. Understanding a software system would typically necessitate a combination of static and dynamic analysis techniques. The aim of this workshop is to gather together researchers working in the area of program comprehension with an emphasis on dynamic analysis. We are interested in investigating how dynamic analysis techniques are used or can be used to enable better comprehension of a software system. The objective is to find common case studies, compare existing techniques, and find possible symbioses for existing solutions. Building upon the two previous editions of the workshop, we aim to set up a forum for exchanging experiences, discussing solutions, and exploring new ideas.	2375-5369	978-0-7695-3034-5				computer science education;program diagnostics;software maintenance	program comprehension;dynamic analysis;software maintenance;software evolution;software system;static analysis		1		4		10 Dec 2007			IEEE	IEEE Conferences
Quality Evaluation of Modern Code Reviews Through Intelligent Biometric Program Comprehension	quality evaluation of modern code reviews through intelligent biometric program comprehension	10.1109/TSE.2022.3158543	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9733211	H. Hijazi; J. Duraes; R. Couceiro; J. Castelhano; R. Barbosa; J. Medeiros; M. Castelo-Branco; P. De Carvalho; H. Madeira	Department of Informatics Engineering, University of Coimbra, 37829 Coimbra, Coimbra, Portugal, 3004-504; DEIS, Instituto Politecnico de Coimbra, 112015 Coimbra, Coimbra, Portugal; Department of Informatics Engineering, University of Coimbra, 37829 Coimbra, Coimbra, Portugal; Coimbra Institute for Biomedical Imaging and Translational Research (CIBIT), Institute of Nuclear Sciences Applied to Health (ICNAS), University of Coimbra, 37829 Coimbra, Coimbra, Portugal; Department of Informatics Engineering, Universidade de Coimbra, 37829 Coimbra, Portugal, Portugal, 3000-214; Department of Informatics Engineering, University of Coimbra, 37829 Coimbra, Coimbra, Portugal; Coimbra Institute for Biomedical Imaging and Translational Research (CIBIT), Institute of Nuclear Sciences Applied to Health (ICNAS), University of Coimbra, 37829 Coimbra, Coimbra, Portugal; CISUC, University of Coimbra, 37829 Coimbra, Coimbra, Portugal; CISUC, University of Coimbra, 37829 Coimbra, Coimbra, Portugal	IEEE Transactions on Software Engineering		2022	PP	99	1	1	Code review is an essential practice in software engineering to spot code defects in the early stages of software development. Modern code reviews (e.g., acceptance or rejection of pull requests with Git) have become less formal than classic Fagan's inspections, lightweight, and more reliant on individuals (i.e., reviewers). However, reviewers may encounter mentally demanding challenges during the code review, such as code comprehension difficulties or distractions that might affect the code review quality. This work proposes a novel approach that evaluates the quality of code reviews in terms of bug-finding effectiveness and provides the reviewers with a clear message of whether the review should be repeated, indicating the code regions that may not have been well-reviewed. The proposed approach utilizes biometric information collected from the reviewer during the review process using non-intrusive biofeedback devices (e.g., smartwatches). Biometric measures such as Heart Rate Variability (HRV) and task-evoked pupillary response are captured as a surrogate of the cognitive state of the reviewer (e.g., mental workload) and inexpensive desktop eye-trackers compatible with the software development settings. This work uses Artificial Intelligence techniques to predict the cognitive load from the extracted biomarkers and classify each code region according to a set of features. The final evaluation considers various factors such as code complexity, time of the code review, the experience level of the reviewer, and other factors. Our experimental results show the approach could predict the review quality with 87.77%4.65 accuracy and a Spearman correlation coefficient of 0.85 (p-value < 0.001) between the predicted and the actual review performance. This evaluation validates the cognitive load measurement using electroencephalography (EEG) signals as ground truth for the HRV and pupil signals.	1939-3520		BASE project(grant numbers:POCI - 01-0145 - FEDER- 031581,PTDC/PSI-GER/30852/2017,CONNECT-BCI.); 	Artificial Intelligence;Biometrics;Code inspections and walkthroughs;Human factors	Codes;Software;Computer bugs;Biometrics (access control);Inspection;Feature extraction;Task analysis				1			CCBY	11 mar. 2022			IEEE	IEEE Early Access Articles
Improving program comprehension by answering questions (keynote)	improving program comprehension by answering questions (keynote)	10.1109/ICPC.2013.6613827	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613827	B. A. Myers	Human Computer Interaction Institute, Carnegie Mellon University, Pittsburgh, PA, USA	2013 21st International Conference on Program Comprehension (ICPC)	30 Sep 2013	2013			1	2	My Natural Programming Project is working on making software development easier to learn, more effective, and less error prone. An important focus over the last few years has been to discover what are the hard-to-answer questions that developers ask while they are trying to comprehend their programs, and then to develop tools to help answer those questions. For example, when studying programmers working on everyday bugs, we found that they continuously ask “Why” and “Why Not” questions as they try to comprehend what happened. We developed the “Whyline” debugging tool, which allows programmers to directly ask these questions of their programs and get a visualization of the answers. In a small lab study, Whyline increased productivity by a factor of about two. We studied professional programmers trying to understand unfamiliar code and identified over 100 questions they identified as hard-to-answer. In particular, we saw that programmers frequently had specific questions about the feasible execution paths, so we developed a new visualization tool to directly present this information. When trying to use unfamiliar APIs, such as the Java SDK and the SAP eSOA APIs, we discovered some common patterns that make programmers up to 10 times slower in finding and understanding how to use the appropriate methods, so we developed new tools to assist them. This talk will provide an overview of our studies and resulting tools that address program comprehension issues.	1092-8138	978-1-4673-3092-3		Natural Programming;Debugging;Application Programming Interfaces (APIs);Integrated development environments (IDEs);Documentation;Reverse Engineering;Programming Environments	Visualization;Programming;Educational institutions;User interfaces;Usability;Documentation;Software engineering	computer science education;program debugging;program visualisation;project management;reverse engineering	program comprehension;question answering;My Natural Programming Project;software development learning;hard-to-answer questions;tool development;Whyline debugging tool;program visualization;productivity;professional programmer;execution paths;visualization tool;API		1		15		30 Sep 2013			IEEE	IEEE Conferences
A program visualization tool for program comprehension	a program visualization tool for program comprehension	10.1109/HCC.2003.1260243	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1260243	M. Ohki; Y. Hosaka	Nippon Institute of Technology, Japan; Nippon Institute of Technology, Japan	IEEE Symposium on Human Centric Computing Languages and Environments, 2003. Proceedings. 2003	14 jan. 2004	2003			263	265	At the beginning stage of programming education, comprehending program logics plays a more important role than capturing knowledge of a specific program language. In this paper, the authors describe an outline of a visualization tool that animates the actions of a program by adding simple annotations to the variables defined in a program, and show several ideas to improve the usability of this tool. The authors also discuss the effectiveness of program visualization.		0-7803-8225-0			Visualization;Programming profession;Animation;Logic testing;Educational programs;Sorting;Arithmetic;Shape control;Programmable logic arrays;Educational technology	program visualisation;computer animation;reverse engineering;computer science education	program visualization tool;program comprehension;programming education;program logic;software tool;program action animation;program variable annotation		1		3		14 jan. 2004			IEEE	IEEE Conferences
Working session: program comprehension strategies for Web service and service-oriented architectures	working session program comprehension strategies for web service and serviceoriented architectures	10.1109/WPC.2004.1311071	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311071	L. O'Brien; D. Smith	Software Engineering Institute, Carnegie Mellon University; Software Engineering Institute, Carnegie Mellon University, USA	Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.	12 jul. 2004	2004			260	261	The availability of the Web has made it possible to provide new life to legacy systems as Web services components within a service-oriented architecture. Web services are self-contained, modular applications that can be described, published, located, and invoked over a network, generally, the World Wide Web. The service-oriented architecture describes three roles: service provider, service requester and service broker; and three basic operations: publish, find and bind. A network component can play any or all of these roles. Web services focus on the integration and infrastructure complexities of B2B by leveraging the benefits of Web service technologies, Internet standards and common infrastructures. While the migration to Web services has the potential of providing significant value to legacy systems and components, a number of critical program comprehension issues need to be addressed. These include understanding the legacy systems and components in enough detail to make decisions on the types of changes that need to be made for using them within the new service-oriented architecture, understanding the legacy and target architectures, and analyzing the specific Web service technologies that will be required and how to incorporate the legacy components as services. This working session will discuss approaches for addressing these issues. Based on the results of the session, a working model will be developed that lists current approaches, their strengths and weaknesses, as well as current open issues.	1092-8138	0-7695-2149-5			Web services;Service oriented architecture;Conferences;Computer architecture;Software engineering;Decision making;Computer aided software engineering;Availability;Application software;Web sites	reverse engineering;software maintenance;Internet;software prototyping;software architecture;electronic commerce;object-oriented programming	program comprehension;Web service;service-oriented architecture;legacy system;Web services component;World Wide Web;network component;Internet;legacy component		1				12 jul. 2004			IEEE	IEEE Conferences
Building a research infrastructure for program comprehension observations	building a research infrastructure for program comprehension observations	10.1109/WPC.1997.601287	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601287	S. Lang; A. Von Mayrhauser	Department of Computer Science, Colorado State University, Fort Collins, CO, USA; Department of Computer Science, Colorado State University, Fort Collins, CO, USA	Proceedings Fifth International Workshop on Program Comprehension. IWPC'97	6 Aug 2002	1997			165	169	Detailed program comprehension studies are expensive. Today, most of those studies are difficult to aggregate, as analysis methods for the data differ widely between researchers. As part of an effort to build a research infrastructure, a uniform, systematic analysis method for analyzing think-aloud protocols is proposed. This method is shown to be compatible with other analysis methods and extensible. It provides the possibility of aggregating results from experiments and leveraging results through such aggregation.	1092-8138	0-8186-7993-X			Protocols;Encoding;Computer science;Gratings;Programming profession;Software maintenance;Software tools;Guidelines;Documentation;Size control	reverse engineering	research infrastructure;program comprehension observations;program comprehension studies;systematic analysis method;think-aloud protocols;results aggregation		1		12		6 Aug 2002			IEEE	IEEE Conferences
A Case-Based Reasoning Method for Processing Model Recognition and Reuse in Program Comprehension	a casebased reasoning method for processing model recognition and reuse in program comprehension	10.1109/ICCIAS.2006.294101	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4072054	J. Qian; H. Chen; Y. Ding; F. Qi	College of Computer Engineering, University of Shanghai for Science and Technology, Shanghai, China; College of Computer Science and Technology, University of Zhejiang, Hangzhou, China; College of Computer Engineering, University of Shanghai for Science and Technology, Shanghai, China; College of Computer Science and Technology, University of Zhejiang, Hangzhou, China	2006 International Conference on Computational Intelligence and Security	29 jan. 2007	2006	1		113	116	Applying cased-based reasoning (CBR) method in program understanding provides a practical route towards more powerful software engineering technology. A CBR approach to the recognition of model component is presented, and the whole reasoning process of the recognition is presented, including a case representation method and a matching algorithm. A prototype system named process model component recognition & reuse (PMCRR) is developed to implement model transformation and reconstruction. At last, an example is illustrated to check the efficiency of CBR method		1-4244-0604-8			Information systems;Educational institutions;Power system modeling;Power engineering computing;Power engineering and energy;Software prototyping;Prototypes;Computer science;Software engineering;Data mining	case-based reasoning;object-oriented programming;reverse engineering;software reusability	case-based reasoning;program reuse;program comprehension;program understanding;software engineering;process model component recognition;model transformation;model reconstruction				7		29 jan. 2007			IEEE	IEEE Conferences
Working session: Tools for program comprehension: building a comprehender's workbench [Session intro.]	working session tools for program comprehension building a comprehenders workbench [session intro.]	10.1109/WPC.2000.852500	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852500	K. B. Gallagher	Computer Science Department, Loyola College, Baltimore, MD, USA	Proceedings IWPC 2000. 8th International Workshop on Program Comprehension	6 Aug 2002	2000			255	255	Comprehension, the primordial task, hasn't changed much in 40 years. Whether the comprehension task is global (architectural) or atomic (single statement effect), the approach is the same. We run it. We read it. We grep (search) it. An electronic search on the criteria "comprehension and tools" yielded no results. So while there is programmer's workbench, a maintainer's workbench, and a tester’s workbench, the comprehender’s workbench is evidently barren. While borrowing tools from other engineers gives a toe-hold, the question still arises: "What tools belong in a comprehender’s workbench, per se?" This workshop session will try to answer this question.	1092-8138	0-7695-0656-9			Educational institutions;Computer science;Testing;Software maintenance;Buildings;Maintenance engineering;File systems;Libraries;Biographies;NIST								6 Aug 2002			IEEE	IEEE Conferences
Program Comprehension and Code Complexity Metrics: A Replication Package of an fMRI Study	program comprehension and code complexity metrics a replication package of an fmri study	10.1109/ICSE-Companion52605.2021.00071	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9402616	N. Peitek; S. Apel; C. Parnin; A. Brechmann; J. Siegmund	Leibniz Institute for Neurobiology, Magdeburg, Germany; Saarland University, Saarbrücken, Germany; NC State University, Raleigh, North Carolina, USA; Leibniz Institute for Neurobiology Magdeburg, Magdeburg, Germany; Chemnitz University of Technology, Chemnitz, Germany	2021 IEEE/ACM 43rd International Conference on Software Engineering: Companion Proceedings (ICSE-Companion)	7 May 2021	2021			168	169	In this artifact, we document our publicly shared data set of our functional magnetic resonance imaging (fMRI) study on programmers. We have conducted an fMRI study with 19 participants observing program comprehension of short code snippets at varying complexity levels. We dissected four classes of code complexity metrics and their relationship to neuronal, behavioral, and subjective correlates of program comprehension. Our data corroborate that complexity metrics can-to a limited degree-explain programmers' cognition in program comprehension. In the paper on the fMRI study, we outline several follow-up experiments investigating fine-grained effects of code complexity and describe possible refinements to code complexity metrics. We view our conducted experiment as a starting point to link code complexity metrics to neural and behavioral correlates. To enable future research to continue this line of work, we aim to provide as much support as possible to conduct similar studies with this artifact.	2574-1926	978-1-6654-1219-3			Measurement;Functional magnetic resonance imaging;Cognition;Complexity theory;Software engineering	biomedical MRI;brain;cognition;neurophysiology;reverse engineering;software metrics;software tools	fMRI study;program comprehension;short code snippets;varying complexity levels;code complexity metrics;publicly shared data set;functional magnetic resonance imaging study				3		7 May 2021			IEEE	IEEE Conferences
Artifact Driven Communication to Improve Program Comprehension	artifact driven communication to improve program comprehension	10.1109/ICSE-C.2017.47	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7965383	J. Kubelka	Department of Computer Science (DCC), University of Chile, Santiago, Chile	2017 IEEE/ACM 39th International Conference on Software Engineering Companion (ICSE-C)	3 jul. 2017	2017			457	460	Developer communication is an important factor during program comprehension. Live programming environments encourage developers to comprehend applications through manipulation of running instances-liveness. Such application exploration is interrupted whenever programmers need to communicate an issue with dislocated co-workers. Describing the issue becomes challenging as programmers use text based communication mediums, e.g., emails or chats. The issues are magnified during bug day events, where developers around the world meet together in order to improve a project. Communication and coordination need to be increased, but the infrastructure stays the same. We target the research gap by introducing the COLLABORATIVE PLAYGROUND, a tool that exposes liveness into developer communication during programming change tasks and integrates coordination needs during bug day events. We will evaluate our approach by deploying the COLLABORATIVE PLAYGROUND during a series of Bug Day events for Pharo, one of the most active live programming platforms in existence.		978-1-5386-1589-8		Collaborative Programming;Live Programming Environment;Qualitative Study	Computer bugs;Collaboration;Tools;Programming;Libraries;Measurement;Electronic mail	groupware;program debugging	program comprehension;running instance manipulation;text based communication mediums;bug day events;collaborative playground;liveness;developer communication;programming change tasks;coordination needs integration;Pharo;live programming platforms;artifact driven communication				13		3 jul. 2017			IEEE	IEEE Conferences
15 Years of Program Comprehension	15 years of program comprehension	10.1109/ICPC.2007.1	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268263	S. Tilley	Department of Computer Sciences, Florida Institute of Technology, USA	15th IEEE International Conference on Program Comprehension (ICPC '07)	9 jul. 2007	2007			279	280	This paper looks back at fifteen years of program comprehension (WPC, IWPC, ICPC), gathering key themes and important issues that have been discussed. Since the traditional gift for a 15th anniversary is crystal, the workshop also strives to peer into the future and outline some of the coming challenges in the field for the next few years.	1092-8138	0-7695-2860-0			Conferences;Software engineering;Software maintenance;Application software;Particle measurements;Engineering profession;History;Time factors;IEEE Computer Society Press	reverse engineering;software maintenance	program comprehension;program understanding;software engineering;software maintenance				3		9 jul. 2007			IEEE	IEEE Conferences
Workshop on Program Comprehension through Dynamic Analysis (PCODA10)	workshop on program comprehension through dynamic analysis (pcoda10)	10.1109/WCRE.2010.40	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5645500	A. Hamou-Lhadj; D. Rothlisberger; A. Zaidman; O. Greevy	Concordia University, Montreal, QUE, Canada; University of Bern, Switzerland; Delft University of Technnology, Netherlands; Sw-eng Software Engineering GmbH, Switzerland	2010 17th Working Conference on Reverse Engineering	29 nov. 2010	2010			279	280	Applying program comprehension techniques may render software maintenance and evolution easier. Understanding a software system typically requires a combination of static and dynamic analysis techniques. The aim of this workshop is to bring together researchers and practitioners working in the area of program comprehension with an emphasis on dynamic analysis. We are interested in investigating how dynamic analysis techniques are used or can be used to enable better comprehension of a software system. The objective is to compare existing techniques, and to identify common case studies and possible symbioses for existing solutions. Building upon four previous editions of the workshop, we aim to set up a forum for exchanging experiences, discussing solutions, and exploring new ideas.	2375-5369	978-1-4244-8911-4			Conferences;Performance analysis;Reverse engineering;IEEE Computer Society;Software systems;Software maintenance;Special issues and sections						8		29 nov. 2010			IEEE	IEEE Conferences
An Empirical Study of Blindness and Program Comprehension	an empirical study of blindness and program comprehension		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7883372	A. Armaly	University of Notre Dame, Notre Dame, IN, US	2016 IEEE/ACM 38th International Conference on Software Engineering Companion (ICSE-C)	23 mar. 2017	2016			683	685	Blind programmers typically use a screen reader when reading code whereas sighted programmers are able to skim the code with their eyes. This difference has the potential to impact the generalizability of software engineering studies and approaches. We present a summary of a paper which will soon be under review at TSE that investigates how code comprehension of blind programmers differs from that of sighted programmers. Put briefly, we found no statistically-significant differences between the areas of code that the blind programmers found to be important and the areas of code that the sighted programmers found to be important.		978-1-4503-4205-6			Software engineering;Conferences;Computer languages;Programming;Measurement;Software maintenance;Blindness	computer aided instruction;handicapped aids;software engineering	software engineering studies;reading code;screen reader;blind programmers;blindness;program comprehension				17		23 mar. 2017			IEEE	IEEE Conferences
Lost comments support program comprehension	lost comments support program comprehension	10.1109/SANER.2017.7884680	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7884680	T. Omori	Department of Computer Science, Ritsumeikan University, Kusatsu, Shiga, Japan	2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER)	23 mar. 2017	2017			567	568	Source code comments are valuable to keep developers' explanations of code fragments. Proper comments help code readers understand the source code quickly and precisely. However, developers sometimes delete valuable comments since they do not know about the readers' knowledge and think the written comments are redundant. This paper describes a study of lost comments based on edit operation histories of source code. The experimental result shows that developers sometimes delete comments although their associated code fragments are not changed. Lost comments contain valuable descriptions that can be utilized as new data sources to support program comprehension.		978-1-5090-5501-2			History;Software;Encoding;Syntactics;Computer science;Writing;Data mining	software engineering;source code (software)	lost comments support program comprehension;source code comments;code fragments explanation;software developers;edit operation histories				4		23 mar. 2017			IEEE	IEEE Conferences
Empirical Assessment of Program Comprehension Styles in Programming Language Paradigms	empirical assessment of program comprehension styles in programming language paradigms	10.1109/VL/HCC51201.2021.9576333	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9576333	N. Mansoor	Department of Computer Science and Engineering, University of Nebraska-Lincoln, Lincoln, Nebraska, USA	2021 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)	29 Oct 2021	2021			1	2	Developers work with different programming languages and tools throughout their careers. It is a critical skill to be able to build on existing skills and knowledge and learn new programming languages as needed. This makes exploring how developers learn and comprehend different types of programming languages an interesting problem. The research question I plan to address with my research is: how do developers' mental model change when they learn and understand code written in different families of programming languages? My research goals are to leverage empirical software engineering and cognitive sciences to understand learning and program comprehension in developers for answering this research question. I do this by conducting empirical studies on comprehension patterns of developers of varying skill levels using different language paradigms (imperative, declarative, and functional) while they work on a varied set of software tasks such as bug fixes, verification of static analysis alarms, adding new features, code refactoring, and code summarization. The proposed empirical studies are designed using a combination of online questionnaires and biometric equipment (eye trackers) and are performed on both program comprehension and a set of established cognitive tasks with the aim of determining whether there is indeed a relationship between these different tasks and domains on performance. The eye tracking biometric measures provide fine grained details on what tokens/words in code/text developers look at as they work. This better explains the thought process and mental models developers use to solve tasks. I propose multiple studies for which I will recruit both students and professional developers in order to understand the strategies of different levels of expertise. In addition, various other factors such as native language, reading speed, years of experience, programming expertise, cognitive scores (among others) will be used to further describe the data collected on tasks.	1943-6106	978-1-6654-4592-4			Computer languages;Visualization;Codes;Biometrics (access control);Static analysis;Tools;Software	biometrics (access control);cognition;computer aided instruction;computer science education;human computer interaction;program debugging;program diagnostics;programming languages;software maintenance;software quality	cognitive sciences;varying skill levels;language paradigms;mental models developers;professional developers;native language;empirical assessment;program comprehension styles;programming language paradigms;research goals;empirical software engineering;eye trackers;eye tracking biometric measures;programming expertise;cognitive scores				5	IEEE	29 Oct 2021			IEEE	IEEE Conferences
A study on assisting in Prolog program comprehension by using stepwise execution and stepwise comparison	a study on assisting in prolog program comprehension by using stepwise execution and stepwise comparison	10.1109/CIE.2002.1185876	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1185876	Y. Deguchi; M. Nakamura; S. Otsuki	Graduate School of Information Sciences, Hiroshima City University, Japan; Graduate School of Information Sciences, Hiroshima City University, Japan; Graduate School of Information Sciences, Hiroshima City University, Japan	International Conference on Computers in Education, 2002. Proceedings.	20 mar. 2003	2002			106	110 vol.1	Reading a program, learners must understand syntax, semantics, and usage, which are characteristics of each individual programming language. Moreover, they must acquire typical writing art through understanding various good programs. In order to obtain good programming methods, learners must also know the execution flow of programs, which is difficult to explain statically. In this paper, as a learning environment for Prolog programs, an animation tree is proposed, which allows learners to interactively manipulate program execution back and forth in a stepwise manner. The effect of the animation tree in the problem solving process and the contents of finding through comparison of two programs with the same structure are investigated.		0-7695-1509-6			Computer languages;Animation;Problem-solving;Cognitive science;Magnetic heads;Writing;Art;Programming profession;Buildings;Computer science education	computer science education;computer animation;PROLOG;programming language semantics;flowcharting	Prolog program;syntax;semantics;usage;programming language;writing art;programming methods;program execution flow;animation tree;learning environment;stepwise execution;stepwise comparison;Prolog program comprehension						20 mar. 2003			IEEE	IEEE Conferences
Tree-matching object concept assignment to support program comprehension	treematching object concept assignment to support program comprehension	10.1109/ICCCYB.2004.1437719	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1437719	Chen Hua; Qian Jianfei; Chen Qi; Yu Ruizhao	College of Computer Science, University of Zhejiang, Hangzhou, China; College of Computer Science, University of Zhejiang, Hangzhou, China; College of Computer Science, University of Zhejiang, Hangzhou, China; College of Computer Science, University of Zhejiang, Hangzhou, China	Second IEEE International Conference on Computational Cybernetics, 2004. ICCC 2004.	13 jun. 2005	2004			249	251	This paper outlines a method for assisting program comprehension by addressing the concept assignment problem. The method, termed tree-matching object concept assignment, uses information gathered from program execution to assign plausible object concept to source code. The candidate concepts are selected from knowledge base. An evaluation of prototype system has shown that the method can accurately recognize object concepts in a range of real-world programs		0-7803-8588-8			Software maintenance;Costs;Educational institutions;Computer science;Software systems;Software engineering;Prototypes;Typesetting;Desktop publishing;Application software	program diagnostics;reverse engineering;software maintenance	tree-matching object concept assignment;program comprehension;desktop publishing format;software maintenance				6		13 jun. 2005			IEEE	IEEE Conferences
Working Session: Program Comprehension and Migration Strategies for Web Service and Service-Oriented Architectures	working session program comprehension and migration strategies for web service and serviceoriented architectures	10.1109/ICPC.2006.52	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631126	D. Smith; L. O'Brien; K. Kontogiannis	Software Engineering Institute, USA; Lero-ISERC, Ireland; University of Waterloo, Canada	14th IEEE International Conference on Program Comprehension (ICPC'06)	26 jun. 2006	2006			235	240	The migration to Web services has the potential of providing significant value to keeping legacy systems and components operational in a networked environment, a number of critical issues still need to be addressed. These issues can be classified in three categories; a) program comprehension and analysis issues; b) legacy system migration issues and; c) technology and standards issues. This paper discusses and debates approaches for addressing these issues. The paper's objective is twofold. First, is to explore the current state of the art in methods, tools and technologies that can assist in carrying out the required work and to identify a taxonomy of current approaches as well as, their strengths and weaknesses. The second objective is to identify open issues and research opportunities in the area of migrating legacy systems in Web enabled environments	1092-8138	0-7695-2601-2			Web services;Service oriented architecture;Computer architecture;Object oriented modeling;Software engineering;Web and internet services;Taxonomy;Application software;Middleware;Decision making	Internet;reverse engineering;software architecture	program comprehension;Web service;service-oriented architecture;legacy system;legacy system migration;taxonomy				6		26 jun. 2006			IEEE	IEEE Conferences
Automatic analysis of functional program style	automatic analysis of functional program style	10.1109/ASWEC.1996.534121	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=534121	G. Michaelson	Department of Computing and Electrical Engineering, Heriot-Watt University, UK	Proceedings of 1996 Australian Software Engineering Conference	6 Aug 2002	1996			38	46	Functional programming style is discussed and seven simple semantic style rules, based on program transformation, are enunciated. An automatic style analyser developed from these rules is then presented.		0-8186-7635-3			Computer languages;Automatic programming;Natural languages;Functional programming;Testing;Writing;Humans;Computer errors;Program processors;Optimizing compilers	functional programming;functional languages;automatic programming	automatic analysis;functional program style;functional programming style;simple semantic style rules;program transformation;automatic style analyser		4		25		6 Aug 2002			IEEE	IEEE Conferences
Impacts of Coding Practices on Readability	impacts of coding practices on readability		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8972984	R. Magalhães dos Santos; M. Aurélio Gerosa	Instituto de Pesquisas Tecnologicas de Sao Paulo; Northern Arizona University, Flagstaff, AZ, USA	2018 IEEE/ACM 26th International Conference on Program Comprehension (ICPC)	30 jan. 2020	2018			277	2778	Several conventions and standards aim to improve maintain-ability of software code. However, low levels of code readability perceived by developers still represent a barrier to their daily work. In this paper, we describe a survey that assessed the impact of a set of Java coding practices on the readability perceived by software developers. While some practices promoted an enhancement of readability, others did not show statistically significant effects. Interestingly, one of the practices worsened the readability. Our results may help to identify coding conventions with a positive impact on readability and, thus, guide the creation of coding standards.	2643-7171	978-1-4503-5714-2		Code Readability;Code Comprehension;Programming Style;Coding Best Practices;Software Developers' Opinions Survey		Java;software maintenance;software standards	software code;code readability;Java coding practices;software developers;coding standards				29		30 jan. 2020			IEEE	IEEE Conferences
Program readability: procedures versus comments	program readability procedures versus comments	10.1109/32.6171	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6171	T. Tenny	Department of Computer Science, Texas Christian University, Fort Worth, TX, USA	IEEE Transactions on Software Engineering	6 Aug 2002	1988	14	9	1271	1279	A 3*2 factorial experiment was performed to compare the effects of procedure format (none, internal, or external) with those of comments (absent or present) on the readability of a PL/1 program. The readability of six editions of the program, each having a different combination of these factors, was inferred from the accuracy with which students could answer questions about the program after reading it. Both extremes in readability occurred in the program editions having no procedures: without comments the procedureless program was the least readable and with comments it was the most readable.<>	1939-3520				Testing;Programming profession;Software engineering;Proposals;Costs;Computer science	PL/1;programming	procedures;comments;factorial experiment;procedure format;PL/1 program;readability		82		13	IEEE	6 Aug 2002			IEEE	IEEE Journals
An Empirical Study on the Impact of C++ Lambdas and Programmer Experience	an empirical study on the impact of c++ lambdas and programmer experience	10.1145/2884781.2884849	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886954	P. M. Uesbeck; A. Stefik; S. Hanenberg; J. Pedersen; P. Daleiden	Department of Computer Science, University of Nevada, Las Vegas, Nevada; Department of Computer Science, University of Nevada, Las Vegas, Nevada; Universitat Duisburg-Essen, Duisburg, Nordrhein-Westfalen, DE; Department of Computer Science, University of Nevada, Las Vegas, Nevada; Department of Computer Science, University of Nevada, Las Vegas, Nevada	2016 IEEE/ACM 38th International Conference on Software Engineering (ICSE)	3 Apr 2017	2016			760	771	Lambdas have seen increasing use in mainstream programming languages, notably in Java 8 and C++ 11. While the technical aspects of lambdas are known, we conducted the first randomized controlled trial on the human factors impact of C++ 11 lambdas compared to iterators. Because there has been recent debate on having students or professionals in experiments, we recruited undergraduates across the academic pipeline and professional programmers to evaluate these findings in a broader context. Results afford some doubt that lambdas benefit developers and show evidence that students are negatively impacted in regard to how quickly they can write correct programs to a test specification and whether they can complete a task. Analysis from log data shows that participants spent more time with compiler errors, and have more errors, when using lambdas as compared to iterators, suggesting difficulty with the syntax chosen for C++. Finally, experienced users were more likely to complete tasks, with or without lambdas, and could do so more quickly, with experience as a factor explaining 45.7% of the variance in our sample in regard to completion time.	1558-1225	978-1-4503-3900-1		Lambda Expressions;Human Factors;C++11	C++ languages;Java;Syntactics;Context;Algorithm design and analysis;Libraries	C++ language;formal specification	C++ lambda;programmer experience;mainstream programming languages;Java 8 languages;C++ 11 languages;test specification		16		59		3 Apr 2017			IEEE	IEEE Conferences
Enhancing program readability and comprehensibility with tools for program visualization	enhancing program readability and comprehensibility with tools for program visualization	10.1109/ICSE.1988.93716	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=93716	R. Baecker	Dept. of Comput. Sci., Toronto Univ., Ont., Canada	Proceedings. [1989] 11th International Conference on Software Engineering	6 Aug 2002	1988			356	366	To make computer programs for comprehensible, the presentation of program source text, program documentation, and program execution needs to be enhanced. A number of techniques and tools developed to achieve these ends are described. One of these is a design for the effective presentation of source text in the C programming language using high-quality digital typography; a processor which implements the design is also given. Some experimental evidence is summarized to demonstrate that the resulting source text presentation is significantly more readable and comprehensible than the presentation conventionally used today. Brief descriptions are given of two other techniques, the development of a system of structured program documentation incorporating both text and graphics and the portrayal of program execution with colored computer animation.<>		0-89791-258-6			Visualization;Computer graphics;Animation;Computer interfaces;Software engineering;Programming profession;Computer languages;Writing;Computer aided software engineering;Computer science	software tools;system documentation	software tools;program readability;comprehensibility;program visualization;computer programs;program source text;program documentation;program execution;C programming language;high-quality digital typography;structured program documentation;graphics;program execution;colored computer animation		8		66		6 Aug 2002			IEEE	IEEE Conferences
Program factors as predictors of program readability	program factors as predictors of program readability	10.1109/CMPSAC.1979.762579	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=762579	G. E. DeYoung; G. R. Kampen	Department of Psychology, Saint Louis University, USA; Department of Computer Science, University of Illinois, USA	COMPSAC 79. Proceedings. Computer Software and The IEEE Computer Society's Third International Applications Conference, 1979.	10 Dec 2002	1979			668	673	In comparison with such objective aspects of program quality as efficiency and correctness, readability is elusive and hard-to-measure. Since it is surely an important factor in the cost of maintaining a program over its lifetime, the usefulness of an accurate and inexpensive measure of readability is obvious. In an attempt to find such a measure, a set of 30 Algol 68 programs written by students in an upper-level course was graded by hand for readability and the results compared with a set of program parameters extracted by a SNOBOL program. Correlation and multiple regression techniques were used to test hypotheses suggested in the literature on program quality, and to find a combination of parameters with maximum predictive value. A set of three variables was found to be effective in predicting readability.					Psychology;Costs;Testing;Programming profession;Guidelines;Maintenance;Area measurement;Software measurement;Program processors;Feedback				1		14		10 Dec 2002			IEEE	IEEE Conferences
Understand Code Style: Efficient CNN-Based Compiler Optimization Recognition System	understand code style efficient cnnbased compiler optimization recognition system	10.1109/ICC.2019.8761073	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8761073	S. Yang; Z. Shi; G. Zhang; M. Li; Y. Ma; L. Sun	School of Cyber Security, University of Chinese Academy of Sciences, Beijing, China; School of Cyber Security, University of Chinese Academy of Sciences, Beijing, China; School of Cyber Security, University of Chinese Academy of Sciences, Beijing, China; School of Cyber Security, University of Chinese Academy of Sciences, Beijing, China; School of Cyber Security, University of Chinese Academy of Sciences, Beijing, China; School of Cyber Security, University of Chinese Academy of Sciences, Beijing, China	ICC 2019 - 2019 IEEE International Conference on Communications (ICC)	15 jul. 2019	2019			1	6	Compiler optimization level recognition can be applied to vulnerability discovery and binary analysis. Due to the exists of many different compilation optimization options, the difference in the contents of the binary file is very complicated. There are thousands of compiler optimization algorithms and multiple different processor architectures, so it is very difficult to manually analyze binary files and recognize its compiler optimization level with rules. This paper first proposes a CNN-based compiler optimization level recognition model: BinEye. The system extracts semantic and structural differences and automatically recognize the compiler optimization levels. The model is designed to be very suitable for binary file processing and is easy to understand. We built a dataset containing 80028 binary files for the model training and testing. Our proposed model achieves an accuracy of over 97%. At the same time, BinEye is a fully CNN-based system and it has a faster forward calculation speed, at least 8 times faster than the normal RNN-based model. Through our analysis of the model output, we successfully found the difference in assembly codes caused by the different compiler optimization level. This means that the model we proposed is interpretable. Based on our model, we propose a method to analyze the code differences caused by different compiler optimization levels, which has great guiding significance for analyzing closed source compilers and binary security analysis.	1938-1883	978-1-5386-8088-9			Optimization;Security;Convolution;Analytical models;Task analysis;Software;Semantics	convolutional neural nets;optimising compilers;recurrent neural nets;security of data	compiler optimization algorithms;CNN-based compiler optimization level recognition model;binary file processing;closed source compilers;binary security analysis;understand code style;RNN-based model;CNN-based compiler optimization recognition system		7		21		15 jul. 2019			IEEE	IEEE Conferences
From code understanding needs to reverse engineering tool capabilities	from code understanding needs to reverse engineering tool capabilities	10.1109/CASE.1993.634824	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=634824	A. von Mayrhauser; A. M. Vans	Department of Computer Science, Colorado State University, Fort Collins, CO, USA; Department of Computer Science, Colorado State University, Fort Collins, CO, USA	Proceedings of 6th International Workshop on Computer-Aided Software Engineering	6 Aug 2002	1993			230	239	A major portion of the software maintenance effort is spent on the reverse engineering activity of understanding existing software. If one can learn more about how programmers understand code successfully, one can build better tools to support the understanding process. This contributes to higher quality and improved efficiency of maintenance tasks. An integrated code comprehension model and experiences with it in an industrial setting are presented. Audio-taped, think-aloud reports were used to investigate how well the integrated code comprehension model works during industrial maintenance activities that range from code fixes to enhancements, code leverage, and reuse. The tapes were analyzed for information needs during maintenance activities, and tool capabilities were derived accordingly. The results are presented and discussed.	1066-1387	0-8186-3480-4			Programming profession;Cognition;Switches;Computer science;Software maintenance;Reverse engineering;Information analysis;Computer industry;Electrical equipment industry;Large-scale systems	reverse engineering	audio-taped think-aloud reports;code enhancements;code reuse;understanding needs;reverse engineering tool capabilities;software maintenance;quality;efficiency;integrated code comprehension model;industrial maintenance activities;code fixes;code leverage;information needs		31		22		6 Aug 2002			IEEE	IEEE Conferences
Reusing Program Investigation Knowledge for Code Understanding	reusing program investigation knowledge for code understanding	10.1109/ICPC.2008.10	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556132	M. P. Robillard; P. Manggala	School of Computer Science, McGill University, Montreal, QUE, Canada; School of Computer Science, McGill University, Montreal, QUE, Canada	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			202	211	Software maintenance tasks typically involve an important amount of program investigation effort on the part of software developers. To what extent can we benefit from prior program investigation activities to decrease this effort? To investigate this question, we studied the revision history of two systems to determine how knowledge derived from prior investigation activities could have been reused to support other change tasks. Our initial investigation used a tool, ConcernDetector, that can recommend sets of program elements associated with a high-level concern when elements in the set overlap with elements currently being modified. We discovered that simple overlap-based techniques for retrieving prior investigation knowledge have important limitations, and that effective reuse of prior program investigation knowledge requires analyses that can partially infer the nature and intent of a task.	1092-8138	978-0-7695-3176-2		Program Investigation;Concerns;Software Navigation;Knowledge Reuse	Software maintenance;History;Documentation;Computer science;Software systems;Computer bugs;Joining processes;Open source software;Context modeling	software maintenance	program investigation knowledge;code understanding;software maintenance;software developers;ConcernDetector;high-level concern;overlap-based techniques		4		22		2 jul. 2008			IEEE	IEEE Conferences
Code understanding through program transformation for reusable component identification	code understanding through program transformation for reusable component identification	10.1109/WPC.1997.601283	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601283	Hongj Yang; P. Luker; W. C. Chu	Department of Computer Science, De Montfort University, UK; Department of Computer Science, De Montfort University, UK; Department of Information Engineering, Feng Chia University FCU, Taiwan	Proceedings Fifth International Workshop on Program Comprehension. IWPC'97	6 Aug 2002	1997			148	157	Code understanding is the most essential step in all post delivery software activities such as software maintenance and reuse. In the Reverse-engineering Reuse Redevelopment Assistant (R/sup 3/ A), a tool aimed at providing a comprehensive approach for all post delivery software activities, code understanding has been addressed by reverse engineering through program transformation. The paper proposes a method to deal with this problem and discusses in detail how program transformation techniques, program comprehension techniques and the role of human knowledge are integrated into R/sup 3/ A, i.e., how they are used during reverse engineering to recognise reusable components, and how they are used by semantic interface analysis to represent formally reusable components. The experiments conducted strongly suggest the proposed method is a practical approach to software reuse.	1092-8138	0-8186-7993-X			Software maintenance;Reverse engineering;Information resources;Software tools;Humans;Computer science;Recycling;Costs;Hardware;Software testing	reverse engineering;software maintenance;software reusability;software tools;formal specification	code understanding;program transformation;reusable component identification;post delivery software activities;software maintenance;Reverse-engineering Reuse Redevelopment Assistant;R/sup 3/ A;reverse engineering;program comprehension techniques;human knowledge;reusable components;semantic interface analysis;formally reusable components;software reuse		3	4	20		6 Aug 2002			IEEE	IEEE Conferences
Novice Code Understanding Strategies during a Software Maintenance Assignment	novice code understanding strategies during a software maintenance assignment	10.1109/ICSE.2015.341	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202973	C. Szabo	School of Computer Science, The University of Adelaide, Adelaide, Australia	2015 IEEE/ACM 37th IEEE International Conference on Software Engineering	17 Aug 2015	2015	2		276	284	Existing efforts on teaching software maintenance have focussed on constructing adequate codebases that students with limited knowledge could maintain, with little focus on the learning outcomes of such exercises and of the approaches that students employ while performing maintenance. An analysis of the code understanding strategies employed by novice students as they perform software maintenance exercises is fundamental for the effective teaching of software maintenance. In this paper, we analyze the strategies employed by second year students in a maintenance exercise over a large codebase. We analyze student reflections on their code understanding, maintenance process and the use of tools. We show that students are generally capable of working with large codebases. Our study also finds that the majority of students follow a systematic approach to code understanding, but that their approach can be significantly improved through the use of tools and a better understanding of reverse engineering approaches.	1558-1225	978-1-4799-1934-5		software maintenance;software engineering;cognitive models	Software maintenance;Maintenance engineering;Software engineering;Education;Testing;Systematics	computer science education;reverse engineering;software maintenance	novice code understanding strategies;software maintenance assignment;adequate codebases;learning outcomes;novice students;software maintenance exercises;second year students;reverse engineering approaches		2		20		17 Aug 2015			IEEE	IEEE Conferences
MulCode: A Multi-task Learning Approach for Source Code Understanding	mulcode a multitask learning approach for source code understanding	10.1109/SANER50967.2021.00014	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9426045	D. Wang; Y. Yu; S. Li; W. Dong; J. Wang; L. Qing	College of Computer Science, National University of Defense Technology, Changsha, China; College of Computer Science, National University of Defense Technology, Changsha, China; College of Computer Science, National University of Defense Technology, Changsha, China; College of Computer Science, National University of Defense Technology, Changsha, China; College of Computer Science, National University of Defense Technology, Changsha, China; College of Computer Science and Technology, Harbin Institute of Technology (Shenzhen), Shenzhen, China	2021 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)	11 May 2021	2021			48	59	Recent years have witnessed the significant rise of Deep Learning (DL) techniques applied to source code. Researchers exploit DL for a multitude of tasks and achieve impressive results. However, most tasks are explored separately, resulting in a lack of generalization of the solutions. In this work, we propose MulCode, a multi-task learning approach for source code understanding that learns unified representation space for tasks, with the pre-trained BERT model for the token sequence and the Tree-LSTM model for abstract syntax trees. Furthermore, we integrate two source code views into a hybrid representation via the attention mechanism and set learnable uncertainty parameters to adjust the tasks' relationship.We train and evaluate MulCode in three downstream tasks: comment classification, author attribution, and duplicate function detection. In all tasks, MulCode outperforms the state-of-the-art techniques. Moreover, experiments on three unseen tasks demonstrate the generalization ability of MulCode compared with state-of-the-art embedding methods.	1534-5351	978-1-7281-9630-5	National Natural Science Foundation of China; National Key Research and Development Program of China; 	representation learning;deep learning;multi-task learning;attention mechanism	Deep learning;Uncertainty;Conferences;Bit error rate;Syntactics;Software;Task analysis	deep learning (artificial intelligence);pattern classification;source code (software);trees (mathematics)	duplicate function detection;author attribution;comment classification;attention mechanism;unseen tasks;downstream tasks;source code views;tree-LSTM model;pretrained BERT model;multitask learning approach;MulCode		2		55		11 May 2021			IEEE	IEEE Conferences
Bridging Pre-trained Models and Downstream Tasks for Source Code Understanding	bridging pretrained models and downstream tasks for source code understanding	10.1145/3510003.3510062	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9793959	D. Wang; Z. Jia; S. Li; Y. Yu; Y. Xiong; W. Dong; X. Liao	National University of Defense Technology, China; National University of Defense Technology, China; National University of Defense Technology, China; National University of Defense Technology, China; Fudan University, Shanghai, China; National University of Defense Technology, China; National University of Defense Technology, China	2022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)	20 jun. 2022	2022			287	298	With the great success of pre-trained models, the pretrain-then-fine tune paradigm has been widely adopted on downstream tasks for source code understanding. However, compared to costly training a large-scale model from scratch, how to effectively adapt pre-trained models to a new task has not been fully explored. In this paper, we propose an approach to bridge pre-trained models and code-related tasks. We exploit semantic-preserving transformation to enrich downstream data diversity, and help pre-trained models learn semantic features invariant to these semantically equivalent transformations. Further, we introduce curriculum learning to or-ganize the transformed data in an easy-to-hard manner to fine-tune existing pre-trained models. We apply our approach to a range of pre-trained models, and they significantly outperform the state-of-the-art models on tasks for source code understanding, such as algorithm classification, code clone detection, and code search. Our experiments even show that without heavy pre-training on code data, natural language pre-trained model RoBERTa fine-tuned with our lightweight approach could outperform or rival existing code pre-trained models fine-tuned on the above tasks, such as CodeBERT and GraphCodeBERT. This finding suggests that there is still much room for improvement in code pre-trained models.	1558-1225	978-1-4503-9221-1	National Natural Science Foundation of China(grant numbers:61690203,61872373,62032019,U1936213); 	fine-tuning;data augmentation;curriculum learning;test-time aug-mentation	Training;Adaptation models;Codes;Natural languages;Semantics;Cloning;Data models	learning (artificial intelligence);natural language processing;software maintenance	source code understanding;downstream tasks;existing pre-trained models;heavy pre-training;natural language pre-trained model RoBERTa fine-tuned;existing code pre-trained models;bridging pre-trained models				58		20 jun. 2022			IEEE	IEEE Conferences
Improving code readability models with textual features	improving code readability models with textual features	10.1109/ICPC.2016.7503707	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7503707	S. Scalabrino; M. Linares-Vásquez; D. Poshyvanyk; R. Oliveto	University of Molise, Pesche, IS, Italy; The College of William and Mary, Williamsburg, Virginia, USA; The College of William and Mary, Williamsburg, Virginia, USA; University of Molise, Pesche, IS, Italy	2016 IEEE 24th International Conference on Program Comprehension (ICPC)	7 jul. 2016	2016			1	10	Code reading is one of the most frequent activities in software maintenance; before implementing changes, it is necessary to fully understand source code often written by other developers. Thus, readability is a crucial aspect of source code that may significantly influence program comprehension effort. In general, models used to estimate software readability take into account only structural aspects of source code, e.g., line length and a number of comments. However, source code is a particular form of text; therefore, a code readability model should not ignore the textual aspects of source code encapsulated in identifiers and comments. In this paper, we propose a set of textual features aimed at measuring code readability. We evaluated the proposed textual features on 600 code snippets manually evaluated (in terms of readability) by 5K+ people. The results demonstrate that the proposed features complement classic structural features when predicting code readability judgments. Consequently, a code readability model based on a richer set of features, including the ones proposed in this paper, achieves a significantly higher accuracy as compared to all of the state-of-the-art readability models.		978-1-5090-1428-6			Feature extraction;Syntactics;Visualization;Computational modeling;Semantics;Software quality	software maintenance;source code (software);text analysis	code readability models;textual features;software maintenance;source code;program comprehension effort;software readability;line length;code snippets		54		46		7 jul. 2016			IEEE	IEEE Conferences
Improving Source Code Readability: Theory and Practice	improving source code readability theory and practice	10.1109/ICPC.2019.00014	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813254	S. Fakhoury; D. Roy; A. Hassan; V. Arnaoudova	School of Electrical Engineering and Computer Science, Washington State University, Pullman (WA), USA; School of Electrical Engineering and Computer Science, Washington State University, Pullman (WA), USA; Infosapex Limited, Dhaka, Bangladesh; School of Electrical Engineering and Computer Science, Washington State University, Pullman (WA), USA	2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC)	29 Aug 2019	2019			2	12	There are several widely accepted metrics to measure code quality that are currently being used in both research and practice to detect code smells and to find opportunities for code improvement. Although these metrics have been proposed as a proxy of code quality, recent research suggests that more often than not, state-of-the-art code quality metrics do not successfully capture quality improvements in the source code as perceived by developers. More specifically, results show that there may be inconsistencies between, on the one hand, the results from metrics for cohesion, coupling, complexity, and readability, and, on the other hand, the interpretation of these metrics in practice. As code improvement tools rely on these metrics, there is a clear need to identify and resolve the aforementioned inconsistencies. This will allow for the creation of tools that are more aligned with developers' perception of quality, and can more effectively help source code improvement efforts. In this study, we investigate 548 instances of source code readability improvements, as explicitly stated by internal developers in practice, from 63 engineered software projects. We show that current readability models fail to capture readability improvements. We also show that tools to calculate additional metrics, to detect refactorings, and to detect style problems are able to capture characteristics that are specific to readability changes and thus should be considered by future readability models.	2643-7171	978-1-7281-1519-1		Readability;Code Quality metrics;Developers perception		project management;software maintenance;software metrics;software quality;source code (software)	code smells;quality improvements;code improvement tools;readability changes;code quality metrics;source code readability;engineered software projects;refactorings		19		34		29 Aug 2019			IEEE	IEEE Conferences
Code Readability Testing, an Empirical Study	code readability testing, an empirical study	10.1109/CSEET.2016.36	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7474473	T. Sedano	Silicon Valley Campus, Carnegie Mellon Unveristy, Moffett Field, CA, USA	2016 IEEE 29th International Conference on Software Engineering Education and Training (CSEET)	23 May 2016	2016			111	117	Context: One of the factors that leads to improved code maintainability is its readability. When code is difficult to read, it is difficult for subsequent developers to understand its flow and its side effects. They are likely to introduce new bugs while trying to fix old bugs or adding new features. But how do software developers know they have written readable code? Objective: This paper presents a new technique, Code Readability Testing, to determine whether code is readable and evaluates whether the technique increases programmers' ability to write readable code. Method: The researcher conducted a field study using 21 software engineering master students and followed the Code Readability Testing with each student in four separate sessions evaluating different "production ready" software. After the observations, a questionnaire evaluated the programmer's perspective. Results: By following Code Readability Testing, half of the programmers writing "unreadable" code started writing "readable" code after four sessions. Programmers writing "readable" code also improved their ability to write readable code. The study reveals that the most frequent suggestions for increasing code readability are improving variable names, improving method names, creating new methods in order to reduce code duplication, simplifying if conditions and structures, and simplifying loop conditions. The programmers report that readability testing is worth their time. They observe increases in their ability to write readable code. When programmers experience a reader struggling to understand their code, they become motivated to write readable code. Conclusion: This paper defines code readability, demonstrates that Code Readability Testing improves programmers' ability to write readable code, and identifies frequent fixes needed to improve code readability.	2377-570X	978-1-5090-0765-3			Testing;Software;Programming profession;Writing;Software engineering;Computers	computer science education;program control structures;software maintenance	code readability testing;code maintainability;readable code;code duplication reduction;loop conditions;software engineering master students		11		30		23 May 2016			IEEE	IEEE Conferences
A new decapsulating the frame method for DVB-S2 based on RM code	a new decapsulating the frame method for dvbs2 based on rm code	10.1109/MEC.2011.6025916	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6025916	X. Rui; X. Lina; L. Xiaoru; Z. Tao	Dept. electronic engineering department, North china institute of aerospace engineering, LangFang, China; Dept. electronic engineering department, North china institute of aerospace engineering, LangFang, China; Dept. Communication Station, National Meteorological Information Center, Beijing, China; Dept. electronic engineering department, North china institute of aerospace engineering, LangFang, China	2011 International Conference on Mechatronic Science, Electric Engineering and Computer (MEC)	22 Sep 2011	2011			2147	2150	The structure of the Physical Layer Frame (PLHFRAME) is flexible for DVB-S2 system. At the receiver, it is critical for decapsulating the frame design. By further analyzing the structure of the PLHFRAME, we find some useful properties and also introduce some optimizations into the algorithm. The algorithm is based on a first order Reed-Muller (RM) code to achieve decapsulating the frame. The design scheme has implemented on Xilinx Virtex xc4vlx25 FPGA. Hardware test results show that the new scheme can be achieved under large carrier frequency offset (as large as 5MHz at 25MSps) and low SNR threshold of-2.5dB.		978-1-61284-722-1		decapsulating the frame;Reed-Muller code;formatting;FPGA	Synchronization;Digital video broadcasting;Receivers;Field programmable gate arrays;Encoding;Physical layer;Detectors	digital video broadcasting;field programmable gate arrays;optimisation;radio receivers;Reed-Muller codes	Reed-Muller code;RM code;frame method;DVB-S2;physical layer frame;receiver;optimizations;Xilinx Virtex xc4vlx25 FPGA;hardware test				6		22 Sep 2011			IEEE	IEEE Conferences
An Exploratory Study of How Developers Seek, Relate, and Collect Relevant Information during Software Maintenance Tasks	an exploratory study of how developers seek, relate, and collect relevant information during software maintenance tasks	10.1109/TSE.2006.116	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4016573	A. J. Ko; B. A. Myers; M. J. Coblenz; H. H. Aung	Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA; Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA; Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA; Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA	IEEE Transactions on Software Engineering	30 nov. 2006	2006	32	12	971	987	Much of software developers' time is spent understanding unfamiliar code. To better understand how developers gain this understanding and how software development environments might be involved, a study was performed in which developers were given an unfamiliar program and asked to work on two debugging tasks and three enhancement tasks for 70 minutes. The study found that developers interleaved three activities. They began by searching for relevant code both manually and using search tools; however, they based their searches on limited and misrepresentative cues in the code, environment, and executing program, often leading to failed searches. When developers found relevant code, they followed its incoming and outgoing dependencies, often returning to it and navigating its other dependencies; while doing so, however, Eclipse's navigational tools caused significant overhead. Developers collected code and other information that they believed would be necessary to edit, duplicate, or otherwise refer to later by encoding it in the interactive state of Eclipse's package explorer, file tabs, and scroll bars. However, developers lost track of relevant code as these interfaces were used for other tasks, and developers were forced to find it again. These issues caused developers to spend, on average, 35 percent of their time performing the mechanics of navigation within and between source files. These observations suggest a new model of program understanding grounded in theories of information foraging and suggest ideas for tools that help developers seek, relate, and collect information in a more effective and explicit manner.	1939-3520			Program investigation;program understanding;program comprehension;empirical software engineering;information foraging;information scent.	Software maintenance;Programming;Navigation;Software engineering;Software tools;Performance gain;Debugging;Encoding;Packaging;Bars	program debugging;software maintenance	software maintenance tasks;software development environment;debugging task;search tool;Eclipse package explorer;file tabs;scroll bars;source files;program understanding;information foraging		376	1	51	IEEE	30 nov. 2006			IEEE	IEEE Journals
Recognizing Sorting Algorithms with the C4.5 Decision Tree Classifier	recognizing sorting algorithms with the c4.5 decision tree classifier	10.1109/ICPC.2010.11	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521763	A. Taherkhani	Department of Computer Science and Engineering, Aalto University of Science and Technology, Aalto, Finland	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			72	75	We present a method for automatic algorithm recognition, which consists of two phases. First, the target algorithms are converted into characteristic vectors, which are computed based on static analysis of program code including various statistics of language constructs and analysis of Roles of Variables. In the second phase, the algorithms are classified based on these vectors using the C4.5 decision tree classifier. We have developed a prototype and successfully applied the method to sorting algorithms. Evaluated with leave-one-out technique, the accuracy of the constructed decision tree classifier is 97.1%.	1092-8138	978-1-4244-7603-9		Algorithm recognition;program comprehension;program understanding;roles of variables;C4.5 algorithm	Sorting;Decision trees;Classification tree analysis;Algorithm design and analysis;Statistical analysis;Computer science;Prototypes;Computational complexity;Computer languages;Programming profession	decision trees;pattern classification;sorting;statistical analysis	sorting algorithms;algorithm recognition;C4.5 decision tree classifier;language constructs statistics;program code analysis;roles-of-variables analysis;leave-one-out technique		9		23		26 jul. 2010			IEEE	IEEE Conferences
Software Reliability Model for Modular Program Structure	software reliability model for modular program structure	10.1109/TR.1979.5220576	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5220576	B. Littlewood	City University, London, UK	IEEE Transactions on Reliability	25 Aug 2009	1979	R-28	3	241	246	The paper treats a modular program in which transfers of control between modules follow a semi-Markov process. Each module is failure-prone, and the different failure processes are assumed to be Poisson. The transfers of control between modules (interfaces) are themselves subject to failure. The overall failure process of the program is described, and an asymptotic Poisson process approximation is given for the case when the individual modules and interfaces are very reliable. A simple formula gives the failure rate of the overall program (and hence mean time between failures) under this limiting condition. The remainder of the paper treats the consequences of failures. Each failure results in a cost, represented by a random variable with a distribution typical of the type of failure. The quantity of interest is the total cost of running the program for a time t, and a simple approximating distribution is given for large t. The parameters of this limiting distribution are functions only of the means and variances of the underlying distributions, and are thus readily estimable. A calculation of program availability is given as an example of the cost process. There follows a brief discussion of methods of estimating the parameters of the model, with suggestions of areas in which it might be used.	1558-1721			Software reliability measurement;Software reliability costs;Modular software reliability;Semi-Markov process;Asymptotic Poisson process;Software failure costs;Software life-cycle costs;Availability	Software reliability;Costs;Hardware;Space technology;Software measurement;Battery powered vehicles;Traffic control;Manufacturing processes;Process control;Application software				153		16		25 Aug 2009			IEEE	IEEE Journals
Test Case Prioritization Based on Analysis of Program Structure	test case prioritization based on analysis of program structure	10.1109/APSEC.2008.63	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4724580	Z. Ma; J. Zhao	Department of Computer Science, Shanghai Jiaotong university, Shanghai, China; Department of Computer Science, Shanghai Jiaotong university, Shanghai, China	2008 15th Asia-Pacific Software Engineering Conference	22 Dec 2008	2008			471	478	Test case prioritization techniques have been empirically proved to be effective in improving the rate of fault detection in regression testing. However, most of previous techniques assume that all the faults have equal severity, which dose not meet the practice. In addition, because most of the existing techniques rely on the information gained from previous execution of test cases or source code changes, few of them can be directly applied to non-regression testing. In this paper, aiming to improve the rate of severe faults detection for both regression testing and non-regression testing, we propose a novel test case prioritization approach based on the analysis of program structure. The key idea of our approach is the evaluation of testing-importance for each module (e.g., method) covered by test cases. As a proof of concept, we implement $Apros$, a test case prioritization tool, and perform an empirical study on two real, non-trivial Java programs. The experimental result represents that our approach could be a promising solution to improve the rate of severe faults detection.	1530-1362	978-0-7695-3446-6		Test case prioritization;call graph;program analysis	Fault detection;Software testing;Computer science;Computer bugs;Software engineering;Performance evaluation;Java;Information analysis;Fault location;System testing	Java;program testing;software engineering	test case prioritization;program structure analysis;regression testing;nontrivial Java programs		12	1	21		22 Dec 2008			IEEE	IEEE Conferences
Visual exploration of program structure, dependencies and metrics with SolidSX	visual exploration of program structure, dependencies and metrics with solidsx	10.1109/VISSOF.2011.6069461	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6069461	D. Reniers; L. Voinea; A. Telea	SolidSource BV, Netherlands; SolidSource BV, Netherlands; University of Groningen, Netherlands	2011 6th International Workshop on Visualizing Software for Understanding and Analysis (VISSOFT)	3 nov. 2011	2011			1	4	We present SolidSX, an visual analysis tool for code structure, dependencies, and metrics. Our tool facilitates the understanding of large program code bases by simplifying the entire pipeline from data acquisition up to visualization and interactive querying. Secondly, SolidSX is an easy to use, scalable, and configurable visualization component for compound attributed graphs extracted by third-party tools, easy to integrate by developers in their own applications. We detail the architecture and functions of SolidSX, present examples for its two use-cases, and outline insights collected from tool usage in academia and industry.		978-1-4577-0823-7			Visualization;Software;Measurement;Data visualization;Lenses;Layout;Databases	data visualisation	visual exploration;program structure;program dependencies;program metrics;SolidSX;visual analysis tool;program code understanding;data acquisition;interactive querying;configurable visualization component;compound attributed graphs		11		31		3 nov. 2011			IEEE	IEEE Conferences
Genetic Programming With Image-Related Operators and a Flexible Program Structure for Feature Learning in Image Classification	genetic programming with imagerelated operators and a flexible program structure for feature learning in image classification	10.1109/TEVC.2020.3002229	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9117044	Y. Bi; B. Xue; M. Zhang	School of Engineering and Computer Science, Victoria University of Wellington, Wellington, New Zealand; School of Engineering and Computer Science, Victoria University of Wellington, Wellington, New Zealand; School of Engineering and Computer Science, Victoria University of Wellington, Wellington, New Zealand	IEEE Transactions on Evolutionary Computation	28 jan. 2021	2021	25	1	87	101	Feature extraction is essential for solving image classification by transforming low-level pixel values into high-level features. However, extracting effective features from images is challenging due to high variations across images in scale, rotation, illumination, and background. Existing methods often have a fixed model complexity and require domain expertise. Genetic programming (GP) with a flexible representation can find the best solution without the use of domain knowledge. This article proposes a new GP-based approach to automatically learning informative features for different image classification tasks. In the new approach, a number of image-related operators, including filters, pooling operators, and feature extraction methods, are employed as functions. A flexible program structure is developed to integrate different functions and terminals into a single tree/solution. The new approach can evolve solutions of variable depths to extract various numbers and types of features from the images. The new approach is examined on 12 different image classification tasks of varying difficulty and compared with a large number of effective algorithms. The results show that the new approach achieves better classification performance than most benchmark methods. The analysis of the evolved programs/solutions and the visualization of the learned features provide deep insights on the proposed approach.	1941-0026		Marsden Fund of New Zealand Government(grant numbers:VUW1509,VUW1615); Science for Technological Innovation Challenge(grant numbers:E3603/2903); University Research Fund at Victoria University of Wellington(grant numbers:223805/3986); Ministry of Business, Innovation and Employment Data Science SSIF Fund(grant numbers:RTVU1914); National Natural Science Foundation of China(grant numbers:61876169); China Scholarship Council/Victoria University Scholarship; 	Evolutionary computation (EC);feature learning;genetic programming (GP);image classification;representation	Feature extraction;Task analysis;Histograms;Principal component analysis;Benchmark testing;Kernel;Artificial neural networks	feature extraction;genetic algorithms;image classification;learning (artificial intelligence);object detection	high-level features;fixed model complexity;genetic programming;flexible representation;GP-based approach;informative features;image-related operators;pooling operators;extraction methods;flexible program structure;image classification tasks;classification performance;feature learning;feature extraction;low-level pixel values		11		57	IEEE	15 jun. 2020			IEEE	IEEE Journals
The influence of coordination on program structure	the influence of coordination on program structure	10.1109/HICSS.1997.667277	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=667277	F. Arbab	Center of Mathematics and Computer Science, Amsterdam, Netherlands	Proceedings of the Thirtieth Hawaii International Conference on System Sciences	6 Aug 2002	1997	1		300	309 vol.1	We examine the inherent properties of some of the most popular coordination models of today and show how they contribute to the difficulty of systematic construction of coordination protocols for the cooperation of concurrent processes, as explicit, tangible pieces of software. They include the object oriented models of communication and the generative tuple space paradigm of models such as Linda. We then describe a new generic model: Idealized Worker Idealized Manager (IWIM) and discuss its advantages for coordination of concurrent activities, especially in control oriented applications. We demonstrate its "completeness" by showing that it can trivially emulate other well known communication and coordination models. Separation of computation and coordination code into different program modules is one of the important properties of this model, which is fully exploited in the pure coordination language MANIFOLD.	1060-3425	0-8186-7743-0			Object oriented modeling;Application software;Protocols;Communication system control;History;Mathematics;Computer science;Mathematical model;Transaction databases;Banking	parallel programming;parallel languages;object-oriented programming;message passing	program structure;coordination models;systematic construction;coordination protocols;concurrent processes;object oriented models;generative tuple space paradigm;Linda;Idealized Worker Idealized Manager;concurrent activities;control oriented applications;completeness;coordination code;program modules;pure coordination language MANIFOLD		9	7	36		6 Aug 2002			IEEE	IEEE Conferences
Exploiting Domain and Program Structure to Synthesize Efficient and Precise Data Flow Analyses (T)	exploiting domain and program structure to synthesize efficient and precise data flow analyses (t)	10.1109/ASE.2015.41	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372048	E. Sherman; M. B. Dwyer	Department of Computer Science Boise State University; NA	2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)	7 jan. 2016	2015			608	618	A key challenge in implementing an efficient and precise data flow analysis is determining how to abstract the domain of values that a program variable can take on and how to update abstracted values to reflect program semantics. Such updates are performed by a transfer function and recent work by Thakur, Elder and Reps defined the bilateral algorithm for computing the most precise transfer function for a given abstract domain. In this paper, we identify and exploit the special case where abstract domains are comprised of disjoint subsets. For such domains, transfer functions computed using a customized algorithm can improve performance and in combination with symbolic modeling of block-level transfer functions improve precision as well. We implemented these algorithms in Soot and used them to perform data flow analysis on more than 100 non-trivial Java methods drawn from open source projects. Our experimental data are promising as they demonstrate that a 25-fold reduction in analysis time can be achieved and precision can be increased relative to existing methods.		978-1-5090-0025-8		Data flow analysis;transfer function;abstract domain	Transfer functions;Algorithm design and analysis;Concrete;Computational modeling;Semantics;Lattices;Computer science	data flow analysis;Java;transfer functions	program structure;domain structure;data flow analysis;program semantics;bilateral algorithm;abstract domains;disjoint subsets;symbolic modeling;block-level transfer functions;Soot;Java methods;open source projects		5		29		7 jan. 2016			IEEE	IEEE Conferences
How Does Program Structure Impact the Effectiveness of the Crossover Operator in Evolutionary Testing?	how does program structure impact the effectiveness of the crossover operator in evolutionary testing	10.1109/SSBSE.2010.11	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5635164	P. McMinn	Department of Computer Science, University of Sheffield, Sheffield, UK	2nd International Symposium on Search Based Software Engineering	11 nov. 2010	2010			9	18	Recent results in Search-Based Testing show that the relatively simple Alternating Variable hill climbing method outperforms Evolutionary Testing (ET) for many programs. For ET to perform well in covering an individual branch, a program must have a certain structure that gives rise to a fitness landscape that the crossover operator can exploit. This paper presents theoretical and empirical investigations into the types of program structure that result in such landscapes. The studies show that crossover lends itself to programs that process large data structures or have an internal state that is reached over a series of repeated function or method calls. The empirical study also investigates the type of crossover which works most efficiently for different program structures. It further compares the results obtained by ET with those obtained for different variants of hill climbing algorithm, which are found to be effective for many structures considered favourable to crossover, with the exception of structures with landscapes containing entrapping local optima.		978-1-4244-8341-9		Evolutionary Testing;Crossover;Search-Based Test Data Generation	Biological cells;Input variables;Testing;Gallium;Arrays;Software engineering	data structures;program testing	program structure;crossover operator;evolutionary testing;search-based testing;alternating variable hill climbing method;fitness landscape;data structure		4		17		11 nov. 2010			IEEE	IEEE Conferences
Program-Structure-Guided Approximation of Large Fault Spaces	programstructureguided approximation of large fault spaces	10.1109/PRDC47002.2019.00044	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952147	O. Pusz; D. Kiechle; C. Dietrich; D. Lohmann	Leibniz Universität, Hannover, Germany; Leibniz Universität, Hannover, Germany; Leibniz Universität, Hannover, Germany; Leibniz Universität, Hannover, Germany	2019 IEEE 24th Pacific Rim International Symposium on Dependable Computing (PRDC)	9 jan. 2020	2019			138	13809	Due to shrinking structure sizes and operating voltages, hardware becomes more susceptible to transient faults. Fault injection campaigns are a common approach to systematically assess the resilience of a system and the effectiveness of software-based counter measures. However, experimentally injecting all possible faults to achieve full fault-space coverage is infeasible in practice. While precise pruning techniques, such as def/use pruning, already provide a significant reduction of the campaign size, the number of injections remains still challenging for even medium-sized systems. We propose fault-space regions (FSRs) as a method to approximately cover the complete fault space with a significantly lower number of required injections. Instead of probabilistic subsampling of the fault space, our approximation exploits the actual program structure and execution trace (e.g., flow of basic blocks) to identify injection points that are representatives for a larger set of faults. We identify such data-flow regions and inject only data values that flow across region boundaries. Thereby, we can further reduce the number of injections by up to 76 percent, while the results divert only by less than 2.7 percent from those of a complete and precise fault-injection campaign. Furthermore, we keep the locality of the results regarding silent data corruptions to a deviation of less than 6.9 percent.	2473-3105	978-1-7281-4961-5		reliability;functional correctness;single event upset;bit flip;fault injection;fault space approximation		program diagnostics;program verification;software fault tolerance	complete fault-injection campaign;precise fault-injection campaign;program-structure-guided approximation;structure sizes;operating voltages;fault injection campaigns;software-based counter measures;fault-space coverage;precise pruning techniques;campaign size;medium-sized systems;fault-space regions;complete fault space;actual program structure;execution trace;injection points;data-flow regions;inject only data values		3		35		9 jan. 2020			IEEE	IEEE Conferences
Robust Learning for Adaptive Programs by Leveraging Program Structure	robust learning for adaptive programs by leveraging program structure	10.1109/ICMLA.2010.150	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5708973	J. Pinto; A. Fern; T. Bauer; M. Erwig	School of Electrical Engineering and Computer Science, Oregon State University, Corvallis, OR, USA; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis, OR, USA; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis, OR, USA; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis, OR, USA	2010 Ninth International Conference on Machine Learning and Applications	4 Feb 2011	2010			943	948	We study how to effectively integrate reinforcement learning (RL) and programming languages via adaptation-based programming, where programs can include non-deterministic structures that can be automatically optimized via RL. Prior work has optimized adaptive programs by defining an induced sequential decision process to which standard RL is applied. Here we show that the success of this approach is highly sensitive to the specific program structure, where even seemingly minor program transformations can lead to failure. This sensitivity makes it extremely difficult for a non-RL-expert to write effective adaptive programs. In this paper, we study a more robust learning approach, where the key idea is to leverage information about program structure in order to define a more informative decision process and to improve the SARSA(λ) RL algorithm. Our empirical results show significant benefits for this approach.		978-1-4244-9211-4		adaptation-based programming;reinforcement learning;partial programming	Context;Training;Games;Java;Markov processes;Libraries;Instruments	decision making;learning (artificial intelligence);programming languages	robust learning;adaptive programs;leveraging program structure;reinforcement learning;programming languages;adaptation-based programming;informative decision process;SARSA(λ) RL algorithm		2		11		4 Feb 2011			IEEE	IEEE Conferences
Measuring program structure with inter-module metrics	measuring program structure with intermodule metrics	10.1109/CMPSAC.1994.342817	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=342817	M. H. Ammann; R. D. Cameron	Simon Fraser University, BC, Canada; Simon Fraser University, BC, Canada	Proceedings Eighteenth Annual International Computer Software and Applications Conference (COMPSAC 94)	6 Aug 2002	1994			139	144	A good structure is an important quality aspect of a program. Well-structured, modular programs are less costly to maintain than unstructured monolithic ones. Quantitatively assessing structure and modularity of programs can be useful to help ensure that a program is well-structured by indicating a potential need for restructuring of poorly structured code. However, previous structure metrics do not sufficiently account for the modular features used in modern, object-oriented programming languages. We propose four novel measures to assess the modular structure of a software project. Our measures are based on the principle of vocabulary hiding and measure a form of cohesion. A metrics prototype tool has been implemented for the Modula-3 programming language. Informal tests suggest that they are indeed useful to assess the quality of the program structure.<>		0-8186-6705-2			Vocabulary;Entropy;Fluid flow measurement;Object oriented programming;Modems;Prototypes;Computer languages;System testing;Operating systems;Inspection	software metrics;object-oriented programming;object-oriented languages;Modula;software tools	program structure measures;inter-module metrics;well-structured modular programs;poorly structured code;modular features;object-oriented programming languages;vocabulary hiding;cohesion;Modula-3		2		14		6 Aug 2002			IEEE	IEEE Conferences
Program structure as basis for parallelizing global register allocation	program structure as basis for parallelizing global register allocation	10.1109/ICCL.1992.185490	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=185490	A. Zobel	School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA	Proceedings of the 1992 International Conference on Computer Languages	6 Aug 2002	1992			262	271	A model that uses knowledge about program structure to guide global register allocation explicitly is proposed. Restrictions that must be met by the live ranges of loops and conditionals such that the corresponding portion of the register conflict graph is an interval graph are defined. Interval graphs are desirable because they can be colored optimally in polynomial time and because clique separators can be located systematically in interval graphs. Clique separated components of the conflict graph can be colored individually and recombined to an overall coloring, a platform for parallel global register allocation. The method has been implemented and results are presented for a benchmark of C kernels. It was possible to map most conflict graphs of the benchmark to an equivalent interval graph. In each conflict graph, it was possible to identify a large number of clique separators; the parallelization of global register allocation is then straightforward.<>		0-8186-2585-6			Registers;Computer science;Polynomials;Particle separators;Tree graphs;Merging	parallel programming;performance evaluation;resource allocation	register conflict graph;interval graph;clique separators;parallel global register allocation;benchmark;C kernels		2	3	15		6 Aug 2002			IEEE	IEEE Conferences
Heavy Tails in Program Structure	heavy tails in program structure	10.1109/LCA.2016.2574350	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7480837	H. Sasaki; F. -H. Su; T. Tanimoto; S. Sethumadhavan	Department of Computer Science, Columbia University, New York, NY; Department of Computer Science, Columbia University, New York, NY; Graduate School of Information Science and Electrical Engineering, Kyushu University, Fukuoka, Japan; Department of Computer Science, Columbia University, New York, NY	IEEE Computer Architecture Letters	16 jun. 2017	2017	16	1	34	37	Designing and optimizing computer systems require deep understanding of the underlying system behavior. Historically many important observations that led to the development of essential hardware and software optimizations were driven by empirical observations about program behavior. In this paper, we report an interesting property of program structures by viewing dynamic program execution as a changing network. By analyzing the communication network created as a result of dynamic program execution, we find that communication patterns follow heavy-tailed distributions. In other words, a few instructions have consumers that are orders of magnitude larger than most instructions in a program. Surprisingly, these heavy-tailed distributions follow the iconic power law previously seen in man-made and natural networks. We provide empirical measurements based on the SPEC CPU2006 benchmarks to validate our findings as well as perform semantic analysis of the source code to reveal the causes of such behavior.	1556-6064		JSPS; US National Science Foundation(grant numbers:1302269); Columbia University; 	Program characterization;statistical distribution;empirical studies	Registers;Benchmark testing;Communication networks;Image edge detection;Shape;Computers;Optimization	program diagnostics;statistical distributions	program structure;system behavior;computer systems;hardware optimization;software optimization;dynamic program execution;heavy-tailed distribution;SPEC CPU2006 benchmarks;semantic analysis		1		9	IEEE	30 May 2016			IEEE	IEEE Journals
Runtime optimization utilizing program structure	runtime optimization utilizing program structure	10.1109/ADCOM.2012.6563583	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6563583	N. P. K. Gorti; A. K. Somani	Electrical and Computer Engineering, Iowa State University, USA; Electrical and Computer Engineering, Iowa State University, USA	2012 18th International Conference on Advanced Computing and Communications (ADCOM)	22 jul. 2013	2012			46	53	Dynamic Binary Optimization and dynamic compilation based schemes are widely employed for runtime program optimization. They are effective in specific program scenarios, but their scope of applicability is limited by the associated runtime overhead. Their capabilities can be exploited well with the knowledge of program parameters and execution conditions. These high level structures affect the runtime optimization decisions, thereby reducing the overhead in rediscovering them. In the current program flow process, the binary executable files are devoid of this program high-level structure. Such structures exist at earlier stages, i.e., at higher level program in the compiler front end generated parse and attributed abstract syntax trees, and data structures generated in the compiler back end for optimization, i.e. a call graph. However, the information is discarded at the final code generation stage. In this paper, we develop a framework that automatically captures attributes of program structure, which are carried forward through static compilation. They are used to make the runtime optimization process faster and lightweight in nature. We also develop a novel Runtime Management Module (RMM) to control the program execution process and reoptimize the code to better suit the current execution conditions, as needed. Our metadata extraction techniques coupled with the effectiveness of RMM results into significant performance gains during execution of diverse benchmarks from SPEC and Splash 2 benchmark suites.		978-1-4799-0801-1			Runtime;Optimization;Monitoring;Benchmark testing;Performance gain;Libraries;Program processors	abstract data types;computational linguistics;meta data;optimising compilers;program diagnostics;tree data structures	dynamic binary optimization;dynamic compilation-based schemes;runtime program optimization;runtime overhead;program parameters;program execution conditions;runtime optimization decisions;overhead reduction;program flow process;binary executable files;high-level program structure;compiler front end;abstract syntax trees;data structures;compiler back end;call graph;code generation;program structure attributes;static compilation;runtime management module;RMM;program execution process control;code reoptimization;metadata extraction techniques;performance gains;SPEC benchmark suite;Splash 2 benchmark suite				16		22 jul. 2013			IEEE	IEEE Conferences
Proposal of Surrogate Model for Genetic Programming Based on Program Structure Similarity	proposal of surrogate model for genetic programming based on program structure similarity	10.23919/SICE48898.2020.9240324	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9240324	S. Kino; T. Harada; R. Thawonmas	College of Information Science and Engineering, Ritsumeikan University, Japan; Faculty of Systems Design, Tokyo Metropolitan University, Tokyo, Japan; College of Information Science and Engineering, Ritsumeikan University, Japan	2020 59th Annual Conference of the Society of Instrument and Control Engineers of Japan (SICE)	2 nov. 2020	2020			808	813	This paper proposes a novel surrogate model for genetic programming that estimates the fitness of each individual by using the tree structure similarity. In particular, the fitness of each individual is estimated with the nearest neighbor method by comparing each individual with the evaluated population. We conduct an experiment to investigate the effectiveness of the proposed method. In the experiment, we compare genetic programming with and without the proposed surrogate model on the symbolic regression problem. We assess the convergence speed and the discovery ratio of the optimum program. The experimental result reveals that the proposed method improves the convergence speed of genetic programming while maintaining the discovery rate of the optimum program.		978-1-7281-1089-9		genetic programming;surrogate model;tree structure similarity;symbolic regression	Job shop scheduling;Sociology;Genetic programming;Nearest neighbor methods;Proposals;Statistics;Convergence	genetic algorithms;regression analysis;trees (mathematics)	surrogate model;genetic programming;program structure similarity;tree structure similarity;optimum program				9		2 nov. 2020			IEEE	IEEE Conferences
New methods for exploiting program structure and behavior in computer architecture	new methods for exploiting program structure and behavior in computer architecture	10.1109/IWIA.1998.779075	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=779075	A. Roth; G. S. Sohi	Computer Sciences Department, University of Wisconsin, Madison, WI, USA; Computer Sciences Department, University of Wisconsin, Madison, WI, USA	Innovative Architecture for Future Generation High-Performance Processors and Systems	6 Aug 2002	1998			71	76	Micro-architectural techniques of the next decade will have to be more efficient and scalable in order to handle growing workloads and longer communication and memory latencies. We believe that information about program structure, the data and control relationships between instructions, can be used as a powelful framework for new techniques. We argue that program structure information has several inherent advantages over frameworks that associate information either with instructions in isolation or with data. We present summaries of four novel methods that apply program structure information to memory system problems from disambiguation and data cache bandwdith to. prefetching and coherence optimization.	1537-3223	0-7695-0125-7			Computer architecture;Delay;Prefetching;System performance;History;Communication system control;Circuits;Clocks;Frequency;Parallel processing						6		6 Aug 2002			IEEE	IEEE Conferences
Test program structure and development on the Common Test Station	test program structure and development on the common test station	10.1109/AUTEST.1996.547682	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=547682	A. W. Martel	Hughes Missiles Systems Company, Tucson, AZ, USA	Conference Record. AUTOTESTCON '96	6 Aug 2002	1996			86	94	As with all Automated Test Equipment (ATE), providing the ability to efficiently develop high-quality test programs has been a primary goal during the development of the Common Test Station (CTS). The CTS is currently under development by HMSC and was recently identified by the US Department of Defense Automated Test System (ATS) Executive Agent as a designated ATS family. The modularity and configurability of the CTS design end Its capability to support a wide range of test implementations, from real-time measurement and data collection to traditional stimulus-response test sequencing, have played a significant role in the structuring of test programs. Consideration was also given to the entire Test Program Set (TPS) development process in order to efficiently coordinate the availability or test requirement and hardware design data into the test program software development effort. To accomplish this in the most cost effective end flexible manner, a CTS test program is structured around a collection of databases that provide instrumentation, test requirement, test path end test sequencing data. The CTS Executive provides the tools necessary to create and modify the databases required by the test program.	1088-7725	0-7803-3379-9			Logic testing;Databases;Switches;Instruments;System testing;Automatic testing;Software testing;Missiles;Test equipment;Hardware	automatic test equipment;automatic test software;software engineering;military computing	test program structure;Common Test Station;automated test equipment;modularity;real-time measurement;data collection;stimulus-response test sequencing;test program software development;ATE;US Department of Defense						6 Aug 2002			IEEE	IEEE Conferences
A Replication Study on Code Comprehension and Expertise using Lightweight Biometric Sensors	a replication study on code comprehension and expertise using lightweight biometric sensors	10.1109/ICPC.2019.00050	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813259	D. Fucci; D. Girardi; N. Novielli; L. Quaranta; F. Lanubile	University of Hamburg, Germany; University of Bari Aldo Moro, Italy; University of Bari Aldo Moro, Italy; University of Bari Aldo Moro, Italy; University of Bari Aldo Moro, Italy	2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC)	29 Aug 2019	2019			311	322	Code comprehension has been recently investigated from physiological and cognitive perspectives using medical imaging devices. Floyd et al. (i.e., the original study) used fMRI to classify the type of comprehension tasks performed by developers and relate their results to their expertise. We replicate the original study using lightweight biometrics sensors. Our study participants-28 undergrads in computer science-performed comprehension tasks on source code and natural language prose. We developed machine learning models to automatically identify what kind of tasks developers are working on leveraging their brain-, heart-, and skin-related signals. The best improvement over the original study performance is achieved using solely the heart signal obtained through a single device (BAC 87%vs. 79.1%). Differently from the original study, we did not observe a correlation between the participants' expertise and the classifier performance (τ= 0.16, p= 0.31). Our findings show that lightweight biometric sensors can be used to accurately recognize comprehension opening interesting scenarios for research and practice.	2643-7171	978-1-7281-1519-1		machine learning;software development tasks;biometric sensors		biomedical MRI;biometrics (access control);brain;cardiology;cognition;learning (artificial intelligence);natural language processing;sensors;signal classification	performed comprehension task;heart signal;brain signal;fMRI;machine learning model;lightweight biometrics sensors;medical imaging devices;cognitive perspectives;physiological perspectives;code comprehension;replication study;lightweight biometric sensors;classifier performance;skin-related signals		8		48		29 Aug 2019			IEEE	IEEE Conferences
Does the Documentation of Design Pattern Instances Impact on Source Code Comprehension? Results from Two Controlled Experiments	does the documentation of design pattern instances impact on source code comprehension results from two controlled experiments	10.1109/WCRE.2011.18	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079776	C. Gravino; M. Risi; G. Scanniello; G. Tortora	Facoltà di Scienze MM. FF. NN, University of Salerno, Fisciano, Salerno, Italy; Facoltà di Scienze MM. FF. NN, University of Salerno, Fisciano, Salerno, Italy; Dipartimento di Matematica e Informatica, University of Basilicata, Potenza, Italy; Facoltà di Scienze MM. FF. NN, University of Salerno, Fisciano, Salerno, Italy	2011 18th Working Conference on Reverse Engineering	17 nov. 2011	2011			67	76	We present the results of a controlled experiment and a differentiated replication that have been carried out to assess the effect of the documentation of design patterns on the comprehension of source code. The two experiments involved Master Students in Computer Science at the University of Basilicas a and at University of Salerno, respectively. The participants to the original experiment performed a comprehension task with and without graphically-documented design patterns. Textually documented design patterns were provided or not to the participants to perform a comprehension task within the replication. The data analysis revealed that participants employing graphically documented design patterns achieved significantly better performances than the participants provided with source code alone. Conversely, the effect of textually documented design patterns was not statistically significant. A further analysis revealed that the documentation type (textual and graphical) does not significantly affect the performance, when participants correctly recognize design pattern instances.	2375-5369	978-1-4577-1948-6		Design Patterns;Controlled Experiment;Maintenance	Documentation;Unified modeling language;Educational institutions;Maintenance engineering;Software systems;Particle measurements	computer graphics;computer science education;data analysis;design of experiments;software engineering;source coding;system documentation	design pattern instances;source code comprehension;controlled experiment;differentiated replication;design patterns documentation;master students;computer science;University of Basilicas;University of Salerno;comprehension task;graphically-documented design patterns;textually documented design patterns;data analysis;documentation type		7		21		17 nov. 2011			IEEE	IEEE Conferences
Towards a Tool for Rigorous, Automated Code Comprehension Using Symbolic Execution and Semantic Analysis	towards a tool for rigorous, automated code comprehension using symbolic execution and semantic analysis	10.1109/SEW.2005.46	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1521197	M. E. M. Stewart	NASA Glenn Research Center, QSS Group, Inc., Brook Park, OH, USA	29th Annual IEEE/NASA Software Engineering Workshop	27 Dec 2005	2005			89	96	This paper presents an implementation and critical analysis of a technique for automated, rigorous scientific program comprehension and error detection. The procedure involves taking a user's existing code, adding semantic declarations for some primitive variables, symbolically executing the user's code, and recognizing semantic concepts from the symbolic expressions generated. This analysis provides high-level, semantic information and detects errors in a user's code. Symbolic execution of a 5k line of code (LOC) scientific code demonstrates implementation of a practical symbolic execution/semantic analysis tool. Despite the promise of this technique, one key challenge is examined, namely ensuring reliability during the symbolic execution/semantic analysis procedure	1550-6215	0-7695-2306-4			Costs;NASA;Lab-on-a-chip;Programming;Software engineering;Software maintenance;Information analysis;Hardware;Manuals;Debugging	natural sciences computing;program debugging;program diagnostics;programming language semantics;symbol manipulation	automated code comprehension;symbolic execution tool;semantic analysis tool;automated rigorous scientific program comprehension;error detection		4		14		27 Dec 2005			IEEE	IEEE Conferences
An Early Investigation on the Contribution of Class and Sequence Diagrams in Source Code Comprehension	an early investigation on the contribution of class and sequence diagrams in source code comprehension	10.1109/CSMR.2013.51	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6498490	G. Scanniello; C. Gravino; G. Tortora	Dipartimento di Matematica e Informatica, Universitá della Basilicata, Italy; Department of Management and Information Technology, University of Salerno, Italy; Department of Management and Information Technology, University of Salerno, Italy	2013 17th European Conference on Software Maintenance and Reengineering	15 Apr 2013	2013			367	370	We report the preliminary results of a controlled experiment conducted to analyze whether the combined use of UML class and sequence diagrams better supports source code comprehension with respect to the use of class and sequence diagrams alone. We also investigated which notation between class and sequence diagrams provides a better support in the execution of comprehension tasks on source code. The results suggest that it is better to use class and sequence diagrams together with respect to using either class or sequence diagrams alone. The difference in the source code comprehension is statistically significant with respect to the use of class diagrams alone, while is not statistically significant with respect to the sequence diagrams alone.	1534-5351	978-0-7695-4948-4		Comprehension;Controlled Experiment;UML	Unified modeling language;Object oriented modeling;Software engineering;Maintenance engineering;Software systems;Software maintenance	diagrams;Unified Modeling Language	UML class diagrams;sequence diagrams;source code comprehension		4		15		15 Apr 2013			IEEE	IEEE Conferences
A Quick Review on Machine Learning Techniques in Code Comprehension and Code Review Estimated by Neurophysiological Data	a quick review on machine learning techniques in code comprehension and code review estimated by neurophysiological data	10.1109/MELECON53508.2022.9842909	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9842909	H. Hijazi; R. Couceiro; J. Castelhano; M. Castelo-Branco; P. d. Carvalho; H. Madeira	CISUC, University of Coimbra, Coimbra, Portugal; CISUC, University of Coimbra, Coimbra, Portugal; ICNAS, University of Coimbra, Coimbra, Portugal; ICNAS/CIBIT, University of Coimbra, Coimbra, Portugal; CISUC, University of Coimbra, Coimbra, Portugal; CISUC, University of Coimbra, Coimbra, Portugal	2022 IEEE 21st Mediterranean Electrotechnical Conference (MELECON)	3 Aug 2022	2022			408	413	Machine Learning has been extensively used in studies that utilized neurophysiological data (e.g., fMRI, EEG, ECG) in capturing brain and the Autonomic Nervous System (ANS) activity in various software engineering (SE) tasks such as code comprehension and development. However, there is a lack of research efforts to review machine learning techniques used in code comprehension and code review analysis as primary tasks of SE. This quick review partly covers the research body that used machine learning techniques in code comprehension and code review analysis using neurophysiological signals (i.e., neural and ANS activity) as their primary input feature. The analysis shows that more research is needed to investigate the potential of wearable biofeedback devices (i.e.., smart-watches that generate relevant data for machine learning methods) in capturing the ANS responses of software developers while performing intellectual and abstract tasks.	2158-8481	978-1-6654-4280-0	Universidade de Coimbra; 	Artificial Intelligence;Biofeedback;Cognitive Load;Code Review;Content Comprehension	Performance evaluation;Electric potential;Codes;Machine learning;Functional magnetic resonance imaging;Electrocardiography;Software	brain;electroencephalography;learning (artificial intelligence);medical signal processing;neurophysiology;signal classification	utilized neurophysiological data;Autonomic Nervous System activity;software engineering tasks;code comprehension;code review analysis;quick review;smart-watches that generate relevant data for machine learning methods;machine Learning techniques				29	IEEE	3 Aug 2022			IEEE	IEEE Conferences
Pinpoint: A Record, Replay, and Extract System to Support Code Comprehension and Reuse	pinpoint a record, replay, and extract system to support code comprehension and reuse	10.1109/VL/HCC53370.2022.9833105	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9833105	W. Wang; G. Fraser; M. Bobbadi; B. T. Tabarsi; T. Barnes; C. Martens; S. Jiao; T. Price	North Carolina State University, Raleigh, USA; University of Passau, Passau, Germany; North Carolina State University, Raleigh, USA; North Carolina State University, Raleigh, USA; North Carolina State University, Raleigh, USA; North Carolina State University, Raleigh, USA; North Carolina State University, Raleigh, USA; North Carolina State University, Raleigh, USA	2022 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)	17 Aug 2022	2022			1	10	Block-based programming environments, such as Scratch and Snap!, engage users to create programming artifacts such as games and stories, and share them in an online community. Many Snap! users start programming by reusing and modifying an example project, but encounter many barriers when searching and identifying the relevant parts of the program to learn and reuse. We present Pinpoint, a system that helps Snap! programmers understand and reuse an existing program by isolating the code responsible for specific events during program execution. Specifically, a user can record an execution of the program (including user inputs and graphical output), replay the output, and select a specific time interval where the event of interest occurred, to view code that is relevant to this event. We conducted a small-scale user study to compare users’ program comprehension experience with and without Pinpoint, and found suggestive evidence that Pinpoint helps users understand and reuse a complex program more efficiently.	1943-6106	978-1-6654-4214-5	National Science Foundation; 		Visualization;Codes;Games;Programming;Programming environments						41	IEEE	17 Aug 2022			IEEE	IEEE Conferences
Incremental Annotate-Generalize-Search Framework for Interactive Source Code Comprehension	incremental annotategeneralizesearch framework for interactive source code comprehension	10.1109/COMPSAC.2017.147	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8029623	K. Nakayama; S. Tano; T. Hashiyama; E. Sakai	Graduate School of Information Systems, The University of Electro-Communications, Tokyo, Japan; Graduate School of Information Systems, The University of Electro-Communications, Tokyo, Japan; Graduate School of Information Systems, The University of Electro-Communications, Tokyo, Japan; Department of Humane Informatics Faculty of Letters, Otani University, Kyoto, Japan	2017 IEEE 41st Annual Computer Software and Applications Conference (COMPSAC)	11 Sep 2017	2017	1		311	316	Understanding unfamiliar source code is inherently difficult for a software engineer, despite its importance. Thus, an experienced engineer prefers to guess the intended behavior, rather than to trace it line-by-line, by combining semantic chunks found in the source code. It is, however, still hard for a system to help in this activity, for lack of ways of both representing semantic chunks and of preparing a rich dictionary of chunks. In this paper, an integrated framework for annotating and searching source code is presented. Since the research is still in its early stage, this paper focuses on the framework itself, together with a brief description of our prototype implementation. In the framework, each engineer gathers (annotates) semantic chunks that have the same meaning and interactively generalizes them to get a search pattern. As a result, a dictionary of semantic chunks together with their search patterns is incrementally created through engineer collaboration. To realize this, two representations are used: a tuple of nodes of an abstract syntax tree (AST) for a semantic chunk and a classifier on generative attribute vectors for search patterns.	0730-3157	978-1-5386-0367-3		semantic chunk;abstract syntax tree	Semantics;Knowledge engineering;Syntactics;Natural languages;Software;Collaboration;Systems support	computational linguistics;software maintenance;source code (software);tree data structures	incremental annotate-generalize-search framework;interactive source code comprehension;unfamiliar source code understanding;semantic chunks;search pattern;abstract syntax tree;AST;generative attribute vectors				18		11 Sep 2017			IEEE	IEEE Conferences
Block-Orthogonal Space–Time Code Structure and Its Impact on QRDM Decoding Complexity Reduction	blockorthogonal space–time code structure and its impact on qrdm decoding complexity reduction	10.1109/JSTSP.2011.2166755	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6007039	T. P. Ren; Y. L. Guan; C. Yuen; E. Y. Zhang	College of Electronic Science and Engineering, National University of Defense Technology, Changsha, China; School of Electrical and Electronic Engineering, Nanyang Technological University, Singapore; Singapore University of Technology and Design, Singapore; College of Electronic Science and Engineering, National University of Defense Technology, Changsha, China	IEEE Journal of Selected Topics in Signal Processing	17 nov. 2011	2011	5	8	1438	1450	Full-rate space time codes (STCs) with rate number of transmit antennas have high multiplexing gain, but high decoding complexity even when decoded using reduced-complexity decoders such as sphere or QRDM decoders. In this paper, we introduce a new code property of STC called block-orthogonal property, which can be exploited by QR-decomposition-based decoders to achieve significant decoding complexity reduction without performance loss. We show that such complexity reduction principle can benefit the existing algebraic codes such as Perfect and DjABBA codes due to their inherent (but previously undiscovered) block-orthogonal property. In addition, we construct and optimize new full-rate block-orthogonal STC (BOSTC) that further maximize the QRDM complexity reduction potential. Simulation results of bit error rate (BER) performance against decoding complexity show that the new BOSTC outperforms all previously known codes as long as the QRDM decoder operates in reduced-complexity mode, and the code exhibits a desirable complexity saturation property.	1941-0484			Block-orthogonal space–time codes (STC);decoding complexity;orthogonal STC;QRD-M algorithm;quasi-orthogonal STC	Complexity theory;Space time codes;Maximum likelihood decoding;Matrix decomposition;Bit error rate;Transmitting antennas;Decoding	algebraic codes;decoding;error statistics;orthogonal codes;space-time block codes	block-orthogonal space-time code structure;QRDM decoding complexity reduction;transmit antenna;multiplexing gain;sphere decoder;QRDM decoder;block-orthogonal property;QR-decomposition-based decoder;algebraic codes;perfect code;DjABBA code;full-rate block-orthogonal STC;BOSTC;bit error rate performance		28	2	35	IEEE	1 Sep 2011			IEEE	IEEE Journals
Selecting software phase markers with code structure analysis	selecting software phase markers with code structure analysis	10.1109/CGO.2006.32	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1611536	J. Lau; E. Perelman; B. Calder	Department of Computer Science and Engineering, University of California, San Diego, USA; Department of Computer Science and Engineering, University of California, San Diego, USA; Department of Computer Science and Engineering, University of California, San Diego, USA	International Symposium on Code Generation and Optimization (CGO'06)	10 Apr 2006	2006			12 pp.	146	Most programs are repetitive, where similar behavior can be seen at different execution times. Algorithms have been proposed that automatically group similar portions of a program's execution into phases, where samples of execution in the same phase have homogeneous behavior and similar resource requirements. In this paper, we present an automated profiling approach to identify code locations whose executions correlate with phase changes. These ''software phase markers" can be used to easily detect phase changes across different inputs to a program without hardware support. Our approach builds a combined hierarchical procedure call and loop graph to represent a program's execution, where each edge also tracks the max, average, and standard deviation in hierarchical execution variability on paths from that edge. We search this annotated call-loop graph for instructions in the binary that accurately identify the start of unique stable behaviors across different inputs. We show that our phase markers can be used to accurately partition execution into units of repeating homogeneous behavior by counting execution cycles and data cache hits. We also compare the use of our software markers to prior work on guiding data cache reconfiguration using data-reuse markers. Finally, we show that the phase markers can be used to partition the program's execution at code transitions to pick accurately simulation points for SimPoint. When simulation points are defined in terms of phase markers, they can potentially be re-used across inputs, compiler optimizations, and different instruction set architectures for the same source code.		0-7695-2499-0			Hardware;Optimizing compilers;Clustering algorithms;Computer science;Phase detection;Tracking loops;Program processors;Acceleration;Heuristic algorithms;Pattern analysis	program diagnostics;optimising compilers;program control structures;instruction sets	software phase markers;code structure analysis;automated profiling approach;code location identification;phase change detection;hierarchical procedure call;call-loop graph;execution cycles;data cache hits;data cache reconfiguration;data-reuse markers;program execution partition;SimPoint;compiler optimizations;instruction set architectures		27	1	28		10 Apr 2006			IEEE	IEEE Conferences
Assessment of the GPS L2C Code Structure for Efficient Signal Acquisition	assessment of the gps l2c code structure for efficient signal acquisition	10.1109/TAES.2012.6237568	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6237568	S. U. Qaisar; A. G. Dempster	School of Surveying and Spatial Information Systems, University of New South Wales, Sydney, NSW, Australia; School of Surveying and Spatial Information Systems, University of New South Wales, Sydney, NSW, Australia	IEEE Transactions on Aerospace and Electronic Systems	11 jul. 2012	2012	48	3	1889	1902	L2C is the second Global Positioning System (GPS) civilian signal to become available over the full constellation. Because of the unusually-long ranging codes used in L2C signal, the search space and the computational complexity for signal acquisition become huge. The time-multiplexed nature of L2C code can, however, be exploited to design smarter replica codes that expedite the signal search and reduce the computational complexity. In this paper, various designs of L2C replica code are assessed for efficient signal acquisition, and the search capabilities and potential application scenarios for each of the assessed designs are identified. The nonreturn-to-zero civil moderate (NRZ CM) replica code design is exploited to develop a chipwise (CW) correlation strategy. In this strategy, the received L2C code samples are accumulated across each chip period, and the correlation is then performed at the L2C code chipping rate, reducing both the code search space and the computational complexity significantly. The detection performance of CW strategy is assessed as equivalent to that of the full-rate correlation, irrespective of the phase of the received L2C code.	1557-9603				Correlation;Optical signal processing;Global Positioning System;Doppler effect;Computational complexity;Satellites;Noise	codes;correlation methods;Global Positioning System;signal detection	GPS L2C code structure;efficient signal acquisition;Global Positioning System civilian signal;time-multiplexed L2C code;signal search;computational complexity;L2C replica code;nonreturn-to-zero civil moderate replica code design;chipwise correlation strategy;L2C code chipping rate		16		22		11 jul. 2012			IEEE	IEEE Journals
Signal Detection in a Space–Frequency Coded Cooperative Communication System With Multiple Carrier Frequency Offsets by Exploiting Specific Properties of the Code Structure	signal detection in a space–frequency coded cooperative communication system with multiple carrier frequency offsets by exploiting specific properties of the code structure	10.1109/TVT.2009.2014955	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4781616	F. Tian; X. -G. Xia; P. C. Ching; W. -K. Ma	Department of Electronics Engineering, Chinese University of Hong Kong, Sha Tin, Hong Kong, China; Department of Electrical and Computer Engineering, University of Delaware, Newark, DE, USA; Department of Electronics Engineering, Chinese University of Hong Kong, Sha Tin, Hong Kong, China; Department of Electronics Engineering, Chinese University of Hong Kong, Sha Tin, Hong Kong, China	IEEE Transactions on Vehicular Technology	18 Aug 2009	2009	58	7	3396	3409	In cooperative communications, carrier frequency offsets (CFOs) between pairs of nodes may be different, making CFO compensation difficult, if not impossible. These multiple CFOs may drastically degrade the performance of a space-frequency (SF)-coded cooperative system. In this paper, we consider the signal-detection problem in an SF-coded cooperative communication system with multiple CFOs, where the SF codes are rotational based and can achieve both full spatial and full multipath diversity orders in a multiantenna system. By exploiting the structure of the SF codes, we propose three signal detection methods to deal with the multiple CFOs problem in the SF-coded orthogonal frequency-division multiplexing (OFDM) system - the minimum mean-squared error (MMSE) filtering method, the two-stage simple frequency-shift Q taps method, and the multiple fast Fourier transform (M-FFT) method - all of which offer different tradeoffs between performance and computational complexity. Simulation results indicate that our proposed detection methods work well, as long as the carrier frequency offsets between nodes are not unreasonably large.	1939-9359			Cooperative communications;diversity;intercarrier interference (ICI);multiple carrier frequency offsets (CFOs);orthogonal frequency-division multiplexing (OFDM);space–frequency (SF) codes	Signal detection;OFDM;Frequency division multiplexing;Timing;Relays;Cooperative systems;Interference;Frequency diversity;MIMO;Frequency synchronization	antenna arrays;communication complexity;diversity reception;fast Fourier transforms;filtering theory;intercarrier interference;mean square error methods;multipath channels;OFDM modulation;signal detection	signal detection method;space-frequency coded cooperative communication system;multiple carrier frequency offset;multiple CFO compensation;full spatial diversity;full multipath diversity;multiantenna system;SF-coded OFDM system;orthogonal frequency-division multiplexing system;minimum mean-squared error method;MMSE filtering method;two-stage simple frequency-shift Q tap method;multiple fast Fourier transform method;M-FFT method;computational complexity;intercarrier interference;multipath channel		5		27	IEEE	10 Feb 2009			IEEE	IEEE Journals
An efficient code structure and search strategy for stochastic coding at 8 kb/s	an efficient code structure and search strategy for stochastic coding at 8 kb/s	10.1109/ICASSP.1990.115754	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=115754	D. E. Veeneman; B. Mazor	GTE Laboratories, Inc., Waltham, MA, USA; GTE Laboratories, Inc., Waltham, MA, USA	International Conference on Acoustics, Speech, and Signal Processing	6 Aug 2002	1990			481	484 vol.1	Methods of increasing the performance of two components of stochastic coding, the codebook excitation search and the long-term synthesis filter, while maintaining or reducing complexity are discussed. A flexible tree-coding technique is introduced that significantly lowers the complexity of the codebook search with very little loss in quality. An efficient method of performing a three-tap long-term prediction analysis in a closed loop is developed. It improves perceptual quality and requires little additional complexity. The result is a stochastic coder which produces high-quality speech at 8 kb/s with manageable computational complexity.<>	1520-6149				Stochastic processes;Filters;Performance analysis;Speech;Computational complexity	encoding;filtering and prediction theory;search problems;speech analysis and processing;speech synthesis	speech synthesis;code structure;stochastic coding;codebook excitation search;synthesis filter;flexible tree-coding;three-tap long-term prediction analysis;computational complexity;8 kbit/s		4	2	6		6 Aug 2002			IEEE	IEEE Conferences
Binary Complementary Code Structure via a Simple Necessary Condition	binary complementary code structure via a simple necessary condition	10.1109/TAES.2017.2674199	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7862836	G. E. Coxson; W. Haloupek; J. Russo	U.S. Naval Academy, Annapolis, MD, USA; Mount Laurel, NJ, USA; Lockheed Martin Advanced Technology Lab, Cherry Hill, NJ, USA	IEEE Transactions on Aerospace and Electronic Systems	7 Aug 2017	2017	53	4	1846	1854	A complementary set of K binary ±1 codes of length N has the useful property that the sum of the autocorrelation sequences of the codes has only one nonvanishing element, its size-K N peak. The N x K matrix whose columns are the codes of a binary complementary set, arranged in order, is the code set's complementary code matrix (CCM). One might ask for which K and N such matrices exist. A simple necessary condition for the existence of an N x K CCM is introduced, involving the sum of the squares of the imbalance values of the codes in the set (the imbalance of a binary ±1 code being the difference between the number of 1 and number of -1s in the code). The one-to-one relationship between binary CCMs and binary complementary code sets allows the necessary condition for the N x K CCM existence to extend to a necessary condition for sets of K complementary code sets of length N. We examine the sum-of-squares condition for the separate cases of N even and N odd. The odd case is especially interesting, since representations in terms of sums of squares of odd integers are equivalent to representations as sums of triangular numbers, a subject of recent research in Number Theory. Furthermore, we exhibit a refinement of the existence condition in terms of the imbalance values of pairs of interlaced subcodes. This refinement is new, to the best of our knowledge. Finally, we investigate whether odd-length complementary code sets exist for K , 2, unlike the Golay case of K = 2 where odd-length sets cannot exist. We easily find, by computer search, a four-code set of length 15, suggesting that these are likely not uncommon.	1557-9603			Binary code;code imbalance;complementary code matrix (CCM);complementary code set;Golay pair;radar;sum of squares	Correlation;Doppler effect;Sensitivity;Binary codes;Doppler radar;Radar applications	binary codes	binary complementary code structure;autocorrelation sequences;complementary code matrix;odd-length complementary code sets;four-code set		4		32	IEEE	23 Feb 2017			IEEE	IEEE Journals
Application Architecture Discovery - Towards Domain-driven, Easily-Extensible Code Structure	application architecture discovery towards domaindriven, easilyextensible code structure	10.1109/WCRE.2011.56	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079867	H. Sajnani; R. Naik; C. Lopes	School of Information and Computer Sciences, University of California, Irvine, Irvine, CA, USA; Tata Research Development and Design Center, Pune, India; School of Information and Computer Sciences, University of California, Irvine, Irvine, CA, USA	2011 18th Working Conference on Reverse Engineering	17 nov. 2011	2011			401	405	The architecture of a software system and its code structure have a strong impact on its maintainability - the ability to fix problems, and make changes to the system efficiently. To ensure maintainability, software systems are usually organized as subsystems or modules, each with atomically defined responsibilities. However, as the system evolves, the structure of the system undergoes continuous modifications, drifting away from its original design, leading to functionally non-atomic modules and intertwined dependencies between the modules. In this paper, we propose an approach to improve the code structure and architecture by leveraging the domain knowledge of the system. Our approach exploits the knowledge about the functional architecture of the system to restructure the source code and align physically with the functional elements and the re-usable library layers. The approach is validated by applying to a case study which is an existing financial system. The preliminary analysis for the case-study reveals that the approach creates meaningful structure from the legacy code, which enables the developers to quickly identify the code that implements a given functionality.	2375-5369	978-1-4577-1948-6			Organizations;Computer architecture;Software systems;Conferences;Banking;Automation	financial data processing;software architecture;software maintenance	application architecture discovery;software system architecture;software code structure;software maintainability;system domain knowledge;financial system;legacy code		3		15		17 nov. 2011			IEEE	IEEE Conferences
Comparative Code Structure Analysis using Deep Learning for Performance Prediction	comparative code structure analysis using deep learning for performance prediction	10.1109/ISPASS51385.2021.00032	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9408199	T. Ramadan; T. Z. Islam; C. Phelps; N. Pinnow; J. J. Thiagarajan	Texas State University; Texas State University; Texas State University; Lawrence Livermore National Laboratory; Lawrence Livermore National Laboratory	2021 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS)	28 Apr 2021	2021			151	161	Performance analysis has always been an afterthought during the application development process, focusing on application correctness first. The learning curve of the existing static and dynamic analysis tools are steep, which requires understanding low-level details to interpret the findings for actionable optimizations. Additionally, application performance is a function of a number of unknowns stemming from the application-, runtime-, and interactions between the OS and underlying hardware, making it difficult to model using any deep learning technique, especially without a large labeled dataset. In this paper, we address both of these problems by presenting a large corpus of a labeled dataset for the community and take a comparative analysis approach to mitigate all unknowns except their source code differences between different correct implementations of the same problem. We put the power of deep learning to the test for automatically extracting information from the hierarchical structure of abstract syntax trees to represent source code. This paper aims to assess the feasibility of using purely static information (e.g., abstract syntax tree or AST) of applications to predict performance change based on the change in code structure. This research will enable performance-aware application development since every version of the application will continue to contribute to the corpora, which will enhance the performance of the model. We evaluate several deep learning-based representation learning techniques for source code. Our results show that tree-based Long Short-Term Memory (LSTM) models can leverage source code's hierarchical structure to discover latent representations. Specifically, LSTM-based predictive models built using a single problem and a combination of multiple problems can correctly predict if a source code will perform better or worse up to 84% and 73% of the time, respectively.		978-1-7281-8643-6		Comparative performance modeling;machine learning;Long Short-Term Memory Networks;Deep Graph Learning	Deep learning;Analytical models;Neural networks;Syntactics;Predictive models;Tools;Network architecture	computational linguistics;deep learning (artificial intelligence);feature extraction;program diagnostics;program testing;recurrent neural nets;software maintenance;software performance evaluation;source code (software);trees (mathematics)	performance prediction;application development process;application correctness;static analysis tools;dynamic analysis tools;deep learning;source code;automatic information extraction;abstract syntax trees;LSTM based predictive models;code structure analysis;performance aware application development;tree based long short term memory models		1		37		28 Apr 2021			IEEE	IEEE Conferences
A study on RFID code structure for traceability system of electric vehicle batteries	a study on rfid code structure for traceability system of electric vehicle batteries		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6148487	Woo Ram Kim; Yoon Seok Chang	Logistics System Department, Korea Aerospace University, Goyang, South Korea; Logistics System Department, Korea Aerospace University, Goyang, South Korea	2011 International Conference for Internet Technology and Secured Transactions	9 Feb 2012	2011			490	494	As the issues like global warming and depletion of fossil fuel are considered as urgent problems, the development of electric vehicle (EV) is becoming more attention by automobile industry. Recently, many major automobile companies have launched various types of EV in the market. But the wide adoption of EVs is not coming yet, because of many issues concerning conventional battery charging EV such as long recharging time and expensive price of batteries etc. As an alternative solution to the battery charging EV, the idea of battery changing EV is introduced. To realize the battery changing business model, one should solve the ownership issue of battery. To address such issue, the concept of battery sharing should be considered together with good traceability system. In this study, we studied RFID code structure to provide visibility and traceability for shared EV batteries.		978-1-908320-00-1		EV;battery;RFID code;charge;change	Batteries;Radiofrequency identification;Companies;Manufacturing;Code standards;Electric vehicles	battery powered vehicles;radiofrequency identification;secondary cells	RFID code structure;electric vehicle battery traceability system;global warming;fossil fuel;automobile industry;automobile companies;battery charging EV;battery changing business model;battery sharing concept				15		9 Feb 2012			IEEE	IEEE Conferences
Interleaver design for punctured turbo codes based on RSC code structure	interleaver design for punctured turbo codes based on rsc code structure	10.1109/ICTC.2013.6675380	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6675380	Hyun-Kyung Kim; Hyeung-Gun Joo; Dong-Joon Shin	Department of Electronics and Computer Engineering, Hanyang University, Seoul, Korea; Department of Electronics and Computer Engineering, Hanyang University, Seoul, Korea; Department of Electronics and Computer Engineering, Hanyang University, Seoul, Korea	2013 International Conference on ICT Convergence (ICTC)	2 Dec 2013	2013			393	397	Punctured turbo codes may show poor performance for some specific code rates, due to uneven error protection of input bits after puncturing. In this paper, such phenomenon is analyzed by considering the structure of recursive systematic convolutional (RSC) code and, new design criteria of interleaver are proposed such that the information bits are protected as equally as possible. Simulation results confirm that the proposed interleaver show good performance for the specific code rates considered	2162-1241	978-1-4799-0698-7		generator polynomials;interleaver;recursive systematic convolutional (RSC) codes;turbo codes	Turbo codes;Polynomials;Bit error rate;Decoding;Generators;Periodic structures;Algorithm design and analysis	convolutional codes;interleaved codes;polynomials;turbo codes	interleaver design;punctured turbo codes;RSC code structure;recursive systematic convolutional code;error protection			3	11		2 Dec 2013			IEEE	IEEE Conferences
Automatic Generation of Comments Based on Code Structure Enhancements	automatic generation of comments based on code structure enhancements	10.1109/BDAI56143.2022.9862730	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9862730	X. Ren; Y. Shuai; S. Zang; H. Cheng; H. Liu; J. Wu	College of Artificial Intelligence, Southwest University, Chongqing, China; College of Artificial Intelligence, Southwest University, Chongqing, China; College of Artificial Intelligence, Southwest University, Chongqing, China; College of Artificial Intelligence, Southwest University, Chongqing, China; College of Artificial Intelligence, Southwest University, Chongqing, China; School of Physical Science and Technology, Southwest University, Chongqing, China	2022 IEEE 5th International Conference on Big Data and Artificial Intelligence (BDAI)	26 Aug 2022	2022			105	110	Code comments play a significant role in software maintenance as they can greatly improve the efficiency of software developers' program understanding and reduce maintenance costs. However, due to the bad programming habits of developers and tight project development time, the annotations of many projects are incomplete. Studies have shown that project maintainers spend almost half of their time on understanding programs. Accordingly, this paper proposes a dual-encoder-based deep learning method code structure-enhanced comment generation (CSE-GC) to automatically generate annotation texts for Java methods. CSE-GC uses the CSE traversal method to traverse the abstract syntax tree of the Java method; input the structure information obtained by the traversal and vocabulary information of the source code into the gate recurrent unit encoder and convolutional neural network encoder, respectively; and use the attention mechanism to guide the decoder to generate annotations. This study obtained 131,823 Java methods as the training set data to train the model. The final METEOR value on the test set is 30.95%, and the BLEU-4 value is 45.01%. The results demonstrate that the method proposed in this paper has better performance compared to state-of-the-art models.		978-1-6654-7081-0	National Natural Science Foundation of China(grant numbers:60907003,61805278,61875168); China Postdoctoral Science Foundation(grant numbers:2018M633704); NUDT(grant numbers:JC13-02-13,ZK17-03-01); Program for New Century Excellent Talents in University(grant numbers:NCET-12-0142); 	code comments;abstract syntax tree;deep learning;attention mechanism;neural machine translation	Deep learning;Training;Java;Vocabulary;Software maintenance;Codes;Annotations	convolutional neural nets;deep learning (artificial intelligence);encoding;Java;recurrent neural nets;software maintenance;trees (mathematics)	source code;gate recurrent unit encoder;convolutional neural network encoder;Java methods;code comments;software maintenance;software developers;maintenance costs;project development time;project maintainers;CSE-GC;annotation texts;Java method;CSE traversal method;structure information;vocabulary information;dual-encoder-based deep learning method;code structure-enhanced comment generation;METEOR value				14	IEEE	26 Aug 2022			IEEE	IEEE Conferences
New decoding scheme for LDPC codes based on simple product code structure	new decoding scheme for ldpc codes based on simple product code structure	10.1109/JCN.2015.000066	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7265217	B. Shin; S. Hong; H. Park; J. -S. No; D. -J. Shin	Seoul National University, Gwanak-gu, Seoul, KR; Seoul National University, Gwanak-gu, Seoul, KR; Seoul National University, Gwanak-gu, Seoul, KR; Seoul National University, Gwanak-gu, Seoul, KR; Hanyang University, Seongdong-gu, Seoul, KR	Journal of Communications and Networks	14 Sep 2015	2015	17	4	351	361	In this paper, a new decoding scheme is proposed to improve the error correcting performance of low-density parity-check (LDPC) codes in high signal-to-noise ratio (SNR) region by using post-processing. It behaves as follows: First, a conventional LDPC decoding is applied to received LDPC codewords one by one. Then, we count the number of word errors in a predetermined number of decoded codewords. If there is no word error, nothing needs to be done and we can move to the next group of codewords with no delay. Otherwise, we perform a proper post-processing which pro-ducesa new soft-valued codeword (this will befully explained in the main body of this paper) and then apply the conventional LDPC decoding to it again to recover the unsuccessfully decoded codewords. For the proposed decoding scheme, we adopt a simple product code structure which contains LDPC codes and simple algebraic codes as its horizontal and vertical codes, respectively. The decoding capability of the proposed decoding scheme is defined and analyzed using the parity-check matrices of vertical codes and, especially, the combined-decodability is derived for the case of single parity-check (SPC) codes and Hamming codes used as vertical codes. It is also shown that the proposed decoding scheme achieves much better error correcting capability in high SNR region with little additional decoding complexity, compared with the conventional LDPC decoding scheme.	1976-5541			Combined-decodability;decoding;low-density parity-check (LDPC) codes;post-processing;product codes	Decoding;Parity check codes;Product codes;Encoding;Systematics;Mathematical model;Signal to noise ratio	algebraic codes;computational complexity;decoding;error correction codes;Hamming codes;matrix algebra;parity check codes	LDPC decoding scheme;LDPC codes;low-density parity-check codes;simple product code structure;high signal-to-noise ratio region;error correcting performance improvement;LDPC codewords;word error number;predetermined decoded codeword number;soft-valued codeword;algebraic codes;horizontal codes;vertical codes;decoding capability;parity-check matrices;combined-decodability;parity-check codes;SPC codes;Hamming codes;error correcting capability;decoding complexity			1			14 Sep 2015			KICS	KICS Journals
Method Name Generation Based on Code Structure Guidance	method name generation based on code structure guidance	10.1109/SANER53432.2022.00127	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9825891	Z. Qu; Y. Hu; J. Zeng; B. Cai; S. Yang	School of Cyber Science and Engineering, Wuhan University, Wuhan, China; School of Cyber Science and Engineering, Wuhan University, Wuhan, China; School of Cyber Science and Engineering, Wuhan University, Wuhan, China; School of Cyber Science and Engineering, Wuhan University, Wuhan, China; School of Cyber Science and Engineering, Wuhan University, Wuhan, China	2022 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)	21 jul. 2022	2022			1101	1110	The proper names of software engineering functions and methods can greatly assist developers in understanding and maintaining the code. Most researchers convert the method name generation task into the text summarization task. They take the token sequence and the abstract syntax tree (AST) of source code as input, and generate method names with a decoder. However, most proposed models learn semantic and structural features of the source code separately, resulting in poor performance in the method name generation task. Actually, each token in source code must have a corresponding node in its AST. Inspired by this observation, we propose SGMNG, a structure-guided method name generation model that learns the representation of two combined features. Additionally, we build a code graph called code relation graph (CRG) to describe the code structure clearly. CRG retains the structure of the AST of source code and contains data flows and control flows. SGMNG captures the semantic features of the code by encoding the token sequence and captures the structural features of the code by encoding the CRG. Then, SGMNG matches tokens in the sequence and nodes in the CRG to construct the combination of two features. We demonstrate the effectiveness of the proposed approach on the public dataset Java-Small with 700K samples, which indicates that our approach achieves significant improvement over the state-of-the-art baseline models in the ROUGE metric.	1534-5351	978-1-6654-3786-8		method name generation;graph representation;code semantic features;code structural features	Measurement;Codes;Conferences;Semantics;Syntactics;Encoding;Software	graph theory;Java;software maintenance;source code (software);text analysis	code structure;software engineering functions;text summarization task;token sequence;AST;source code;structure-guided method name generation model;code relation graph;CRG;code maintenance;syntax tree;SGMNG;public dataset Java-Small;ROUGE metric				34	IEEE	21 jul. 2022			IEEE	IEEE Conferences
Woven Coded CPFSK With Hierarchical Code Structure	woven coded cpfsk with hierarchical code structure	10.1109/TCOMM.2007.904353	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4303356	S. Kempf; S. Shavgulidze; M. Bossert	Nokia SiemensNetworks, Ulm, Germany; Department of Digital Communication Theory, Georgian Technical University, Tbilisi, Germany; Institute of Telecommunications and Applied Information Theory, University of Ulm, Ulm, Germany	IEEE Transactions on Communications	17 Sep 2007	2007	55	9	1661	1666	We introduce hierarchical woven coded continuous phase frequency-shift keying (hierarchical WCCPFSK) as the serial concatenation of different outer convolutional codes and inner CPFSK. We compare it to WCCPFSK with identical outer convolutional codes. With the proposed code combinations, hierarchical WCCPFSK achieves superior decoding capability. Simulations show that it performs better at medium SNRs.	1558-0857			Continuous phase modulation (CPM);iterative decoding;woven codes	Maximum likelihood decoding;Convolutional codes;Iterative decoding;Phase modulation;Frequency shift keying;Concatenated codes;Mutual information;Demodulation;Maximum likelihood detection;Bandwidth	concatenated codes;continuous phase modulation;convolutional codes;decoding;frequency shift keying	hierarchical woven coded continuous phase frequency-shift keying;serial concatenation;outer convolutional codes;decoding				15		17 Sep 2007			IEEE	IEEE Journals
Code Structure	code structure		https://ieeexplore.ieee.org/xpl/ebooks/bookPdfWithBanner.jsp?fileName=6278346.pdf&bkn=6267318&pdfType=chapter	V. A. Pedroni	UTFPR – Federal Technological University of Parana State	Circuit Design with VHDL		2004			11	30	This chapter contains sections titled: Fundamental VHDL Units, VHDL Libraries and Packages, Library/Package Declarations, ENTITY, ARCHITECTURE, GENERIC, Introductory VHDL Examples, Coding Guidelines, VHDL 2008, Exercises		9780262256780											24 Sep 2012			MIT Press	MIT Press eBook Chapters
Development of a Three Dimensional Multi-Service/Multi-Diagonal Code for OCDMA System	development of a three dimensional multiservice/multidiagonal code for ocdma system	10.23919/SOFTCOM.2018.8555799	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8555799	N. Jellali; M. Ferchichi; M. Najjar	National Engineering School of Tunis, Communications Systems; National Engineering School of Tunis, Communications Systems; Higher Institute of Computer (ISI), University of Tunis El Manar	2018 26th International Conference on Software, Telecommunications and Computer Networks (SoftCOM)	2 Dec 2018	2018			1	5	A new three-dimensional multi-service / multi-diagonal (3D-MS/MD) code is proposed for spectral/time/spatial non-coherent optical code division multiple access (OCDMA) system. The code construction is based on one dimensional multi-diagonal (ID-MD) code, for spatial component, and two-dimensional multi-service (2D-MS), for spectral/time encoding. The 3D-MS/MD can suppress the phase-induced intensity noise by using the multi access interference (MAI) cancellation property. The simulation results reveal that the new system can accommodate 3.9, 8.29, 21.66 times the users number supported by ID-MD, ID-MS and 2D-MS systems, with a high data rate and low source power.	1847-358X	978-9-5329-0087-3		multi-service code;multi-diagonal code;style;phase-induced intensity noise;multi access interference	Codes;Simulation;Interference;Software;Encoding;Computer networks;Telecommunications	code division multiplexing;encoding	three dimensional multiservice/multidiagonal code;OCDMA system;2D-MS systems;ID-MS;multiaccess interference cancellation property;two-dimensional multiservice;ID-MD;noncoherent optical code division multiple access system;3D-MS/MD		1		16		2 Dec 2018			IEEE	IEEE Conferences
Self-Supervised Source Code Annotation from Related Research Papers	selfsupervised source code annotation from related research papers	10.1109/ICDMW53433.2021.00140	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9679867	P. Haritz; L. Pfahler; T. Liebig; H. Kotthaus	Department of Computer Science, Chair of Artificial Intelligence, TU Dortmund, Dortmund, Germany; Department of Computer Science, Chair of Artificial Intelligence, TU Dortmund, Dortmund, Germany; Department of Computer Science, Chair of Artificial Intelligence, TU Dortmund, Dortmund, Germany; ML2R, Dortmund, Germany	2021 International Conference on Data Mining Workshops (ICDMW)	20 jan. 2022	2021			1083	1084	Language analysis of scientific documents and analysis of source code have been done independently in the past. This work presents a network architecture and a self-supervised training approach to find alignments between published computer science research papers and their corresponding public source code by learning a representation of encodings from transformers, from which source code can be enriched with helpful information. We present our ideas, findings and plans for upcoming research.	2375-9259	978-1-6654-2427-1	Ministry of Education; 	natural language processing;code understanding;transformers;self-supervised learning	Training;Codes;Text analysis;Annotations;Semantics;Natural languages;Network architecture	computer science;software architecture;source code (software)	self-supervised source code annotation;language analysis;scientific documents;network architecture;self-supervised training;computer science research papers;public source code				11	IEEE	20 jan. 2022			IEEE	IEEE Conferences
Behavioural validation of software engineering artefacts	behavioural validation of software engineering artefacts	10.1145/1810295.1810453	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6062270	G. de Caso	Departamento de Computación, FCEyN, Universidad de Buenos Aires, Buenos Aires, Argentina	2010 ACM/IEEE 32nd International Conference on Software Engineering	27 Oct 2011	2010	2		505	506	Software engineering artefacts that define behaviour tend to be of a fragmented nature in order to facilitate their construction, modification, and modular reasoning (e.g. modular code, pre/post-conditions specifications). However, fragmentation makes the validation of global behaviour difficult. Typically synthesis techniques that yield global representations of large or infinite states are used in combination with simulation or partial explorations, techniques which necessarily lose the global view of system behaviour. I am working on the development of abstraction-for-validation techniques that automatically produce finite state abstractions that are sufficiently small to support validating the emergent behaviour of a fragmented description "at a glance".	1558-1225	978-1-60558-719-6		behaviour models;code understanding;contract conformance	Contracts;Software engineering;Analytical models;Software;Cognitive science;Protocols;Complexity theory						10		27 Oct 2011			IEEE	IEEE Conferences
Behavioural validation of software engineering artefacts	behavioural validation of software engineering artefacts	10.1145/1810295.1810380	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6062202	G. de Caso	Departamento de Computación, FCEyN, Universidad de Buenos Aires, Buenos Aires, Argentina	2010 ACM/IEEE 32nd International Conference on Software Engineering	27 Oct 2011	2010	2		335	336	Software engineering artefacts that define behaviour tend to be of a fragmented nature in order to facilitate their construction, modification, and modular reasoning (e.g. modular code, pre/post-conditions specifications). However, fragmentation makes the validation of global behaviour difficult. Typically synthesis techniques that yield global representations of large and potentially infinite states are used in combination with simulation, animation or partial explorations, techniques which necesarily loose the global view of system behaviour. I aim to develop abstraction-for-validation techniques that automatically produce finite state abstractions that are sufficiently small to support validating the emergent behaviour of a fragmented description "at a glance".	1558-1225	978-1-60558-719-6		behaviour models;code understanding;contract conformance	Contracts;Software engineering;Analytical models;Software;Cognitive science;Complexity theory;Approximation methods	approximation theory;software engineering	software engineering artefact;behavioural validation;abstraction-for-validation technique;finite state abstraction;finite state approximation				8		27 Oct 2011			IEEE	IEEE Conferences
Program understanding: Challenge for the 1990s	program understanding challenge for the 1990s	10.1147/sj.282.0294	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5387570	T. A. Corbi	IBM Data Systems Division, P.O. Box 390, Poughkeepsie, New York 12602, USA	IBM Systems Journal	6 Apr 2010	1989	28	2	294	306	In the Program Understanding Project at IBM's Research Division, work began in late 1986 on tools which could help programmers in two key areas: static analysis (reading the code) and dynamic analysis (running the code). The work is reported in the companion papers by Cleveland and by Pazel in this issue. The history and background which motivated and which led to the start of this research on tools to assist programmers in understanding existing program code is reported here.	0018-8670								126				6 Apr 2010			IBM	IBM Journals
Using a concept lattice of decomposition slices for program understanding and impact analysis	using a concept lattice of decomposition slices for program understanding and impact analysis	10.1109/TSE.2003.1205178	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1205178	P. Tonella	ITC-IRST-Centro per la Ricerca Scientifica e Tecnologica, Trento, Italy	IEEE Transactions on Software Engineering	20 jun. 2003	2003	29	6	495	509	The decomposition slice graph and concept lattice are two program representations used to abstract the details of code into a higher-level view of the program. The decomposition slice graph partitions the program into computations performed on different variables and shows the dependence relation between computations, holding when a computation needs another computation as a building block. The concept lattice groups program entities which share common attributes and organizes such groupings into a hierarchy of concepts, which are related through generalizations/specializations. This paper investigates the relationship existing between these two program representations. The main result of this paper is a novel program representation, called concept lattice of decomposition slices, which is shown to be an extension of the decomposition slice graph, and is obtained by means of concept analysis, with additional nodes associated with weak interferences between computations, i.e., shared statements which are not decomposition slices. The concept lattice of decomposition slices can be used to support software maintenance by providing relevant information about the computations performed by a program and the related dependences/interferences, as well as by representing a natural data structure on which to conduct impact analysis. Preliminary results on small to medium size code support the applicability of this method at the intraprocedural level or when investigating the dependences among small groups of procedures.	1939-3520				Lattices;Interference;Software maintenance;Data structures;Performance analysis;Information analysis;Application software	reverse engineering;program slicing;software maintenance	program representations;program understanding;impact analysis;concept lattice;decomposition slice graph;dependence relation;common attributes;generalizations;specializations;weak interferences;shared statements;software maintenance;data structure;intraprocedural level		117	3	38		20 jun. 2003			IEEE	IEEE Journals
The concept assignment problem in program understanding	the concept assignment problem in program understanding	10.1109/ICSE.1993.346017	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=346017	T. J. Biggerstaff; B. G. Mitbander; D. Webster	Microsoft Research; Microelectronics and Computer Technology Corporation, USA; Microelectronics and Computer Technology Corporation, USA	Proceedings of 1993 15th International Conference on Software Engineering	6 Aug 2002	1993			482	498	Concept assignment is a process of recognizing concepts within a computer program and building up an understanding of the program by relating the recognized concepts to portions of the program, its operational context and to one another. The problem of discovering individual human oriented concepts and assigning them to their implementation oriented counterparts for a given program is the concept assignment problem. The authors argue that the solution to this problem requires methods that have a strong plausible reasoning component. They illustrate these ideas through example scenarios using an existing design recovery system called DESIRE. DESIRE is evaluated based on its usage on real-world problems over the years.<>	0270-5257	0-8186-3700-5			Humans;Pattern recognition;Context;Microelectronics;Reverse engineering;Vocabulary;Automatic control;Communication system control;Maintenance engineering;Assembly	software tools;program diagnostics;software maintenance	concept assignment problem;program understanding;human oriented concepts;implementation oriented counterparts;plausible reasoning;design recovery system;DESIRE		89	1	19		6 Aug 2002			IEEE	IEEE Conferences
How do program understanding tools affect how programmers understand programs?	how do program understanding tools affect how programmers understand programs	10.1109/WCRE.1997.624572	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=624572	M. . -A. D. Storey; K. Wong; H. A. Muller	School of Computing Science, Simon Fraser University, Burnaby, BC, Canada; Department of Computer Science, University of Victoria, Victoria, BC, Canada; Department of Computer Science, University of Victoria, Victoria, BC, Canada	Proceedings of the Fourth Working Conference on Reverse Engineering	6 Aug 2002	1997			12	21	We explore the question of whether program understanding tools enhance or change the way that programmers understand programs. The strategies that programmers use to comprehend programs vary widely. Program understanding tools should enhance or ease the programmer's preferred strategies, rather than impose a fixed strategy that may not always be suitable. We present observations from a user study that compares three tools for browsing program source code and exploring software structures. In this study, 30 participants used these tools to solve several high level program understanding tasks. These tasks required a broad range of comprehension strategies. We describe how these tools supported or hindered the diverse comprehension strategies used.		0-8186-8162-4			Programming profession;Switches;Software tools;Software maintenance;Reverse engineering;Displays;Visualization;Computer science;Software systems;Animation	reverse engineering;software maintenance;software tools;human factors	program understanding tools;programmers;user study;program source code browsing;software structures;high level program understanding tasks;diverse comprehension strategies		54		19		6 Aug 2002			IEEE	IEEE Conferences
Using latent semantic analysis to identify similarities in source code to support program understanding	using latent semantic analysis to identify similarities in source code to support program understanding	10.1109/TAI.2000.889845	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=889845	J. I. Maletic; A. Marcus	Division of Computer Science, The Department of Mathematical Sciences, University of Memphis, Memphis, TN, USA; Division of Computer Science, The Department of Mathematical Sciences, University of Memphis, Memphis, TN, USA	Proceedings 12th IEEE Internationals Conference on Tools with Artificial Intelligence. ICTAI 2000	6 Aug 2002	2000			46	53	The paper describes the results of applying Latent Semantic Analysis (LSA), an advanced information retrieval method, to program source code and associated documentation. Latent semantic analysis is a corpus based statistical method for inducing and representing aspects of the meanings of words and passages (of natural language) reflective in their usage. This methodology is assessed for application to the domain of software components (i.e., source code and its accompanying documentation). Here LSA is used as the basis to cluster software components. This clustering is used to assist in the understanding of a nontrivial software system, namely a version of Mosaic. Applying latent semantic analysis to the domain of source code and internal documentation for the support of program understanding is a new application of this method and a departure from the normal application domain of natural language.	1082-3409	0-7695-0909-6			Documentation;Information retrieval;Software systems;Information analysis;Natural languages;Application software;Statistical analysis;Computer science;Computer architecture;Software maintenance	reverse engineering;information retrieval;natural languages;computational linguistics;system documentation;statistical analysis	latent semantic analysis;source code similarities;program understanding;information retrieval method;source code;corpus based statistical method;natural language;software components;LSA;software component clustering;nontrivial software system;Mosaic;internal documentation		46	1	21		6 Aug 2002			IEEE	IEEE Conferences
Towards a framework for program understanding	towards a framework for program understanding	10.1109/WPC.1996.501117	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501117	S. R. Tilley; S. Paul; D. B. Smith	Software Engineering Institute, Carnegie Mellon University, USA; Center for Software Engineering, IBM Thomas J. Watson Research Center; Software Engineering Institute, Carnegie Mellon University, USA	WPC '96. 4th Workshop on Program Comprehension	6 Aug 2002	1996			19	28	The paper describes an initial conceptual framework for the classification of reverse engineering tools and techniques that aid program understanding. It is based on a description of the canonical activities that are characteristic of the reverse engineering process. A descriptive model is presented that categorizes important support mechanism features based on a hierarchy of attributes.	1092-8138	0-8186-7283-8			Reverse engineering;Software engineering;Software maintenance;Programming profession;Cognition;Relational databases	reverse engineering;computer aided software engineering;cognitive systems	program understanding framework;reverse engineering tools;canonical activities;descriptive model;support mechanism features;attribute hierarchy		41	2	23		6 Aug 2002			IEEE	IEEE Conferences
The interleaving problem in program understanding	the interleaving problem in program understanding	10.1109/WCRE.1995.514705	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=514705	S. Rugaber; K. Stirewalt; L. M. Wills	College of Computing, Georgia Institute of Technology, Atlanta, GA, USA; College of Computing, Georgia Institute of Technology, Atlanta, GA, USA; College of Computing, Georgia Institute of Technology, Atlanta, GA, USA	Proceedings of 2nd Working Conference on Reverse Engineering	6 Aug 2002	1995			166	175	One of the factors that can make a program difficult to understand is that code responsible for accomplishing more than one purpose may be woven together in a single section. We call this interleaving, and it may arise either intentionally-for example, in optimizing a program, a programmer may use some intermediate result for several purposes-or unintentionally, due to patches, quick fixes, or other hasty maintenance practices. To understand this phenomenon, we have looked at a variety of interleaving instances in actual programs and have distilled characteristic features. If the characterization proves to be robust then it will enable the design of tools for detection of interleavings and the extraction of the individual strands of computation.		0-8186-711-43			Interleaved codes;Programming	reverse engineering;software maintenance;software tools	interleaving problem;program understanding;program optimization;software maintenance;computation;reverse engineering		31	10	29		6 Aug 2002			IEEE	IEEE Conferences
Program understanding and maintenance with the CANTO environment	program understanding and maintenance with the canto environment	10.1109/ICSM.1997.624233	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5726937	G. Antoniol; R. Fiutem; G. Lutteri; P. Tonella; S. Zanfei; E. Merlo	IRST, Povo, Trento, Italy; IRST, Povo, Trento, Italy; IRST, Povo, Trento, Italy; IRST, Povo, Trento, Italy; IRST, Povo, Trento, Italy; Department Electrical and Computer Engineering, Ecole Polytechnique, Montreal, QUE, Canada	1997 Proceedings International Conference on Software Maintenance	15 Oct 2012	1997			72	81	During maintenance activities, the availability of integrated conceptual views that present software at different levels of abstraction, from software architecture to control and data flow relations at code level, is fundamental to understand and modify legacy systems. This paper presents CANTO (Code and Architecture Analysis Tool), a comprehensive program understanding and maintenance environment which integrates fine grained information with architectural views extracted from source code, giving the user control of what is being computed by analyses. The capabilities and usefulness of CANTO are illustrated with reference to a real understanding and maintenance task	1063-6773	0-8186-8013-X				data flow analysis;program control structures;reverse engineering;software maintenance;software tools	CANTO;Code and Architecture Analysis Tool;abstraction levels;architectural views;data flow relations;fine grained information;integrated conceptual views;legacy systems;program control;program understanding;software architecture;software maintenance;source code		30		15		15 Oct 2012			IEEE	IEEE Conferences
Lackwit: A Program Understanding Tool Based on Type Inference	lackwit a program understanding tool based on type inference	10.1145/253228.253351	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=610284	R. O'Callahan; D. Jackson	School of Computer Science, Carnegie Mellon University; School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA	Proceedings of the (19th) International Conference on Software Engineering	6 Aug 2002	1997			338	348		0270-5257	0-89791-914-9			Computer science;Data structures;Prototypes;Inference algorithms	restructuring, abstraction, C, representation			29	1	17		6 Aug 2002			IEEE	IEEE Conferences
Data-centered program understanding	datacentered program understanding	10.1109/ICSM.1994.336767	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=336767	Joiner; Tsai; Chen; Subramanian; Sun; Gandamaneni	University of Minnesota, Minneapolis, MN, US; Dept. of Comput. Sci., Minnesota Univ., Minneapolis, MN, USA; Department of Computer Science, University of Minnesota, Minneapolis, MN, USA; Department of Computer Science, University of Minnesota, Minneapolis, MN, USA; Department of Computer Science, University of Minnesota, Minneapolis, MN, USA; Department of Computer Science, University of Minnesota, Minneapolis, MN, USA	Proceedings 1994 International Conference on Software Maintenance	6 Aug 2002	1994			272	281	Software maintainers use a variety of techniques and representations for understanding programs. Most of these representations first focus on the control structure of a program such as call graphs, control flow graphs and paths. We propose a new approach for program understanding that is data-centered-it first focuses on data and data relationships. We have experimented on both small and large Cobol programs from industry to determine if our methods are useful for program understanding and software maintenance. We have developed DPUTE (Data-centered Program Understanding Tool Environment) that is currently being evaluated and enhanced by our industrial partners.<>		0-8186-6330-8			Software maintenance;Software fault diagnosis;Software tools;Software development environments	software maintenance;program diagnostics;software tools;programming environments	Data-centered Program Understanding Tool Environment;software maintenance;program control structure;call graphs;control flow graphs;control paths;data relationships;Cobol programs;DPUTE		26	2	28		6 Aug 2002			IEEE	IEEE Conferences
Feature-driven program understanding using concept analysis of execution traces	featuredriven program understanding using concept analysis of execution traces	10.1109/WPC.2001.921740	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921740	T. Eisenbarth; R. Koschke; D. Simon	University of Stuttgart, Stuttgart, Germany; University of Stuttgart, Stuttgart, Germany; University of Stuttgart, Stuttgart, Germany	Proceedings 9th International Workshop on Program Comprehension. IWPC 2001	7 Aug 2002	2001			300	309	The first task of a programmer who wants to understand how a certain feature is implemented is to localize the implementation of the feature in the code. If the implementations of a set of related features are to be understood, a programmer is interested in their commonalities and variabilities. For large and badly documented programs, localizing features in code and identifying the commonalities and variabilities of components and features can be difficult and time-consuming. It is useful to derive this information automatically. The feature-component correspondence describes which components are needed to implement a set of features and what are the respective commonalities and variabilities of those features and components. This paper describes a new technique to derive the feature-component correspondence utilizing dynamic information and concept analysis. The method is simple to apply, cost-effective, largely language-independent, and can yield results quickly.	1092-8138	0-7695-1131-7			Programming profession;Information analysis;Information resources;Documentation;Software architecture	reverse engineering;program diagnostics;subroutines	feature-driven program understanding;concept analysis;program execution traces;code feature implementation localization;feature commonalities;feature variabilities;large programs;badly documented programs;software components;automatic information derivation;feature-component correspondence;dynamic information;application simplicity;cost-effectiveness;language-independent method		23		16		7 Aug 2002			IEEE	IEEE Conferences
Investigating reverse engineering technologies for the CAS program understanding project	investigating reverse engineering technologies for the cas program understanding project	10.1147/sj.333.0477	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5387326	E. Buss; R. De Mori; W. M. Gentleman; J. Henshaw; H. Johnson; K. Kontogiannis; E. Merlo; H. A. Muller; J. Mylopoulos; S. Paul; A. Prakash; M. Stanley; S. R. Tilley; J. Troster; K. Wong	IBM Software Solutions Division, Toronto Laboratory, IBM Canada Limited, North York, ONT, Canada; School of Computer Science, McGill University, Quebec, Canada; Institutefor Information Technology, National Research Council Canada, Ottawa, ONT, Canada; IBM Software Solutions Division, Toronto Laboratory, IBM Canada Limited, North York, ONT, Canada; Institute for Information Technology, National Research Council Canada, Ottawa, ONT, Canada; School of Computer Science, McGill University, Quebec, Canada; Departement de Genie Electrique, Ecole Polytechnique, Quebec, Canada; Department of Computer Science, University of Victoria, P.O. Box 3055, BC V8W 3P6, Canada; Department of Computer Science, University of Toronto, Toronto, ONT, Canada; Software Systems Research Laboratory, Department of EECS, University of Michigan, Michigan; Software Systems Research Laboratory, Department of EECS, University of Michigan, Michigan; Department of Computer Science, University of Victoria, Victoria, BC, Canada; Department of Computer Science, University of Victoria, Victoria, BC, Canada; IBM Software Solutions Division, Toronto Laboratory, IBM Canada Limited, North York, ONT, Canada; Department of Computer Science, University of Victoria, Victoria, BC, Canada	IBM Systems Journal	6 Apr 2010	1994	33	3	477	500	Corporations face mounting maintenance and re-engineering costs for large legacy systems. Evolving over several years, these systems embody substantial corporate knowledge, including requirements, design decisions, and business rules. Such knowledge is difficult to recover after many years of operation, evolution, and personnel change. To address the problem of program understanding, software engineers are spending an ever-growing amount of effort on reverse engineering technologies. This paper describes the scope and results of an ongoing research project on program understanding undertaken by the IBM Toronto Software Solutions Laboratory Centre for Advanced Studies (CAS). The project involves a team from CAS and five research groups working cooperatively on complementary reverse engineering approaches. All the groups are using the source code of SQL/DS™ (a multimillion-line relational database system) as the reference legacy system. Also discussed is an approach adopted to integrate the various tools under a single reverse engineering environment.	0018-8670								23				6 Apr 2010			IBM	IBM Journals
A use-case driven method of architecture recovery for program understanding and reuse reengineering	a usecase driven method of architecture recovery for program understanding and reuse reengineering	10.1109/CSMR.2000.827302	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=827302	D. Bojic; D. Velasevic	Faculty of Electrical Engineering, University of Belgrade, Belgrade, Serbia; Faculty of Electrical Engineering, University of Belgrade, Belgrade, Serbia	Proceedings of the Fourth European Conference on Software Maintenance and Reengineering	6 Aug 2002	2000			23	31	This work focuses on architectural recovery for program understanding and reuse reengineering of legacy object-oriented systems. The proposed method is based on dynamic analysis of the system for the selected test cases that cover relevant use cases. The theory of formal concept analysis is applied to decompose the logical hierarchy of subsystems, so that parts of the system which implement similar functionality are grouped together.		0-7695-0546-5			Unified modeling language;Software systems;Computer architecture;Clustering algorithms;System testing;Software architecture;Communication system control;Access protocols;Documentation;Technology planning	software architecture;reverse engineering;system recovery;software reusability;systems re-engineering;object-oriented programming;object-oriented methods	use-case driven method;software architecture recovery;program understanding;reuse reengineering;legacy object-oriented systems;dynamic systems analysis;formal concept analysis;logical hierarchy decomposition;subsystems;functionality		17		38		6 Aug 2002			IEEE	IEEE Conferences
Folding: an approach to enable program understanding of preprocessed languages	folding an approach to enable program understanding of preprocessed languages	10.1109/WCRE.2001.957805	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=957805	B. Kullbach; V. Riediger	Institute for Software Technology, University of Koblenz and Landau, Koblenz, Germany; Institute for Software Technology, University of Koblenz and Landau, Koblenz, Germany	Proceedings Eighth Working Conference on Reverse Engineering	7 Aug 2002	2001			3	12	Since the early days of programming, preprocessors have been used to increase the expressiveness of programming languages. As a prominent example, the C Preprocessor cpp even allows low level configuration management through conditional compilation. But preprocessors significantly complicate the task of program understanding because "what the user sees is not what the compiler gets". There is a need for bridging the gap between preprocessor input and preprocessor output. The authors propose the use of folding for explicitly representing preprocessor replacements within a program understanding environment. The approach presented has been implemented as part of the GUPRO program understanding workbench. The user is enabled to individually choose the level of detail from the programmer's view to the compiler's view on the source code.	1095-1350	0-7695-1303-4			Reverse engineering;Program processors;Data preprocessing;Computer languages;Databases;Lattices;Visualization;Bidirectional control	reverse engineering;program processors;configuration management;C language	Folding;program understanding;preprocessed languages;programming language expressiveness;C Preprocessor;cpp;low level configuration management;conditional compilation;preprocessor input;preprocessor output;preprocessor replacements;program understanding environment;GUPRO program understanding workbench;source code;compiler view		17		14		7 Aug 2002			IEEE	IEEE Conferences
Augmenting abstract syntax trees for program understanding	augmenting abstract syntax trees for program understanding	10.1109/ASE.1997.632832	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=632832	C. A. Welty	Computer Science Department, Vassar College, Poughkeepsie, NY, USA	Proceedings 12th IEEE International Conference Automated Software Engineering	6 Aug 2002	1997			126	133	Program understanding efforts by individual maintainers are dominated by a process known as discovery, which is characterized by low-level searches through the source code and documentation to obtain information that is important to the maintenance task. Discovery is complicated by the delocalization of information in the source code, and can consume from 40-60% of a maintainer's time. This paper presents an ontology for representing code-level knowledge based on abstract syntax trees, that was developed in the context of studying maintenance problems in a small software company. The ontology enables the utilization of automated reasoning to counter delocalization, and thus to speed up discovery.		0-8186-7961-1			Software maintenance;Laboratories;Ontologies;Software systems;Computer industry;Industrial training;Educational institutions;Computer science;Documentation;Counting circuits	reverse engineering;software maintenance;trees (mathematics);knowledge representation;inference mechanisms;computer aided software engineering	abstract syntax trees;program understanding;software maintenance;discovery;low-level searches;source code;documentation;information delocalization;code-level knowledge representation;automated reasoning;software information systems		16		23		6 Aug 2002			IEEE	IEEE Conferences
The program understanding problem: analysis and a heuristic approach	the program understanding problem analysis and a heuristic approach	10.1109/ICSE.1996.493397	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=493397	S. Woods; Qiang Yang	Department of Computer Science, University of Waterloo, Waterloo, ONT, Canada; School of Computing Science, Simon Fraser University, Burnaby, BC, Canada	Proceedings of IEEE 18th International Conference on Software Engineering	6 Aug 2002	1996			6	15	Program understanding is the process of making sense of a complex source code. This process has been considered as computationally difficult and conceptually complex. So far no formal complexity results have been presented, and conceptual models differ from one researcher to the next. We formally prove that program understanding is NP hard. Furthermore, we show that even a much simpler subproblem remains NP hard. However we do not despair by this result, but rather offer an attractive problem solving model for the program understanding problem. Our model is built on a framework for solving constraint satisfaction problems, or CSPs, which are known to have interesting heuristic solutions. Specifically, we can represent and heuristically address previous and new heuristic approaches to the program understanding problem with both existing and specially designed constraint propagation and search algorithms.	0270-5257	0-8186-7247-1			Libraries;Computer science;Problem-solving;Algorithm design and analysis;Computer languages;Artificial intelligence	reverse engineering;computational complexity;constraint handling;search problems	program understanding problem;heuristic approach;complex source code;formal complexity results;conceptual models;NP hard;problem solving model;constraint satisfaction problems;CSPs;heuristic solutions;constraint propagation;search algorithms		15		19		6 Aug 2002			IEEE	IEEE Conferences
A program understanding support environment	a program understanding support environment	10.1147/sj.282.0324	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5387572	L. Cleveland	IBM Research Division, T. J. Watson Research Center, Yorktown Heights, NY	IBM Systems Journal	6 Apr 2010	1989	28	2	324	344	Software maintenance represents the largest cost element in the life of a software system, and the process of understanding the software system utilizes 50 percent of the time spent on software maintenance. Thus there is a need for tools to aid the program understanding task. The tool described in this paper—program UNderstanding Support environment (PUNS)—provides the needed environment. Here the program understanding task is supported with multiple views of the program and a simple strategy for moving between views and exploring a particular view in depth. PUNS consists of a repository component that loads and manages a repository of information about the program to be understood and a user interface component that presents the information in the repository, utilizing graphics to emphasize the relationships and allowing the user to move among the pieces of information quickly and easily.	0018-8670								14				6 Apr 2010			IBM	IBM Journals
The concept assignment problem in program understanding	the concept assignment problem in program understanding	10.1109/WCRE.1993.287781	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=287781	T. J. Biggerstaff; B. G. Mitbander; D. Webster	Microsoft Research; Microelectronics and Computer Technology Corporation, USA; Microelectronics and Computer Technology Corporation, USA	[1993] Proceedings Working Conference on Reverse Engineering	6 Aug 2002	1993			27	43	The problem of discovering individual human oriented concepts and assigning them to their implementation-oriented counterparts for a given program is the concept assignment problem. It is argued that the solution to this problem requires methods that have a strong plausible reasoning component. These ideas are illustrated through recovery system called DESIRE. DESIRE is evaluated based on its use on real-world problems over the years.<>		0-8186-3780-3			Humans;Pattern recognition;Microelectronics;Reverse engineering;Vocabulary;Automatic control;Communication system control;Context;Maintenance engineering;Assembly	program diagnostics;software engineering;systems analysis	concept assignment problem;program understanding;human oriented concepts;implementation-oriented counterparts;plausible reasoning;recovery system;DESIRE		12		18		6 Aug 2002			IEEE	IEEE Conferences
A little knowledge can go a long way towards program understanding	a little knowledge can go a long way towards program understanding	10.1109/WPC.1997.601275	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601275	J. Sayyad-Shirabad; T. C. Lethbridge; S. Lyon	Department of Computer Science, University of Ottawa, Ottawa, Canada; Department of Computer Science, University of Ottawa, Ottawa, Canada; Mitel Corporation, Kanata, ONT, Canada	Proceedings Fifth International Workshop on Program Comprehension. IWPC'97	6 Aug 2002	1997			111	117	Large, complex software systems are hard to learn and navigate. In an ideal environment, documentation can help in this process. However the latter is usually out of date and hard to use. Others have proposed using large knowledge bases to model software systems, however these are very, extensive to build and may be as unmaintainable as the code. We propose instead to use a highly circumscribed, small, conceptual knowledge base, whose purpose is to help the apprentice navigate a software system, and facilitate search within the code. We present our vision, and some initial experiments which involve building such a knowledge base in a semiautomated way.	1092-8138	0-8186-7993-X			Documentation;Software systems;Maintenance engineering;Cognitive science;Navigation;Computer science;Application software;Knowledge acquisition;Design methodology;Computer industry	reverse engineering;knowledge based systems;utility programs	program understanding;large complex software systems;ideal environment;documentation;software system modelling;small conceptual knowledge base;apprentice;knowledge engineering		12		8		6 Aug 2002			IEEE	IEEE Conferences
Model-based tools to record program understanding	modelbased tools to record program understanding	10.1109/WPC.1993.263902	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263902	E. J. Younger; K. H. Bennett	School of Engineering and Computer Science, University of Durham, Durham, UK; School of Engineering and Computer Science, University of Durham, Durham, UK	[1993] IEEE Second Workshop on Program Comprehension	6 Aug 2002	1993			87	95	Tools to record the knowledge gained by maintainers engaged in understanding an existing program are described. These tools are based on a model of the comprehension process and of reverse engineering as a whole. They form a part of an integrated reverse engineering toolset based around a central repository. Using these tools new documentation for an existing software system may be built up incrementally by successive maintainers who work on the system.<>	1092-8138	0-8186-4042-1			Documentation;Application software;Software maintenance;Reverse engineering;Maintenance engineering;Knowledge engineering;Computer science;Software systems;Software quality;Software tools	software maintenance;software tools;system documentation	maintenance;program understanding;comprehension process;reverse engineering;central repository;documentation		11		24		6 Aug 2002			IEEE	IEEE Conferences
Function-theoretic principles of program understanding	functiontheoretic principles of program understanding	10.1109/HICSS.1990.205177	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=205177	M. G. Pleszkoch; P. A. Hausler; A. R. Hevner; R. C. Linger	University of Maryland, IBM, Corporation, Baltimore, USA; University of Maryland, IBM, Corporation, Baltimore, USA; University of Maryland, College Park, USA; IBM, Corporation	Twenty-Third Annual Hawaii International Conference on System Sciences	6 Aug 2002	1990	2		74	81 vol.2	The authors propose a comprehensive methodology for automated program abstraction of computer programs. The theoretical foundations that support program abstraction are functional abstraction, data analysis, program slicing, and pattern matching. The theory of functional abstraction is applied to an example program. The localization of data scope is described as a step to facilitate the abstraction process. Techniques are presented for automatically abstracting the functions of both nonlooping and looping control structures.<>					Software maintenance;Documentation;Business;Software performance;Libraries;Debugging;Educational institutions;Data analysis;Large-scale systems;Automation	data structures;program processors;programming theory;software tools	program understanding;automated program abstraction;functional abstraction;data analysis;program slicing;pattern matching;data scope;nonlooping;looping control structures		11		17		6 Aug 2002			IEEE	IEEE Conferences
A user interface for an environment to support program understanding	a user interface for an environment to support program understanding	10.1109/ICSM.1988.10145	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=10145	L. Cleveland	IBM Research Division, IBM Thomas J. Watson Research Center	Proceedings. Conference on Software Maintenance, 1988.	6 Aug 2002	1988			86	91	A static analysis of the program to be understood can yield much valuable information. However, to be of value to the programmer involved in an understanding task, the presentation of the static analysis data must not complicate, nor distract from, the task of understanding the program. An appropriate technique for presenting such static analysis data to the programmer engaged in the understanding task is described. This user interface assumes a multiple-window environment and supports an intelligent cursor. The techniques described integrate the presentation of the various types of static analysis data yielding an interface that does not distract the programmer as he or she attempts to understand the program.<>		0-8186-0879-X			User interfaces;Programming profession;Data analysis;Software maintenance;Costs;Information analysis;Flow graphs;Couplings;Vehicles;Informatics	multiprogramming;program verification;programming environments;software tools;user interfaces	program verification;software tools;user interface;program understanding;static analysis;multiple-window environment;intelligent cursor		11				6 Aug 2002			IEEE	IEEE Conferences
Integrated hypertext and program understanding tools	integrated hypertext and program understanding tools	10.1147/sj.303.0363	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5387485	P. Brown	IBM Enterprise Systems Division, Suffern, NY	IBM Systems Journal	6 Apr 2010	1991	30	3	363	392	This paper describes some concepts and issues related to software tools integration. Questions regarding data integration and functional integration between tools are identified and discussed. Some techniques for handling large volumes of data are briefly described. A prototype tool is described in which hypertext links are automatically created between program analysis data and hypertext documentation. With this tool, end users can freely move between source code views and related documentation. A common annotation feature lets software developers and information developers share information and synchronize maintenance activities in a single tools environment.	0018-8670								9				6 Apr 2010			IBM	IBM Journals
Program understanding needs during corrective maintenance of large scale software	program understanding needs during corrective maintenance of large scale software	10.1109/CMPSAC.1997.625084	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=625084	A. von Mayrhauser; A. M. Vans	Computer Science Department, Colorado State University, Fort Collins, CO, USA; Computer Science Department, Colorado State University, Fort Collins, CO, USA	Proceedings Twenty-First Annual International Computer Software and Applications Conference (COMPSAC'97)	6 Aug 2002	1997			630	637	We report on a software understanding field study during corrective maintenance of large-scale software by professional software maintenance engineers. We explain the general understanding process, the information needs of these software engineers during their tasks, and the tool capabilities that would help them to be more productive.	0730-3157	0-8186-8105-5			Large-scale systems;Software maintenance;Programming profession;Software tools;Switches;Documentation;Computer science;Software testing;Software algorithms;Cognition	reverse engineering;software maintenance;human resource management;software tools	program understanding needs;corrective maintenance;large scale software;software understanding field study;professional software maintenance engineers;information needs;software tool;productivity		8		16		6 Aug 2002			IEEE	IEEE Conferences
Evaluating process clusters to support automatic program understanding	evaluating process clusters to support automatic program understanding	10.1109/WPC.1996.501134	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501134	T. Kunz	Department of Computer Science, University of Waterloo, Waterloo, ONT, Canada	WPC '96. 4th Workshop on Program Comprehension	6 Aug 2002	1996			198	207	Evaluating the design of a distributed application is difficult but provides useful information for program development and maintenance. In distributed debugging, for example, processes are often grouped together and treated as one entity to reduce the debugging complexity. We previously identified multiple approaches to automatic process clustering and prototypical tools implementing these approaches have been developed. The process clusters derived with these tools have been evaluated by comparing them to the author's understanding of the application design. This paper discusses a quantitative measure for process cluster evaluation. The measure uses information derived by a static source analysis as well as information about interprocess communication during the application execution. Experiments show that the resulting quantitative evaluation conforms with a human evaluation of the same clusters.	1092-8138	0-8186-7283-8			Debugging;Software maintenance;Humans;Computer science;Application software;Prototypes;Information analysis;Distributed computing;Parallel processing;Message passing	reverse engineering;software maintenance;distributed processing;program debugging;program diagnostics;software tools	process cluster evaluation;automatic program understanding;distributed application;software design;program development;software maintenance;distributed debugging;prototypical tools;software tools;application design;static source analysis;interprocess communication;application execution;quantitative evaluation		8		17		6 Aug 2002			IEEE	IEEE Conferences
Program understanding as constraint satisfaction	program understanding as constraint satisfaction	10.1109/CASE.1995.465302	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=465302	S. Woods; Qiang Yang	Department of Computer Science, University of Waterloo, Waterloo, ONT, Canada; Department of Computer Science, University of Waterloo, Waterloo, ONT, Canada	Proceedings Seventh International Workshop on Computer-Aided Software Engineering	6 Aug 2002	1995			318	327	The process of understanding a source code in a high-level programming language involves complex computation. Given a piece of legacy code and a library of program plan templates, understanding the code corresponds to building mappings from parts of the source code to particular program plans. These mappings could be used to assist an expert in reverse engineering legacy code, to facilitate software reuse, or to assist in the translation of the source into another programming language. In this paper we present a model of program understanding using constraint satisfaction. Within this model we intelligently compose a partial global picture of the source program code by transforming knowledge about the problem domain and the program itself into sets of constraints. We then systematically study different search algorithms and empirically evaluate their performance. One advantage of the constraint satisfaction model is its generality; many previous attempts in program understanding could now be cast under the same spectrum of heuristics, and thus be readily compared. Another advantage is the improvement in search efficiency using various heuristic techniques in constraint satisfaction.<>		0-8186-7078-9			Humans;Libraries;Computer science;Intelligent agent;Software engineering;Computer languages;Debugging;Logic programming;Costs;Artificial intelligence	reverse engineering;constraint handling;high level languages;software libraries;search problems;heuristic programming	program understanding;constraint satisfaction;high-level programming language;legacy code;program plan templates;reverse engineering;software reuse;programming language translation;search algorithms;performance evaluation;heuristics;search efficiency;heuristic techniques		7		20		6 Aug 2002			IEEE	IEEE Conferences
A case study of domain-based program understanding	a case study of domainbased program understanding	10.1109/WPC.1997.601273	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601273	R. Clayton; S. Rugaber; L. Taylor; L. Wills	College of Computing Georgia Institute of Technology, USA; College of Computing Georgia Institute of Technology, USA; College of Computing Georgia Institute of Technology, USA; School of Electrical and Computer Engineering, Georgia Institute of Technology, USA	Proceedings Fifth International Workshop on Program Comprehension. IWPC'97	6 Aug 2002	1997			102	110	Program understanding relates a computer program to the goals and requirements it is designed to accomplish. Understanding techniques that rely only on source code analysis are limited in their ability to derive this relationship. Application-domain analysis is another source of information that can aid program understanding by guiding the source analysis and providing structure to its results. This paper describes the application of a domain based program understanding process, Synchronized Refinement, to the problem of reverse engineering the Mosaic World Wide Web browser software. It discusses the domain analysis undertaken, the corresponding source code analysis we plan to perform, and the strengths and limitations of available automated tools.	1092-8138	0-8186-7993-X			Computer aided software engineering;Application software;Reverse engineering;Information analysis;Strontium;Software systems;Web sites;Performance analysis;Software tools;Documentation	reverse engineering;Internet;online front-ends;software tools;systems re-engineering	case study;domain-based program understanding;system requirements;source code analysis;application-domain analysis;Synchronized Refinement;reverse engineering;Mosaic World Wide Web browser;domain analysis;software tools;reengineering		7		20		6 Aug 2002			IEEE	IEEE Conferences
A documentation-related approach to object-oriented program understanding	a documentationrelated approach to objectoriented program understanding	10.1109/WPC.1994.341247	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341247	L. H. Etzkorn; C. G. Davis	University of Alabama Huntsville, USA; University of Alabama Huntsville, USA	Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94	6 Aug 2002	1994			39	45	Object-oriented code is considered to be inherently more reusable than functional decomposition code; however, object-oriented code can suffer from a program understanding standpoint since good object-oriented style seems to require a large number of small methods. Hence code for a particular task may be scattered widely. Thus good semantics based tools are necessary. This paper describes an approach to object-oriented code understanding that focuses largely on informal linguistic aspects of code, such as comments and identifiers.<>	1092-8138	0-8186-5647-6			Scattering;Formal specifications;Flow graphs;Software engineering;Encapsulation;Object oriented programming;Object oriented modeling;Software maintenance;Qualifications;Tree graphs	reverse engineering;object-oriented programming;software reusability;system documentation	object-oriented program understanding;documentation;reusable;semantics based tools;linguistic aspects;comments;identifiers		7		14		6 Aug 2002			IEEE	IEEE Conferences
A toolset for program understanding	a toolset for program understanding	10.1109/WPC.1993.263900	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263900	P. E. Livadas; S. D. Alden	Computer and Information Sciences, University of Florida, Gainesville, FL, USA; Computer and Information Sciences, University of Florida, Gainesville, FL, USA	[1993] IEEE Second Workshop on Program Comprehension	6 Aug 2002	1993			110	118	Program understanding is associated with the hierarchy of abstractions and interpretations that are deduced from the code. Program understanding requires the identification and study of the numerous complex interrelationships that are induced by the data flow, calling, and functional dependencies that exist in the software. Therefore, an environment is needed in order aid the programmer in understanding software. The authors have previously discussed both an internal program representation and an environment that conforms to the requirements stated. The toolset is referred to as Ghinsu and it supports a number of tasks over a program written in a subset of ANSI C such as slicing, dicing, and ripple analysis. They present some background on the problems associated with program understanding and show how the Ghinsu toolset can aid the programmer in understanding software.<>	1092-8138	0-8186-4042-1			Software maintenance;Costs;Programming profession;Intellectual property;Control systems;Software tools;Life estimation;Lifetime estimation;Computer aided instruction;Military computing	software maintenance;software tools	program understanding;data flow;calling;functional dependencies;understanding software;internal program representation;ANSI C;slicing;dicing;ripple analysis		6		19		6 Aug 2002			IEEE	IEEE Conferences
Toward a constraint-satisfaction framework for evaluating program-understanding algorithms	toward a constraintsatisfaction framework for evaluating programunderstanding algorithms	10.1109/WPC.1996.501121	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501121	A. Quilici; S. Woods	Department of Electrical Engineering, University of Hawai, Honolulu, HI, USA; Department of Computer Science, Davis Centre for Computer Research, University of Waterloo, Waterloo, ONT, Canada	WPC '96. 4th Workshop on Program Comprehension	6 Aug 2002	1996			55	64	Different program understanding algorithms often use different representational frameworks and take advantage of numerous heuristic tricks. This situation makes it difficult to compare these approaches and their performance. The paper addresses this problem by proposing constraint satisfaction as a general framework for describing program understanding algorithms, demonstrating how to transform a relatively complex existing program understanding algorithm into an instance of a constraint satisfaction problem, and showing how this facilitates better understanding of its performance.	1092-8138	0-8186-7283-8			Libraries;Performance analysis;Algorithm design and analysis;Indexing;Computer science;Distributed computing;Scalability;Heuristic algorithms;Decoding	reverse engineering;heuristic programming;constraint handling;constraint theory	constraint satisfaction framework;program understanding algorithm evaluation;representational frameworks;heuristic tricks		6		21		6 Aug 2002			IEEE	IEEE Conferences
On the role of program understanding in re-engineering tasks	on the role of program understanding in reengineering tasks	10.1109/AERO.1996.495930	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=495930	A. Von Mayrhauser; A. M. Vaus	Colorado State University, Fort Collins, CO, US; Dept. of Comput. Sci., Colorado State Univ., Fort Collins, CO, USA	1996 IEEE Aerospace Applications Conference. Proceedings	6 Aug 2002	1996	2		253	267 vol.2	This paper reports on a software understanding experiment during re-engineering of large-scale software. Participants were professional software maintenance engineers. The paper explains the general understanding process, the information needs of these software engineers during their tasks, and the tool capabilities that would help them to be more productive.		0-7803-3196-6			Programming profession;Object oriented modeling;Large scale integration;Computer science;Application software;Large-scale systems;Software maintenance;Software tools;Filters;Software performance	systems re-engineering;software maintenance;reverse engineering	program understanding;re-engineering tasks;professional software maintenance engineers;information needs;tool capabilities;comprehension model		5		24		6 Aug 2002			IEEE	IEEE Conferences
JACKAL: a hierarchical approach to program understanding	jackal a hierarchical approach to program understanding	10.1109/WCRE.1997.624579	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=624579	A. A. Reeves; J. D. Schlesinger	IDA/Center for Computing Sciences; IDA/Center for Computing Sciences	Proceedings of the Fourth Working Conference on Reverse Engineering	6 Aug 2002	1997			84	93	We present a tool, JACKAL, that represents both a program and cliches in an abstract language (AL) expressly developed for the purpose of facilitating the cliche matching task at a very high level rather than using abstract syntax trees. We then apply various matching algorithms to the AL representation. The language and two algorithms are presented.		0-8186-8162-4			Vegetation mapping;Libraries;Data structures;Pattern recognition;Size control;Lab-on-a-chip;Programming profession;Performance analysis;Reverse engineering;Pattern matching	reverse engineering;pattern matching;software libraries;formal languages	JACKAL;hierarchical approach;program understanding;cliches;abstract language;cliche matching task;high level;matching algorithms;AL representation		5		16		6 Aug 2002			IEEE	IEEE Conferences
Points to analysis for program understanding	points to analysis for program understanding	10.1109/WPC.1997.601271	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601271	P. Tonella; G. Antoniol; R. Fiutem; E. Merlo	IRST, ISaint per laRicerca Scientifica e Tecnologica, Trento, Italy; IRST, ISaint per laRicerca Scientifica e Tecnologica, Trento, Italy; IRST, ISaint per laRicerca Scientifica e Tecnologica, Trento, Italy; Department Electrical and Computer Engineering, Ecole Polytechnique, Montreal, QUE, Canada	Proceedings Fifth International Workshop on Program Comprehension. IWPC'97	6 Aug 2002	1997			90	99	Real world programs (in languages like C) heavily make use of pointers. Program understanding activities are thus made more difficult, since pointers affect the memory locations that are referenced in a statement, and also the functions called by a statement, when function pointers are used. The programmer needs to build a mental model of the memory use and of the pointers to its locations, in order to comprehend the functionalities of the system. This paper presents an efficient flow insensitive context insensitive points-to analysis algorithm capable of dealing with the features of the C code. It is extremely promising with regard to scalability, because of the low complexity. The results are valuable by themselves, as their graphical display represents the points to links between locations. They are also integrated with other program understanding techniques like, e.g., call graph construction, slicing, plan recognition and architectural recovery.	1092-8138	0-8186-7993-X			Programming profession;Algorithm design and analysis;Testing;Cognitive science;Scalability;Displays;Computer languages;Data mining;Maintenance engineering;Data engineering	reverse engineering;C language;program control structures	points to analysis;program understanding;C language;pointers;memory locations;function calls;function pointers;mental model;flow insensitive;context insensitive;scalability;graphical display;call graph;program slicing;plan recognition;architectural recovery		5	1	16		6 Aug 2002			IEEE	IEEE Conferences
Theory and practice of middle-out programming to support program understanding	theory and practice of middleout programming to support program understanding	10.1109/WPC.1994.341267	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341267	K. H. Bennett; M. P. Ward	Department of Computer Science, University of Durham, Durham, UK; Department of Computer Science, University of Durham, Durham, UK	Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94	6 Aug 2002	1994			168	175	Theories of top-down and bottom-up program comprehension have existed for several years, but it has been recognised that understanding rarely happens in practice in such a well-ordered way. The paper describes recent work and results at Durham on what is termed middle-out programming. The objective is to avoid the problems of top-down and bottom-up approaches, by designing a very high level language specific to the application domain. Domain knowledge is captured in the design of this language, which retains a strong formal basis. This paper takes the view that software engineering will become strongly application domain based, and that knowledge representation of the domain will be a crucial factor in supporting program comprehension. An example of using this approach in the design of a large software system is presented.<>	1092-8138	0-8186-5647-6			Computer science;Software engineering;Large-scale systems;Application software;Software systems;High level languages;Knowledge representation;Domain specific languages;Formal languages;Concurrent engineering	programming;reverse engineering;high level languages	middle-out programming;program understanding;top-down program comprehension;bottom-up program comprehension;very high level language;domain knowledge;software engineering;knowledge representation;program comprehension;large software system design		4		19		6 Aug 2002			IEEE	IEEE Conferences
Program understanding during software adaptation tasks	program understanding during software adaptation tasks	10.1109/ICSM.1998.738523	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=738523	A. von Mayrhauser; A. M. Vans	Computer Science Department,239 University Services Center, Colorado State University, Fort Collins, CO, USA; Computer Science Department,239 University Services Center, Colorado State University, Fort Collins, CO, USA	Proceedings. International Conference on Software Maintenance (Cat. No. 98CB36272)	6 Aug 2002	1998			316	325	This paper reports on a software understanding study during adaptation of large-scale software by software maintenance professionals. The paper explains the general understanding process, the information needs of these software engineers during their tasks, and the tool capabilities that would help them to be more productive. We also contrast programmer behavior during adaptation with that during other maintenance activities like corrective maintenance and enhancement.	1063-6773	0-8186-8779-7			Programming profession;Large-scale systems;Computer science;Operating systems;Software systems;Databases;Application software;Software tools;Documentation;Computer industry	reverse engineering;software maintenance	program understanding;software adaptation tasks;large-scale software;software maintenance;corrective maintenance		4		22		6 Aug 2002			IEEE	IEEE Conferences
Jan - Java animation for program understanding	jan java animation for program understanding	10.1109/HCC.2003.1260205	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1260205	K. . -P. Lohr; A. Vratislavsky	Freie Universität Berlin, Germany; Germany	IEEE Symposium on Human Centric Computing Languages and Environments, 2003. Proceedings. 2003	14 jan. 2004	2003			67	75	Jan is a system for animated execution of Java programs. Its application area is program understanding rather than debugging. To this end, the animation can be customized, both by annotating the code with visualization directives and by interactively adapting the visual appearance to the user's personal taste. Object diagrams and sequence diagrams are supported. Scalability is achieved by recognizing object composition: object aggregates are displayed in a nested fashion; mechanisms for collapsing and exploding aggregates are provided. Jan has been applied to itself producing an animation of its visualization back-end.		0-7803-8225-0			Java;Animation;Aggregates;Unified modeling language;Debugging;Scalability;Instruments;Data visualization;Displays;Collaboration	Java;reverse engineering;computer animation;program visualisation;diagrams;object-oriented programming	Jan;Java animation;program understanding;animated Java program execution;object diagrams;sequence diagrams;object composition;object aggregates;program visualization		3		17		14 jan. 2004			IEEE	IEEE Conferences
The relationship of slicing and debugging to program understanding	the relationship of slicing and debugging to program understanding	10.1109/WPC.1999.777749	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=777749	M. A. Francel; S. Rugaber	Department of Mathematics and Computer Science, Citadel; Georgia Institute of Technology, College of Computing Georgia Institute of Technology, USA	Proceedings Seventh International Workshop on Program Comprehension	6 Aug 2002	1999			106	113	The paper describes a study that explores the relationship between program slicing and code understanding gained while debugging. The study consisted of an experiment that compared the program understanding abilities of two classes of debuggers: those who slice while debugging and those who do not. For debugging purposes, a slice can be thought of as a minimal subprogram of the original code that contains the program faults. Those who only examine statements within a slice for correctness are considered slicers; all others are considered non-slicers. Using accuracy of reconstruction as a measure of understanding, it was determined that slicers have a better understanding of the code after debugging.	1092-8138	0-7695-0180-x			Debugging;Terminology;Mathematics;Computer science;Educational institutions;Fault diagnosis;IEEE standard glossaries	reverse engineering;program slicing;program debugging	program understanding;debugging;program slicing;code understanding;minimal subprogram;program faults		3		9		6 Aug 2002			IEEE	IEEE Conferences
A cognitive approach to program understanding	a cognitive approach to program understanding	10.1109/WCRE.1993.287784	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=287784	K. Bertels; P. Vanneste; C. De Backer	University of Namur, Namur, Belgium; K.U. Leuven Campus Kortrijk, K.U. Leuven Campus Kortrijk, Kortrijk, Belgium; UFSIA, Antwerp, Belgium	[1993] Proceedings Working Conference on Reverse Engineering	6 Aug 2002	1993			1	7	A method of program understanding is presented, based on a cognitive model of programming knowledge, and incorporating the basic concepts, structures, and strategies used by human expert programmers. The approach involves the generation of a high-level description of the program with, as main advantages, the use of abstraction and robustness with respect to conceptual errors. The use of abstraction permits the transcending of any syntactical variation and allows focusing on the semantics. This also potentially allows the analysis of larger programs. The method can cope with erroneous code, and can generate a precise description of the bug(s) involved. The method is useful for integration in a tutoring system for programming.<>		0-8186-3780-3			Flow graphs;Programming profession;Humans;Robustness;Computer bugs;Libraries;Testing;Usability;Calculus;Error correction	program debugging;program diagnostics;systems analysis	program description generation;program analysis;program debugging;program tutoring;program understanding;cognitive model;programming knowledge;human expert programmers;high-level description;conceptual errors;syntactical variation;semantics;erroneous code;tutoring system		3	1	12		6 Aug 2002			IEEE	IEEE Conferences
Applying plan recognition algorithms to program understanding	applying plan recognition algorithms to program understanding	10.1109/KBSE.1996.552827	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=552827	A. Quilici; Qiang Yang; S. Woods	Department of Electrical Engineering, University of Hawaii, Manoa, Honolulu, HI, USA; School of Computing Science, Simon Fraser University, Burnaby, BC, Canada; Department of Computer Science, University of Waterloo, Waterloo, ONT, Canada	Proceedings of the 11th Knowledge-Based Software Engineering Conference	6 Aug 2002	1996			96	103	Program understanding is often viewed as the task of extracting plans and design goals from program source. As such, it is natural to try to apply standard AI plan recognition techniques to the program understanding problem. Yet program understanding researchers have quietly, but consistently, avoided the use of these plan recognition algorithms. This paper shows that treating program understanding as plan recognition is too simplistic and that traditional AI search algorithms for plan recognition are not suitable. In particular, we show that: the program understanding task differs significantly from the typical general plan recognition task along several key dimensions; the program understanding task has particular properties that make it particularly amenable to constraint satisfaction techniques; and augmenting AI plan recognition algorithms with these techniques can lead to effective solutions for the program understanding problem.	1068-3062	0-8186-7681-7			Artificial intelligence;Computer science;Libraries;Algorithm design and analysis;Reverse engineering;Computer applications;Uncertainty	reverse engineering	plan recognition algorithms;program understanding;software design;artificial intelligence;search algorithms;constraint satisfaction		3		25		6 Aug 2002			IEEE	IEEE Conferences
A cooperative program understanding environment	a cooperative program understanding environment	10.1109/KBSE.1994.342670	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=342670	A. Quilici; D. N. Chin	Department of Electrical Engineering, University of Hawai, Honolulu, HI, USA; Department of Information and Computer Science, University of Hawai, Honolulu, HI, USA	Proceedings KBSE '94. Ninth Knowledge-Based Software Engineering Conference	6 Aug 2002	1994			125	132	The large size and high-percentage of domain-specific code in most legacy systems makes it unlikely that automated understanding tools will be able to completely understand them. Yet automated tools can clearly recognize portions of the design. That suggests exploring environments in which programmer and system work together to understand legacy software. This paper describes such an environment that supports programmer and system cooperating to extract an object-oriented design from legacy software systems. It combines an automated program understanding component that recognizes standard implementations of domain independent plans with with a structured notebook that the programmer uses to link object-oriented design primitives to arbitrary source code fragments. This jointly extracted information is used to support conceptual queries about the program's code and design.<>	1068-3062	0-8186-6380-4			Programming profession;Data mining;Computer architecture;Code standards;Software tools;Pattern recognition;Libraries;Computer science;Software prototyping;Software design	program diagnostics;software tools;object-oriented programming;knowledge based systems;software maintenance	cooperative program understanding environment;domain-specific code;legacy systems;automated understanding tools;object-oriented design;domain independent plans;structured notebook;source code fragments		3		20		6 Aug 2002			IEEE	IEEE Conferences
Influence of domain-specific notation to program understanding	influence of domainspecific notation to program understanding	10.1109/IMCSIT.2009.5352767	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5352767	T. Kosar; M. Mernik; M. Črepinšek; P. R. Henriques; D. da Cruz; M. J. Varanda Pereira; N. Oliveira	Faculty of Electrical Engineering and Computer Science, University of Maribor, Maribor, Slovenia; Faculty of Electrical Engineering and Computer Science, University of Maribor, Maribor, Slovenia; Faculty of Electrical Engineering and Computer Science, University of Maribor, Maribor, Slovenia; Department of Computer Science, University of Minho, Braga, Portugal; Faculty of Electrical Engineering and Computer Science, University of Maribor, Maribor, Slovenia; Polytechnic Institute of Bragança, Braganca, Portugal; Faculty of Electrical Engineering and Computer Science, University of Maribor, Maribor, Slovenia	2009 International Multiconference on Computer Science and Information Technology	11 Dec 2009	2009			675	682	Application libraries are the most commonly used implementation approach to solve problems in general-purpose languages. Their competitors are domain-specific languages, which can provide notation close to the problem domain. We carried out an empirical study on comparing domain-specific languages and application libraries regarding program understanding. In this paper, one case study is presented. Over 3000 lines of code were studied and more than 86 pages long questionnaires were answered by end-users, answering questions on learning, perceiving and evolving programs written in domain-specific language as well as general-purpose language using application library. In this paper, we present comparison results on end-users' correctness and consumed time. For domain-specific language and application library same problem domain has been used—a well-known open source graph description language, DOT.	2157-5525	978-1-4244-5314-6			DSL;Domain specific languages;Libraries;Computer science;Productivity;Information technology;Cognitive science;Programming environments;Skeleton;Software engineering	program diagnostics;programming languages;specification languages	domain specific notation;program understanding;application libraries;general purpose languages;domain specific languages;learning;open source graph description language		3		17		11 Dec 2009			IEEE	IEEE Conferences
PUI: a tool to support program understanding	pui a tool to support program understanding	10.1109/WPC.1997.601293	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601293	Pui-Shan Chan; M. Munro	Visualisation Research Group Centre for Software Maintenance, University of Durham, Durham, UK; Visualisation Research Group Centre for Software Maintenance, University of Durham, Durham, UK	Proceedings Fifth International Workshop on Program Comprehension. IWPC'97	6 Aug 2002	1997			192	198	Static analysis tools are useful in extracting information from programs. Maintainers are more likely to be overloaded with information extracted from these analysis tools as programs grow in size. This paper outlines some of the theories and strategies of program comprehension and describes how the various strategies can be realised by a simple browsing tool, PUI (Program Understanding Implement), which allows maintainers to understand the relationships between program elements. The tool is based on a matrix of program relations designed to reflect the multi-dimensional nature of programs. This work is centred on the C programming language.	1092-8138	0-8186-7993-X			Information analysis;Data mining;Computer languages;Switches;Visualization;Software maintenance;DH-HEMTs;Documentation;Information resources;Control systems	software tools;reverse engineering;program diagnostics;software maintenance;C language;computer aided software engineering	PUI;Program Understanding Implement;static analysis tool;program information extraction;software maintenance;program comprehension;browsing tool;program element relationships;program relations matrix;multi-dimensional programs;C programming language		3		14		6 Aug 2002			IEEE	IEEE Conferences
Program understanding as constraint satisfaction	program understanding as constraint satisfaction	10.1109/WCRE.1995.514719	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=514719	S. Woods; Qiang Yang	Department of Computer Science, University of Waterloo, Waterloo, ONT, Canada; Department of Computer Science, University of Waterloo, Waterloo, ONT, Canada	Proceedings of 2nd Working Conference on Reverse Engineering	6 Aug 2002	1995			314	323	The process of understanding a source code in a high-level programming language involves complex computation. Given a piece of legacy code and a library of program plan templates, understanding the code corresponds to building mappings from parts of the source code to particular program plans. These mappings could be used to assist an expert in reverse engineering legacy code, to facilitate software reuse, or to assist in the translation of the source into another programming language. In this paper, we present a model of program understanding using constraint satisfaction. Within this model, we intelligently compose a partial global picture of the source program code by transforming knowledge about the problem domain and the program itself into sets of constraints. We then systematically study different search algorithms and empirically evaluate their performance. One advantage of the constraint satisfaction model is its generality; many previous attempts in program understanding could now be cast under the same spectrum of heuristics, and thus be readily compared. Another advantage is the improvement in search efficiency using various heuristic techniques in constraint satisfaction.		0-8186-711-43			Computer languages;Humans;Libraries;Computer science;Intelligent agent;Software engineering;Debugging;Logic programming;Costs;Artificial intelligence	reverse engineering;constraint handling;search problems;heuristic programming;software libraries;software reusability	program understanding;constraint satisfaction;source code understanding;high-level programming language;complex computation;legacy code;program plan template library;mappings;software reuse;program translation;partial global picture;problem domain knowledge transformation;search algorithms;performance evaluation;heuristic techniques;search efficiency		2		20		6 Aug 2002			IEEE	IEEE Conferences
On inserting program understanding technology into the software change process	on inserting program understanding technology into the software change process	10.1109/WPC.1996.501124	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501124	K. Wong	Department of Computer Science, University of Victoria, Victoria, BC, Canada	WPC '96. 4th Workshop on Program Comprehension	6 Aug 2002	1996			90	99	Program understanding technologies can be applied effectively in the analysis phase of a software change process. The analysis phase naturally follows a goal driven metaprocess. Described are issues involved with inserting program understanding technology into existing practice and into such a metaprocess. The implied processes of program understanding and reverse engineering tools play an important role. These issues pose major problems for the acceptance of redocumentation tools such as Rigi, an evolvable reverse engineering tool. An example using Rigi and its analysis methodology for change impact analysis is considered.	1092-8138	0-8186-7283-8			Software quality;Reverse engineering;Costs;Software systems;Computer science;Software development management;Computer industry;Programming;Customer satisfaction;Matched filters	reverse engineering;management of change;system documentation;software tools	program understanding technology;software change process;analysis phase;goal driven metaprocess;reverse engineering tools;redocumentation tools;evolvable reverse engineering tool;change impact analysis		2		20		6 Aug 2002			IEEE	IEEE Conferences
Binary-level lightweight data integration to develop program understanding tools for embedded software in C	binarylevel lightweight data integration to develop program understanding tools for embedded software in c	10.1109/APSEC.2004.36	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1371936	K. Gondow; T. Suzuki; H. Kawashima	Tokyo Institute of Technology, Meguro, Tokyo, Japan; NA; Japan Advanced Institute of Science and Technology, Tatsunokuchi, Ishikawa, Japan	11th Asia-Pacific Software Engineering Conference	17 jan. 2005	2004			336	345	In embedded software development, the programming language C and inline assembly code are traditionally widely used. However, tools for C program-understanding, e.g., cross-referencers or call graph extractors, are not mature still today. In this paper, we introduce a novel technique for developing program-understanding tools, based on binary-level lightweight data integration. To verify this idea, we first propose a new markup language for DWARF2 debugging information, and then, using the technique, we experimentally developed two cross-referencers (called dxref and rxref) and a call graph extractor (called bscg) for C. Our preliminary evaluation shows that the technique enabled us to efficiently develop practical and flexible tools.	1530-1362	0-7695-2245-9			Embedded software;Software engineering	data integrity;C language;reverse engineering;embedded systems;software tools	binary-level lightweight data integration;program understanding tool;embedded software;C;embedded software development;programming language;inline assembly code;cross-referencer;call graph extractor;markup language;DWARF2 debugging information		2		32		17 jan. 2005			IEEE	IEEE Conferences
Assessment of support for program understanding	assessment of support for program understanding	10.1109/AQSDT.1992.205843	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=205843	Eun Man Choi; A. von Mayrhauser	Department of Computer Science, Illinois Institute of Technology, Chicago, IL, USA; Computer Science Department, Colorado State University, Fort Collins, CO, USA	[1992] Proceedings of the Second Symposium on Assessment of Quality Software Development Tools	6 Aug 2002	1992			102	111	Discusses tools for program understanding during the software maintenance phase. The program understanding is crucial to successful maintenance, but it is still poorly supported by analysis-oriented tools. In the light of cognitive studies for program understanding, the authors assess the existing tools for program understanding, and suggest an approach which facilitates the understanding of complex code during maintenance via the chunking process. During this process programmers recognize the abstract function or meaning of groups of statements and then piece together these chunks to form even larger chunks until the entire code is understood and mapped out. Chunking support can be effective as part of a maintenance toolkit. It lets maintenance personnel control code abstraction and ask many semantic questions about chunks and their relationship to other parts of the code.<>		0-8186-2620-8			Software maintenance;Programming profession;Computer science;Pattern recognition;Personnel;Software testing;Application software;Computer architecture;Productivity;Character recognition	human factors;software maintenance;software tools	software tools;program understanding;software maintenance;cognitive studies;chunking process;personnel;code abstraction		1		31		6 Aug 2002			IEEE	IEEE Conferences
Towards Trace Based Model Synthesis for Program Understanding and Test Automation	towards trace based model synthesis for program understanding and test automation	10.1109/ICSEA.2007.80	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4299927	T. Kanstren	VTT Technical Research Center of Finland, Oulu, Finland	International Conference on Software Engineering Advances (ICSEA 2007)	10 Sep 2007	2007			46	46	Effective maintenance and evolution of complex, software intensive systems requires understanding how the system works and having tests available to verify the effects of changes. Understanding complex systems is difficult, and testability of these systems is often low due to design constraints, system complexity and long- term evolution. Thus understanding the system and adding new tests is difficult. Yet, especially in these cases, the understanding and tests are important to verify the system correctness over long-term evolution. This paper discusses synthesizing models from system traces and using these models to facilitate program understanding and test automation. Basing the models on execution traces allows generation of automated tests even for low testability systems. Generating and visualizing abstracted models facilitates program understanding, which helps in system maintenance.		0-7695-2937-2			Automatic testing;Automation;System testing;Instruments;Software testing;Software maintenance;Software systems;Visualization;Real time systems;Control systems	program diagnostics;program testing	program understanding;test automation;trace based model synthesis;software intensive system		1		26		10 Sep 2007			IEEE	IEEE Conferences
Improving program understanding by unfolding layers of interacting patterns	improving program understanding by unfolding layers of interacting patterns	10.1109/WPC.1996.501135	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501135	R. R. Klosch; R. T. Mittermeir	Information & Computer Science Department, University of California, Irvine, Irvine, CA, USA; Institute of Informatics, Klagenfurt University, Klagenfurt, Austria	WPC '96. 4th Workshop on Program Comprehension	6 Aug 2002	1996			208	217	Reverse engineering of legacy systems is a cumbersome task. Some of its aspects can be automated reasonably well, others are better not touched or require the intervention of a human expert. In an attempt to improve our rearchitecturing methodology, COREM, we found that various patterns, software developers use or have to use when developing systems, can serve to support the program understanding part of the reverse engineering process. We depart from the widely accepted hypothesis that software developed by experts is not a mere sequence of relatively primitive statements, but rather the result of a set of interacting, time and situation specific problem, design, and language patterns. To support these considerations, the paper shows how different language paradigms influence the actual code even with a simple problem. The extension of these ideas to interacting high level design patterns is motivated.	1092-8138	0-8186-7283-8			Reverse engineering;Application software;Programming profession;Software systems;Computer science;Informatics;Humans;Error analysis;Image analysis;Information analysis	reverse engineering;software reusability;automatic programming;software tools	program understanding;reverse engineering;legacy systems;rearchitecturing methodology;COREM;reverse engineering process;situation specific problem;language patterns;language paradigms;interacting high level design patterns		1		31		6 Aug 2002			IEEE	IEEE Conferences
Applying the signature concept to plan-based program understanding	applying the signature concept to planbased program understanding	10.1109/ICSM.2003.1235438	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1235438	Y. Limpiyakorn; I. Burnstein	Department of Computer Engineering, Chulalongkom University, Bangkok, Thailand; Department of Computer Science, Illinois Institute of Technology, Chicago, IL, USA	International Conference on Software Maintenance, 2003. ICSM 2003. Proceedings.	7 Oct 2003	2003			325	334	Program understanding tools that are able to process large legacy systems are needed to support software engineers with maintenance tasks. One type of tool, a plan-based program understander, recognizes concepts in the code by comparing the target code against a library of programming plans. For a large plan library, an exhaustive search for a matching plan during concept recognition is not effective. This drawback limits the practical scalability of these types of tools. We propose a signature-based approach to prune the plan library. A signature in this work is a set of high level attributes derived from code features suggested by studies on human program comprehension. A SIGMA prototype is implemented to embody the proposed approach. Program plan retrieval with SIGMA (signature matching agent) shows promising results in removing irrelevant plans from consideration prior to attempting the later computational concept recognition process. It appears that the signature approach to plan retrieval may be able to facilitate the scaling up of plan-based understanders so that they can better support maintenance tasks on large legacy systems.	1063-6773	0-7695-1905-9			Software maintenance	reverse engineering;software maintenance;software tools;software libraries;pattern matching	plan-based program understanding;program understanding tools;legacy systems;software engineering support;software maintenance tasks;plan library;signature-based approach;human program comprehension;SIGMA prototype;signature matching agent;program plan retrieval;computational concept recognition		1		19		7 Oct 2003			IEEE	IEEE Conferences
Automated assistance to program understanding	automated assistance to program understanding	10.1109/TENCON.1994.369160	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=369160	Eun Man Choi; A. von Mayrhauser	Department of Computer Engineering, DongGuk University, Seoul, South Korea; Computer Science Department, Colorado State University, Fort Collins, CO, USA	Proceedings of TENCON'94 - 1994 IEEE Region 10's 9th Annual International Conference on: 'Frontiers of Computer Technology'	6 Aug 2002	1994			1002	1007 vol.2	Software maintenance requires the understanding of existing code, determining whether to make changes, assessing the impact of modifications, rebuilding code after alterations, and regression testing to validate changes. Program understanding is a bottleneck phase when the code to be maintained is invisible which means difficult to get needed information. This paper suggests a method for supporting program understanding by bottom-up driven and code-oriented view. The toolset includes abstraction mechanism, restructuring capability, ripple effect analysis, chunking guidance, and reuse. It lets the maintenance programmer understand the program effectively, refer to other people's understanding, analyze the effect of changes, and reusable program segments.<>		0-7803-1862-5			Programming profession;Cognitive science;Guidelines;Character recognition	reverse engineering;software maintenance;program debugging;programming environments;software tools;software reusability	program understanding;software maintenance;code rebuilding;regression testing;bottom-up driven;code-oriented view;toolset;abstraction mechanism;restructuring capability;ripple effect analysis;chunking guidance;software reuse;maintenance programmer;program segments		1		13		6 Aug 2002			IEEE	IEEE Conferences
Simplicity: a key engineering concept for program understanding	simplicity a key engineering concept for program understanding	10.1109/WPC.2001.921718	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921718	Yang Li; Hongji Yang	Computer Science Department, De Montfort University, UK; Computer Science Department, De Montfort University, UK	Proceedings 9th International Workshop on Program Comprehension. IWPC 2001	7 Aug 2002	2001			98	107	One of the most significant problems for existing program comprehension methods is its scalability. We introduce a new technique to make the scalability possible. In particular, we advocate the concept of "simplicity" for program understanding. We first propose a simplified semantic network as domain knowledge representation; we then introduce a linear and domain-oriented program partitioning method which can partition a huge program into self-contained program modules so that the recovery of domain knowledge can be carried out within smaller program space. We also introduce a set of rules for recovering domain knowledge from C code followed by a theoretical analysis on these algorithms. A case study on programming style based program partitioning method is given. Finally, comparisons with other work are made and a conclusion is drawn.	1092-8138	0-7695-1131-7			Software systems;Documentation;Programming profession;Humans;Computational complexity;Scalability;Linear programming;Couplings;Knowledge engineering;Computer science	reverse engineering;semantic networks;program slicing;C language	program understanding;program comprehension;scalability;simplicity;semantic network;domain knowledge representation;program partitioning;domain knowledge recovery;C code;case study;programming style		1	1	25		7 Aug 2002			IEEE	IEEE Conferences
Building program understanding tools using visitor combinators	building program understanding tools using visitor combinators	10.1109/WPC.2002.1021335	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021335	A. van Deursen; J. Visser	CWI, Amsterdam, Netherlands; CWI, Amsterdam, Netherlands	Proceedings 10th International Workshop on Program Comprehension	10 Dec 2002	2002			137	146	Program understanding tools manipulate program representations, such as abstract syntax trees, control-flow graphs or data-flow graphs. This paper deals with the use of visitor combinators to conduct such manipulations. Visitor combinators are an extension of the well-known visitor design pattern. They are small, reusable classes that carry out specific visiting steps. They can be composed in different constellations to build more complex visitors. We evaluate the expressiveness, reusability, ease of development and applicability of visitor combinators to the construction of program understanding tools. To that end, we conduct a case study in the use of visitor combinators for control-flow analysis and visualization as used in a commercial Cobol program understanding tool.	1092-8138	0-7695-1495-2			Tree graphs;Visualization;Concrete;Testing;Pattern analysis;Software design;Flow graphs;Solid modeling;Context modeling;Design engineering	reverse engineering;software tools;object-oriented methods;program diagnostics;software reusability;computer aided software engineering;flow graphs;COBOL	Cobol program understanding tool;visitor combinators;program representations manipulation;abstract syntax trees;control-flow graphs;data-flow graphs;visitor design pattern;reusable classes;visiting steps;constellations;expressiveness;reusability;ease of development;tool construction applicability;case study;control-flow analysis;software visualization;program analysis;program comprehension		1		16		10 Dec 2002			IEEE	IEEE Conferences
Evolving Ispell: a case study of program understanding for reuse	evolving ispell a case study of program understanding for reuse	10.1109/WPC.2002.1021341	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021341	L. Aversano; G. Canfora; A. De Lucia; S. Stefanucci	Department of Engineering, University of Sannio, Rome, Italy; Department of Engineering, University of Sannio, Rome, Italy; Department of Engineering, University of Sannio, Rome, Italy; Department of Engineering, University of Sannio, Rome, Italy	Proceedings 10th International Workshop on Program Comprehension	10 Dec 2002	2002			197	206	Text processing has proven helpful in a number of software engineering tasks. We discuss how a morphological analyser for the Italian language, and its associated linguistic resources, have been developed by reusing and evolving an existing system, Ispell, which is an open-source spell-checker. The need to develop such an analyser derives from the need to improve the traceability link recovery process described by G. Antoniol et al. (2000, 2002). This paper shows how the program understanding exercise was useful to develop a system in a specialized application domain in which we had a very limited background knowledge.	1092-8138	0-7695-1495-2			Computer aided software engineering;Information retrieval;Text processing;Data mining;Software engineering;Software maintenance;Programming profession;Indexing;Application software;Stress	spelling aids;reverse engineering;software reusability;linguistics;public domain software;computer aided analysis;text analysis	Ispell system evolution;case study;program understanding;software reuse;text processing;software engineering;morphological analyser;Italian language;linguistic resources;open-source spell-checker;traceability link recovery process;specialized application domain;limited background knowledge		1		32		10 Dec 2002			IEEE	IEEE Conferences
A prototype system for static and dynamic program understanding	a prototype system for static and dynamic program understanding	10.1109/WCRE.1993.287775	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=287775	D. P. Olshefski; A. Cole	IBM Thomas J. Watson Research Center, Yorktown Heights, NY, USA; IBM Thomas J. Watson Research Center, Yorktown Heights, NY, USA	[1993] Proceedings Working Conference on Reverse Engineering	6 Aug 2002	1993			93	106	A tool called PUNDIT (Program Understanding Investigation Tool) is described. It is a prototype intended to serve as a vehicle for exploring and testing ideas in the area of program understanding; it combines static analysis information with information collected at runtime. The architecture of PUNDIT is described, together with its two main components (the C source analyzer and a graphical user interface). Several of the views provided by the tool are explained, including a high-level structure chart, a dynamic call graph, a control flow graph animated during program execution, a type definition window, and others. By integrating static and dynamic information, the tool provides a more comprehensive understanding of a program as the first step to reengineering or maintaining the application that can be obtained by static analysis alone.<>		0-8186-3780-3			Prototypes;Information analysis;Vehicle dynamics;Runtime;User interfaces;Vehicles;Testing;Flow graphs;Maintenance engineering;Humans	graphical user interfaces;program diagnostics;software maintenance;software tools	software tool;program testing;runtime information;software reengineering;software maintenance;prototype system;PUNDIT;Program Understanding Investigation Tool;static analysis information;C source analyzer;graphical user interface;high-level structure chart;dynamic call graph;control flow graph;program execution;type definition window		1	2	13		6 Aug 2002			IEEE	IEEE Conferences
Evaluation of a knowledge-based approach to program understanding	evaluation of a knowledgebased approach to program understanding	10.1109/ICSM.1996.565017	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=565017	S. K. Abd-El-Hafiz	Dept. of Eng. Math., Cairo Univ., Giza, Egypt	1996 Proceedings of International Conference on Software Maintenance	6 Aug 2002	1996			275	284	The paper evaluates a recently presented knowledge-based program understanding approach that generates first order predicate logic annotations of loops. An initial and partial evaluation of this approach was performed on an existing program of reasonable size. Plans in the knowledge base were designed by performing an analysis of the existing program. As a result, the previous study did not demonstrate that the knowledge base generated for a given program is generally usable beyond that program. An extensive evaluation of the analysis approach is performed. Plans developed during the initial evaluation stage are used to analyze a set of 92 loops in five randomly selected Pascal programs. Results concerning the analyzed loops and utilization of the existing plans are given and discussed. These results generally show a good usability of the knowledge base beyond the original program.	1063-6773	0-8186-7677-9			Reverse engineering	reverse engineering	knowledge-based program understanding evaluation;first order predicate logic loop annotation;partial evaluation;plans;program analysis;initial evaluation;Pascal programs;usability		1		23		6 Aug 2002			IEEE	IEEE Conferences
Using an artificial intelligence approach to build an automated program understanding/fault localization tool	using an artificial intelligence approach to build an automated program understanding/fault localization tool	10.1109/TAI.1999.809768	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=809768	I. Burnstein; R. Saner; Y. Limpiyakorn	Computer Science Department, Illinois Institute of Technology, Chicago, IL, USA; Computer Science Department, Illinois Institute of Technology, Chicago, IL, USA; Computer Science Department, Illinois Institute of Technology, Chicago, IL, USA	Proceedings 11th International Conference on Tools with Artificial Intelligence	6 Aug 2002	1999			69	76	Artificial intelligence techniques and architectures have played a large role in the design of a blackboard-based program understanding/fault localization tool we have been developing. We focus on a system knowledge source called the plan processor which will have artificial intelligence support for two of its major tasks. One task is to retrieve a set of program plans from a plan library using indices called signatures. To make this retrieval task more effective we propose using a genetic algorithm. We also describe a fuzzy reasoning component which supports the plan processor with a second task; ranking the retrieved plans in order of similarity to the target code. The most similar plan is then used for the complex plan/code matching required for automated program understanding. Our approach may eliminate the need for exhaustive plan library searches, and could lead to automated program understanders that scale up for use on software systems from a variety of problem domains.	1082-3409	0-7695-0456-6			Artificial intelligence;Computer architecture;Software systems;Computer science;Genetic algorithms;Software libraries;Software maintenance;Software tools;Knowledge engineering;Programming profession	blackboard architecture;reverse engineering;program debugging;planning (artificial intelligence);genetic algorithms;fuzzy logic;inference mechanisms;uncertainty handling	artificial intelligence;program understanding;fault localization tool;blackboard-based tool;system knowledge source;plan processor;plan library;genetic algorithm;fuzzy reasoning		1		18		6 Aug 2002			IEEE	IEEE Conferences
A graphics-based system that supports the program understanding process	a graphicsbased system that supports the program understanding process	10.1109/ICSI.1990.138671	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=138671	B. R. Rimes	Dept. of Comput. Sci., Univ. of Southern Mississippi, Hattiesburg, MS, USA	Systems Integration '90. Proceedings of the First International Conference on Systems Integration	6 Aug 2002	1990			117	124	A visual system called PEEC (program execution environment configuration) that is designed to support the program understanding process through the use of the program's flow model represented in three-dimensional space is described. PEEC augments the control model by localizing source code and displaying identifiers based on their scope definition. The building blocks, tiers, used to construct a graphical model of the program's execution flow are defined. The format of the flow model in three-dimensional space is also defined. The tiers and the three-dimensional configuration of these tiers form the basis for the graphical representation of the program's execution environment. Examples of the flow model are provided that demonstrate the user's options as he/she browses the flow model.<>		0-8186-9027-5			Programming profession;Computer science;Visual system;Graphics;Three dimensional displays;Control systems	computer graphics;configuration management;programming environments;visual programming	graphics-based system;program understanding process;visual system;PEEC;program execution environment configuration;flow model;three-dimensional space;control model;source code;identifiers;scope definition;building blocks;tiers;graphical model;execution flow;three-dimensional configuration				9		6 Aug 2002			IEEE	IEEE Conferences
Temporal event analysis and program understanding	temporal event analysis and program understanding	10.1109/CMPSAC.1995.524751	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=524751	W. E. Howden; G. M. Shi	SERL, University of Hawai, Honolulu, HI, USA; SERL, University of Hawai, Honolulu, HI, USA	Proceedings Nineteenth Annual International Computer Software and Applications Conference (COMPSAC'95)	6 Aug 2002	1995			4	11	A temporal event analysis approach to program understanding is described. Program understanding is viewed as a sequence of episodes in which the programmer concludes that an informal event occurs that corresponds to some part of the code. This can be viewed as accepting that the code is an adequate definition of the meaning of the informal event. Often, such a definition is contingent upon working hypotheses that describe other informal program properties that should be verified in order to confirm the validity of the understanding process. Verification of working hypotheses may depend on the formulation of additional definitions or working hypotheses. The understanding process can be assisted through the use of a documentation language for describing events and hypotheses, and a hypothesis verification tool. The paper describes a temporal event language in which hypotheses are formulated in terms of expected event sequences. A hypothesis verification tool was built, and experimentation was carried out on a set of programs. The tool was found to be very useful in understanding the detailed, control oriented aspects of a program. Program faults were discovered in every program that was analyzed, indicating that it facilitates a deep level of understanding.	0730-3157	0-8186-7119-X			Programming profession;Documentation;Reverse engineering;IEEE Policy and Procedures	reverse engineering;program verification;system documentation;temporal logic	temporal event analysis approach;program understanding;informal event;working hypotheses;documentation language;hypothesis verification tool;temporal event language;expected event sequences;control oriented aspects;program faults				15		6 Aug 2002			IEEE	IEEE Conferences
Graph services for program understanding tools	graph services for program understanding tools	10.1109/AQSDT.1992.205859	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=205859	P. Brown; D. W. Stafford	IBM Sterling Forest, Suffern, NY, USA; IBM Sterling Forest, Suffern, NY, USA	[1992] Proceedings of the Second Symposium on Assessment of Quality Software Development Tools	6 Aug 2002	1992			238	251	Many types of problems are more easily understood when represented with graphs. This paper presents an organization of graph theoretical functions for use by an application program. The paper covers a unified set of generalized routines and data structures for graph reductions, path analysis, and data flow problems. Some suggestions for user interfaces are provided. Examples of problems in which these functions might be used are program understanding, software testing, software design, scheduling, and network management.<>		0-8186-2620-8			Application software;Data structures;Data analysis;Flow graphs;User interfaces;Software testing;Scheduling;Graphics;Graph theory;Information analysis	computer graphics;data structures;graphical user interfaces;program testing;software engineering	program understanding tools;graph theoretical functions;application program;generalized routines;data structures;graph reductions;path analysis;data flow problems;user interfaces;software testing;software design;scheduling;network management			1	8		6 Aug 2002			IEEE	IEEE Conferences
An automatic assistant for program understanding	an automatic assistant for program understanding	10.1109/ICCSSE.1988.72245	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=72245	V. Gafni	MBT Israel Aircraft Industries Limited	[1988] Proceedings. The Third Israel Conference on Computer Systems and Software Engineering	6 Aug 2002	1988			79	85	The paper explores the problem of understanding imperative programs. It points out the role of the procedural nature of knowledge representation as the main reason for difficulties in understanding this type of program. The paper suggests a generic process for reasoning about the knowledge embodied in an imperative program as a way to confront this problem. It proceeds with a concrete implementation of the process and a tool that has been constructed accordingly, thus demonstrating its practical usefulness. The goal of this work is to show a possible direction in automating the software development process rather than presenting a definite solution.<>		0-8186-0884-6			Software systems;Computer languages;Application software;Object oriented programming;Aircraft;Aerospace industry;Knowledge representation;Concrete;Natural languages;Humans	inference mechanisms;knowledge based systems;knowledge representation;software tools	automatic assistant;program understanding;imperative programs;procedural nature;knowledge representation;reasoning;software development process				10		6 Aug 2002			IEEE	IEEE Conferences
Effects of decomposition techniques on knowledge-based program understanding	effects of decomposition techniques on knowledgebased program understanding	10.1109/ICSM.1997.624227	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5726931	S. K. Abd-El-Hafiz	Engineering Mathematics Department, Faculty of Engineering, Cairo University, Giza, Egypt	1997 Proceedings International Conference on Software Maintenance	15 Oct 2012	1997			21	30	This paper studies the effects of two different program decomposition techniques on knowledge-based program understanding. The first technique generates events which encapsulate program parts that are interdependent with respect to data flow. The second technique is program slicing. Both techniques are briefly described and the resulting slices and events are compared. An understanding of a program is formed by matching its events or slices against previously designed knowledge base plans. In order to have a detailed insight into the design and utilization of the knowledge base, we perform a two-phase case study. The first phase uses the decomposition results of a set of 65 loops to construct two different knowledge bases; one for recognizing loop events and the other for recognizing loop slices. This phase of the case study demonstrates the different design decisions made during the construction of the two knowledge bases. The second phase of the case study utilizes the previously designed plans in analyzing a set of 92 loops extracted from five randomly selected programs. Finally, the results of comparing the two decomposition techniques are summarized	1063-6773	0-8186-8013-X				data flow analysis;knowledge based systems;program control structures;reverse engineering;software maintenance	case study;data flow;design decisions;knowledge base plans;knowledge-based program understanding;program decomposition techniques;program loop events;program loop slices;program parts;program slicing				35		15 Oct 2012			IEEE	IEEE Conferences
PUMP: a program understanding tool for MODSIM programs	pump a program understanding tool for modsim programs	10.1109/SIMSYM.2000.844908	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=844908	A. S. Bhullar; L. G. Birta	School of Information Technology and Engineering, University of Ottawa, Ottawa, ONT, Canada; School of Information Technology and Engineering, University of Ottawa, Ottawa, ONT, Canada	Proceedings 33rd Annual Simulation Symposium (SS 2000)	6 Aug 2002	2000			121	130	Automated program understanding tools have the potential to make important contributions to reducing the very substantial costs of program maintenance. We formulate a particular approach to program understanding within the context of the object-oriented simulation language, MODSIM. The software tool that has been developed is called PUMP (Program Understanding of MODSIM Programs). The input to this tool is the syntactically correct MODSIM program code for a simulation project which typically is distributed over several files. The main presentation of information about the program is via a user interface that is organized along hierarchical lines that correspond to the organizational structure of MODSIM programs. The hierarchical approach permits examination of program features in increasing levels of detail. The main thrust of the analysis is to identify entity types (e.g., objects, methods, variables) used in the program together with their interrelationships. The key design aspects of PUMP are outlined in the paper and an overview of the user interface is presented. Emphasis is given to the mechanisms specifically developed for handling the object-oriented features of MODSIM.	1080-241X	0-7695-0598-8			Software maintenance;Software systems;Application software;Costs;Programming profession;Documentation;Information technology;Electrical capacitance tomography;Software engineering;Object oriented programming	reverse engineering;digital simulation;software maintenance;object-oriented languages;simulation languages;software tools;user interfaces	PUMP tool;program understanding tool;MODSIM programs;program maintenance;costs;object-oriented simulation language;software tool;user interface				8		6 Aug 2002			IEEE	IEEE Conferences
Evaluation of a knowledge-based approach to program understanding	evaluation of a knowledgebased approach to program understanding	10.1109/WCRE.1996.558931	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=558931	S. K. Abd-El-Hafiz	Engineering Mathematics Department, Faculty of Engineering, Cairo University, Giza, Egypt	Proceedings of WCRE '96: 4rd Working Conference on Reverse Engineering	6 Aug 2002	1996			259	268	Paper reprinted from ICSM '96. This paper evaluates a knowledge-based program understanding approach that generates first order predicate logic annotations of loops. An initial and partial evaluation of this approach was performed on an existing program of reasonable size. Plans in the knowledge base were designed by performing an analysis of the existing program. As a result the previous study did not demonstrate that the knowledge base generated for a given program is generally usable beyond that program. In this study, an extensive evaluation of the analysis approach is performed. Plans developed during the initial evaluation stage are used to analyze a set of 92 loops in five randomly selected Pascal programs. Results concerning the analyzed loops and utilization of the existing plans are given and discussed. These results generally show a good usability of the knowledge base beyond the original program.		0-8186-7674-4			Performance analysis;Performance evaluation;Automation;Logic programming;Usability;Mathematics;Design methodology;Testing	knowledge based systems	knowledge-based approach;program understanding;first order predicate logic annotations;program loops;plans;Pascal programs;system usability				23		6 Aug 2002			IEEE	IEEE Conferences
About Interferable Binary Code Constructions	about interferable binary code constructions	10.1109/SYNCHROINFO49631.2020.9166042	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9166042	A. S. Adzhemov; A. Y. Kudryashova	Moscow Technical University of Communications and Informatics, Moscow, Russia; Moscow Technical University of Communications and Informatics, Moscow, Russia	2020 Systems of Signal Synchronization, Generating and Processing in Telecommunications (SYNCHROINFO)	13 Aug 2020	2020			1	4	Modern infocommunication systems, combining the capabilities of computer technology and communication devices, almost always have a digital implementation using binary code. In this case, various code structures are used, which on the one hand provide high transmission efficiency of the initial messages, the required noise immunity and, as far as possible, simple practical implementation, which allows to achieve lower technical and financial costs, minimize delays, etc. Moreover, the question of how the solutions used differ from theoretically achievable potential boundaries is very important.		978-1-7281-6072-6		code structure;minimum code distance;noise immunity;coding efficienc;theoretically achievable boundary;cascading codes	Optimization;Error correction codes;Binary codes;Channel coding;Telecommunications;Conferences	binary codes	financial costs;technical costs;required noise immunity;initial messages;high transmission efficiency;code structures;digital implementation;communication devices;computer technology;modern infocommunication systems;interferable binary code constructions		7		19		13 Aug 2020			IEEE	IEEE Conferences
Stuck in The Middle: Removing Obstacles to New Program Features through Batch Refactoring	stuck in the middle removing obstacles to new program features through batch refactoring	10.1109/ICSE-Companion.2019.00083	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8802630	E. Fernandes	OPUS Research Group, Pontifical Catholic University of Rio de Janeiro (PUC-Rio), Rio de Janeiro, Brazil	2019 IEEE/ACM 41st International Conference on Software Engineering: Companion Proceedings (ICSE-Companion)	19 Aug 2019	2019			206	209	Developers may introduce poor code structures spotted by code smells along the software maintenance. However, only some of these structures eventually become obstacles to the addition of new features. Developers are forced to remove these obstacles before adding features. Identifying which poor structures are actual obstacles is hard, due to their subtlety and scattering across code elements. Such identification has been largely debated by developers in public platforms such as Gerrit Code Review. Fully removing obstacles is also hard, as developers often have to perform non-trivial sets of interrelated code transformations. Despite enabling the feature addition, certain sets of transformations tend to introduce rather than remove code smells. The scarce knowledge on recurring obstacles, and how refactoring can cope with them, helps little in guiding the feature addition. This doctoral research aims to address the current scarceness via empirical studies with projects and their developers. Our major goal is three-fold: (1) to assess past feature additions in order to elicit recurring obstacles; (2) to understand when interrelated transformations unexpectedly introduce poor code structures; and (3) to propose a refactoring recommender system. Contrarily to the few existing ones, our system aims to guide developers along the feature addition while removing poor code structures.	2574-1934	978-1-7281-1764-5		code refactoring;software maintenance;poor code structure;feature addition;recommender system	Feature extraction;Software maintenance;Recommender systems;Medical services;Scattering;Databases	software maintenance;software quality;software tools	program features;batch refactoring;interrelated code transformations;feature addition;recurring obstacles;code structures;software maintenance;Gerrit code review		6		20		19 Aug 2019			IEEE	IEEE Conferences
Automatic Source Code Summarization of Context for Java Methods	automatic source code summarization of context for java methods	10.1109/TSE.2015.2465386	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181703	P. W. McBurney; C. McMillan	College of Computer Science and Engineering, University Notre Dame, Notre Dame, IN; Computer Science, University of Notre Dame, South Bend, VA	IEEE Transactions on Software Engineering	11 Feb 2016	2016	42	2	103	119	Source code summarization is the task of creating readable summaries that describe the functionality of software. Source code summarization is a critical component of documentation generation, for example as Javadocs formed from short paragraphs attached to each method in a Java program. At present, a majority of source code summarization is manual, in that the paragraphs are written by human experts. However, new automated technologies are becoming feasible. These automated techniques have been shown to be effective in select situations, though a key weakness is that they do not explain the source code's context. That is, they can describe the behavior of a Java method, but not why the method exists or what role it plays in the software. In this paper, we propose a source code summarization technique that writes English descriptions of Java methods by analyzing how those methods are invoked. We then performed two user studies to evaluate our approach. First, we compared our generated summaries to summaries written manually by experts. Then, we compared our summaries to summaries written by a state-of-the-art automatic summarization tool. We found that while our approach does not reach the quality of human-written summaries, we do improve over the state-of-the-art summarization tool in several dimensions by a statistically-significant margin.	1939-3520			Source code summarization;automatic documentation;program comprehension;Source code summarization;automatic documentation;program comprehension	Context;Documentation;Java;Natural languages;Software;Generators;XML	Java;object-oriented methods	source code summarization technique;Java methods;software functionality;documentation generation;Javadocs;Java program;user studies;automatic summarization tool;human-written summaries		88		51	IEEE	6 Aug 2015			IEEE	IEEE Journals
An Eye-Tracking Study of Java Programmers and Application to Source Code Summarization	an eyetracking study of java programmers and application to source code summarization	10.1109/TSE.2015.2442238	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7118751	P. Rodeghero; C. Liu; P. W. McBurney; C. McMillan	Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN	IEEE Transactions on Software Engineering	10 nov. 2015	2015	41	11	1038	1054	Source Code Summarization is an emerging technology for automatically generating brief descriptions of code. Current summarization techniques work by selecting a subset of the statements and keywords from the code, and then including information from those statements and keywords in the summary. The quality of the summary depends heavily on the process of selecting the subset: a high-quality selection would contain the same statements and keywords that a programmer would choose. Unfortunately, little evidence exists about the statements and keywords that programmers view as important when they summarize source code. In this paper, we present an eye-tracking study of 10 professional Java programmers in which the programmers read Java methods and wrote English summaries of those methods. We apply the findings to build a novel summarization tool. Then, we evaluate this tool. Finally, we further analyze the programmers' method summaries to explore specific keyword usage and provide evidence to support the development of source code summarization systems.	1939-3520			Source code summaries;program comprehension;Source code summaries;program comprehension	Java;Software;Documentation;Navigation;XML;Software engineering	Java;program compilers;source code (software)	eye-tracking study;Java programmer;source code summarization;code generation		34		75	IEEE	5 jun. 2015			IEEE	IEEE Journals
Reordering Program Statements for Improving Readability	reordering program statements for improving readability	10.1109/CSMR.2013.50	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6498489	Y. Sasaki; Y. Higo; S. Kusumoto	Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan	2013 17th European Conference on Software Maintenance and Reengineering	15 Apr 2013	2013			361	364	In order to understand source code, humans sometimes execute the program in their mind. When they illustrate the program execution in their mind, it is necessary to memorize what values all the variables are along with the execution. If there are many variables in the program, it is hard to their memorization. However, it is possible to ease to memorize them by shortening the distance between the definition of a variable and its reference if they are separated in the source code. This paper proposes a technique reordering statements in a module by considering how far the definition of a variable is from its references. We applied the proposed technique to a Java OSS and collected human evaluations for the reordered methods. As a result, we could confirm that the reordered methods had better readability than their originals. Moreover, we obtained some knowledge of human consideration about the order of statements.	1534-5351	978-0-7695-4948-4		source code readability;source code analysis;software tool;arranging program statements	Java;Correlation;Software maintenance;Educational institutions;Software metrics;Europe	Java;public domain software;software maintenance	program statement reordering;program execution;program memorization;Java OSS;open-source software;software maintainance;source code readability		3		7		15 Apr 2013			IEEE	IEEE Conferences
Program graphs, an algebra, and their implication for programming	program graphs, an algebra, and their implication for programming	10.1109/TSE.1975.6312853	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6312853	M. R. Paige	Sperry Rand Corporate Research Center, Sudbury, Mass; Science Applications, San Francisco, Calif. 94621	IEEE Transactions on Software Engineering	26 Sep 2012	1975	SE-1	3	286	291	Program graphs have been used as a vehicle to focus attention on the structure of a program. A systematic methodology for partitioning a program graph (digraph) to highlight the relationships between program elements is introduced along with an attendant notation. This notation is described in purely mathematical terms in the first section, and then the programming-related implications of this approach are addressed in the second section.	1939-3520			Partitioning;program graphs;program structure;structured programming	Programming;Computers;Complexity theory;Indexes;Software engineering;Systematics;Flowcharts	graphs;programming	structure;partitioning;program graph		21				26 Sep 2012			IEEE	IEEE Journals
Evolving Computing and Automatic Programming	evolving computing and automatic programming	10.1109/ICICIS.2011.61	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6063233	Q. Wang; A. Wang	Department of Computer Science, Wuhan Institute of Technology, Wuhan, Hubei, China; Department of Computer Science, Wuhan Institute of Technology, Wuhan, Hubei, China	2011 International Conference on Internet Computing and Information Services	31 Oct 2011	2011			213	214	Automatic programming is not only one of the central goals of computer science, but also the goal computer science workers are striving for. Some science workers have been exploring and researching in this field for a long time. Significant advances have been made on evolving computer theory, especially on Genetic Programming (for short G.P.) theory and method. Those bring hopes to automatic programming.		978-1-4577-1561-7		automatic programming;program structure;evolving method	Automatic programming;Computers;Assembly;Software;Genetics	automatic programming	automatic programming;computer science;computer theory;genetic programming		1		7		31 Oct 2011			IEEE	IEEE Conferences
Curriculum development for adult students	curriculum development for adult students	10.1109/EAEEIE46886.2019.9000459	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9000459	K. Gudmundsson; H. Thorbergsson; K. Andersen; S. Thorsteinsson	Faculty of Electrical and Computer Engineering, Applied Enginering Center, University of Iceland, Reykjavik, Iceland; Faculty of Electrical and Computer Engineering, University of Iceland, Reykjavik, Iceland; Faculty of Electrical and Computer Engineering, University of Iceland, Reykjavik, Iceland; Faculty of Electrical and Computer Engineering, University of Iceland, Reykjavik, Iceland	2019 29th Annual Conference of the European Association for Education in Electrical and Information Engineering (EAEEIE)	17 Feb 2020	2019			1	4	This paper reports on curriculum and course structure development, a pilot program to address the needs of entry point for adult students into the tertiary studies in Iceland. With the new program structure, we seek to appeal to older students, working people who missed their opportunity to go to university as young adults for various reasons. Also, we seek to appeal to young adults that wish to attend a shorter university program, 90 ECTS with the option of continue to a full B.Sc. Degree later.	2472-7687	978-1-7281-3222-8		curriculum development;program structure;adult students;life-long learning		continuing professional development;educational courses;educational institutions	adult students;tertiary studies;program structure;older students;young adults;university program;curriculum development;course structure development;Iceland		1		10		17 Feb 2020			IEEE	IEEE Conferences
Program Design	program design	10.1109/TR.1980.5220870	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5220870	W. J. Dodds	RCA; Picture Tube Division; Lancaster, PA 17604 USA	IEEE Transactions on Reliability	25 Aug 2009	1980	R-29	4	349	349	Flow charts are useful for engineering development programs.	1558-1721			Book review;Program design;Program structure;Flow charts	Book reviews;Reliability engineering;Companies;Data mining;Electron tubes;Marine vehicles						1	IEEE	25 Aug 2009			IEEE	IEEE Journals
Genetic Programming for Image Classification: A New Program Representation with Flexible Feature Reuse	genetic programming for image classification a new program representation with flexible feature reuse	10.1109/TEVC.2022.3169490	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9761990	Q. Fan; Y. Bi; B. Xue; M. Zhang	School of Engineering and Computer Science, Victoria University of Wellington, Wellington 6140, New Zealand.; School of Engineering and Computer Science, Victoria University of Wellington, Wellington 6140, New Zealand.; School of Engineering and Computer Science, Victoria University of Wellington, Wellington 6140, New Zealand.; School of Engineering and Computer Science, Victoria University of Wellington, Wellington 6140, New Zealand.	IEEE Transactions on Evolutionary Computation		2022	PP	99	1	1	Extracting effective features from images is crucial for image classification, but it is challenging due to high variations across images. Genetic programming (GP) has become a promising machine learning approach to feature learning in image classification. The representation of existing GP-based image classification methods is usually the tree-based structure. These methods typically learn useful image features according to the output of the GP program’s root node. However, they are not flexible enough in feature learning since the features produced by internal nodes of the GP program have seldom been directly used. In this paper, we propose a new image classification approach using GP with a new program structure, which can flexibly reuse features generated from different nodes including internal nodes of the GP program. The new method can automatically learn various informative image features based on the new function set and terminal set for effective and efficient image classification. Furthermore, instead of relying on a predefined classification algorithm, the proposed approach can automatically select a suitable classification algorithm based on the learned features and conduct classification simultaneously in a single evolved GP program for an image classification task. The experimental results on 12 benchmark datasets of varying difficulty suggest that the new approach achieves better performance than many state-of-the-art methods. Further analysis demonstrates the effectiveness and efficiency of the flexible feature reuse in the proposed approach. The analysis of evolved GP programs/solutions shows their potentially high interpretability.	1941-0026		the Marsden Fund of New Zealand Government(grant numbers:VUW1913, VUW1914, VUW2115); the Science for Technological Innovation Challenge SfTI fund(grant numbers:E3603/2903); MBIE Data Science SSIF Fund(grant numbers:RTVU1914); National Natural Science Foundation of China(grant numbers:61876169); 	Genetic Programming;Image Classification;Feature Learning;Program Structure;Feature Reuse.	Feature extraction;Task analysis;Representation learning;Training;Benchmark testing;Transforms;Support vector machines							IEEE	22 Apr 2022			IEEE	IEEE Early Access Articles
Develop on On-line Test System of Cutting Force Base on Single-Chip Computer	develop on online test system of cutting force base on singlechip computer	10.1109/ICDMA.2010.217	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5701213	W. Li; Q. Yang	Hebei Normal University, Shijiazhuang, Hebei, China; Hebei University of Science and Technology, Shijiazhuang, Hebei, China	2010 International Conference on Digital Manufacturing & Automation	24 jan. 2011	2010	1		526	529	Using metal cutting theory to research detecting cutting force on-line rationale and test principle, take electric motor input power as intermediate value, uses a way which of the direct measure stator winding transient voltage and the electric current to test cutting force, to realize monitor on-line cutting force of the machine tool. The concrete has designed the single chip computer system's hardware principle structure and the test program structure and the main module flow for which test real-time cutting force.		978-0-7695-4286-7		cutting force;electric power;single-chip;computer system;program structure	Force;Power generation;Machine tools;Voltage measurement;Stator windings;Computers;Hardware	cutting tools;force measurement;machine testing;machine tools;mechanical engineering computing	on-line test system;cutting force;single-chip computer;metal cutting theory;electric motor input power;stator winding transient voltage;machine tool				4		24 jan. 2011			IEEE	IEEE Conferences
The Rental-Type Application System Based on Web Service	the rentaltype application system based on web service	10.1109/ISBIM.2008.46	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5116446	J. -f. Tu; Z. -m. Fang; F. -f. Ye	Faculty of Engineering, Ningbo University, Ningbo, China; Faculty of Engineering, Ningbo University, Ningbo, China; Faculty of Engineering, Ningbo University, Ningbo, China	2008 International Seminar on Business and Information Management	26 jun. 2009	2008	2		161	164	Traditional rental-type application systems such as ASP and so on can not perform well in protecting userspsila data, making the rental-type application system not be widely applied. Through the analysis on the requirements of the rental-type business and the program structure of rental-type application system, the advantage and disadvantage of the B/S and C/S program structure used in rental-type application system are discussed, it concludes that the B/S and C/S program structure are not good for the development of rental business. A mixed program structure based on Web service is proposed, which is divided into two layers of Web service layer of service provider and business system layer of rental customer. The mixed program structure is a kind of feasible solution to rental-type application since it can achieve independent management on userspsila data and improve the security of the data. A CRM system for small-and-medium-sized enterprises based on the mixed program structure as an example is given.		978-0-7695-3560-9		Web service;mixed program structure;rental-type application;CRM;ASP	Web services;Application software;Application specific processors;Protection;Data security;Marketing and sales;Resource management;Costs;Safety;Software systems	customer relationship management;database management systems;rental;security of data;small-to-medium enterprises;Web services	rental-type application system;Web service;B/S program structure;C/S program structure;rental business;service provider;business system;rental customer;data management;data security;CRM system;small-and-medium-sized enterprise;mixed program structure				7		26 jun. 2009			IEEE	IEEE Conferences
Analyzing service-oriented systems using their data and structure	analyzing serviceoriented systems using their data and structure	10.1109/S-Cube.2012.6225510	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6225510	D. Ivanović; M. Carro; M. Hermenegildo	Universidad Politécnica de Madrid, Madrid, Spain; Boadilla del Monte, UPM and IMDEA Software Institute, Madrid, Spain; Boadilla del Monte, UPM and IMDEA Software Institute, Madrid, Spain	2012 First International Workshop on European Software Services and Systems Research - Results and Challenges (S-Cube)	28 jun. 2012	2012			47	48	We describe our approaches to enhance consistency validation and QoS prediction in service-oriented systems by making use of data properties and the structure of workflows and service compositions.		978-1-4673-1807-5		Service-oriented computing;Static analysis;Inference;Data and program structure	Quality of service;Lattices;Current measurement;Abstracts;Medical services;Approximation methods;Context	data handling;quality of service;service-oriented architecture	analyzing service-oriented systems;QoS prediction;data properties;service compositions;workflow compositions				6		28 jun. 2012			IEEE	IEEE Conferences
Develop on feed-forward real time compensation control system for movement error in CNC machining	develop on feedforward real time compensation control system for movement error in cnc machining	10.1109/ICCASM.2010.5619386	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5619386	Weihua Li; Qingjian Yang	Hebei Normal University, Shijiazhuang, Hebei, China; Hebei University of Science and Technology, Shijiazhuang, Hebei, China	2010 International Conference on Computer Application and System Modeling (ICCASM 2010)	4 nov. 2010	2010	7		V7-234	V7-238	A theory model of feed-forward compensation controlling system is constructed by the method of precision compensation. A feed-forward compensation hardware control system is designed to MCS51CPU as the core and structure of compensation data processing program. Established components of linear contour error mathematical model, thus determine the amount of feed-forward compensation algorithm. CNC x-y experiment platform simulation results indicate that this design can effectively eliminate the phase lag and amplitude errors of the computer numerical control (CNC) system, and improve the general CNC machining accuracy on the part contour.	2161-9077	978-1-4244-7237-6		feed-forward compensation;movement error;error model;hardware system;program structure;simulation test	Process control	computerised numerical control;error compensation;feedforward;machining;precision engineering;real-time systems	feedforward real time compensation control system;movement error;CNC machining;precision compensation;MCS51CPU;linear contour error mathematical model;CNC x-y experiment platform				5		4 nov. 2010			IEEE	IEEE Conferences
Entity based source code summarization (EBSCS)	entity based source code summarization (ebscs)	10.1109/ICACCS.2016.7586385	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7586385	Chitti babu K; Kavitha C.; SankarRam N	Dept. of. CSE, RMKCET, Chennai, India; Dept. of. CSE, RMKCET, Chennai, India; Dept. of. CSE, RMKCET, Chennai, India	2016 3rd International Conference on Advanced Computing and Communication Systems (ICACCS)	10 Oct 2016	2016	1		1	5	In the software evolution process a developer must analyze the source code in order to understand the entities in it. In general this analysis is done manually which takes lots of time and is a tedious task. The other option is to use automated source code summarization techniques. Existing techniques does not provide the required summary and most of them are complex. Source code summarization is the task of creating readable summaries that describe the functionality of software. Source code summarization is a critical component of documentation generation. In this paper we propose a novel summarization technique called EBSCS which is based on the entities like packages, classes, methods control statements and comments in the source code. In this technique description is generated for the entities and the comment lines are used to generate summary for the source code.		978-1-4673-9206-8		Source code entities;Source code summarization;Textual clues;source code comprehension	Documentation;Semantics;Communication systems;Software maintenance;Generators;Conferences	software engineering;source code (software);system documentation	entity based source code summarization;EBSCS;software evolution;software functionality;documentation generation		1		14		10 Oct 2016			IEEE	IEEE Conferences
The CodeCompass Comprehension Framework	the codecompass comprehension framework		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8973042	Z. Porkoláb; T. Brunner	Faculty of Informatics, Eötvös Loránd University, Budapest, Hungary; Faculty of Informatics, Eötvös Loránd University, Budapest, Hungary	2018 IEEE/ACM 26th International Conference on Program Comprehension (ICPC)	30 jan. 2020	2018			393	3933	CodeCompass is an open source LLVM/Clang based tool developed by Ericsson Ltd. and the Eötvös Loránd University, Budapest to help understanding large legacy software systems. Based on the LLVM/Clang compiler infrastructure, CodeCompass gives exact information on complex C/C++ language elements like overloading, inheritance, the usage of variables and types, possible uses of function pointers and the virtual functions - features that various existing tools support only partially. Steensgaard's and Andersen's pointer analysis algorithm are used to compute and visualize the use of pointers/references. The wide range of interactive visualizations extends further than the usual class and function call diagrams; architectural, component and interface diagrams are a few of the implemented graphs. To make comprehension more extensive, CodeCompass is not restricted to the source code. It also utilizes build information to explore the system architecture as well as version control information e.g. git commit history and blame view. Clang based static analysis results are also integrated to CodeCompass. Although the tool focuses mainly on C and C++, it also supports Java and Python languages. In this demo we will simulate a typical bug-fixing work flow in a C++ system. First, we show, how to use the combined text and definition based search for a fast feature location. Here we also demonstrate our log search, which can be used to locate the code source of an emitted message. When we have an approximate location of the issue, we can start a detailed investigation understanding the class relationships, function call chains (including virtual calls, and calls via function pointers), and the read/write events on individual variables. We also visualize the pointer relationships. To make the comprehension complete, we check the version control information who committed the code, when and why. This Tool demo submission is complementing our Industry track submission with the similar title. A live demo is also available at the homepage of the tool https://github.com/ericsson/codecompass.	2643-7171	978-1-4503-5714-2		code comprehension;C/C++ programming language;software visualization		C++ language;configuration management;program compilers;program debugging;program visualisation;public domain software;software architecture;software maintenance;source code (software)	CodeCompass comprehension framework;legacy software systems;function pointers;virtual functions;pointer analysis algorithm;interactive visualizations;function call diagrams;interface diagrams;source code;system architecture;version control information;C++ system;code source;function call chains;bug-fixing work flow;Clang based static analysis;open source LLVM/Clang;LLVM/Clang compiler infrastructure;C/C++ language elements				0		30 jan. 2020			IEEE	IEEE Conferences
Program comprehension during software maintenance and evolution	program comprehension during software maintenance and evolution	10.1109/2.402076	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=402076	A. Von Mayrhauser; A. M. Vans	Colorado State University; Colorado State University, USA	Computer	6 Aug 2002	1995	28	8	44	55	Code cognition models examine how programmers understand program code. The authors survey the current knowledge in this area by comparing six program comprehension models: the Letovsky (1986) model; the Shneiderman and Mayer (1979) model; the Brooks (1983) model; Soloway, Adelson and Ehrlich's (1988) top-down model; Pennington's (1987) bottom-up model; and the integrated metamodel of von Mayrhauser and Vans (1994). While these general models can foster a complete understanding of a piece of code, they may not always apply to specialized tasks that more efficiently employ strategies geared toward partial understanding. We identify open questions, particularly considering the maintenance and evolution of large-scale code. These questions relate to the scalability of existing experimental results with small programs, the validity and credibility of results based on experimental procedures, and the challenges of data availability.<>	1558-0814				Software maintenance;Cognition;Cognitive science;Programming profession;Application software;Computer architecture;Documentation;Large-scale systems;Scalability;Round robin	software maintenance;reverse engineering;human factors;large-scale systems	program comprehension models;software maintenance;software evolution;code cognition models;program code understanding;integrated metamodel;top-down model;bottom-up model;specialized tasks;partial understanding;large-scale code;scalability;data availability;experimental procedures		316		12		6 Aug 2002			IEEE	IEEE Magazines
Delocalized Plans and Program Comprehension	delocalized plans and program comprehension	10.1109/MS.1986.233414	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1695544	S. Letovsky; E. Soloway	Yale University, USA; Yale University, USA	IEEE Software	11 Sep 2006	1986	3	3	41	49	A maintainer's understanding can go awry when it is based on purely local clues. How can we spell out the intentions behind a piece of code?	1937-4194				Programming profession;Documentation;Binary trees;Algorithm design and analysis;Error analysis;Sorting;Merging;Scattering;Failure analysis;Text recognition				143	4	17		11 Sep 2006			IEEE	IEEE Magazines
Supporting program comprehension using semantic and structural information	supporting program comprehension using semantic and structural information	10.1109/ICSE.2001.919085	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=919085	J. I. Maletic; A. Marcus	Division of Computer Science, Department of Mathematical Sciences, University of Memphis, Memphis, TN, USA; Division of Computer Science, Department of Mathematical Sciences, University of Memphis, Memphis, TN, USA	Proceedings of the 23rd International Conference on Software Engineering. ICSE 2001	7 Aug 2002	2001			103	112	Focuses on investigating the combined use of semantic and structural information of programs to support the comprehension tasks involved in the maintenance and reengineering of software systems. "Semantic information" refers to the domain-specific issues (both the problem and the development domains) of a software system. The other dimension, structural information, refers to issues such as the actual syntactic structure of the program, along with the control and data flow that it represents. An advanced information retrieval method, latent semantic indexing, is used to define a semantic similarity measure between software components. Components within a software system are then clustered together using this similarity measure. Simple structural information (i.e. the file organization) of the software system is then used to assess the semantic cohesion of the clusters and files with respect to each other. The measures are formally defined for general application. A set of experiments is presented which demonstrates how these measures can assist in the understanding of a nontrivial software system, namely a version of NCSA Mosaic.	0270-5257	0-7695-1050-7			Information retrieval;Software systems;Data mining;Indexing;Software measurement;Documentation;Natural languages;Computer science;Application software;Computer languages	reverse engineering;program control structures;software maintenance;systems re-engineering;software metrics;online front-ends;data flow analysis;information retrieval;indexing	program comprehension;semantic information;structural information;software systems maintenance;software systems reengineering;domain-specific issues;problem domain;software development domain;syntactic program structure;control flow;data flow;information retrieval method;latent semantic indexing;semantic similarity measure;software component clustering;file organization;semantic cohesion;NCSA Mosaic		95		49		7 Aug 2002			IEEE	IEEE Conferences
The role of concepts in program comprehension	the role of concepts in program comprehension	10.1109/WPC.2002.1021348	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021348	V. Rajlich; N. Wilde	Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, University of West Florida, Pensacola, FL, USA	Proceedings 10th International Workshop on Program Comprehension	10 Dec 2002	2002			271	278	The paper presents an overview of the role of concepts in program comprehension. It discusses concept location, in which the implementation of a specific concept is located in the code. This process is very common and precedes a large proportion of code changes. The paper also discusses the process of learning about the domain from the code, which is a prerequisite of code reengineering. The paper notes the similarities and overlaps between program comprehension and human learning.	1092-8138	0-7695-1495-2			Programming profession;Humans;Software maintenance;Computer science;Documentation;Visualization;Conferences;Software engineering;Credit cards	reverse engineering;software maintenance;systems re-engineering	program comprehension;concept location;code changes;code reengineering;human learning;concepts		93	2	28		10 Dec 2002			IEEE	IEEE Conferences
Easing program comprehension by sharing navigation data	easing program comprehension by sharing navigation data	10.1109/VLHCC.2005.32	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1509509	R. DeLine; M. Czerwinski; G. Robertson	Microsoft Research, Microsoft Corporation, Redmond, USA; Microsoft Research, Microsoft Corporation, Redmond, USA; Microsoft Research, Microsoft Corporation, Redmond, USA	2005 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC'05)	17 Oct 2005	2005			241	248	Large software projects often require a programmer to make changes to unfamiliar source code. This paper describes a set of tools, called Team Tracks, designed to ease program comprehension by showing the source code navigation patterns of fellow development team members. One technique shows a list of related items, given that the user is viewing a given method or class. Another technique shows the favorite classes, by showing a class hierarchy view that hides less frequently visited classes, methods, and members. Two user studies, a laboratory study and a field study, were run to evaluate the effectiveness of these techniques. The results of the two studies demonstrate that sharing navigation data can improve program comprehension and is subjectively preferred by users.	1943-6106	0-7695-2443-5			Navigation;Costs;Data visualization;Usability;Documentation;Instruments;Programming profession;Fellows;Laboratories;Unified modeling language	program visualisation;reverse engineering	program comprehension;navigation data sharing;software project;software programming;Team Tracks;source code navigation pattern;class hierarchy		71	4	13		17 Oct 2005			IEEE	IEEE Conferences
Aiding program comprehension by static and dynamic feature analysis	aiding program comprehension by static and dynamic feature analysis	10.1109/ICSM.2001.972777	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=972777	T. Eisenbarth; R. Koschke; D. Simon	Universität Stuttgart, Stuttgart, Germany; Universität Stuttgart, Stuttgart, Germany; Universität Stuttgart, Stuttgart, Germany	Proceedings IEEE International Conference on Software Maintenance. ICSM 2001	6 Aug 2002	2001			602	611	Understanding a system's implementation without prior knowledge is a hard task for reengineers in general. However, some degree of automatic aid is possible. The authors present a technique for building a mapping between the system's externally visible behavior and the relevant parts of the source code. The technique combines dynamic and static analyses to rapidly focus on the system's parts urgently required for a goal-directed process of program understanding.	1063-6773	0-7695-1189-9			Documentation;Reverse engineering;Terminology;Computer languages;Information analysis	reverse engineering;systems re-engineering;program diagnostics;software maintenance	program comprehension;static/dynamic feature analysis;system implementation understanding;prior knowledge;reengineers;automatic aid;externally visible behavior;source code;dynamic analyses;static analyses;goal-directed process;program understanding		66		22		6 Aug 2002			IEEE	IEEE Conferences
Program Comprehension through Software Habitability	program comprehension through software habitability	10.1109/ICPC.2007.30	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268257	R. Wettel; M. Lanza	Faculty of Informatics, University of Lugano, Switzerland; Faculty of Informatics, University of Lugano, Switzerland	15th IEEE International Conference on Program Comprehension (ICPC '07)	9 jul. 2007	2007			231	240	The comprehensive understanding of a large software system is a daunting task because of the sheer size and complexity that such systems exhibit. In this context software visualization is a widely used approach, since well-conceived visual representations allow one to spot patterns. The large majority of visualizations use 2D representations, because they are easier to construct, navigate, and interact with. 3D representations usually exploit the 3rd dimension as an additional means to encode quantitative values, which is dismissed by many as a too small benefit in the light of the added complexity in terms of navigation and interaction. We argue that a well-constructed, interactive, and easily navigable 3D visualization can greatly help in program comprehension tasks by supporting habitability. Habitability transmits to a developer the notion that a software system is a physical space with strong orientation points. This can give developers the feeling of being "at home" in a system. We propose a 3D visualization of software systems hinging on the city metaphor. It is useful for program comprehension because it leads to clarity about the overall structure of a system. We apply our visualization technique on two large systems and discuss its benefits and drawbacks.	1092-8138	0-7695-2860-0			Visualization;Software systems;Cities and towns;Writing;Navigation;Informatics;Reverse engineering;Cognitive science;Humans;Programming profession	program visualisation;reverse engineering	program comprehension;software habitability;software visualization;visual representation;3D representation;metaphor;UML		52	1	22		9 jul. 2007			IEEE	IEEE Conferences
From program comprehension to tool requirements for an industrial environment	from program comprehension to tool requirements for an industrial environment	10.1109/WPC.1993.263903	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263903	A. von Mayrhauser; A. M. Vans	Department of Computer Science, Colorado State University, Fort Collins, CO, USA; Department of Computer Science, Colorado State University, Fort Collins, CO, USA	[1993] IEEE Second Workshop on Program Comprehension	6 Aug 2002	1993			78	86	A major portion of the maintenance effort is spent understanding existing software. The authors present an integrated code comprehension model and experiences with it in an industrial setting. They use audio-taped, think-aloud reports to investigate how well this integrated code comprehension model works during industrial maintenance activities ranging from code fixes to enhancements, code leverage, and reuse. They analyze the tapes for information needs during maintenance activities and derive tool capabilities accordingly.<>	1092-8138	0-8186-4042-1			Cognition;Programming profession;Switches;Computer industry;Computer science;Software maintenance;Large-scale systems;Software tools;Information analysis;Electrical equipment industry	software maintenance;software tools	program comprehension;tool requirements;industrial environment;maintenance effort;code comprehension model;think-aloud reports;industrial maintenance activities;code fixes;enhancements;code leverage;reuse;information needs;tool capabilities		47		22		6 Aug 2002			IEEE	IEEE Conferences
Building Usage Contexts During Program Comprehension	building usage contexts during program comprehension	10.1109/ICPC.2006.14	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631101	C. Parnin; C. Gorg	College of Computing, Georgia Institute of Technology, Atlanta, GA, USA; College of Computing, Georgia Institute of Technology, Atlanta, GA, USA	14th IEEE International Conference on Program Comprehension (ICPC'06)	26 jun. 2006	2006			13	22	Software developers often work on multiple simultaneous projects. Even when only a single project is underway, everyday distractions interrupt the development effort. Consequently, developers spend significant effort pursuing recovery of their context. By context, we focus on the classes and methods within the code that are relevant to a specific bug being fixed or enhancement made. Context is reified by a program in terms of a set of presentations (windows a containing source code, command executions, and data files); however, it is not enough to save the latest context. Even when working on a single task, programmers flip between contexts as they extend their understanding, and when they decide on a change, they may have to visit several contexts in order to address all possible ripple effects. Consequently, we would like to record a history of contexts and be able to retrieve them as demanded by the current task. We introduce a novel technique to obtain a context, consisting of a set of methods relevant for the current task, from a programmer's interactions with an IDE. Using this context, we demonstrate how to improve the ability of a programmer to recover the mental state associated with tasks and to facilitate the exploration of software through recommendation systems	1092-8138	0-7695-2601-2			Programming profession;Educational institutions;History;Software systems;Energy resolution;Organizing;Context modeling	human factors;project management;reverse engineering;software engineering	program usage context;program comprehension;software project development;program bug;programmer interaction;IDE;recommendation system		43		18		26 jun. 2006			IEEE	IEEE Conferences
Impact of the visitor pattern on program comprehension and maintenance	impact of the visitor pattern on program comprehension and maintenance	10.1109/ESEM.2009.5316015	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5316015	S. Jeanmart; Y. -G. Gueheneuc; H. Sahraoui; N. Habra	PReCISE Research Center, University of Namur, Namur, Belgium; Ptidej Team, DGIGL, École Polytechnique de Montréal, QUE, Canada; GEODES, DIRO, University of Montreal, QUE, Canada; PReCISE Research Center, University of Namur, Namur, Belgium	2009 3rd International Symposium on Empirical Software Engineering and Measurement	6 nov. 2009	2009			69	78	In the software engineering literature, many works claim that the use of design patterns improves the comprehensibility of programs and, more generally, their maintainability. Yet, little work attempted to study the impact of design patterns on the developers' tasks of program comprehension and modification. We design and perform an experiment to collect data on the impact of the visitor pattern on comprehension and modification tasks with class diagrams. We use an eye-tracker to register saccades and fixations, the latter representing the focus of the developers' attention. Collected data show that the visitor pattern plays a role in maintenance tasks: class diagrams with its canonical representation requires less efforts from developers.	1949-3789	978-1-4244-4842-5			Unified modeling language;Software engineering;Software measurement;Level measurement;Electronic mail;Pattern analysis;Visualization;Performance evaluation;Standards development;Design for experiments	object-oriented programming;reverse engineering;software maintenance	visitor pattern;program comprehension;program maintenance;software engineering literature;design patterns		40		28		6 nov. 2009			IEEE	IEEE Conferences
Brain activity measurement during program comprehension with NIRS	brain activity measurement during program comprehension with nirs	10.1109/SNPD.2014.6888727	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6888727	Y. Ikutani; H. Uwano	Department of Information Engineering, Nara National College of Technology, Nara, Yamatokoriyama, Japan; Department of Information Engineering, Nara National College of Technology, Nara, Yamatokoriyama, Japan	15th IEEE/ACIS International Conference on Software Engineering, Artificial Intelligence, Networking and Parallel/Distributed Computing (SNPD)	1 Sep 2014	2014			1	6	Near infrared spectroscopy (NIRS) has been used as a low cost, noninvasive method to measure brain activity. In this paper, we experiment to measure the effects of variables and controls in a source code to the brain activity in program comprehension. The measurement results are evaluated after noise reduction and normalization to statistical analysis. As the result of the experiment, significant differences in brain activity were observed at a task that requires memorizing variables to understand a code snippet. On the other hand, no significant differences between different levels of mental arithmetic tasks were observed. We conclude that the frontal pole reflects workload to short-term memory caused by variables without affected from calculation.		978-1-4799-5604-3			Brain;Atmospheric measurements;Particle measurements;Noise;Blood;Noise reduction;Statistical analysis	blood;blood flow measurement;brain;infrared spectra;medical signal processing;neurophysiology;signal denoising;statistical analysis	brain activity measurement;program comprehension;near infrared spectroscopy;noninvasive method;source code;noise reduction;normalization;statistical analysis;mental arithmetic tasks;short-term memory;frontal pole;code snippet		30		10		1 Sep 2014			IEEE	IEEE Conferences
Using Sex Differences to Link Spatial Cognition and Program Comprehension	using sex differences to link spatial cognition and program comprehension	10.1109/ICSM.2006.72	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4021352	M. Fisher; A. Cox; L. Zhao	Department of Psychology, Saint Mary''s University, Halifax, NS, Canada; Faculty of Computer Science, Dalhousie University, Halifax, NS, Canada; Faculty of Computer Science, Dalhousie University, Halifax, NS, Canada	2006 22nd IEEE International Conference on Software Maintenance	11 Dec 2006	2006			289	298	Spatial cognition and program development have both been examined using contrasting models. We suggest that sex-based differences in one's perception of risk is the key to relating these models. Specifically, the survey map approach to navigation and the top-down development/comprehension strategy use similar and related high risk cognitive skills that males show a preference towards. Conversely, the route-based approach to navigation and the bottom-up development/comprehension strategy use similar and related low risk cognitive skills that women show a preference towards. On the assumption that programmers are consistent in their risk-taking behaviours, we believe that they, as much as possible, tend to use the same strategy when performing program development and comprehension. In an experimental setting, we compare programmer's performance on spatial cognition and program comprehension tasks. The correlations that we found suggest that programmers use equivalently risky strategies for program comprehension and spatial cognition. Thus, there is evidence that similar cognitive skills are used for spatial cognition and program comprehension/development, and that the similarities are a consequence of sex-based differences in risk-taking behaviour	1063-6773	0-7695-2354-4			Cognition;Navigation;Programming profession;Software maintenance;Computer science;Psychology;Application software;Software systems;Cognitive science;Flow graphs	cognition;gender issues;programming;reverse engineering	sex differences;spatial cognition;program comprehension;program development;risk-taking behaviour		30		36		11 Dec 2006			IEEE	IEEE Conferences
Tactile programming: a unified manipulation paradigm supporting program comprehension, composition and sharing	tactile programming a unified manipulation paradigm supporting program comprehension, composition and sharing	10.1109/VL.1996.545275	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=545275	A. Repenning; J. Ambach	Department of Computer Science Center for LifeLong Learning and Design, University of Colorado, Boulder, CO, USA; Department of Computer Science Center for LifeLong Learning and Design, University of Colorado, Boulder, CO, USA	Proceedings 1996 IEEE Symposium on Visual Languages	6 Aug 2002	1996			102	109	Although visual programming techniques have been used to lower the threshold of programming for end users, they are not sufficient for creating end user programming environments that are both easy to use and powerful. To achieve this, an environment must support the definition of programs that are not just static representations of behavior, but are instead dynamic collections of program objects which can be applied in a number of contexts rather than just a program editor. We describe an approach to end user programming called tactile programming which extends visual techniques with a unified program manipulation paradigm that makes programs easy to comprehend, compose and, most importantly, share over the World Wide Web. Tactile programming's inherent ability to support the social context in which programming takes place along with its ability to ease program comprehension and composition is what differentiates this approach from others. In the context of the Agentsheets programming substrate, we have created an instance of a tactile programming environment called Visual AgenTalk which is used to create interactive simulations.	1049-2615	0-8186-7508-X			Programming profession;Programming environments;Computational modeling;Computer science;Web sites;Context modeling;Computer languages;Collaboration	visual programming;programming environments	visual programming;tactile programming;end user programming environments;program manipulation paradigm;social context;program comprehension;Agentsheets programming substrate;Visual AgenTalk;interactive simulations		29	1	24		6 Aug 2002			IEEE	IEEE Conferences
An empirical investigation of the influence of a type of side effects on program comprehension	an empirical investigation of the influence of a type of side effects on program comprehension	10.1109/TSE.2003.1214329	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1214329	J. J. Dolado; M. Harman; M. C. Otero; L. Hu	Department of Computer Languages and Systems, University of Basque Country (UPV-EHU), San Sabastian, Spain; Department of Information Systems and Computing, Brunei University, Uxbridge, Middlesex, UK; Department of Computer Languages and Systems, University of Basque Country (UPV-EHU), San Sabastian, Spain; Department of Information Systems and Computing, Brunei University, Uxbridge, Middlesex, UK	IEEE Transactions on Software Engineering	22 jul. 2003	2003	29	7	665	670	This paper reports the results of a study on the impact of a type of side effect (SE) upon program comprehension. We applied a crossover design on different tests involving fragments of C code that include increment and decrement operators. Each test had an SE version and a side-effect-free counterpart. The variables measured in the treatments were the number of correct answers and the time spent in answering. The results show that the side-effect operators considered significantly reduce performance in comprehension-related tasks, providing empirical justification for the belief that side effects are harmful.	1939-3520				Testing;Programming profession;Time measurement;Impedance;Computer languages;Humans;Algorithm design and analysis;Software maintenance	program testing;software engineering	side-effect-free programs;program comprehension;LinSERT algorithm;crossover design;program tests;side-effect operators		27		22		22 jul. 2003			IEEE	IEEE Journals
Layered explanations of software: a methodology for program comprehension	layered explanations of software a methodology for program comprehension	10.1109/WPC.1994.341248	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341248	V. Rajlich; J. Doran; R. T. S. Gudla	Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA	Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94	6 Aug 2002	1994			46	52	In dealing with the legacy systems, one often encounters poorly documented and heavily maintained software. Lack of understandability of these systems complicates the task of software maintenance, making it time consuming and limiting the possibilities of the evolution of the system. We present a methodology that helps the programmers to understand programs. Our approach is compatible with the "top-down theory" of software understanding, where the programmer creates a chain of hypotheses and subsidiary hypotheses, concerning the properties of the code. Then he/she looks for evidence (beacons) in the code. Our approach shortens the process of hypotheses creation and verification, and allows recording of successful hypotheses for the future maintenance. All information needed for understanding is recorded in layers of annotations. An experiment was conducted to investigate how the proposed methodology helps in program understanding. A tool supporting the methodology, is presented.<>	1092-8138	0-8186-5647-6			Programming profession;Software maintenance;Software tools;Computer science;Software engineering;Terminology;Cognitive science;Data structures	software maintenance;reverse engineering	legacy systems;software maintenance;program comprehension;layered explanations;understandability;hypotheses		26		11		6 Aug 2002			IEEE	IEEE Conferences
Program comprehension in multi-language systems	program comprehension in multilanguage systems	10.1109/WCRE.1998.723183	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=723183	B. Kullbach; A. Winter; P. Dahm; J. Ebert	Institute for Software Technology, University of Koblenz and Landau, Koblenz, Germany; Institute for Software Technology, University of Koblenz and Landau, Koblenz, Germany; Institute for Software Technology, University of Koblenz and Landau, Koblenz, Germany; Institute for Software Technology, University of Koblenz and Landau, Koblenz, Germany	Proceedings Fifth Working Conference on Reverse Engineering (Cat. No.98TB100261)	6 Aug 2002	1998			135	143	This paper presents an approach to program comprehension in multi-language systems. Such systems are characterized by a high amount of source codes in various languages for programming, database definition and job control. Coping with those systems requires the references crossing the language boundaries to be analyzed. Using the EER/GRAL approach to graph-based conceptual modeling, models representing relevant aspects of single language are built and integrated into a common conceptual model. Since conceptual modeling focusses on specific problems, the integrated model presented here is especially tailored to multi-language aspects. Software systems are parsed and represented according to this conceptual model and queried by using a powerful graph query mechanism. This allows multi-language cross references to be easily retrieved. The multi-language conceptual model and the query facilities have been developed in cooperation with the maintenance programmers at an insurance company within the GUPRO project.		0-8186-8967-6			Power system modeling;Software systems;Software maintenance;Relational databases;Database languages;Insurance;Software performance;Programming;Data structures;Image databases	software maintenance;systems re-engineering;query languages	program comprehension;multi-language systems;source codes;database definition;job control;graph-based conceptual modeling;common conceptual model;integrated model;graph query mechanism;multilanguage conceptual model;GUPRO project		26	1	45		6 Aug 2002			IEEE	IEEE Conferences
Search Based Software Engineering for Program Comprehension	search based software engineering for program comprehension	10.1109/ICPC.2007.35	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268235	M. Harman	CREST, King''s College, London, UK	15th IEEE International Conference on Program Comprehension (ICPC '07)	9 jul. 2007	2007			3	13	Search based software engineering (SBSE) is an approach to software engineering in which search based optimization algorithms are used to identify optimal or near optimal solutions and to yield insight. SBSE techniques can cater for multiple, possibly competing objectives and/or constraints and applications where the potential solution space is large and complex. Such situations are common in software engineering, leading to an increasing interest in SBSE. This paper provides a brief overview of SBSE, explaining some of the ways in which it has already been applied to program-comprehension related activities. The paper also outlines some possible future applications of and challenges for the further application of SBSE to program comprehension.	1092-8138	0-7695-2860-0			Software engineering;Application software;Software testing;Biomedical engineering;Software algorithms;Educational institutions;Cost function;Automatic testing;Optimizing compilers;Quality assessment	optimisation;software engineering	program comprehension;search based software engineering;optimization algorithms		26		82		9 jul. 2007			IEEE	IEEE Conferences
Early field experience with the Software Reconnaissance technique for program comprehension	early field experience with the software reconnaissance technique for program comprehension	10.1109/ICSM.1996.565034	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=565034	Wilde; Casey	University of West Florida, Pensacola, FL, USA; University of West Florida, Pensacola, FL, USA	1996 Proceedings of International Conference on Software Maintenance	6 Aug 2002	1996			312	318	Software Reconnaissance is a dynamic analysis technique to help programmers locate code that they need to understand, fix, or enhance in an unfamiliar system. The technique was originally motivated by comments by industrial maintainers about the need for better ways of locating software features in large systems. It was then prototyped in a university setting and an initial tool called RECON was developed. The paper describes four case studies applying Reconnaissance to three different industrial programs of moderate size. Reconnaissance seems to be effective in finding "places to start looking" for maintainers of unfamiliar code. It can also be used to recover a traceability relation between program features and program code that may help identify design patterns. The case studies are the initial phase of an ongoing technology transfer project of the Software Engineering Research Center, to make Software Reconnaissance into a usable industrial technique.	1063-6773	0-8186-7677-9			Reverse engineering	reverse engineering	Software Reconnaissance technique;program comprehension;dynamic analysis technique;programmers;code location;industrial maintainers;software feature location;large systems;RECON tool;industrial programs;traceability relation;program features;program code;design patterns		22		15		6 Aug 2002			IEEE	IEEE Conferences
Comprehending Studies on Program Comprehension	comprehending studies on program comprehension	10.1109/ICPC.2017.9	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961527	I. Schröter; J. Krüger; J. Siegmund; T. Leich	Otto-von-Guericke-University, Magdeburg, Germany; Otto-von-Guericke-University, Magdeburg, Germany; University of Passau, Germany; Harz University of Applied Sciences, Wernigerode, Germany	2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC)	29 jun. 2017	2017			308	311	Program comprehension is an important aspect of developing and maintaining software, as programmers spend most of their time comprehending source code. Thus, it is the focus of many studies and experiments to evaluate approaches and techniques that aim to improve program comprehension. As the amount of corresponding work increases, the question arises how researchers address program comprehension. To answer this question, we conducted a literature review of papers published at the International Conference on Program Comprehension, the major venue for research on program comprehension. In this article, we i) present preliminary results of the literature review and ii) derive further research directions. The results indicate the necessity for a more detailed analysis of program comprehension and empirical research.		978-1-5386-0535-6		Systematic Review;Study Comprehension;Empirical Research	Terminology;Bibliographies;Documentation;Software;Guidelines;Context;Testing	software maintenance;source code (software)	source code;program comprehension;software maintenance;software development		21		22		29 jun. 2017			IEEE	IEEE Conferences
Trace visualization for program comprehension: A controlled experiment	trace visualization for program comprehension a controlled experiment	10.1109/ICPC.2009.5090033	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090033	B. Cornelissen; A. Zaidman; A. van Deursen; B. van Rompaey	Delft University of Technnology, Netherlands; Delft University of Technnology, Netherlands; Delft University of Technnology, Netherlands; University of Antwerp, Leuven, Belgium	2009 IEEE 17th International Conference on Program Comprehension	19 jun. 2009	2009			100	109	Understanding software through dynamic analysis has been a popular activity in the past decades. One of the most common approaches in this respect is execution trace analysis: among our own efforts in this context is EXTRAVIS, a tool for the visualization of large traces. Similar to other trace visualization techniques, our tool has been validated through anecdotal evidence, but should also be quantitatively evaluated to assess its usefulness for program comprehension. This paper reports on a first controlled experiment concerning trace visualization for program comprehension. We designed eight typical tasks aimed at gaining an understanding of a representative subject system, and measured how a control group (using the Eclipse IDE) and an experimental group (using both Eclipse and EXTRAVIS) performed in terms of correctness and time spent. The results are statistically significant in both regards, showing a 21% decrease in time and a 43% increase in correctness for the latter group.	1092-8138	978-1-4244-3998-0			Software maintenance;Time measurement;Performance evaluation;Scalability;Gain measurement;Control systems;Programming;Documentation;Data visualization;Design for experiments	program diagnostics;program visualisation;programming environments;reverse engineering	trace visualization;program comprehension;software understanding;dynamic analysis;execution trace analysis;EXTRAVIS tool;Eclipse IDE		21		22		19 jun. 2009			IEEE	IEEE Conferences
Program comprehension risks and opportunities in extreme programming	program comprehension risks and opportunities in extreme programming	10.1109/WCRE.2001.957822	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=957822	A. van Deursen	CWI, Amsterdam, Netherlands	Proceedings Eighth Working Conference on Reverse Engineering	7 Aug 2002	2001			176	185	Investigates the relationship between reverse engineering and program comprehension on the one hand, and the software process on the other. To understand this relationship, we select one particular existing software process, extreme programming (XP), and study the role played in it by program comprehension and reverse engineering. To that end, we analyze five key XP practices in depth: pair programming, unit testing, refactoring, evolutionary design and collaborative planning. The contributions of this paper are: (1) the identification of promising research areas in the field of program comprehension; (2) the identification of new application perspectives for reverse engineering technology; (3) a critical analysis of XP resulting in research questions that could help resolve some of the uncertainties surrounding XP; and (4) a discussion of the role that comprehension and reverse engineering can play in software process design.	1095-1350	0-7695-1303-4			Reverse engineering;Software testing;System testing;Genetic programming;Costs;Software systems;World Wide Web;Collaboration;Application software;Uncertainty	programming;reverse engineering;program testing;software prototyping	program comprehension;reverse engineering;software process;extreme programming;risks;pair programming;unit testing;refactoring;evolutionary design;collaborative planning;application perspectives identification;uncertainties;collaborative work		20		36		7 Aug 2002			IEEE	IEEE Conferences
Designing your Next Empirical Study on Program Comprehension	designing your next empirical study on program comprehension	10.1109/ICPC.2007.17	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268264	M. Di Penta; R. E. K. Stirewalt; E. Kraemer	RCOST-Research Centre on Software Technology, University of Sannio, Benevento, Italy; Computer Science and Engineering, Michigan State University, East Lansing, MI, USA; Computer Science Department, University of Georgia, Athens, GA, USA	15th IEEE International Conference on Program Comprehension (ICPC '07)	9 jul. 2007	2007			281	285	The field of program comprehension is characterized by both the continuing development of new tools and techniques and the adaptation of existing techniques to address program comprehension needs for new software development and maintenance scenarios. The adoption of these techniques and tools in industry requires proper experimentation to assess the advantages and disadvantages of each technique or tool and to let the practitioners choose the most suitable approach for a specific problem. The objective of this working session is to encourage researchers and practitioners working in the area of program comprehension to join forces to design and carry out studies related to program comprehension, including observational studies, controlled experiments, case studies, surveys, and contests, and to develop standards for describing and carrying out such studies in a way that facilitates replication of data and aggregation of the results of related studies.	1092-8138	0-7695-2860-0			Software maintenance;Computer science;Software tools;Programming;Force control;Standards development;Software engineering;Documentation;Collaboration;Best practices	design;software engineering	program comprehension;software development;software maintenance;data replication		19		25		9 jul. 2007			IEEE	IEEE Conferences
InfoSound: an audio aid to program comprehension	infosound an audio aid to program comprehension	10.1109/HICSS.1990.205229	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=205229	D. H. Sonnenwald; B. Gopinath; G. O. Haberman; W. M. Keese; J. S. Myers	Bell Communications Research, Inc., Red Bank, NJ, USA; Bell Communications Research, Inc., Red Bank, NJ, USA; Bell Communications Research, Inc., Red Bank, NJ, USA; Bell Communications Research, Inc., Red Bank, NJ, USA; Bell Communications Research, Inc., Red Bank, NJ, USA	Twenty-Third Annual Hawaii International Conference on System Sciences	6 Aug 2002	1990	2		541	546 vol.2	The authors have explored ways to enhance users' comprehension of complex applications using music and special sound effects to present application program events that are difficult to visually detect. A prototype system, InfoSound, allows developers to create and store musical sequences and special sound effects, to associate stored musical sequences and sound effects to application events, and to have real-time, continuous auditory control of sounds during application execution. InfoSound has been used to create auditory interfaces for two applications: a telephone network service simulation and a parallel computation simulation. The auditory interfaces in these applications helped users detect rapid, multiple event sequences that were difficult to visually detect using text and graphical interfaces. The paper describes the architecture of InfoSound, use of the system, and lessons the authors have learnt.<>					Event detection;Computational modeling;Music;Prototypes;Real time systems;Control systems;Telephony;Computer interfaces;Computer networks;Concurrent computing	digital simulation;electronic music;parallel processing;software tools;telephone networks;user interfaces	user comprehension;earcons;music;special sound effects;application program events;prototype system;InfoSound;musical sequences;application events;continuous auditory control;auditory interfaces;telephone network service simulation;parallel computation simulation;multiple event sequences		16	2	16		6 Aug 2002			IEEE	IEEE Conferences
Two program comprehension tools for automatic parallelization	two program comprehension tools for automatic parallelization	10.1109/4434.824311	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=824311	B. Di Martino; C. W. Kessler	Second University of Naples, Italy; NA	IEEE Concurrency	6 Aug 2002	2000	8	1	37	47	The authors compare two program-comprehension systems targeted to support automatic parallelization: PARAMAT (PARAllelization by pattern MATching) and the PAP (Parallelizable Algorithmic Patterns) Recognizer. The authors illuminate the main differences of each method, discussing the tradeoff between the speed of the first and the generality of the second.	1558-0849				Runtime;Microwave integrated circuits;Parallel algorithms;Automatic control;Linear algebra;Partial differential equations;Algorithm design and analysis;Pattern recognition;Libraries;Program processors	reverse engineering;parallelising compilers;software tools;pattern matching;software performance evaluation	program comprehension tools;automatic parallelization;PARAMAT;pattern matching;PAP Recognizer;parallelizable algorithmic patterns;generality;execution speed		16	1	18		6 Aug 2002			IEEE	IEEE Magazines
Facilitating program comprehension by mining association rules from source code	facilitating program comprehension by mining association rules from source code	10.1109/WPC.2003.1199196	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199196	C. Tjortjis; L. Sinos; P. Layzell	Department of Computation, UMIST (University of Manchester Institute of Science and Technology), Manchester, UK; Department of Computation, UMIST (University of Manchester Institute of Science and Technology), Manchester, UK; Department of Computation, UMIST (University of Manchester Institute of Science and Technology), Manchester, UK	11th IEEE International Workshop on Program Comprehension, 2003.	21 May 2003	2003			125	132	Program comprehension is an important part of software maintenance, especially when program structure is complex and documentation is unavailable or outdated. Data mining can produce structural views of source code thus facilitating legacy systems understanding. This paper presents a method for mining association rules from code aiming at capturing program structure and achieving better system understanding. A tool was implemented to assess this method. It inputs data extracted from code and derives association rules. Rules are then processed to abstract programs into groups containing interrelated entities. Entities are grouped together if their attributes participate in common rules. The abstraction is performed at the function level, in contrast to other approaches, that work at the program level. The method was evaluated using real, working programs. Programs are fed into a code analyser which produces the input needed for the mining tool. Results show that the method facilitates program comprehension by only using source code where domain knowledge and reliable documentation are not available or reliable.	1092-8138	0-7695-1883-4			Data mining;Association rules;Software maintenance;Documentation;Performance analysis;Algorithm design and analysis;Spatial databases;Software performance;Guidelines;Software tools	reverse engineering;data mining;software maintenance	program comprehension;association rule mining;source code;software maintenance;data mining;structural views;legacy systems understanding;program structure;system understanding;interrelated entities;function level		16	4	25		21 May 2003			IEEE	IEEE Conferences
An empirical study of amorphous slicing as a program comprehension support tool	an empirical study of amorphous slicing as a program comprehension support tool	10.1109/WPC.2000.852490	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852490	D. Binkley; M. Harman; L. R. Raszewski; C. Smith	Loyola College, MD, USA; Goldsmiths College, University of London, UK; Loyola College, MD, USA; Loyola College, MD, USA	Proceedings IWPC 2000. 8th International Workshop on Program Comprehension	6 Aug 2002	2000			161	170	Amorphous program slicing relaxes the syntactic constraint of traditional slicing and can therefore produce considerably smaller slices. This simplification power can be used to answer questions a software engineer might have about a program by first augmenting the program to make the question explicit and then slicing out an answer. One benefit of this technique is that the answer is in the form of a program and thus, in a language that the software engineer understands well. To test the usefulness of amorphous slicing in answering such questions, the question of array access safety is considered. A safety slice (an amorphous slice of an augmented program) is used to guide a software engineer to potential array bounds violations. A series of experiments was conducted to determine whether the safety slice was an effective aid to an engineer. 76 subjects participated in the controlled experiments. For experiments involving novice programmers, the null hypothesis could not be rejected, and so it was not possible to conclude that amorphous slicing assisted such programmers. However for more experienced groups, the experimental subjects (who were able to consult amorphous slices) significantly outperformed the control group. The study lends empirical support to the assertion that amorphous slicing assists program comprehension.	1092-8138	0-7695-0656-9			Amorphous materials;Educational institutions;Safety;Testing;Humans;Power engineering and energy;Programming profession;Councils;Debugging;Logic	program slicing;reverse engineering;software engineering;safety;arrays	amorphous program slicing;program comprehension support tool;syntactic constraint;simplification;software engineering questions;program augmentation;array access safety;safety slice;array bounds violations;novice programmers;empirical validation		15		14		6 Aug 2002			IEEE	IEEE Conferences
Program comprehension through the identification of abstract data types	program comprehension through the identification of abstract data types	10.1109/WPC.1994.341243	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341243	A. Cimitile; M. Tortorella; M. Munro	DIS, Department of Informatica e Sistemistica, University of Naples, Naples, Italy; DIS, Department of Informatica e Sistemistica, University of Naples, Naples, Italy; CSM, Centre for Software Maintenance, University of Durham, Durham, UK	Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94	6 Aug 2002	1994			12	19	The paper presents the results of experiments carried out on identifying abstract data types in existing code by an improved algorithm described in previous work (G. Canfora et al., 1994). It presents a brief description of the improved algorithm and then describes the results of the experiments. It addresses issues in program comprehension from the perspective of software reuse.<>	1092-8138	0-8186-5647-6			Software engineering;Software systems;Software testing;System testing;Debugging;Software maintenance;Tree graphs	abstract data types;data structures;object-oriented programming;software reusability;software maintenance	program comprehension;abstract data type identification;software reuse		15		11		6 Aug 2002			IEEE	IEEE Conferences
Using feature modeling for program comprehension and software architecture recovery	using feature modeling for program comprehension and software architecture recovery	10.1109/ECBS.2004.1316725	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1316725	I. Pashov; M. Riebisch	Technical University Ilmenau, Ilmenau, Germany; Technical University Ilmenau, Ilmenau, Germany	Proceedings. 11th IEEE International Conference and Workshop on the Engineering of Computer-Based Systems, 2004.	26 jul. 2004	2004			406	417	The available evidence in a legacy software system, which can help in its understanding and recovery of its architecture are not always sufficient. Very often the system's documentation is poor and outdated. One may argue that the most reliable resource of information is the system's source code. Nevertheless a significant knowledge about the problem domain is required in order to facilitate the extraction of the system's useful architectural information. In this approach feature modeling is introduced as an additional step in a system's architectural recovery process. Feature modeling structures the system's functionality and supports reverse engineering by detecting the relations between source code elements and requirements. Tracing these relations may lead to a better understanding of the program's behavior and the recovery of various architectural elements. In this way, by providing a mapping between source code and features, the system's feature model supports program comprehension and architectural recovery. The approach is developed as first part of a migration methodology towards a component-based architecture of legacy systems. Recovered information about features and architecture is collected in a repository to enable a refactoring as next step. The approach is currently applied in a large project for reengineering of an industrial image processing system.		0-7695-2125-8			Software architecture;Reverse engineering;Computer architecture;Software systems;Documentation;Data mining;Image processing;Companies;Image reconstruction;Information resources	systems re-engineering;software architecture;software prototyping;software maintenance;reverse engineering;formal verification;object-oriented programming	legacy software system;software architecture recovery;feature modeling;reverse engineering;program comprehension;component-based architecture;software refactoring;industrial image processing system		14		29		26 jul. 2004			IEEE	IEEE Conferences
Collective Code Bookmarks for Program Comprehension	collective code bookmarks for program comprehension	10.1109/ICPC.2011.19	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970168	A. Guzzi; L. Hattori; M. Lanza; M. Pinzger; A. v. Deursen	Delft University of Technology, The Netherlands; REVEAL @ Faculty of Informatics University of Lugano, Switzerland; REVEAL @ Faculty of Informatics University of Lugano, Switzerland; Delft University of Technology, The Netherlands; NA	2011 IEEE 19th International Conference on Program Comprehension	1 Aug 2011	2011			101	110	The program comprehension research community has been developing useful tools and techniques to support developers in the time-consuming activity of understanding software artifacts. However, the majority of the tools do not bring collective benefit to the team: After gaining the necessary understanding of an artifact (e.g., using a technique based on visualization, feature localization, architecture reconstruction, etc.), developers seldom document what they have learned, thus not sharing their knowledge. We argue that code bookmarking can be effectively used to document a developer's findings, to retrieve this valuable knowledge later on, and to share the findings with other team members. We present a tool, called Pollicino, for collective code bookmarking. To gather requirements for our bookmarking tool, we conducted an online survey and interviewed professional software engineers about their current usage and needs of code bookmarks. We describe our approach and the tool we implemented. To assess the tool's effectiveness, adequacy, and usability, we present an exploratory pre-experimental user study we have performed with 11 participants.	1092-8138	978-0-7695-4398-7			Usability;Interviews;XML;Navigation;Documentation;Particle measurements	reverse engineering;software tools;system documentation	program comprehension;software artifact understanding;developer findings documentation;Pollicino;collective code bookmarking		14	1	17		1 Aug 2011			IEEE	IEEE Conferences
Does the "Refactor to Understand" reverse engineering pattern improve program comprehension?	does the refactor to understand reverse engineering pattern improve program comprehension	10.1109/CSMR.2005.25	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1402151	B. Du Bois; S. Demeyer; J. Verelst	Laboratory On ReEngineering, Universiteit Antwerpen, Belgium; Laboratory On ReEngineering, Universiteit Antwerpen, Belgium; Department of Management Information Systems, Universiteit Antwerpen, Belgium	Ninth European Conference on Software Maintenance and Reengineering	4 Apr 2005	2005			334	343	Program comprehension is a fundamental requirement for all but the most trivial maintenance activities. Previous research has demonstrated key principles for improving comprehension. Among others, these consist of the introduction of beacons as indexes into knowledge, and the chunking of low-level structures into higher-level abstractions. These principles are naturally reflected in the reverse engineering pattern Refactor to Understand, which uses incremental renaming and extracting of program elements as the means to decipher cryptic code. In this paper, we discuss a controlled experiment to explore differences in program comprehension between the application of Refactor to Understand and the traditional Read to Understand pattern. Our results support added value of Refactor to Understand regarding specific aspects of program comprehension and specific types of source code. These findings illustrate the need for further experiments to provide clear guidelines on the application of refactorings for improving program comprehension.	1534-5351	0-7695-2304-8			Reverse engineering;Management information systems;Guidelines;Pattern analysis;Computer science;Time factors;Delay;Software maintenance;Software testing;System testing	reverse engineering;software maintenance;software process improvement	Refactor to Understand reverse engineering pattern;program comprehension improvement;incremental renaming;program element extraction;Read to Understand pattern;source code		14		22		4 Apr 2005			IEEE	IEEE Conferences
A structured demonstration of program comprehension tools	a structured demonstration of program comprehension tools	10.1109/WCRE.2000.891465	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=891465	S. E. Sim; M. A. D. Storey	Department of Computer Science, University of Victoria, Victoria, BC, Canada; Department of Computer Science, University of Toronto, Toronto, ONT, Canada	Proceedings Seventh Working Conference on Reverse Engineering	6 Aug 2002	2000			184	193	This paper describes a structured tool demonstration, a hybrid evaluation technique that combines elements from experiments, case studies and technology demonstrations. Developers of program understanding tools were invited to bring their tools to a common location to participate in a scenario with a common subject system. Working simultaneously the tool teams were given reverse engineering tasks and maintenance tasks to complete on an unfamiliar subject system. Observers were assigned to each team to find out how useful the observed program comprehension tool would be in an industrial setting. The demonstration was followed by a workshop panel where the development teams and the observers presented their results and findings from this experience.	1095-1350	0-7695-0881-2			Reverse engineering;Software systems;Software tools;Computer science;Educational institutions;Technology transfer;Scalability;Nominations and elections;Visualization;Operating systems	reverse engineering;software maintenance;software tools	program comprehension tools;structured tool demonstration;hybrid evaluation technique;experiments;case studies;technology demonstrations;program understanding;reverse engineering;software maintenance		13		24		6 Aug 2002			IEEE	IEEE Conferences
Bridging program comprehension tools by design navigation	bridging program comprehension tools by design navigation	10.1109/ICSM.2000.882972	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=882972	Robitaille; Schauer; Keller	Department IRO, Universite de Montreal, Montreal, QUE, Canada; Department IRO, Universite de Montreal, Montreal, QUE, Canada; Department IRO, Universite de Montreal, Montreal, QUE, Canada	Proceedings 2000 International Conference on Software Maintenance	6 Aug 2002	2000			22	32	Source code investigation is one of the most time-consuming activities during software maintenance and evolution, yet currently-available tool support suffers from several shortcomings. Browsing is typically limited to low-level elements, investigation is only supported as a one-way activity, and tools provide little help in getting an encompassing picture of the system under examination. In our research, we have developed tool support for design navigation that addresses these shortcomings. A design browser allows for flexible browsing of a system's design-level representation and for information exchange with a suite of program comprehension tools. The browser is complemented with a retriever supporting full-text and structural searching. In this paper, we detail these tools and their integration into a reverse engineering environment, present three case studies and put them into perspective.	1063-6773	0-7695-0753-0			Reverse engineering	reverse engineering;full-text databases;online front-ends;software maintenance;computer aided software engineering;software tools	program comprehension tools;design navigation;source code investigation;software maintenance;software evolution;design browser;retriever;low-level elements;one-way activity;flexible browsing;system design-level representation;information exchange;full-text searching;structural searching;reverse engineering environment;case studies		13	1	29		6 Aug 2002			IEEE	IEEE Conferences
Using background colors to support program comprehension in software product lines	using background colors to support program comprehension in software product lines	10.1049/ic.2011.0008	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6083163	J. Feigenspan; M. Schulze; M. Papendieck; C. Kästner; R. Dachselt; V. Köppen; M. Frisch	University of Magdeburg, Germany; University of Magdeburg, Germany; University of Magdeburg, Germany; Philipps University of Marburg, Germany; University of Magdeburg, Germany; University of Magdeburg, Germany; University of Magdeburg, Germany	15th Annual Conference on Evaluation & Assessment in Software Engineering (EASE 2011)	17 nov. 2011	2011			66	75	Background: Software product line engineering provides an effective mechanism to implement variable software. However, the usage of preprocessors, which is typical in industry, is heavily criticized, because it often leads to obfuscated code. Using background colors to support comprehensibility has shown effective, however, scalability to large software product lines (SPLs) is questionable. Aim: Our goal is to implement and evaluate scalable usage of background colors for industrial-sized SPLs. Method: We designed and implemented scalable concepts in a tool called FeatureCommander. To evaluate its effectiveness, we conducted a controlled experiment with a large real-world SPL with over 160,000 lines of code and 340 features. We used a within-subjects design with treatments colors and no colors. We compared correctness and response time of tasks for both treatments. Results: For certain kinds of tasks, background colors improve program comprehension. Furthermore, subjects generally favor background colors. Conclusion: We show that background colors can improve program comprehension in large SPLs. Based on these encouraging results, we will continue our work improving program comprehension in large SPLs.		978-1-84919-509-6				data flow analysis;reverse engineering;software engineering	background colors;program comprehension;software product line engineering;preprocessors;obfuscated code;FeatureCommander		12				17 nov. 2011			IET	IET Conferences
Inference-based and expectation-based processing in program comprehension	inferencebased and expectationbased processing in program comprehension	10.1109/WPC.2001.921715	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921715	M. P. O'Brien; J. Buckley	Department of Information Technology, Limerick Institute of Technology, Ireland; Department of Information Technology, Limerick Institute of Technology, Ireland	Proceedings 9th International Workshop on Program Comprehension. IWPC 2001	7 Aug 2002	2001			71	78	This paper formally distinguishes between two variants of top-down comprehension (as originally described by Brooks (1983) and Soloway (1984)). The first is inference-based comprehension, where the programmer derives meaning from cliched implementations in the code. The second is expectation-based comprehension, where the programmer has pre-generated expectations of the code's meaning. The paper describes the distinguishing features of the two variants, and uses these characteristics as the basis for an empirical study. This study establishes their existence, and identifies their relationship with programmers' domain and coding standards familiarity.	1092-8138	0-7695-1131-7			Programming profession;Costs;Documentation;Information technology;Bridges;Data mining;Performance evaluation;Cognitive science	reverse engineering	program comprehension;top-down comprehension;inference-based comprehension;expectation-based comprehension;coding standards		12		16		7 Aug 2002			IEEE	IEEE Conferences
A workbench for program comprehension during software maintenance	a workbench for program comprehension during software maintenance	10.1109/WPC.1996.501118	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501118	G. Canfora; L. Mancini; M. Tortorella	DIIIE-Dipartimento di Ingegneria dellInformazione ed Ingegneria Elettrica Faculty of Engineering at Benevento, University of Salerno, Italy; O.Group, Italy; DIS-Dipartimento di Informatica e Sistemistica Federico II, University of Naples, Italy	WPC '96. 4th Workshop on Program Comprehension	6 Aug 2002	1996			30	39	The paper describes the research carried out into the process of program comprehension during software maintenance within the EUREKA project REM (Reverse Engineering and Maintenance). Tools to aid maintenance programmers to achieve and document an overall interpretation of the system being maintained, as well as a deep understanding of the fine details of the source code, are presented. The cognition model assumed exploits both the top down and the bottom up approaches: program comprehension is intended as an iterative process of guessing, constructing hypotheses and verifying them This process is supported by providing maintenance programmers with a flexible system for querying source code and testing hypotheses against the evidence in the code. Several facilities generate new documents at the design and specification level, thus allowing maintenance programmers to record the knowledge gained for future use.	1092-8138	0-8186-7283-8			Software maintenance;Programming profession;Documentation;Reverse engineering;Costs;Proposals;Switches;Cognition;Iterative methods;System testing	reverse engineering;software maintenance;software tools;cognitive systems	program comprehension;software maintenance;EUREKA project REM;maintenance programmers;source code;cognition model;bottom up approaches;iterative process;specification level		11		22		6 Aug 2002			IEEE	IEEE Conferences
Backward conditioning: a new program specialisation technique and its application to program comprehension	backward conditioning a new program specialisation technique and its application to program comprehension	10.1109/WPC.2001.921717	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921717	C. Fox; M. Harman; R. Hierons; S. Danicic	Kings College, University of London, London, UK; Brunei University, Uxbridge, UK; Brunei University, Uxbridge, UK; Goldsmiths College, University of London, London, UK	Proceedings 9th International Workshop on Program Comprehension. IWPC 2001	7 Aug 2002	2001			89	97	This paper introduces backward conditioning. Like forward conditioning (used in conditioned slicing), backward conditioning consists of specialising a program with respect to a condition inserted into the program. However, whereas forward conditioning deletes statements which are not executed when the initial state satisfies the condition, backward conditioning deletes statements which cannot cause execution to enter a state which satisfies the condition. The relationship between backward and forward conditioning is reminiscent of the relationship between backward and forward slicing. Forward conditioning addresses program comprehension questions of the form 'what happens if the program starts in a state satisfying condition c?', whereas backward conditioning addresses questions of the form 'what parts of the program could potentially lead to the program arriving in a state satisfying condition c?' The paper illustrates the use of backward conditioning as a program comprehension assistant and presents an algorithm for constructing backward conditioned programs.	1092-8138	0-7695-1131-7			Educational institutions;Programming profession;Temperature	reverse engineering;program slicing	program specialisation;program comprehension;backward conditioning;forward conditioning;conditioned slicing		11		19		7 Aug 2002			IEEE	IEEE Conferences
Individual differences in program comprehension strategies in unfamiliar programming systems	individual differences in program comprehension strategies in unfamiliar programming systems	10.1109/WPC.2003.1199201	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199201	A. J. Ko; B. Uttl	Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA; Department of Psychology, College of Liberal Arts, Oregon State University, Corvallis, OR, USA	11th IEEE International Workshop on Program Comprehension, 2003.	21 May 2003	2003			175	184	This study examines the effect of individual differences on the program comprehension strategies of users working with an unfamiliar programming system. Participants of varying programming expertise were given a battery of psychological tests, a brief introduction to a statistical programming environment, and a 20-minute debugging task. Our data show three distinct comprehension strategies that were related to programming experience, but individuals with stronger domain knowledge for specific bugs tended to succeed.	1092-8138	0-7695-1883-4			Programming profession;Debugging;Psychology;Computer bugs;Predictive models;Documentation;Computer science;Educational institutions;Art;Batteries	reverse engineering;program debugging;human factors;programming environments	program comprehension strategies;unfamiliar programming systems;individual differences;programming expertise;psychological tests;statistical programming environment;program understanding;debugging task;programming experience		11		16	IEEE	21 May 2003			IEEE	IEEE Conferences
Intensions are a key to program comprehension	intensions are a key to program comprehension	10.1109/ICPC.2009.5090022	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090022	V. Rajlich	Department of Computer Science, Wayne State University, Detroit, MI, USA	2009 IEEE 17th International Conference on Program Comprehension	19 jun. 2009	2009			1	9	The classical comprehension theories study relations between extensions, intensions, and names. Originally developed in linguistics and mathematics, these theories are applicable to program comprehension as well. While extensions are present in the program, the intensions are usually missing, and evolution and maintenance programmers have to recover them as the program cannot be successfully comprehended and changed without them.	1092-8138	978-1-4244-3998-0			Mathematics;Programming profession;Hardware;Computer science;Visualization;Humans;Cities and towns;Marketing and sales;Credit cards;Software engineering	computational linguistics;reverse engineering;software maintenance;software metrics	program comprehension effort;program intension;software evolution;software maintenance;linguistics;software development;program extension		11		27		19 jun. 2009			IEEE	IEEE Conferences
Reading the documentation of invoked API functions in program comprehension	reading the documentation of invoked api functions in program comprehension	10.1109/ICPC.2009.5090040	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090040	U. Dekel; J. D. Herbsleb	Institute of Software Research, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA; Institute of Software Research, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA	2009 IEEE 17th International Conference on Program Comprehension	19 jun. 2009	2009			168	177	Comprehending an unfamiliar code fragment requires an awareness of explicit usage directives that may be present in the documentation of some invoked functions. Since it is not practical for developers to thoroughly investigate every call, directives may be missed and errors may occur. We previously reported on a tool called eMoose, which highlights calls to methods with associated directives, and on a controlled comparative lab study in which eMoose users were more successful at fixing bugs in given code fragments. In this paper we attempt to shed light on the factors behind these differences with a detailed analysis of videos from the study. We argue that information foraging theory may explain the subjects' reading choices and the impact of our tool. We also suggest ways to structure documentation to increase the prospects of knowledge acquisition.	1092-8138	978-1-4244-3998-0			Documentation;Java;Functional programming;Computer science;Computer bugs;Videos;Knowledge acquisition;Software maintenance;Collaborative software;Application software	application program interfaces;knowledge acquisition;program debugging;software maintenance	application programming interfaces;software maintenance;program comprehension;information foraging theory;knowledge acquisition		10		13		19 jun. 2009			IEEE	IEEE Conferences
How Webmining and Coupling Metrics Improve Early Program Comprehension	how webmining and coupling metrics improve early program comprehension	10.1109/ICPC.2006.26	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631107	A. Zaidman; Bart Du Bois; S. Demeyer	Lab On REngineering (LORE), University of Antwerp, Belgium; Lab On REngineering (LORE), University of Antwerp, Belgium; Lab On REngineering (LORE), University of Antwerp, Belgium	14th IEEE International Conference on Program Comprehension (ICPC'06)	26 jun. 2006	2006			74	78	During initial program comprehension, software engineers could benefit from knowing the most need-to-be-understood classes in the system under study in order to kick-start their software reconnaissance. Previously we have used Webmining techniques on runtime trace data to identify these important classes. Here, we reprise this Webmining technique and make a thorough comparison of its effectiveness when collecting static information of the software system under study. Apache Ant and Jakarta JMeter, two medium-scale open source Java software systems, serve as case studies. From publicly available developers notes we conclude that the Webmining technique in combination with dynamic analysis provides the best results with a level of recall of 90% when comparing with the developers' opinion	1092-8138	0-7695-2601-2			Software systems;Runtime;Open source software;Information analysis;Reconnaissance;Java;Large-scale systems;Leg;Availability;Scalability	data mining;Internet;Java;public domain software;reverse engineering;software maintenance;software metrics;system monitoring	Webmining;coupling metrics;program comprehension;software engineering;software reconnaissance;runtime trace data;Apache Ant;Jakarta JMeter;open source Java software system;dynamic analysis		10		7		26 jun. 2006			IEEE	IEEE Conferences
Enhancing program comprehension with recovered state models	enhancing program comprehension with recovered state models	10.1109/WPC.2002.1021325	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021325	S. S. Some; T. C. Lethbridge	School of Information Technology and Engineering (SITE), University of Ottawa, Canada; School of Information Technology and Engineering (SITE), University of Ottawa, Canada	Proceedings 10th International Workshop on Program Comprehension	10 Dec 2002	2002			85	93	State transition machines are high-level behavior descriptions often used as modeling tools for the design and implementation of a large class of software systems. Some of the state transition machine implementation approaches are such that the static structure of the resulting code closely matches that of the original state transition machines. Therefore, having a representation of the original state transition machines is likely to improve the corresponding code understandability. We present an approach supported by a prototype tool, to extract state transition machines by static analysis of source code. An objective of this work is to enhance program comprehension with visual representations of the behavior of the programs being analyzed.	1092-8138	0-7695-1495-2			Object oriented modeling;Software systems;Software maintenance;Data mining;Information technology;Design engineering;Software prototyping;Prototypes;Software tools;Navigation	reverse engineering;program visualisation;program diagnostics;graph theory	program comprehension;recovered state models;state transition machines;high-level behavior descriptions;modeling tools;software systems;static structure;code understandability;static analysis;source code;visual representations		10	1	16		10 Dec 2002			IEEE	IEEE Conferences
On evaluating the layout of UML class diagrams for program comprehension	on evaluating the layout of uml class diagrams for program comprehension	10.1109/WPC.2005.26	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421047	D. Sun; K. Wong	Department of Computing Science, University of Alberta, Canada; Department of Computing Science, University of Alberta, Canada	13th International Workshop on Program Comprehension (IWPC'05)	23 May 2005	2005			317	326	UML class diagrams are helpful for understanding the structure of a software system. Algorithms and tools have been developed to generate UML class diagrams automatically for program understanding purposes. However, many tools often ignore perceptual factors in the layout of these diagrams. Therefore, users still have to spend much time and effort rearranging boxes and lines to make the diagram understandable. This paper presents key criteria and guidelines for the effective layout of UML class diagrams from the perspective of perceptual theories. Two UML tools have been analyzed and evaluated to illustrate how the criteria can be applied to improve the readability of class diagrams.	1092-8138	0-7695-2254-8		UML class diagrams;perceptual theory;aesthetics;graph layout;UML modeling tools	Unified modeling language;Software systems;Layout;Guidelines;Visualization;Sun;Reverse engineering;Documentation;Knowledge engineering;Large-scale systems	Unified Modeling Language;program visualisation;reverse engineering;diagrams;software tools	software system understanding;UML class diagram layout;perceptual theory;program comprehension;graph layout;Unified Modeling Language;program visualisation;software tools		10		33		23 May 2005			IEEE	IEEE Conferences
Enriching program comprehension for software reuse	enriching program comprehension for software reuse	10.1109/WPC.1997.601279	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601279	E. Burd; M. Munro	The Centre for Software Maintenance, University of Durham, Durham, UK; The Centre for Software Maintenance, University of Durham, Durham, UK	Proceedings Fifth International Workshop on Program Comprehension. IWPC'97	6 Aug 2002	1997			130	137	The paper describes the process of code scavenging for reuse. In particular we consider enriching program comprehension for the identification and integration of reuse components by information abstraction and the use of graphical representations. The requirements of good reuse candidates are described, and then a description of a process of identifying and preparing for their reengineering into reuse units is given, In particular we describe two main activities: the identification of units; and the definition of the units user interface. Initially, the identification of reusable units applies some of the methods from RE/sup 2/ but is extended with the use of graph simplification procedures. The identification process is based on the calling structure of the code. Secondly, data analysis is performed on the identified reuse candidates. The data analysis process provides an indication of the potential use of the component and the effect required to make the candidate reusable. The paper provides examples and results from a number of case studies which have been used to evaluate this work. Our work relies heavily on there being communication between technical and non-technical staff. We achieve this through the use of graphical representation and thus results are displayed graphically where applicable.	1092-8138	0-8186-7993-X			Software reusability;Software maintenance;Data analysis;Costs;Software quality;User interfaces;Productivity;Programming;Software design;Software performance	software reusability;reverse engineering;systems re-engineering;visual programming	program comprehension;software reuse;code scavenging;reuse components;information abstraction;graphical representations;reuse candidates;reengineering;reuse units;units user interface;unit identification;RE/sup 2/;graph simplification procedures;calling structure;data analysis;graphical representation		9		12		6 Aug 2002			IEEE	IEEE Conferences
DOCKET: program comprehension-in-the-large	docket program comprehensioninthelarge	10.1109/WPC.1993.263897	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263897	P. J. Layzell; R. Champion; M. J. Freeman	Department of Computation, UMIST (University of Manchester Institute of Science and Technology), Manchester, UK; Department of Computation, UMIST (University of Manchester Institute of Science and Technology), Manchester, UK; Department of Computation, UMIST (University of Manchester Institute of Science and Technology), Manchester, UK	[1993] IEEE Second Workshop on Program Comprehension	6 Aug 2002	1993			140	148	With the growing awareness of the importance of software maintenance, has come a re-evaluation of software maintenance tools. Such tools range from source code analysers to semi-intelligent tools which seek to reconstruct systems designs and specification documents from source code. However, it is clear that relying solely upon source code as the basis for reverse engineering has many problems. This paper proposes the need for program comprehension-in-the-large and describes the work of the Esprit DOCKET project which seeks to provide such a support capability. The DOCKET project has developed a prototype environment to support the development of a system model linking user-oriented, business aspects of a system, to operational code using a variety of knowledge source inputs: code, documents and user expertise. The aim is to provide a coherent model to form the basis for system and program understanding and to support the software change and evolution process.<>	1092-8138	0-8186-4042-1			Software maintenance;Documentation;Humans;Reverse engineering;Software engineering;Computer industry;Software tools;Software systems;Software prototyping;Prototypes	software maintenance;software tools	DOCKET;program comprehension-in-the-large;software maintenance;maintenance tools;source code analysers;semi-intelligent tools;specification documents;business aspects;operational code;knowledge source;program understanding;software change;evolution process		8		6		6 Aug 2002			IEEE	IEEE Conferences
Program comprehension for Web services	program comprehension for web services	10.1109/WPC.2004.1311057	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311057	N. Gold; K. Bennett	Department of Computation, UMIST (University of Manchester Institute of Science and Technology), Manchester, UK; Department of Computer Science, University of Durham, Durham, UK	Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.	12 jul. 2004	2004			151	160	Web services provide programmatic interaction between organisations within large heterogeneous distributed systems. Using recent experiences of constructing and enhancing a data integration system for the health domain, based on Web services, we draw conclusions about new problems for program comprehension. These derive from the fundamentally dynamic and distributed nature of the environment. We suggest several key research topics for program comprehension, arguing that these are crucial if software constructed from Web services is to be supportable over a long period. Finally, we briefly summarise some wider conclusions about understanding Web services at the application domain level.	1092-8138	0-7695-2149-5			Web services;Software maintenance;Application software;Software debugging;Software prototyping;Gold;Distributed computing;Computer science;Cost function;Computer bugs	software maintenance;Internet;data integrity;reverse engineering	program comprehension;Web services;distributed systems;data integration;software maintenance;service-based software		8		19		12 jul. 2004			IEEE	IEEE Conferences
Queue-based cost evaluation of mental simulation process in program comprehension	queuebased cost evaluation of mental simulation process in program comprehension	10.1109/METRIC.2003.1232480	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1232480	M. Nakamura; A. Monden; T. Itoh; K. Matsumoto; Y. Kanzaki; H. Satoh	Graduate School of Information Science, Nara Institute of Science and Technology, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Japan; Matsushita Elecrric Indusrrial Company Limited, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Japan	Proceedings. 5th International Workshop on Enterprise Networking and Computing in Healthcare Industry (IEEE Cat. No.03EX717)	23 Sep 2003	2003			351	360	We present a method to estimate the cost of mental (hand) simulation of programs. In mental simulation, human short term memory is extensively used to recall and memorize values of variables. When the simulation reaches a variable reference, the simulation can be performed easily if the value is still remembered. However, if not, we have to backtrack the simulation until the value is obtained, which is time consuming. Taking the above observation into consideration, we first present a model, called virtual mental simulation model (VMSM), which exploits a queue representing short term memory. The VMSM takes one of the abstract processes recall or backtrack, depending on whether the variable is currently stored in the queue or not. Then, applying cost functions to the VMSM, we derive four dynamic metrics reflecting the cost of mental simulation. In our empirical study, the proposed VMSM metrics reveal that the backtrack process for nonconstant variables gives a significant impact on the cost of mental simulation. Since the proposed method can be fully automated, it can provide a practical means to estimate the cost of mental simulation, which can be also used as a program comprehension measure.	1530-1435	0-7695-1987-3			Computational modeling;Humans;Computer simulation;Cost function;Computer hacking;Information science;Programming profession;Debugging;Computer crime;Protection	reverse engineering;software metrics;backtracking	program comprehension;mental program simulation;queue-based cost evaluation;virtual mental simulation model;human short-term memory;dynamic metrics;recall process;backtrack process		8		15		23 Sep 2003			IEEE	IEEE Conferences
Automated chunking to support program comprehension	automated chunking to support program comprehension	10.1109/WPC.1997.601262	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601262	I. Burnstein; K. Roberson	Computer Science Department, Illinois Institute of Technology, Chicago, IL, USA; Computer Science Department, Illinois Institute of Technology, Chicago, IL, USA	Proceedings Fifth International Workshop on Program Comprehension. IWPC'97	6 Aug 2002	1997			40	49	We report on a program comprehension support tool called the Chunker. It partitions code into abstractions called candidate chunks using data dependency analysis and a set of heuristics. The candidate chunks can be mapped to programming and problem domain concepts by a software engineer and are useful for building mental models during comprehension. We describe the implementation of the Chunker, performance issues, and plans for tool enhancement.	1092-8138	0-8186-7993-X			Cognitive science;Data analysis;Software tools;Data visualization;Displays;Computer science;Software performance;Buildings;Computer languages;Assembly	reverse engineering;software tools;user modelling;software performance evaluation	automated chunking;program comprehension support tool;Chunker;code partitioning;abstractions;candidate chunks;data dependency analysis;heuristics;programming;mental models;software performance		7		12		6 Aug 2002			IEEE	IEEE Conferences
Early field experience with the Software Reconnaissance technique for program comprehension	early field experience with the software reconnaissance technique for program comprehension	10.1109/WCRE.1996.558934	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=558934	N. Wilde; C. Casey	University of West Florida, Pensacola, FL, USA; University of West Florida, Pensacola, FL, USA	Proceedings of WCRE '96: 4rd Working Conference on Reverse Engineering	6 Aug 2002	1996			270	276	Paper reprinted from ICSM '96. Software Reconnaissance is a dynamic analysis technique to help programmers locate code that they need to understand, fix, or enhance in an unfamiliar system. The technique was originally motivated by comments by industrial maintainers about the need for better ways of locating software features in large systems. It was then prototyped in a university setting and an initial tool called RECON was developed. This paper describes four case studies applying Reconnaissance to three different industrial programs of moderate site. Reconnaissance seems to be effective in finding "places to start looking" for maintainers of unfamiliar code. It can also be used to recover a traceability relation between program features and program code that may help identify design patterns. The case studies are the initial phase of an ongoing technology transfer project of the Software Engineering Research Center, to make Software Reconnaissance into a usable industrial technique.		0-8186-7674-4			Reconnaissance;Software maintenance;Computer industry;Technology transfer;Programming profession;Software engineering;Industrial relations;Communication system software;Switches;Testing	reverse engineering	Software Reconnaissance technique;program comprehension;dynamic analysis technique;program enhancement;unfamiliar system;software maintenance;RECON tool;traceability relation;design patterns;technology transfer project;Software Engineering Research Center;industrial technique		7		15		6 Aug 2002			IEEE	IEEE Conferences
A role for chunking and fuzzy reasoning in a program comprehension and debugging tool	a role for chunking and fuzzy reasoning in a program comprehension and debugging tool	10.1109/TAI.1997.632243	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=632243	I. Burnstein; K. Roberson; F. Saner; A. Mirza; A. Tubaishat	Computer Science Department, Illinois Institute of Technology, Chicago, IL, USA; Computer Science Department, Illinois Institute of Technology, Chicago, IL, USA; Computer Science Department, Illinois Institute of Technology, Chicago, IL, USA; Computer Science Department, Illinois Institute of Technology, Chicago, IL, USA; Computer Science Department, Illinois Institute of Technology, Chicago, IL, USA	Proceedings Ninth IEEE International Conference on Tools with Artificial Intelligence	6 Aug 2002	1997			102	109	We are applying artificial intelligence techniques to develop a tool called BUG-DOCTOR that assists software engineers with program comprehension and debugging. In this paper we describe two of BUG-DOCTOR's knowledge sources, the Chunker and the Plan Processor. The Chunker identifies candidate chunks in the target code using program analysis techniques and a set of heuristics. Candidate chunks map to higher level concepts, and have a signature which captures their major identifying characteristics. The Plan Processor uses a signature to retrieve a set of program plans from a Plan Library with features that are similar to those of the candidate chunk. Its fuzzy reasoner then ranks the retrieved plans. The plan chosen as most similar to the candidate chunk is used for program comprehension and debugging tasks that follow. We believe that this approach could lead to more scalable tools for program comprehension and debugging.	1082-3409	0-8186-8203-5			Fuzzy reasoning;Libraries;Programming profession;Fault diagnosis;Target recognition;Computer science;Software debugging;Software tools;Artificial intelligence;Fuzzy systems	program debugging;inference mechanisms;artificial intelligence;fuzzy logic;knowledge based systems	fuzzy reasoning;program comprehension;debugging tool;artificial intelligence;BUG-DOCTOR;software engineers;knowledge sources;Chunker;Plan Processor;program analysis techniques;heuristics;Plan Library		7		14		6 Aug 2002			IEEE	IEEE Conferences
Expressiveness and effectiveness of program comprehension: Thoughts on future research directions	expressiveness and effectiveness of program comprehension thoughts on future research directions	10.1109/FOSM.2008.4659246	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4659246	J. I. Maletic; H. Kagdi	Kent State University, Kent, OH, US; Department of Computer Science, Missouri University of Science and Technology, Rolla, MO, USA	2008 Frontiers of Software Maintenance	24 Oct 2008	2008			31	37	A number of research challenges in the area of program comprehension are presented. The expressiveness and effectiveness of program comprehension are discussed, and research directions are organized along these two axes. Both fundament research issues are raised along with new applications for program comprehension methods. The work advocates the investigation of better measures, further empirical studies, and controlled experiments to assess the effectiveness of program comprehension techniques.		978-1-4244-2654-6			Libraries;Software;Programming;Software engineering;Humans;Tracking;Software systems	program visualisation;reverse engineering;software maintenance;software prototyping	program comprehension expressiveness;program comprehension effectiveness;software evolution;software change;program visualization;software maintenance		7		29		24 Oct 2008			IEEE	IEEE Conferences
Sonification design guidelines to enhance program comprehension	sonification design guidelines to enhance program comprehension	10.1109/ICPC.2009.5090035	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090035	K. Hussein; E. Tilevich; I. I. Bukvic; SooBeen Kim	Department of Computer Science, Virginia Technology, Blacksburg, VA, USA; Department of Computer Science, Virginia Technology, Blacksburg, VA, USA; Department of Music, Virginia Technology, Blacksburg, VA, USA; Wellesley College, Wellesley, MA, USA	2009 IEEE 17th International Conference on Program Comprehension	19 jun. 2009	2009			120	129	Faced with the challenges of understanding the source code of a program, software developers are assisted by a wealth of software visualization research. This work explores how visualization can be supplemented by sonification as a cognitive tool for code comprehension. By engaging the programmer's auditory senses, sonification can improve the utility of program comprehension tools. This paper reports on our experiences of creating and evaluating a program comprehension prototype tool that employs sonification to assist program understanding by rendering sonic cues. Our empirical evaluation of the efficacy of information sonification indicates that this cognitive aid can effectively complement visualization when trying to understand an unfamiliar code base. Based on our experiences, we then propose a set of guidelines for the design of a new generation of tools that increase their information utility by combining visualization and sonification.	1092-8138	978-1-4244-3998-0			Guidelines;Visualization;Software maintenance;Software systems;Programming;Auditory displays;Computer science;Educational institutions;Software prototyping;Prototypes	program visualisation;source coding	sonification design guidelines;program source code;software developers;software visualization;cognitive tool;code comprehension;auditory senses;program comprehension tools		7		56		19 jun. 2009			IEEE	IEEE Conferences
Moral dominance relations for program comprehension	moral dominance relations for program comprehension	10.1109/TSE.2003.1232289	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1232289	S. C. Shaw; M. Goldstein; M. Munro; E. Burd	Department of Mathematical Sciences, Science Laboratories, University of Durham, Durham, UK; Department of Mathematical Sciences, Science Laboratories, University of Durham, Durham, UK; Research Institute in Software Evolution, Department of Computer Science,Science Laboratories, University of Durham, Durham, UK; Research Institute in Software Evolution, Department of Computer Science,Science Laboratories, University of Durham, Durham, UK	IEEE Transactions on Software Engineering	23 Sep 2003	2003	29	9	851	863	Dominance trees have been used as a means for reengineering legacy systems into potential reuse candidates. The dominance relation suggests the reuse candidates which are identified by strongly directly dominated subtrees. We review the approach and illustrate how the dominance tree may fail to show the relationship between the strongly direct dominated procedures and the directly dominated procedures. We introduce a relation of generalized conditional independence which strengthens the argument for the adoption of the potential reuse candidates suggested by the dominance tree and explains their relationship with the directly dominated vertices. This leads to an improved dominance tree, the moral dominance tree, which helps aid program comprehension available from the tree. The generalized conditional independence relation also identifies potential reuse candidates that are missed by the dominance relation.	1939-3520				Ethics;Tree graphs;Software maintenance;Databases;Graphical models;Reverse engineering;Testing;Companies;Software performance;Documentation	tree data structures;reverse engineering;software reusability;systems re-engineering	moral dominance relations;program comprehension;dominance trees;legacy systems reengineering;reuse candidates;strongly directly dominated subtrees;directly dominated vertices;generalized conditional independence relation		7		29	IEEE	23 Sep 2003			IEEE	IEEE Journals
Reducing Program Comprehension Effort in Evolving Software by Recognizing Feature Implementation Convergence	reducing program comprehension effort in evolving software by recognizing feature implementation convergence	10.1109/ICPC.2007.33	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268237	J. Kothari; T. Denton; A. Shokoufandeh; S. Mancoridis	Department of Computer Science College of Engineering, Drexel University, Philadelphia, PA, USA; Department of Computer Science College of Engineering, Drexel University, Philadelphia, PA, USA; Department of Computer Science College of Engineering, Drexel University, Philadelphia, PA, USA; Department of Computer Science College of Engineering, Drexel University, Philadelphia, PA, USA	15th IEEE International Conference on Program Comprehension (ICPC '07)	9 jul. 2007	2007			17	26	The implementations of software features evolve as an application matures. We define a measure of feature implementation overlap that determines how similar features are in their execution by examining their call graphs. We consider how this measure changes over time, and evaluate the hypothesis that over time and subsequent versions of a software application, the implementations of semantically similar features converge. As the features of an application converge in their implementation, we are able to more effectively determine groups of semantically similar features and to reduce the cost of program comprehension by selecting few key features that give an overview of the system. We present a case study analyzing the features of the Jext, Firefox, and Gaim software systems to support our hypothesis.	1092-8138	0-7695-2860-0			Convergence;Application software;Software systems;Costs;Computer science;Educational institutions;Software measurement;Time measurement;Maintenance engineering;Text processing	configuration management;feature extraction;reverse engineering;software cost estimation;software maintenance;software metrics;software prototyping	program comprehension effort reduction;software evolution;software feature implementation convergence;call graph;software version;software refactoring		7		12		9 jul. 2007			IEEE	IEEE Conferences
Enabling program comprehension through a visual object-focused development environment	enabling program comprehension through a visual objectfocused development environment	10.1109/VLHCC.2011.6070389	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6070389	F. Olivero; M. Lanza; M. D'Ambros; R. Robbes	REVEAL @ Faculty of Informatics, University of Lugano, Switzerland; REVEAL @ Faculty of Informatics, University of Lugano, Switzerland; REVEAL @ Faculty of Informatics, University of Lugano, Switzerland; PLEIAD@DCC, University of Chile, Chile	2011 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)	10 nov. 2011	2011			127	134	Integrated development environments (IDEs) include many tools that provide the means to construct programs. Coincidentally, the very same IDEs are a primary vehicle for program comprehension. We claim that IDEs may be an impediment for program comprehension because they treat software elements as text, which may be counterproductive in the context of program understanding-where abstracting from the source text to the level of structural entities and relationships is the key. We are currently building Gaucho, a visual object-focused environment that allows developers to write programs by creating and manipulating lightweight and intuitive depictions of object-oriented constructs. The research question we investigate here is how such an environment compares with traditional IDEs when it comes to performing program comprehension tasks. To answer our question, we conducted a preliminary controlled experiment with eight subjects, comparing Gaucho against a traditional IDE. We found that Gaucho outperforms the IDE regarding the correctness of the tasks, while it is slower with respect to the completion time. Our preliminary results suggest that alternative-visual-IDEs may be superior to traditional IDEs as program comprehension aids.	1943-6106	978-1-4577-1247-0			Shape;Navigation;Visualization;Software;Programming;Object oriented modeling;Layout	object-oriented methods;software maintenance	program comprehension;visual object-focused development environment;integrated development environment;program understanding context;Gaucho environment;object-oriented constructs		6		25		10 nov. 2011			IEEE	IEEE Conferences
Detecting and comparing brain activity in short program comprehension using EEG	detecting and comparing brain activity in short program comprehension using eeg	10.1109/FIE.2017.8190486	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8190486	M. K. . -C. Yeh; D. Gopstein; Y. Yan; Y. Zhuang	College of Information Sciences and Technology, Penn State University, Brandywine; College of Education, Penn State University, University Park; Department of Computer Science and Engineering, New York University; Department of Computer Science, University of Colorado	2017 IEEE Frontiers in Education Conference (FIE)	14 Dec 2017	2017			1	5	Program comprehension is a common task in software development. Programmers perform program comprehension at different stages of the software development life cycle. Detecting when a programmer experiences problems or confusion can be difficult. Self-reported data may be useful, but not reliable. More importantly, it is hard to use the self-reported feedback in real time. In this study, we use an inexpensive, non-invasive EEG device to record 8 subjects' brain activity in short program comprehension. Subjects were presented either confusing or non-confusing C/C++ code snippets. Paired sample t-tests are used to compare the average magnitude in alpha and theta frequency bands. The results show that the differences in the average magnitude in both bands are significant comparing confusing and non-confusing questions. We then use ANOVA to detect whether such difference also presented in the same type of questions. We found that there is no significant difference across questions of the same difficulty level. Our outcome, however, shows alpha and theta band powers both increased when subjects are under the heavy cognitive workload. Other research studies reported a negative correlation between (upper) alpha and theta band powers.		978-1-5090-5920-1		computer programming;electroencephalograph;EEG	Electroencephalography;Brain;Software;Electrodes;Real-time systems;Performance evaluation	electroencephalography;medical signal processing	EEG device;program comprehension;C/C++ code snippets;ANOVA;brain activity;software development life cycle		6		20		14 Dec 2017			IEEE	IEEE Conferences
Towards automated code parallelization through program comprehension	towards automated code parallelization through program comprehension	10.1109/WPC.1994.341258	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341258	B. D. Martino; G. Iannello	Dipartimento di Informatica e Sistemistica, Università di Napoli Federico II, Napoli, Italy; Dipartimento di Informatica e Sistemistica, Università di Napoli Federico II, Napoli, Italy	Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94	6 Aug 2002	1994			108	115	Currently available parallelizing tools are biased in favor of a particular parallel execution model for generating the output parallel program. This obviously limits the generality of these tools, since programs may be parallelized according to different programming paradigms. In this paper we propose a novel approach to automated code parallelization that tries to overcome these limitations. This approach consists in recognizing first the paradigm that as best suited to a given program to be parallelized, and then applying paradigm-specific transformation to generate the final parallel code. We argue that the recognition phase can be fully automated using techniques developed in the framework of automated program understanding. With the help of a case study, we discuss how this new approach could be implemented and propose the basic structure of a paradigm-oriented parallelizer.<>	1092-8138	0-8186-5647-6			Parallel programming;Pattern recognition;Concurrent computing;Parallel processing;Automatic control;Skeleton;Performance analysis	reverse engineering;parallel programming;automatic programming	automated code parallelization;program comprehension;paradigm-oriented parallelizer;parallel program;automated program understanding		6	3	12		6 Aug 2002			IEEE	IEEE Conferences
Comparing graph-based program comprehension tools to relational database-based tools	comparing graphbased program comprehension tools to relational databasebased tools	10.1109/WPC.2001.921732	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921732	C. Lange; H. M. Sneed; A. Winter	Institute for Software Technology, University of Koblenz and Landau, Koblenz, Germany; Case Consult GmbH, Wiesbaden, Germany; Institute for Software Technology, University of Koblenz and Landau, Koblenz, Germany	Proceedings 9th International Workshop on Program Comprehension. IWPC 2001	7 Aug 2002	2001			209	218	In this paper we compare the experiences of applying the graph-based GUPRO approach to experiences in applying ANAUSoftSpec-an approach based on relational databases. We present the results of a case study in which GUPRO has been applied to a multi-language software system for stock trading (GEOS). Comparing the results of the case study, with experiences of applying ANAL/SoftSpec to GEOS we show that the graph-oriented approach enables an efficient way of source code analysis and program understanding.	1092-8138	0-7695-1131-7			Relational databases;Software tools;Software systems;Reverse engineering;Industrial relations;Application software;Usability;Programming profession;Embedded system;Layout	relational databases;reverse engineering;software maintenance;query processing	graph-based program comprehension tools;relational database-based tools;graph-based GUPRO approach;ANAUSoftSpec;multi-language software system;stock trading;graph-oriented approach;source code analysis;program understanding		6	9	29		7 Aug 2002			IEEE	IEEE Conferences
Data mining source code to facilitate program comprehension: experiments on clustering data retrieved from C++ programs	data mining source code to facilitate program comprehension experiments on clustering data retrieved from c++ programs	10.1109/WPC.2004.1311063	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311063	Y. Kanellopoulos; C. Tjortjis	Department of Computation, UMIST (University of Manchester Institute of Science and Technology), Manchester, UK; Department of Computation, UMIST (University of Manchester Institute of Science and Technology), Manchester, UK	Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.	12 jul. 2004	2004			214	223	This paper presents ongoing work on using data mining to discover knowledge about software systems thus facilitating program comprehension. We discuss how this work fits in the context of tool supported maintenance and comprehension and report on applying a new methodology on C++ programs. The overall framework can provide practical insights and guide the maintainer through the specifics of systems, assuming little familiarity with these. The contribution of this work is two-fold: it provides a model and associated method to extract data from C++ source code which is subsequently to be mined, and evaluates a proposed framework for clustering such data to obtain useful knowledge. The methodology is evaluated on three open source applications, results are assessed and conclusions are presented. This paper concludes with directions for future work.	1092-8138	0-7695-2149-5			Data mining;Information retrieval;Software maintenance;Software systems;Object oriented modeling;Application software;Data models;Documentation;Character recognition;Computer languages	data mining;C++ language;reverse engineering;software maintenance;public domain software	data mining;program comprehension;data clustering;C++ programs;tool supported maintenance;data extraction;C++ source code;open source applications		6		20		12 jul. 2004			IEEE	IEEE Conferences
Scalable interfaces to support program comprehension	scalable interfaces to support program comprehension	10.1109/WPC.1996.501127	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501127	W. Citrin; C. Santiago; B. Zorn	Department of Eloectrical and Computer Engineering, University of Colorado, Boulder, CO, USA; Department of Computer Science, University of Colorado, Boulder, CO, USA; NA	WPC '96. 4th Workshop on Program Comprehension	6 Aug 2002	1996			123	132	Studies of how programmers understand code suggest that programmers approach the understanding task in both bottom-up and top-town ways, depending on the context. We present a tool, VIPR, that provides a unified visual representation of both high-level and low-level constructs and a smooth transition between the two levels through smoothly animated zooming and focus and context ('fisheyeing') techniques. VlPR is currently being used to visualize Tcl programs, but the technique is generally applicable to programs written in any imperative programming language.	1092-8138	0-8186-7283-8			Programming profession;Visualization;Animation;Microstructure;Computer languages;Programming environments;User interfaces;Computer science	reverse engineering;program diagnostics;software tools;visual programming;data visualisation;graphical user interfaces	scalable interfaces;program comprehension;programmers;program understanding;bottom-up;top-town;VIPR;software tool;visual representation;zooming;animation;fisheye;program visualization;Tcl programs;imperative programming language;programming environment;graphical user interface		5	2	17		6 Aug 2002			IEEE	IEEE Conferences
Assessing the contribution of the individual alpha frequency (IAF) in an EEG-based study of program comprehension	assessing the contribution of the individual alpha frequency (iaf) in an eegbased study of program comprehension	10.1109/EMBC.2016.7591752	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7591752	I. Crk; T. Kluthe	Department of Computer Science, Southern Illinois University Edwardsville, Edwardsville, IL, USA; Department of Computer Science, Southern Illinois University Edwardsville, Edwardsville, IL, USA	2016 38th Annual International Conference of the IEEE Engineering in Medicine and Biology Society (EMBC)	18 Oct 2016	2016			4601	4604	Empirical studies of programming language learnability and usability have thus far depended on indirect measures of human cognitive performance, attempting to capture what is at its essence a purely cognitive exercise through various indicators of comprehension, such as the time spent working out the meaning of code and producing acceptable solutions. We present evidence of the relative contribution of experience and the individual alpha frequency (IAF) to achieving correct performance during program comprehension tasks, specifically that more experience and higher IAF are both associated with an increased likelihood of correct task performance, with experience playing the greater part.	1558-4615	978-1-4577-0220-4			Electroencephalography;Atmospheric measurements;Particle measurements;Timing;Programming;Frequency conversion	cognition;electroencephalography;human computer interaction	individual alpha frequency;EEG-based study;program comprehension tasks;programming language learnability;programming language usability;human cognitive performance;empirical study;human-computer interaction	Alpha Rhythm;Comprehension;Electroencephalography;Humans;Logistic Models;Reproducibility of Results;Task Performance and Analysis;Time Factors	5		22		18 Oct 2016			IEEE	IEEE Conferences
Using run-time data for program comprehension	using runtime data for program comprehension	10.1109/WPC.2003.1199208	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199208	T. Gschwind; J. Oberleitner; M. Pinzger	Distributed Systems Group, Technische Universität Wien, Vienna, Austria; Distributed Systems Group, Technische Universität Wien, Vienna, Austria; Distributed Systems Group, Technische Universität Wien, Vienna, Austria	11th IEEE International Workshop on Program Comprehension, 2003.	21 May 2003	2003			245	250	Traditional approaches for program comprehension use static program analysis or dynamic program analysis in the form of execution traces. Our approach, however, makes use of runtime-data such as parameter and object values. Compared to traditional program comprehension techniques, this approach enables fundamentally new ways of program analysis which we have not seen so far. Reflection analysis which allows engineers to understand programs making use of reflective (dynamic) method invocations is one such analysis. Another is object tracing which allows engineers to trace and track the use of a given instance of a class within the program to be understood. In this paper we present these techniques along with a case study to which we have applied them.	1092-8138	0-7695-1883-4			Runtime;Application software;Performance analysis;Collaborative software;Data analysis;Instruments;Algorithm design and analysis;Information analysis;Europe;Reflection	reverse engineering;program diagnostics	run-time data;program comprehension;static program analysis;dynamic program analysis;reflection analysis;programs understanding;object tracing		5	3	16		21 May 2003			IEEE	IEEE Conferences
Criteria for program comprehension derived from software complexity metrics	criteria for program comprehension derived from software complexity metrics	10.1109/WPC.1993.263911	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263911	H. Zuse	Technische Universitat Berlin, Berlin, Germany	[1993] IEEE Second Workshop on Program Comprehension	6 Aug 2002	1993			8	16	Program comprehension is close related to program complexity. In order to analyze program complexity much effort has been spent to measure the complexity of programs. For this reason hundreds of software complexity measures have been proposed. Criteria/conditions for program comprehension from software complexity measures are derived. It is also shown that using measurement theoretic numerical conditions from software complexity measures can be translated back to empirical conditions. That means the term comprehension can be described by empirical axioms. This approach makes it easier to talk about the term program comprehension.<>	1092-8138	0-8186-4042-1			Software measurement;Humans;Software design;Internet;Computer architecture;Programming profession	software engineering;software metrics	program comprehension;software complexity metrics;program complexity;measurement theoretic numerical conditions		5		18		6 Aug 2002			IEEE	IEEE Conferences
From system comprehension to program comprehension	from system comprehension to program comprehension	10.1109/CMPSAC.2002.1045039	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1045039	C. Tjortjis; N. Gold; P. Layzell; K. Bennett	Department of Computation, UMIST (University of Manchester Institute of Science and Technology), UK; Department of Computation, UMIST (University of Manchester Institute of Science and Technology), UK; Department of Computation, UMIST (University of Manchester Institute of Science and Technology), UK; Department of Computer Science, University of Durham, UK	Proceedings 26th Annual International Computer Software and Applications	10 Dec 2002	2002			427	432	Program and system comprehension are vital parts of the software maintenance process. We discuss the need for both perspectives and describe two methods that may be integrated to provide a smooth transition in understanding from the system level to the program level. Results from a qualitative survey of expert industrial software maintainers, their information needs and requirements when comprehending software are initially presented. We then review existing software tools which facilitate system level and program comprehension. Two successful methods from the fields of data mining and concept assignment are discussed, each addressing some of these requirements. We also describe how these methods can be coupled to produce a broader software comprehension method which partly satisfies all the requirements. Future directions including the closer integration of the techniques are also identified.	0730-3157	0-7695-1727-7			Software maintenance;Software quality;Software tools;Computer industry;Acceleration;Gold;Computer science;Data mining;Costs;Guidelines	software maintenance;software tools;data mining	system comprehension;program comprehension;software maintenance;software tools;data mining;concept assignment		5		28		10 Dec 2002			IEEE	IEEE Conferences
Supporting program comprehension with program summarization	supporting program comprehension with program summarization	10.1109/ICIS.2014.6912159	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6912159	Y. Liu; X. Sun; X. Liu; Y. Li	School of Information Engineering, Yangzhou University, Yangzhou, China; School of Information Engineering, Yangzhou University, Yangzhou, China; School of Information Engineering, Yangzhou University, Yangzhou, China; School of Information Engineering, Yangzhou University, Yangzhou, China	2014 IEEE/ACIS 13th International Conference on Computer and Information Science (ICIS)	29 Sep 2014	2014			363	368	A large amount of software maintenance effort is spent on program comprehension. How to accurately and quickly get the functional features in a program becomes a hot issue in program comprehension. Some studies in this area are focused on extracting the topics by analyzing linguistic information in the source code based on the textual mining techniques. However, the extracted topics are usually composed of some standalone words and difficult to understand. In this paper, we attempt to solve this problem based on a novel program summarization technique. First, we propose to use latent semantic indexing and clustering to group source artifacts with similar vocabulary to analyze the composition of each package in the program. Then, some topics composed of a vector of independent words can be extracted based on latent semantic indexing. Finally, we employ Minipar, a nature language parser, to help generate the summaries. The summaries can effectively organize the words from the topics in the form of the predefined sentence based on some rules. With such form of summaries, developers can understand what the features the program has and their corresponding source artifacts.		978-1-4799-4860-4			Pragmatics;Semantics;Large scale integration;Matrix decomposition;Indexing;Software systems	data mining;grammars;indexing;pattern clustering;software maintenance;source code (software);text analysis;vocabulary	program comprehension;software maintenance effort;functional features;topic extraction;linguistic information analysis;source code;textual mining techniques;program summarization technique;latent semantic indexing;program summarization technique;latent semantic clustering;source artifacts;independent word vector extraction;Minipar;language parser		5		20		29 Sep 2014			IEEE	IEEE Conferences
Maintenance of embedded systems: Supporting program comprehension using dynamic analysis	maintenance of embedded systems supporting program comprehension using dynamic analysis	10.1109/SEES.2012.6225492	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6225492	J. Trümper; S. Voigt; J. Döllner	Hasso-Plattner-Institute, University of Potsdam, Germany; Hasso-Plattner-Institute, University of Potsdam, Germany; Hasso-Plattner-Institute, University of Potsdam, Germany	2012 Second International Workshop on Software Engineering for Embedded Systems (SEES)	28 jun. 2012	2012			58	64	Maintenance of embedded software systems is faced with multiple challenges, including the exploration and analysis of the actual system's runtime behavior. As a fundamental technique, tracing can be used to capture data about runtime behavior as a whole, and represents one of the few methods to observe and record data about embedded systems within their production environments. In this paper we present a software-based, function-boundary tracing approach for embedded software systems. It uses static binary instrumentation, which implies only lightweight memory and performance overheads. To further reduce these overheads, instrumentation can be configured per trace, i.e., activated only for a specified group of functions without having to recompile the system. The technique can be characterized by its robust implementation and its versatile usage. It is complemented by a visualization framework that allows for analysis and exploration of a system's runtime behavior, e.g., to examine thread interaction. To show the technique's applicability, we conclude with a case study that has been applied to an industrial embedded software system.		978-1-4673-1853-2			Instruments;Runtime;Embedded systems;Libraries;Hardware	embedded systems;software maintenance	embedded system maintenance;program comprehension support;dynamic analysis;embedded software systems;fundamental technique;production environments;static binary instrumentation;lightweight memory		4		36		28 jun. 2012			IEEE	IEEE Conferences
Program comprehension for the purpose of testing	program comprehension for the purpose of testing	10.1109/WPC.2004.1311058	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311058	H. M. Sneed	ANECON GmbH, Vienna, Austria	Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.	12 jul. 2004	2004			162	171	In this paper, program comprehension techniques are examined within the context of testing. First, the tasks of a tester are identified, then the information requirements of a tester to fulfill these tasks. Comprehension is viewed as a knowledge acquisition process. The knowledge needed depends on the level at which one is testing. For system testing, other knowledge is required than for unit and integration testing. In light of the scope of testing, the paper concludes that it is the tester who needs the broadest knowledge about a software system. Having established the information requirements of testing, a set of tools are presented which help to satisfy these requirements and their practical application discussed.	1092-8138	0-7695-2149-5			Software testing;System testing;Costs;Databases;Software systems;Application software;Documentation;Programming profession;Knowledge acquisition;Software tools	program testing;formal specification;knowledge acquisition	program comprehension;knowledge acquisition;system testing;information requirements;integration testing;software system;software comprehension;testing requirements		4		21		12 jul. 2004			IEEE	IEEE Conferences
Effort estimation for program comprehension	effort estimation for program comprehension	10.1109/WPC.1996.501123	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501123	P. Fiore; F. Lanubile; G. Visaggio	Basica spa, Bari, Italy; Italy Dipartimento di Informatica Via Orabona, University of Bari, Bari, Italy; Italy Dipartimento di Informatica Via Orabona, University of Bari, Bari, Italy	WPC '96. 4th Workshop on Program Comprehension	6 Aug 2002	1996			78	87	The study presents an experience of deriving an econometric model for software comprehension; this process is necessary for the renovation of existing software systems. The model uses data on the process and products. The aim of the econometric model is to minimize the risks when forecasting the budget and time needed to carry out the project. After having obtained the basic model, the correction factors which could reduce the risk or error of the forecast are considered. In particular, one factor, the suitability of the tool for the processes, requires such marked correction that the basic model is divided into two, one for each type of process (automatic or semiautomatic). All the models have the code lines of the existing program as independent variables; the model for semiautomatic processes uses the number of modules to be extracted as a regulator of the risk of forecasting error.	1092-8138	0-8186-7283-8			Predictive models;Economic forecasting;Econometrics;Reverse engineering;Error correction;Electronic mail;Software systems;Regulators;Investments;Humans	reverse engineering;software reusability;economic cybernetics;software management;project management	effort estimation;program comprehension;econometric model;software comprehension;software systems renovation;correction factors;marked correction;code lines;independent variables;semiautomatic processes;forecasting error risk		3		21		6 Aug 2002			IEEE	IEEE Conferences
PFN: A novel program feature network for program comprehension	pfn a novel program feature network for program comprehension	10.1109/ICIS.2014.6912158	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6912158	X. Liu; X. Sun; B. Li; J. Zhu	School of Information Engineering, Yangzhou University, Yangzhou, China; School of Information Engineering, Yangzhou University, Yangzhou, China; School of Information Engineering, Yangzhou University, Yangzhou, China; School of Information Engineering, Yangzhou University, Yangzhou, China	2014 IEEE/ACIS 13th International Conference on Computer and Information Science (ICIS)	29 Sep 2014	2014			349	354	Program comprehension is one of the most frequently performed activities during software maintenance and evolution. In order to facilitate program comprehension, a variety of graphical models have been proposed in software engineering community to construct relationships between program elements. These graphical models are mostly used for understanding the system based on structural syntax dependencies between program elements. However, these graphical models fail to extract the functional or semantic features of the system. Thus, developers still cannot effectively identify the functional part in source code fit for their needs. This paper tries to fill this gap, and proposes a novel representation, program feature network (PFN), to identify the semantic features of the program at class level. PFN is generated based on the relational topic model, a hierarchical probabilistic model of networks. Based on PFN, the semantic features and the links between pairs of two classes in the program can be clearly shown. In addition, PFN can predict the possible links between the newly change request in existing program feature network rather than reconstructing the representation from the start.		978-1-4799-4860-4			Object oriented modeling;Semantics;Graphical models;Syntactics;Graphics;Software systems	network theory (graphs);probability;program testing;software maintenance	software evolution;hierarchical probabilistic model;PFN;relational topic model;class level;program semantic features;program elements;software engineering community;software maintenance;program comprehension;program feature network		3		23		29 Sep 2014			IEEE	IEEE Conferences
Program comprehension through multiple simultaneous views: a session with VinEd	program comprehension through multiple simultaneous views a session with vined	10.1109/WPC.2000.852484	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852484	J. Sajaniemi	Department of Computer Science, University of Joensuu, Joensuu, Finland	Proceedings IWPC 2000. 8th International Workshop on Program Comprehension	6 Aug 2002	2000			99	108	Program comprehension is a hard cognitive task that can be promoted by the use of views, i.e., automatically created concrete representations of a program revealing different aspects of its structure and behavior. VinEd is a view-based editor that allows users to add their own views to the system. The paper analyzes the VinEd approach by presenting a scenario of a session where VinEd is used in a comprehension task. The scenario is analyzed from a cognitive point of view. The VinEd approach is also evaluated using two requirement lists proposed for software exploration tools.	1092-8138	0-7695-0656-9			Programming profession;Concrete;Cognitive science;Transformers;Computer languages;Computer science;Software maintenance;Application software;Navigation;Writing	reverse engineering;configuration management;cognitive systems;text editing	program comprehension;multiple simultaneous views;VinEd;hard cognitive task;automatically created concrete representations;view-based editor;comprehension task;cognitive viewpoint;requirement lists;software exploration tools		3		21		6 Aug 2002			IEEE	IEEE Conferences
An ontology toolkit for problem domain concept location in program comprehension	an ontology toolkit for problem domain concept location in program comprehension	10.1109/ICSE.2013.6606731	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6606731	N. R. Carvalho	Department of Informatics, University of Minho, Braga, Portugal	2013 35th International Conference on Software Engineering (ICSE)	26 Sep 2013	2013			1415	1418	Programmers are able to understand source code because they are able to relate program elements (e.g. modules, objects, or functions), with the real world concepts these elements are addressing. The main goal of this work is to enhance current program comprehension by systematically creating bidirectional mappings between domain concepts and source code. To achieve this, semantic bridges are required between natural language terms used in the problem domain and program elements written using formal programming languages. These bridges are created by an inference engine over a multi-ontology environment, including an ontological representation of the program, the problem domain, and the real world effects program execution produces. These ontologies are populated with data collected from both domains, and enriched using available Natural Language Processing and Information Retrieval techniques.	1558-1225	978-1-4673-3076-3			Ontologies;Conferences;Engines;Software maintenance;Natural languages;Data mining	formal languages;inference mechanisms;information retrieval;natural language processing;ontologies (artificial intelligence);programming languages;reverse engineering	ontology toolkit;problem domain concept location;program comprehension;source code;bidirectional mapping;semantic bridges;natural language terms;program elements;formal programming languages;inference engine;multiontology environment;ontological representation;program execution;natural language processing;information retrieval techniques		3		27		26 Sep 2013			IEEE	IEEE Conferences
Conceptual interpretation of SQL execution traces for program comprehension	conceptual interpretation of sql execution traces for program comprehension	10.1109/PCODA.2015.7067179	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7067179	N. Noughi; A. Cleve	PReCISE Research Center, University of Namur, Belgium; PReCISE Research Center, University of Namur, Belgium	2015 IEEE 6th International Workshop on Program Comprehension through Dynamic Analysis (PCODA)	26 mar. 2015	2015			19	24	Modern data-intensive software systems manipulate an increasing amount of heterogeneous data usually stored in a database. Maintaining such systems became a crucial and complex task, which is especially true due to the lack of sufficient documentation. In this context, program comprehension became a primary and an important step in this task. Unfortunately, the highly dynamic nature of interactions between a system and its database makes it hard to analyze these interactions with static analysis techniques. To this end, we propose a novel approach that combines dynamic analysis techniques and visualization to ease understanding data-intensive systems, by focusing on their database manipulation behavior. The approach consists of defining the conceptual interpretation of SQL execution traces in terms of a domain-specific, platform-independent model.		978-1-4673-6917-6			Visualization;Databases;Cities and towns;Natural languages;Context;Software systems;Abstracts	data visualisation;distributed databases;program diagnostics;SQL	conceptual interpretation;SQL execution traces;program comprehension;data-intensive software systems;heterogeneous data;static analysis techniques;dynamic analysis techniques;data visualization;database manipulation behavior;domain-specific model;platform-independent model		3		12		26 mar. 2015			IEEE	IEEE Conferences
Query Technologies and Applications for Program Comprehension (QTAPC 2008)	query technologies and applications for program comprehension (qtapc 2008)	10.1109/ICPC.2008.27	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556146	M. Verbaere; M. W. Godfrey; T. Girba	Semmle Limited, UK; University of Waterloo, Canada; University of Bern, Switzerland	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			285	288	Industrial software systems are large and complex, both in terms of the software entities and their relationships. Consequently, understanding how a software system works requires the ability to pose queries over the design-level entities of the system. Traditionally, this task has been supported by simple tools (e.g., grep) combined with the programmer's intuition and experience. Recently, however, specialized code query technologies have matured to the point where they can be used in industrial situations, providing more intelligent, timely, and efficient responses to developer queries. This working session aims to explore the state of the art in code query technologies, and discover new ways in which these technologies may be useful in program comprehension. The session brings together researchers and practitioners. We survey existing techniques and applications, trying to understand the strengths and weaknesses of the various approaches, and sketch out new frontiers that hold promise.	1092-8138	978-0-7695-3176-2			Application software;Software engineering;Computer bugs;Software systems;Visualization;Quality assurance;Monitoring;Computer industry;Industrial relations;Software quality	program visualisation;query processing;software quality	program comprehension;industrial software systems;software entities;code query technology		3		32		2 jul. 2008			IEEE	IEEE Conferences
Program comprehension techniques improve software inspections: a case study	program comprehension techniques improve software inspections a case study	10.1109/WPC.2000.852487	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852487	S. Rifkin; L. Deimel	Master Systems, Inc., McLean, VA, USA; Pittsburgh, PA, USA	Proceedings IWPC 2000. 8th International Workshop on Program Comprehension	6 Aug 2002	2000			131	138	Software inspections are widely regarded as a cost-effective mechanism for removing defects in software, though performing them does not always reduce the number of customer-discovered defects. We present a case study in which an attempt was made to reduce such defects through inspection training that introduced program comprehension ideas. The training was designed to address the problem of understanding the artifact being reviewed, as well as other perceived deficiencies of the inspection process itself. Measures, both formal and informal, suggest that explicit training in program understanding may improve inspection effectiveness.	1092-8138	0-7695-0656-9			Inspection;Computer aided software engineering;Software performance;Costs;Programming;Software maintenance;Software measurement;Software testing;Data privacy	reverse engineering;inspection;program debugging;program diagnostics;training;computer science education	program comprehension techniques;software inspections;case study;cost-effective mechanism;software defect removal;customer-discovered defects;training;perceived deficiencies;formal measures;informal measures;program understanding;effectiveness;formal technical reviews;peer reviews		3		14		6 Aug 2002			IEEE	IEEE Conferences
Program comprehension experiences with GXL; comprehension for comprehension	program comprehension experiences with gxl; comprehension for comprehension	10.1109/WPC.2002.1021336	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021336	C. Knight; M. Munro	Department of Computer Science, Research Institute in Software Evolution, University of Durham, Durham, UK; Department of Computer Science, Research Institute in Software Evolution, University of Durham, Durham, UK	Proceedings 10th International Workshop on Program Comprehension	10 Dec 2002	2002			147	156	Tools are vital to support the various activities that form the many tasks that are part of the program comprehension process. In order for these tools to be used and useful, it is necessary that they support the activities of the user. This support must complement the work methods and activities of the user and not hinder them. Whilst features of good tools have been identified, tool builders do not always adhere to them. It is important to consider whether needs have changed, and if those desirable properties need augmenting or revising. From experience of maintaining and enhancing an existing program comprehension tool for the purposes of participating in a re-engineering activity, many lessons on tool support have been learned. Various program comprehension strategies are introduced in this paper. The use of GXL (Graph eXchange Language) and involvement in the SORTIE project are presented with reference to the tool being adapted and used. Details of the changes made are given to illustrate the support desired. These all feed into the final section of the paper that discusses the sort of support that tools should provide, current tool deficiencies and some of the ways in which these could be addressed.	1092-8138	0-7695-1495-2			Software tools;Software maintenance;Visualization;Computer science;Programming profession;Feeds;Conferences	reverse engineering;software tools;visual languages;electronic data interchange;program visualisation	program comprehension;GXL;Graph Exchange Language;user work methods;user activities;reengineering activity;SORTIE project;tool deficiencies		2		22		10 Dec 2002			IEEE	IEEE Conferences
MOOSE - a task-driven program comprehension environment	moose a taskdriven program comprehension environment	10.1109/CMPSAC.2001.960601	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=960601	J. Rilling; A. Seffah	Department of Computer Science, Concordia University, Montreal, QUE, Canada; Department of Computer Science, Concordia University, Montreal, QUE, Canada	25th Annual International Computer Software and Applications Conference. COMPSAC 2001	7 Aug 2002	2001			77	84	Many tools have been developed to derive abstract representations from existing source code. Yet, most of these tools provide only little help in providing an encompassing picture of the system under examination. Graphical visualization techniques derived from reverse engineered source code have long been recognized for their impact on improving the comprehensibility of software systems and their source code. In this paper, we present a task-oriented approach to software comprehension by introducing our MOOSE (Montreal Object-Oriented Slicing Environment) environment that provides a task-driven wizard approach that supports a cognitive comprehension model combined with reverse engineering techniques, algorithmic and visualization support. We close our discussion with a brief overview of typical software comprehension tasks and how the MOOSE environment will benefit users during these comprehension tasks.	0730-3157	0-7695-1372-7			Reverse engineering;Object oriented modeling;Software maintenance;Software systems;Computer science;Design methodology;Data visualization;Pattern matching;Pattern recognition;Software quality	reverse engineering;program slicing;program visualisation;programming environments;object-oriented methods	MOOSE;task-driven program comprehension environment;abstract representations;source code;graphical visualization;reverse engineered source code;task-oriented approach;Montreal Object-Oriented Slicing Environment;task-driven wizard;cognitive comprehension model;reverse engineering techniques		2		31		7 Aug 2002			IEEE	IEEE Conferences
Program comprehension support for knowledge-based parallelization	program comprehension support for knowledgebased parallelization	10.1109/EMPDP.1996.500619	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=500619	S. Andel; B. di Martino; J. Hulman; H. P. Zima	University of Technology, Vienna, Vienna, Austria; University of Technology, Vienna, Vienna, Austria; University of Technology, Vienna, Vienna, Austria; University of Technology, Vienna, Vienna, Austria	Proceedings of 4th Euromicro Workshop on Parallel and Distributed Processing	6 Aug 2002	1996			455	461	Current compilation systems for distributed memory computers have to integrate new techniques to support the highly complex task of producing efficient programs for parallel systems. Two techniques, program comprehension and expert systems, although developed outside the scope of parallelization domain, are extremely useful to improve the quality of the parallel code generated and to make the parallelization process more convenient and automatic. We describe a parallelization environment consisting of three main components: Vienna Fortran Compilation System (VFCS), a tool for recognition of Parallelizable Algorithmic Patterns (PAP Recognizer), and a knowledge based parallelization support tool (Expert Adviser). After these main components are introduced, the paper focuses on integration issues of PAP Recognizer and Expert Adviser within the framework of VFCS. We outline the salient features of a new parallelization environment. The design of the XPA knowledge base for recognized program concepts (patterns) as presented, and the methodology of knowledge acquisition for program patterns is outlined.		0-8186-7376-1			Pattern recognition;Performance analysis;Program processors;Pattern analysis;Message passing;Time measurement;Computer science;Concurrent computing;Distributed computing;Knowledge acquisition	parallel programming;distributed memory systems;programming environments;computer aided software engineering;expert systems;Vienna development method;knowledge acquisition	program comprehension support;knowledge based parallelization;compilation systems;distributed memory computers;expert systems;parallel code quality;parallelization environment;Vienna Fortran Compilation System;Parallelizable Algorithmic Patterns;PAP Recognizer;knowledge based parallelization support tool;Expert Adviser;XPA knowledge base;knowledge acquisition;program patterns		2		20		6 Aug 2002			IEEE	IEEE Conferences
Source animation as a means of program comprehension for object-oriented systems	source animation as a means of program comprehension for objectoriented systems	10.1109/WPC.2000.852492	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852492	H. M. Sneed	Arget, Germany	Proceedings IWPC 2000. 8th International Workshop on Program Comprehension	6 Aug 2002	2000			179	187	Object oriented systems are particularly difficult to comprehend because of the distribution of functionality and polymorphism which limits the effectiveness of conventional static analysis methods. The paper proposes a dynamic analysis approach using animation to simulate the use cases in a financial application system. The objective is to offer maintenance programmers a means of familiarizing themselves with complex C++ code while at the same time validating the correctness of the code. For this purpose, control flow slicing and concept lattices are used.	1092-8138	0-7695-0656-9			Animation;Dynamic programming;Object oriented modeling;Lattices;Runtime;Object oriented programming;Analytical models;Programming profession;Delay;Assembly	object-oriented programming;reverse engineering;program visualisation;computer animation;financial data processing;software maintenance;C++ language;program verification	source animation;program comprehension;object oriented systems;polymorphism;conventional static analysis methods;dynamic analysis approach;use case simulation;financial application system;maintenance programmers;complex C++ code;correctness validation;control flow slicing;concept lattices		2		24		6 Aug 2002			IEEE	IEEE Conferences
An exploratory study of code and document interactions during task-directed program comprehension	an exploratory study of code and document interactions during taskdirected program comprehension	10.1109/ASWEC.2004.1290475	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1290475	P. Parkin	School of Information Systems, Technology and Management, University of New South Wales, Australia	2004 Australian Software Engineering Conference. Proceedings.	27 Sep 2004	2004			221	230	This exploratory study investigates the program comprehension strategies employed during enhancement and corrective maintenance from the perspective of the programmer activities of examining both program and task documentation and analysing and potentially modifying program code. Twenty-nine experienced C programmers independently undertook one of two maintenance tasks on the same C program and their various activities were recorded. Analysis and comparisons of activity durations were conducted at various points during the maintenance task as well as at the level of the complete task. The results show that contrary to previous research in this area, programmers implementing a correction utilized program documentation and header information significantly more than programmers undertaking an enhancement. Within their projects, this comparative additional usage occurred predominantly in the second quarter of the project suggesting more pronounced domain modeling than enhancers. Enhancers themselves made much more specific use of task documentation than did corrective programmers, seemingly to map out extensions and adjustments to their program models and, finally, to verify the code modifications made.		0-7695-2089-8			Programming profession;Documentation;Australia;Information analysis;Software maintenance;Management information systems;Technology management;Navigation;Educational programs;Software engineering	formal verification;reverse engineering;system documentation;software maintenance;C language	task directed program comprehension;program documentation;task documentation;C program;program code verification		2		23		27 Sep 2004			IEEE	IEEE Conferences
Evaluating software maintenance support tools for their support of program comprehension	evaluating software maintenance support tools for their support of program comprehension	10.1109/AERO.1998.682191	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=682191	A. Von Mayrhauser; S. Lang	Computer Science Department, Colorado State University, Fort Collins, CO, USA; Computer Science Department, Colorado State University, Fort Collins, CO, USA	1998 IEEE Aerospace Conference Proceedings (Cat. No.98TH8339)	6 Aug 2002	1998	4		173	187 vol.4	New tools that purport to help programmers understand software during maintenance and evolution are appearing on the market with increasing frequency. Just how good are they at supporting software comprehension is frequently only "demonstrated" by anecdote or hearsay. This paper reports on an analysis infrastructure for formally performing such evaluation, and on an application of the evaluation instrument to an existing tool, Lemma.	1095-323X	0-7803-4311-5			Software maintenance;Programming profession;Computer science;Software tools;Frequency;Performance analysis;Performance evaluation;Application software;Instruments;Cognition	software maintenance;software tools;software performance evaluation	software maintenance support tools;program comprehension;programmers;maintenance;evolution;software comprehension;analysis infrastructure;Lemma		2		23		6 Aug 2002			IEEE	IEEE Conferences
User Perspectives on a Visual Aid to Program Comprehension	user perspectives on a visual aid to program comprehension	10.1109/VISSOF.2005.1684308	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1684308	A. Cox; M. Fisher; J. Muzzerall	Faculty of Computer Science, Dalhousie University, Halifax, NS, Canada; Department of Psychology, Saint Mary's University, Halifax, NS, Canada; Faculty of Computer Science, Dalhousie University, Halifax, NS, Canada	3rd IEEE International Workshop on Visualizing Software for Understanding and Analysis	9 Oct 2006	2005			1	6	In an experiment to investigate the utility of variable dependency diagrams, the unsolicited comments of the participants provides important insights into the characteristics of effective visualisations. The data obtained during the experiment provides support for these insights and suggests that to be effective, visualisations must unify the information they provide with the needs of programmers. As well, programmers require training in the use of specific visualisations since, during maintenance tasks, their need to focus on the task causes them to avoid the distraction of learning new, unfamiliar tools. When maintenance requires source code manipulation, visualisations must be capable of directly linking information to the code, as programmers are often incapable or unwilling to identify relationships between the visualisation and the code.		0-7803-9540-9			Programming profession;Computer science;Psychology;Data visualization;Joining processes;Functional programming;Documentation	program visualisation;software maintenance	program comprehension visual aid;variable dependency diagrams;program visualisation;software maintenance;source code manipulation		2		12		9 Oct 2006			IEEE	IEEE Conferences
IDE-independent program comprehension tools via source file overwriting	ideindependent program comprehension tools via source file overwriting	10.1109/INFORMATICS.2017.8327277	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8327277	M. Sulír; J. Porubän; O. Zoricák	Department of Computers and Informatics, Technical University of Košice, Košice, Slovakia; Department of Computers and Informatics, Technical University of Košice, Košice, Slovakia; Department of Computers and Informatics, Technical University of Košice, Košice, Slovakia	2017 IEEE 14th International Scientific Conference on Informatics	29 mar. 2018	2017			372	376	Traditionally, we have two possibilities to design tools for program comprehension and analysis. The first option is to create a standalone program, independent of any source code editor. This way, the act of source code editing is separated from the act of viewing the code analysis results. The second option is to create a plugin for a specific IDE (integrated development environment) - in this case, a separate version must be created for each IDE. We propose an approach where information about source code elements is written directly into source files as annotations or special comments. Before committing to a version control system, the annotations are removed from the source code to avoid code pollution. We briefly evaluate the approach and delineate its limitations.		978-1-5386-0889-0			Tools;Metadata;Java;Control systems;Measurement;Informatics;Computers	configuration management;programming environments;software tools;source code (software)	IDE-independent program comprehension tools;design tools;standalone program;source code editor;source code editing;code analysis results;integrated development environment;source file overwriting;version control system		1		18		29 mar. 2018			IEEE	IEEE Conferences
Assessing Semantic Frames to Support Program Comprehension Activities	assessing semantic frames to support program comprehension activities	10.1109/ICPC52881.2021.00011	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9462995	A. Marques; G. Viviani; G. C. Murphy	Department of Computer Science, University of British Columbia, Canada; Department of Computer Science, University of British Columbia, Canada; Department of Computer Science, University of British Columbia, Canada	2021 IEEE/ACM 29th International Conference on Program Comprehension (ICPC)	28 jun. 2021	2021			13	24	Software developers often rely on natural language text that appears in software engineering artifacts to access critical information as they build and work on software systems. For example, developers access requirements documents to understand what to build, comments in source code to understand design decisions, answers to questions on Q&A sites to understand APIs, and so on. To aid software developers in accessing and using this natural language information, soft-ware engineering researchers often use techniques from natural language processing. In this paper, we explore whether frame semantics, a general linguistic approach, which has been used on requirements text, can also help address problems that occur when applying lexicon analysis based techniques to text associated with program comprehension activities. We assess the applicability of generic semantic frame parsing for this purpose, and based on the results, we propose SEFrame to tailor semantic frame parsing for program comprehension uses. We evaluate the correctness and robustness of the approach finding that SEFrame is correct in between 73% and 74% of the cases and that it can parse text from a variety of software artifacts used to support program comprehension. We describe how this approach could be used to enhance existing approaches to identify meaning on intention from software engineering texts.	2643-7171	978-1-6654-1403-6	Natural Sciences and Engineering Research Council of Canada; 	Empirical Software Engineering;Software Discussions;Natural Language	Semantics;Linguistics;Tools;Software systems;Reliability engineering;Software;Robustness	application program interfaces;natural language processing;software engineering;text analysis	program comprehension activities;software developers;natural language text;software engineering artifacts;software systems;source code;soft-ware engineering researchers;frame semantics;general linguistic approach;requirements text;lexicon analysis;generic semantic frame parsing;software artifacts;software engineering texts;semantic frames assessment;requirements document developer access;APIs		1		52	IEEE	28 jun. 2021			IEEE	IEEE Conferences
An empirical study on program comprehension task classification of novices	an empirical study on program comprehension task classification of novices	10.1109/IC3e.2015.7403479	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7403479	N. Saroni; S. A. Aljunid; S. M. Shuhidan; A. Shargabi	Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia; Faculty of Computer and Mathematical Sciences, Universiti Teknologi MARA, Shah Alam, Malaysia	2015 IEEE Conference on e-Learning, e-Management and e-Services (IC3e)	11 Feb 2016	2015			15	20	Program comprehension is difficult to novices. Tasks have substantial effect on program comprehension. This work is part of larger study aims at identifying tasks that can improve novices' program comprehension. In one of our previous studies, fourteen tasks were identified to be feasibly effective in improving novices' program comprehension. These tasks were also classified into cognitive categories using revised Bloom taxonomy. This particular study is to validate the classification of these tasks. An online survey was conducted to a number of programming instructors as well as developers. The respondents were asked to place each of the fourteen identified tasks into one of the six cognitive categories of revised Bloom taxonomy. The findings showed that most of the respondents agreed with our classification. In future, we plan to replicate this study with more respondents and also to conduct controlled experiments to investigate the effect of the classified tasks on novices.		978-1-4673-9437-6		program comprehensoin;novices;revised Bloom Taxonomy;task	Taxonomy;Programming profession;Debugging;Conferences;Electronic learning;Documentation	educational courses;programming	program comprehension task classification;novices;cognitive categories;revised Bloom taxonomy;programming instructors;programming course		1		26		11 Feb 2016			IEEE	IEEE Conferences
Relational views for program comprehension	relational views for program comprehension	10.1109/WPC.1994.341262	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341262	T. Jones; W. Allison; D. Carrington	Software Verification Research Centre, Department of Computer Science, University of Queensland, QLD, Australia; Software Verification Research Centre, Department of Computer Science, University of Queensland, QLD, Australia; Software Verification Research Centre, Department of Computer Science, University of Queensland, QLD, Australia	Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94	6 Aug 2002	1994			136	144	In this paper we describe UQ*, an integrated development environment that is currently under construction at the University of Queensland. Its architecture supports the definition of multiple documents and multiple document types, and allows the relationships that are implicit within the set of documents to be represented explicitly. We identify two techniques that aid program comprehension which require knowledge about the relationships that exist in and between documents. They are program dependency analysis and literate programming. Two simple examples are presented to illustrate the flexible definition of relations within such an architecture and the use of relations for presentation of and navigation through, various views of a program and its related documentation. These examples highlight the application of such an approach to program dependency analysis and literate programming.<>	1092-8138	0-8186-5647-6			Documentation;Testing;Programming profession;Debugging;Computer science;Computer architecture;Navigation;Application software;Software maintenance;Software systems	reverse engineering;programming environments	UQ*;integrated development environment;program comprehension;relational views;program dependency analysis;literate programming		1		35		6 Aug 2002			IEEE	IEEE Conferences
Integrating Runtime Values with Source Code to Facilitate Program Comprehension	integrating runtime values with source code to facilitate program comprehension	10.1109/ICSME.2018.00093	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530096	M. Sulír	Department of Computers and Informatics, Technical University of Košice, Košice, Slovakia	2018 IEEE International Conference on Software Maintenance and Evolution (ICSME)	11 nov. 2018	2018			743	748	An inherently abstract nature of source code makes programs difficult to understand. In our research, we designed three techniques utilizing concrete values of variables and other expressions during program execution. RuntimeSearch is a debugger extension searching for a given string in all expressions at runtime. DynamiDoc generates documentation sentences containing examples of arguments, return values and state changes. RuntimeSamp augments source code lines in the IDE (integrated development environment) with sample variable values. In this post-doctoral article, we briefly describe these three approaches and related motivational studies, surveys and evaluations. We also reflect on the PhD study, providing advice for current students. Finally, short-term and long-term future work is described.	2576-3148	978-1-5386-7870-1		integrated development environment;documentation;debugging;dynamic analysis;variables	Documentation;Tools;Runtime;Debugging;Task analysis;Graphical user interfaces;Collaboration	Java;program compilers;program debugging;program diagnostics;programming environments;reverse engineering;software maintenance;software tools	documentation sentences;IDE;integrated development environment;program execution;debugger extension;program comprehension;string;runtimesamp augments source code lines;runtimesearch;DynamiDoc;abstract nature		1		35		11 nov. 2018			IEEE	IEEE Conferences
Metrics to identify where object-oriented program comprehension benefits from the runtime structure	metrics to identify where objectoriented program comprehension benefits from the runtime structure	10.1109/WETSoM.2013.6619335	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6619335	M. Abi-Antoun; R. Vanciu; N. Ammar	Department of Computer Science, Wayne State University, USA; Department of Computer Science, Wayne State University, USA; Department of Computer Science, Wayne State University, USA	2013 4th International Workshop on Emerging Trends in Software Metrics (WETSoM)	3 Oct 2013	2013			42	48	To evolve object-oriented code, developers often need to understand both the code structure in terms of classes and packages, as well as the runtime structure in terms of abstractions of objects. Recent empirical studies have shown that for some code modifications tasks, developers do benefit from having access to information about the runtime structure. However, there is no good sense of when object-oriented program comprehension clearly depends on information about the runtime structure. We propose using metrics to identify cases in object-oriented program comprehension that benefit from information about the runtime structure. The metrics relate properties observed on a statically extracted hierarchical object graph to the type structures declared in the code and highlight key differences between the runtime structure and the code structure.	2327-0969	978-1-4673-6331-0		object-oriented runtime structure;metrics	Runtime;Measurement;Abstracts;Context;Concrete;Object recognition;Bismuth	object-oriented programming;software maintenance;software metrics	object-oriented program comprehension;runtime structure;object-oriented code;metrics;statically extracted hierarchical object graph;code structure;software maintenance		1		22		3 Oct 2013			IEEE	IEEE Conferences
A contribution to program comprehension by program analysis: application to numerical programs	a contribution to program comprehension by program analysis application to numerical programs	10.1109/ASE.1997.632833	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=632833	Y. Ait-Ameur	ENSMA-LISI, France	Proceedings 12th IEEE International Conference Automated Software Engineering	6 Aug 2002	1997			134	141	This paper deals with non-functional aspects of software. It presents an approach towards the integration of methods in order to handle properties of numerical programs. We develop a program analysis technique which allows us to formalise, evaluate and check non-functional properties of programs. These property evaluations are used in two main areas. The first one is related to program design to choose data representations and to perform program transformations. The second is related to reverse engineering, and particularly to software reuse and maintenance. As example, a functional language with numerical type only is considered, and the accuracy of the numerical computations is the considered non-functional property.		0-8186-7961-1			Application software;Software maintenance;Program processors;Operating systems;Reverse engineering;Commutation;Equations;Data security;Data structures	reverse engineering;program diagnostics;numerical analysis;software maintenance;software reusability;functional languages;data structures	program comprehension;program analysis;numerical programs;nonfunctional property evaluation;program design;data representations;program transformations;reverse engineering;software reuse;software maintenance;functional language;numerical type;numerical computational accuracy		1		13		6 Aug 2002			IEEE	IEEE Conferences
Is Algorithm Comprehension Different from Program Comprehension?	is algorithm comprehension different from program comprehension	10.1109/ICPC52881.2021.00053	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463024	P. Kather; J. Vahrenhold	Department of Computer Science, Westfälische Wilhelms-Universität Münster; Department of Computer Science, Westfälische Wilhelms-Universität Münster	2021 IEEE/ACM 29th International Conference on Program Comprehension (ICPC)	28 jun. 2021	2021			455	466	At the beginning of their undergraduate studies, computer science students are exposed to introductory programming, discrete mathematics, and algorithms. A large body of literature has studied how such students comprehend programs. Much less attention has been paid to understanding how students comprehend algorithms, i.e., representations of problem-solving processes accompanied by proofs of their properties. To investigate whether algorithm comprehension is under-researched or whether we can simply transfer results from program comprehension (and, possibly, proof comprehension) to the domain of algorithms, we conducted a larger study following a Grounded-Theory approach. For this study, we worked with twelve participants with varying degrees of prior knowledge regarding algorithms, from technically no prior knowledge to advanced graduate students pursuing a doctoral degree in algorithms-related fields. In this paper, we report on the analysis and interpretation of interview data focused on exploring potential differences between program comprehension and algorithm comprehension. Our analyses and interpretations revealed both similarities and differences between program comprehension and algorithm comprehension: Unsurprisingly, we found that aspects known from program comprehension, e.g., using top-down approaches or utilizing prior knowledge of programming plans, can be found in algorithm comprehension as well. However, some of these aspects manifest themselves in notably different details or are influenced by, e.g., the wording of a proof. Most interesting, we found that novice and advanced students alike benefit from switching between reading the representation of the program-solving process and the accompanying proofs. We present qualitative results illustrating both similarities and differences between program comprehension and algorithm comprehensions and offer first explanations for these.	2643-7171	978-1-6654-1403-6		Algorithm Comprehension;Grounded Theory	Switches;Medical services;Programming;Mathematics;Problem-solving;Interviews	computer science education;programming	algorithm comprehension;program comprehension;proof comprehension;algorithms-related fields;program-solving process;grounded-theory approach;computer science students		1		60	IEEE	28 jun. 2021			IEEE	IEEE Conferences
A Concern Visualization Approach for Improving MATLAB and Octave Program Comprehension	a concern visualization approach for improving matlab and octave program comprehension	10.1109/SBES.2015.19	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7328017	I. De M. Lessa; G. De F. Carneiro; M. P. Monteiro; F. B. e. Abreu	Universidade Salvador, Salvador, BA, BR; Universidade Salvador, Salvador, BA, BR; NOVA LINCS, Universidade Nova de Lisboa (UNL), Lisbon, Portugal; ISTAR-IUL, Instituto Universitário de Lisboa (ISCTE-IUL), Lisbon, Portugal	2015 29th Brazilian Symposium on Software Engineering	12 nov. 2015	2015			130	139	The literature has pointed out the need for focusing efforts to better support comprehension of MATLAB and Octave programs. Despite being largely used in the industry and academia in the engineering domain, programs and routines written in those languages still require efforts to propose approaches and tools for its understanding. Considering the use of crosscutting concerns (CCCs) to support the comprehension of object-oriented programs, there is room of its use in the context of MATLAB and Octave programs. The literature has purpose and examples in this direction. Considering this scenario, we propose the use of visualization enriched with CCCs representation to support the comprehension of such programs. This paper discusses the use of a multiple view interactive environment called OctMiner in the context of two case studies to characterize how collected information relating to crosscutting concerns can foster the comprehension of MATLAB and GNU/Octave programs. As a result of the conducted case studies, we propose strategies based on OctMiner and tailored to support different comprehension activities of programs written in MATLAB and Octave.		978-1-4673-9272-3		MATLAB/Octave;software comprehension;crosscutting concerns;software visualization	MATLAB;Visualization;Scattering;Context;XML;Image color analysis	data visualisation;mathematics computing;program diagnostics	concern visualization approach;MATLAB;Octave program comprehension;engineering domain;crosscutting concerns;CCC;OctMiner;multiple view interactive environment;GNU-Octave programs		1		19		12 nov. 2015			IEEE	IEEE Conferences
Facilitating program comprehension via generic components for state machines	facilitating program comprehension via generic components for state machines	10.1109/WPC.1997.601277	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601277	J. Weidl; R. R. Klosch; G. Trausmuth; H. Gall	Distributed Systems Department, Technical University of of Vienna, Vienna, Austria; Distributed Systems Department, Technical University of of Vienna, Vienna, Austria; Distributed Systems Department, Technical University of of Vienna, Vienna, Austria; Distributed Systems Department, Technical University of of Vienna, Vienna, Austria	Proceedings Fifth International Workshop on Program Comprehension. IWPC'97	6 Aug 2002	1997			118	127	Various applications use state transition mechanisms as a major building block. As an example, finite state machines (FSMs) and their graphical counterpart-state transition diagram-are heavily used e.g. for the specification of various kinds of protocols such as network protocols (e.g. TCP/IP), protocols for infrared data transmission, etc. Many embedded systems, such as telephone switching systems and television control, are directly based on state machines. Introducing generic components for state machines can raise the source code abstraction level from "hard coded" control flow decisions such as "switch/case" and "if" to a more flexible implementation model of control flow. The paper shows that it is possible to use statecharts and their advanced mechanisms from specification to implementation of reactive systems. By explicitly modeling states and state transitions the source code is described at a higher abstraction level and thereby top down program comprehension is facilitated. We define a set of specific design patterns to abstract state machine source code from low level implementation to a more abstract level. Furthermore, we introduce a certain degree of genericity and thus flexibility without major losses in efficiency during the design and implementation of generic components.	1092-8138	0-8186-7993-X			Switches;Protocols;Embedded system;Documentation;Europe;Automata;TCPIP;Data communication;Telephony;TV	reverse engineering;finite state machines;formal specification;real-time systems;visual programming	program comprehension;generic components;state machines;state transition mechanisms;finite state machines;graphical counterpart;state transition diagram;specification;network protocols;television control;embedded systems;telephone switching systems;source code abstraction level;flexible implementation model;control flow;statecharts;reactive systems;higher abstraction level;top down program comprehension;abstract state machine source code		1		15		6 Aug 2002			IEEE	IEEE Conferences
Applying program comprehension techniques to karel robot programs	applying program comprehension techniques to karel robot programs	10.1109/IMCSIT.2009.5352762	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5352762	N. Oliveira; P. R. Henriques; D. da Cruz; M. J. Varanda Pereira; M. Mernik; T. Kosar; M. Črepinšek	Department of Computer Science, University of Minho, Braga, Portugal; Department of Computer Science, University of Minho, Braga, Portugal; Department of Computer Science, University of Minho, Braga, Portugal; Polytechnic Institute of Bragança, Bragança, Portugal; Faculty of Electrical Engineering and Computer Science, University of Maribor, Maribor, Slovenia; Faculty of Electrical Engineering and Computer Science, University of Maribor, Maribor, Slovenia; Faculty of Electrical Engineering and Computer Science, University of Maribor, Maribor, Slovenia	2009 International Multiconference on Computer Science and Information Technology	11 Dec 2009	2009			699	706	In the context of program understanding, a challenge research topic1 is to learn how techniques and tools for the comprehension of General-Purpose Languages (GPLs) can be used or adjusted to the understanding of Domain-Specific Languages (DSLs). Being DSLs tailored for the description of problems within a specific domain, it becomes easier to improve these tools with specific visualizations (at a higher abstraction level, closer to the problem level) in order to understand the DSLs programs. In this paper, comprehension techniques will be applied to Karel language. This will allow us to explore the creation of problem domain visualizations for this language and to combine both problem and program domains in order to reach a full understanding of Karel programs.	2157-5525	978-1-4244-5314-6			Robots;DSL;Visualization;Computer science;Data mining;Domain specific languages;Digital signal processing;Information technology;Vocabulary;Natural languages	program visualisation;reverse engineering;robot programming	program comprehension techniques;Karel robot programs;program understanding;general-purpose languages;domain-specific languages;Karel language;problem domain visualizations		1		22		11 Dec 2009			IEEE	IEEE Conferences
Program comprehension in generative programming: a history of grand challenges	program comprehension in generative programming a history of grand challenges	10.1109/WPC.2004.1311042	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311042	D. Batory	Department of Computer Science, University of Texas, Austin, Austin, TX, USA	Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.	12 jul. 2004	2004			2	11	The communities of generative programming (GP) and program comprehension (PC) look at similar problems: GP derives a program from a specification, PC derives a specification from a program. A basic difference between the two is GP's use of specific knowledge representations and mental models that are essential for program synthesis. In this paper, the author presents a historical review of the grand challenges, results, and outlook for GP as they pertain to PC.	1092-8138	0-7695-2149-5			History;Conferences	reverse engineering;automatic programming;formal specification;knowledge representation	program comprehension;generative programming;program specification;knowledge representations;mental models;program synthesis		1		22		12 jul. 2004			IEEE	IEEE Conferences
An application of fuzzy reasoning to support automated program comprehension	an application of fuzzy reasoning to support automated program comprehension	10.1109/WPC.1999.777745	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=777745	I. Burnstein; F. Saner	Computer Science Department, Illinois Institute of Technology, Chicago, IL, USA; Computer Science Department, Illinois Institute of Technology, Chicago, IL, USA	Proceedings Seventh International Workshop on Program Comprehension	6 Aug 2002	1999			66	73	We are developing a knowledge based program understanding/fault localization system called BUGDOCTOR. We describe a system knowledge source called the Plan Processor that retrieves a set of program plans from a plan library using indices called signatures. We propose use of a fuzzy reasoning component to support the Plan Processor with the task of ranking the retrieved plans in order of similarity to the target code. The most similar plan can then be used for the complex plan/code matching required for automated program understanding. Our approach to plan processing may eliminate the need for exhaustive plan library searches, and could lead to automated program understanders that scale up for use on large software systems.	1092-8138	0-7695-0180-x			Fuzzy reasoning;Software libraries;Software systems;Software tools;Artificial intelligence;Debugging;Application software;Computer science;Software maintenance;Knowledge engineering	automatic programming;reverse engineering;uncertainty handling;inference mechanisms;fuzzy set theory	fuzzy reasoning;automated program comprehension;knowledge based program understanding;fault localization system;BUGDOCTOR;system knowledge source;Plan Processor;plan library;program plan retrieval;signatures;fuzzy reasoning component;target code;similar plan;complex plan/code matching;automated program understanding;large software systems		1		17		6 Aug 2002			IEEE	IEEE Conferences
Using Discord Conversations as Program Comprehension Aid	using discord conversations as program comprehension aid	10.1145/3524610.3528388	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796229	M. Raglianti; C. Nagy; R. Minelli; M. Lanza	REVEAL @ Software Institute - USI, Lugano, Switzerland; REVEAL @ Software Institute - USI, Lugano, Switzerland; REVEAL @ Software Institute - USI, Lugano, Switzerland; REVEAL @ Software Institute - USI, Lugano, Switzerland	2022 IEEE/ACM 30th International Conference on Program Comprehension (ICPC)	22 jun. 2022	2022			597	601	Modern communication platforms used in software development host daily conversations among developers and users about a wide range of topics pertaining to software systems, such as language features, APIs, code artifacts like classes and methods, design patterns, usage examples, code reviews, bug reporting and fixing. Discord servers are one of these virtual community hubs that have seen a steep rise in popularity, as coordination and aggregation means for communities of developers. Although Discord supports filter-based search functionalities, the sheer volume, velocity, and small granularity of single messages make it hard to find useful results, let alone complete discussions revolving around particular themes. One reason is that the concept of a discussion, which we call a conversation, does not exist as an explicit concept. We argue that extracting and analyzing such conversations can be used fruitfully to aid program comprehension. We present an approach that reconstructs the conversations that take place on a software community Discord server, focusing on software-related conversations: Our approach binds the conversations to the discussed artifacts. Leveraging our approach, we built a tool that enables the interactive exploration of the conversations' contents. We illustrate its usefulness through a number of examples that highlight how the insights obtained serve as an additional form of software documentation and program comprehension aid.	2643-7171	978-1-4503-9298-3	Swiss National Science Foundation; 	conversations;Discord;visualization	Codes;Design methodology;Computer bugs;Focusing;Oral communication;Documentation;Software systems	application program interfaces;data visualisation;object-oriented programming;program debugging;program diagnostics;public domain software;reverse engineering;software engineering;software maintenance	software-related conversations;discussed artifacts;software documentation;program comprehension aid;Discord conversations;modern communication platforms;software development host daily conversations;software systems;language features;code artifacts;design patterns;usage examples;code reviews;bug reporting;Discord servers;virtual community hubs;filter-based search functionalities;software community Discord server				27		22 jun. 2022			IEEE	IEEE Conferences
Using conceptual roles of data for enhanced program comprehension	using conceptual roles of data for enhanced program comprehension	10.1109/WCRE.2002.1173070	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1173070	Yunbo Deng; S. Kothari	Department of Electrical and Computer Engineering, Iowa State University, Ames, IA, USA; Department of Electrical and Computer Engineering, Iowa State University, Ames, IA, USA	Ninth Working Conference on Reverse Engineering, 2002. Proceedings.	29 jan. 2003	2002			119	127	Without proper background, it is often very difficult for human beings to understand a legacy code. Domain knowledge is valuable to guide domain experts to efficiently comprehend and reengineer domain applications. In the comprehension process, what domain experts normally do is associate domain concepts in the human mind with their representations in the actual code. This paper is addressed as an effort to recover the representations of domain-specific concepts in an application and show the usefulness of such recovery in program comprehension. We describe two important aspects of this research: data-centered program analysis to recover the conceptual roles of data in a program; deriving a "program skeleton" aided by the conceptual roles to present an abstraction to capture the program behavior and the relationship between kernel variables in a program. We are developing a software engineering environment, named "SeeCORE", which incorporates these two approaches. SeeCORE can be customized for different domains by appropriately user-defined domain-specific rules. We have used a class of scientific applications as a domain to demonstrate our approach.	1095-1350	0-7695-1799-4			Reverse engineering	reverse engineering;program diagnostics;programming environments	legacy code;domain knowledge;program comprehension;data-centered program analysis;program skeleton;program behavior;software engineering environment;SeeCORE;user-defined domain-specific rules				16		29 jan. 2003			IEEE	IEEE Conferences
An Empirical Study on the Usage of SQL Execution Traces for Program Comprehension	an empirical study on the usage of sql execution traces for program comprehension	10.1109/QRS-C.2017.17	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8004293	N. Noughi; S. Hanenberg; A. Cleve	PReCISE Research Center, University of Namur; Paluno-The Ruhr Institute for Software Technology, University of Duisburg-Essen, Germany; PReCISE Research Center, University of Namur	2017 IEEE International Conference on Software Quality, Reliability and Security Companion (QRS-C)	10 Aug 2017	2017			47	54	Several studies have investigated dynamic analysis in the context of software maintenance and evolution, and most of them confirmed the positive impact of such analysis on program comprehension tasks. In this paper, we focus on the understanding of the database access behavior of a program, which has become an important (yet largely ignored) aspect of program comprehension. We empirically assess how developers/students are (not) able to understand interactions between the database and the application program. To this end, we used DAViS, a tool for Dynamic Analysis and Visualization of SQL execution traces. We present a controlled experiment that quantitatively evaluates to what extent DAViS can influence program comprehension in terms of duration and correctness of the tasks. The results of the study indicate that DAViS does reduce the response time and increases the correctness (with a large effect size), which means that we found a strong indicator that the chosen approach is truly able to help developers.		978-1-5386-2072-4			Databases;Structured Query Language;Tools;Time factors;Performance analysis;Time measurement;Software	data visualisation;software maintenance;SQL	SQL execution traces;dynamic analysis;software maintenance;software evolution;program comprehension tasks;database access behavior;database;application program;DAViS;dynamic visualization				25		10 Aug 2017			IEEE	IEEE Conferences
Refining existing theories of program comprehension during maintenance for concurrent software	refining existing theories of program comprehension during maintenance for concurrent software	10.1109/ICPC.2008.40	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556114	S. D. Fleming; E. Kraemer; R. E. K. Stirewalt; L. K. Dillon; S. Xie	Department of Computer Science and Engineering, Michigan State University, East Lansing, MI, USA; Department of Computer Science, University of Georgia, Athens, GA, USA; Department of Computer Science and Engineering, Michigan State University, East Lansing, MI, USA; Department of Computer Science and Engineering, Michigan State University, East Lansing, MI, USA; Department of Computer Science, University of Georgia, Athens, GA, USA	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			23	32	While the sources of complexity in the initial design and verification of multi-threaded software systems are well-documented, less is known of the issues specific to the maintenance of these systems. The literature contains a number of observational studies of programmers performing maintenance, conducted in the context of sequential software and designed to investigate the factors and behaviors that lead to success. To help fill the gap in knowledge in the area of concurrent software maintenance, we conducted a study that refines the findings of two prior studies, those of Littman et al. and of Vessey, to address issues and obstacles that arise in the understanding of concurrent software. We validated these refinements by observing programmers performing corrective maintenance on a small but complex multi-threaded server program.	1092-8138	978-0-7695-3176-2			Software maintenance;Programming profession;Concurrent computing;Cognitive science;Software systems;Interleaved codes;Design engineering	concurrent engineering;software maintenance	refining existing theories;program comprehension;concurrent software maintenance;initial design;multithreaded software systems				20		2 jul. 2008			IEEE	IEEE Conferences
Program comprehension by visualization in contexts	program comprehension by visualization in contexts	10.1109/ICSM.2002.1167789	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1167789	Rui Yin; R. K. Keller	Département IRO, Université de Montreal, Montreal, QUE, Canada; Zühlke Engineering AG, Schlieren, Switzerland	International Conference on Software Maintenance, 2002. Proceedings.	29 jan. 2003	2002			332	341	To make program comprehension more effective, the analyst needs high-level information about the software under investigation, in particular information at the structure and the design levels. Visualization in contexts allows the analyst to investigate software in terms of various contexts at different levels of abstraction and to form a variety of mental models of the software at hand. Moreover, the analyst can mentally integrate disparate mental models by cross-referencing. In this paper, the visualization in contexts strategy is introduced. Then, the Context Viewer, a prototype tool supporting the strategy within the SPOOL reverse engineering environment, is detailed. Three usage scenarios illustrate the approach. The scenarios, complemented by an informal evaluation and comparison, suggest the usefulness of the tool and the underlying strategy.	1063-6773	0-7695-1819-2			Object oriented modeling;Cognitive science;Information analysis;Software systems;Reverse engineering;Councils;Data visualization;Software prototyping;Prototypes;Collaborative tools	reverse engineering;program visualisation;software tools	program comprehension;high-level information;software;visualization in contexts;abstraction;mental models;cross-referencing;Context Viewer tool;SPOOL reverse engineering environment				31		29 jan. 2003			IEEE	IEEE Conferences
EEG Activities During Program Comprehension: An Exploration of Cognition	eeg activities during program comprehension an exploration of cognition	10.1109/ACCESS.2021.3107795	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9521874	Y. -T. Lin; Y. -Z. Liao; X. Hu; C. -C. Wu	Graduate Institute of Information and Computer Education, National Taiwan Normal University, Taipei, Taiwan; Graduate Institute of Information and Computer Education, National Taiwan Normal University, Taipei, Taiwan; Human Communication, Development, and Information Sciences, Faculty of Education, The University of Hong Kong, Hong Kong; Graduate Institute of Information and Computer Education, National Taiwan Normal University, Taipei, Taiwan	IEEE Access	3 Sep 2021	2021	9		120407	120421	This study attempts to explore cognition during program comprehension through physiological evidence by recording and comparing electroencephalogram (EEG) activities in different frequency bands and the eye movements of the participants with high or low programming abilities. An experiment was conducted with thirty-three undergraduate students majoring in Computer Science. We recorded their EEG activities when they were reading two programs with three types of program constructs. At the same time, the participants' eye movements were recorded by an eye tracker to further understand the relationship between the program comprehension process and EEG activities. Experimental results show that the high-performance participants displayed higher performance for working memory (theta power), attention resource allocation (lower alpha power), and interaction between working memory and semantic memory (upper alpha power) in program comprehension tasks of complex constructs, which proves related theories proposed in the existing research on programming and cognition. The results of this study not only offer objective evidence of the roles cognition plays in program comprehension but also provide educators with suggestions for designing suitable pedagogical strategies.	2169-3536		Ministry of Science and Technology of Taiwan(grant numbers:MOST109-2511-H-003-010-MY3); 	Computer science education;programming;educational technology	Programming profession;Electroencephalography;Task analysis;Object oriented modeling;Data models;Computational modeling;Brain modeling	cognition;computer aided instruction;electroencephalography;medical signal processing;neurophysiology	EEG activities;eye movements;high programming abilities;low programming abilities;thirty-three undergraduate students majoring;program constructs;eye tracker;program comprehension process;high-performance participants;attention resource allocation;semantic memory;program comprehension tasks;roles cognition plays				86	CCBY	24 Aug 2021			IEEE	IEEE Journals
The role of testing and dynamic analysis in program comprehension supports	the role of testing and dynamic analysis in program comprehension supports	10.1109/WPC.1993.263896	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263896	P. Benedusi; V. Benvenuto; L. Tomacelli	CRIAI, Portici, Italy; CRIAI, Portici, Italy; CRIAI, Portici, Italy	[1993] IEEE Second Workshop on Program Comprehension	6 Aug 2002	1993			149	158	Test cases. amd the human activities involved in testing and error analysis play a peculiar and considerable role in the comprehension of a software product and process. This subject was systematically explored in the context of the Esprit DOCKET Project designing and experimenting second-generation reverse engineering processes which combine multiple knowledge sources. This paper describes the approach, and the architecture which have been designed for the capitalisation of the knowledge products of both existing software life cycle activities and proposed knowledge-elicitation oriented testing strategies.<>	1092-8138	0-8186-4042-1			Software testing;Life testing;Reverse engineering;Software debugging;Error analysis;Software performance;Humans;Animation;Flow graphs;Microscopy	knowledge acquisition;program testing;software maintenance;software tools	testing;dynamic analysis;program comprehension;error analysis;software product;DOCKET;reverse engineering;knowledge sources;software life cycle;knowledge-elicitation				37		6 Aug 2002			IEEE	IEEE Conferences
Interprocedural analysis for program comprehension by specialization	interprocedural analysis for program comprehension by specialization	10.1109/WPC.1996.501128	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501128	S. Blazy; P. Facon	CEDRIC IIE, Evry, France; NA	WPC '96. 4th Workshop on Program Comprehension	6 Aug 2002	1996			133	141	We report on an approach for program comprehension during large-scale maintenance of Fortran application programs. We have adapted partial evaluation (or specialization of programs given specific values for their input data) techniques for program comprehension. We focus on the automatic interprocedural analysis and we describe how we have specified, implemented in a tool, and used that analysis to improve program comprehension. The difficulty of that analysis is due to the lack of well defined interprocedural mechanisms and the complexity of visibility rules in Fortran.	1092-8138	0-8186-7283-8			Large-scale systems;Solid modeling;Power generation;Software maintenance;Formal specifications;Input variables;Displays;Cognition;Fluid flow;Geometry	reverse engineering;software maintenance;FORTRAN;partial evaluation (compilers);program compilers;software tools;program diagnostics	interprocedural analysis;program comprehension;specialization;software maintenance;Fortran;application programs;partial evaluation;software tool;visibility rules				14		6 Aug 2002			IEEE	IEEE Conferences
COSPEX: A Program Comprehension Tool for Novice Programmers	cospex a program comprehension tool for novice programmers	10.1145/3510454.3516842	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9793787	N. Gupta; A. Rajput; S. Chimalakonda	Department of Computer Science & Engineering, Research in Intelligent Software & Human Analytics (RISHA) Lab, Indian Institute of Technology, Tirupati, India; Department of Computer Science & Engineering, Research in Intelligent Software & Human Analytics (RISHA) Lab, Indian Institute of Technology, Tirupati, India; Department of Computer Science & Engineering, Research in Intelligent Software & Human Analytics (RISHA) Lab, Indian Institute of Technology, Tirupati, India	2022 IEEE/ACM 44th International Conference on Software Engineering: Companion Proceedings (ICSE-Companion)	13 jun. 2022	2022			41	45	Developers often encounter unfamiliar code during software maintenance which consumes a significant amount of time for comprehension, especially for novice programmers. Researchers have come up with automated techniques that can provide effective code comprehension and summaries by analyzing a source code and present key information to the developers. Existing debuggers represent the execution states of the program but they do not show the complete execution at a single point. Studies have revealed that the effort required for program comprehension can be reduced if novice programmers are provided with worked examples. Hence, we propose COSPEX (Comprehension using Summarization via Program Execution) - an Atom plugin that dynamically extracts key information for every line of code executed and presents it to the developers in the form of an interactive example-like dynamic information instance. As a preliminary evaluation, we presented 14 undergraduates having Python programming experience up to 1 year with a code comprehension task in a user survey. We observed that COSPEX helped novice programmers in program comprehension and improved their understanding of the code execution. The source code and tool are available at: https://github.com/rishalab/COSPEX, and the demo on Youtube is available at: https://youtu.be/QQY-8KuDaEM.	2574-1926	978-1-6654-9598-1		Software and its engineering → Software maintenance tools Documentation Maintaining software	Software maintenance;Codes;Video on demand;Documentation;Programming;Maintenance engineering;Data mining	program debugging;Python;reverse engineering;software maintenance;source code (software)	interactive example-like dynamic information instance;code comprehension task;COSPEX;novice programmers;code execution;source code;unfamiliar code;program execution;program comprehension tool;Python programming experience				19		13 jun. 2022			IEEE	IEEE Conferences
Presenting micro-theories of program comprehension in pattern form	presenting microtheories of program comprehension in pattern form	10.1109/WPC.2005.28	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421014	A. Murray; T. C. Lethbridge	SITE, University of Ottawa, Ottawa, ONT, Canada; SITE, University of Ottawa, Ottawa, ONT, Canada	13th International Workshop on Program Comprehension (IWPC'05)	23 May 2005	2005			45	54	We present the notion of cognitive patterns, and provide several examples. A cognitive pattern is the written record of a solution to a recurring cognitive problem typically employed by experienced practitioners. We focus on those relevant to program comprehension, which we have developed through studying the literature and conducting field studies. Collectively the set of patterns constitute a rich theory of program comprehension, which is why we call each one a micro-theory. We expand on one pattern, temporal details, which is also a 'pattern language since it breaks down into sub-patterns'. A key use of cognitive patterns is to suggest useful features for tool designers to implement.	1092-8138	0-7695-2254-8			Software maintenance;Software engineering;Software tools;Problem-solving;Software debugging;Software systems;Documentation;Cognitive science;Conferences	reverse engineering;object-oriented programming;software tools	program comprehension micro-theories;cognitive pattern notion;temporal details pattern language;software tools				40		23 May 2005			IEEE	IEEE Conferences
Understanding Lolita: program comprehension in functional languages	understanding lolita program comprehension in functional languages	10.1109/WPC.1993.263909	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263909	J. E. Hazan; S. A. Jarvis; R. G. Morgan; R. Garigliano	Artificial Intelligence Systems Research Group, UK; Artificial Intelligence Systems Research Group, UK; Artificial Intelligence Systems Research Group, UK; Durham Univ., UK	[1993] IEEE Second Workshop on Program Comprehension	6 Aug 2002	1993			26	34	Traditional arguments concerning the comprehensibility of functional programs have been illustrated with trivial examples. The authors present the real-life example of a large system for natural language processing which has been programmed entirely in a lazy functional language. This system is undergoing constant change as new features are added to different areas. They present a series of case studies which illustrate various aspects of the maintenance task, including reuse of existing parts of the system and the integration of the new features. They explain how the choice of a functional language for programming the system has aided in the comprehension of the system by new programmers and how this in turn has led to the simplification of the maintenance task. They describe the ease with which new features have been integrated into the system and relate this to the careful design of abstractions within a functional programming framework.<>	1092-8138	0-8186-4042-1			Functional programming;Programming profession;Artificial intelligence;Natural language processing;Memory management;Councils;Large-scale systems;Ink;Trademarks	functional programming;software maintenance	Lolita;program comprehension;functional languages;functional programs;natural language processing;lazy functional language;maintenance task;reuse;comprehension				13		6 Aug 2002			IEEE	IEEE Conferences
FEPSS: a flexible and extensible program comprehension support system	fepss a flexible and extensible program comprehension support system	10.1109/WCRE.1998.723174	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=723174	Tao Lin; L. O'Brien	CSIRO Mathematical and Information Sciences, Canberra, ACT, Australia; International Management Resources, Inc., Milsons Point, NSW, Australia	Proceedings Fifth Working Conference on Reverse Engineering (Cat. No.98TB100261)	6 Aug 2002	1998			40	49	This paper describes the architecture of an ongoing developed Flexible and Extensible Program comprehension Support System (FEPSS). Program comprehension is a process for supporting users to understand a software system and is required for forward, reverse engineering, and re-engineering. In a program comprehension process some artifacts such as control-flow graphs and data-flow graphs need to be generated to help users in understanding and some artifacts such as design rationale and testing cases also need to be recorded for further re-engineering. It is impossible to predict all the types of artifacts to be supported in a program comprehension process as at least no one makes a re-engineering plan when designing a new software system. Therefore a program comprehension system should support a great flexibility and extensibility in artifact modelling. The approach which FEPSS takes is to provide a support system where the users can add new artifacts even at run time. FEPSS uses a relational object model to link the artifacts in order to integrate various activities in a program comprehension process as a whole. To help users to understand the artifacts and their relationships FEPSS uses 3D visualization to display artifacts. As the number of the artifacts for a software system can be very large FEPSS provides a navigation tool for users to control what artifacts to display. Based on these mechanisms, FEPSS can support users to analyze, model, and explore the artifacts through pictures.		0-8186-8967-6			Data models;Data visualization;Computer architecture;Software systems;Three dimensional displays;Two dimensional displays;Navigation;Reverse engineering;Software maintenance;Information analysis	reverse engineering;software tools;systems re-engineering;data visualisation;data flow graphs	FEPSS;flexible extensible program comprehension system;program understanding;forward engineering;reverse engineering;re-engineering;control-flow graphs;data-flow graphs;design rationale;testing cases;artifact modelling;run time;relational object model;3D visualization;navigation tool			2	24		6 Aug 2002			IEEE	IEEE Conferences
View definitions for language-independent multiple-view program comprehension and editing	view definitions for languageindependent multipleview program comprehension and editing	10.1109/VISSOF.2002.1019789	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1019789	J. Sajaniemi	Department of Computer Science, University of Joensuu, Joensuu, Finland	Proceedings First International Workshop on Visualizing Software for Understanding and Analysis	7 Aug 2002	2002			3	12	View-based editing provides a technique to integrate program analysis tools into the comprehension and editing process. The programmer may study the result of an analysis in a separate view window and make changes in the output, and the system will propagate the changes back to the original program. In this paper, we will study how view-based editors and editable views can be made technically realizable and cognitively usable. The most important technical aspects are data flow considerations, the frequency of transformations, and the treatment of failures. For users, the most significant properties are understandability in the users' framework, avoidance of unexpected changes or side effects, and the smoothness of successive cycles.		0-7695-1662-9			Programming profession;Transformers;Natural languages;Concrete;Computer science;Frequency;Debugging;Text analysis;Conferences;Java	reverse engineering;software engineering;text editing	language-independent multiple-view program comprehension;language-independent multiple-view program editing;view definitions;view-based editing;program analysis tools;editable views;data flow;understandability;user framework				22		7 Aug 2002			IEEE	IEEE Conferences
A cognitive model for program comprehension	a cognitive model for program comprehension	10.1109/SERA.2005.2	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1563188	Shaochun Xu	Department of Computer Science, Algoma University College, ONT, Canada	Third ACIS Int'l Conference on Software Engineering Research, Management and Applications (SERA'05)	27 Dec 2005	2005			392	398	This paper proposes a cognitive model to classify the level of cognition and cognitive activities in program comprehension. This model is composed of input, cognitive process and output, among which the cognitive process includes four activities (absorption, denial, reorganization and expulsion) at six Bloom learning levels. Compared with the existing models, our learning model is more complete and more detailed. It not only describes cognitive activities in detail, but can also be applied in most of the cases. Our model can also reveal the differences between experts and novices in program comprehension. It provides some useful insights on how to build a tool to aid program comprehension. We also find that the so-called traditional program comprehension process involves activities not only at comprehension level of the Bloom's taxonomy, but at higher levels as well. A case study is conducted to validate this learning model.		0-7695-2297-1			Programming profession;Software maintenance;Computer science;Educational institutions;Cognition;Absorption;Taxonomy;Brain modeling;Software engineering;Conference management	reverse engineering;software maintenance;cognition	cognitive model;program comprehension;Bloom learning level;software maintenance;program understanding;Bloom taxonomy				29		27 Dec 2005			IEEE	IEEE Conferences
Semantic clone detection using method IOE-behavior	semantic clone detection using method ioebehavior	10.1109/IWSC.2012.6227874	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227874	R. Elva; G. T. Leavens	University of Central Florida, Orlando, FL, USA; University of Central Florida, Orlando, FL, USA	2012 6th International Workshop on Software Clones (IWSC)	2 jul. 2012	2012			80	81	This paper presents an algorithm for the detection of semantic clones in Java methods. Semantic clones are defined as functionally-identical code fragments. Our detection process operates on the premise that if two code fragments are semantic clones, then their input-output behavior would be identical. We adopt a wholistic approach to the definition of input-output behavior by including not only the parameters and return values of methods; but also their effects, as reflected in the pre- and post-states of the heap. We refer to this as a method's IOE-behavior (input, output and effects).		978-1-4673-1795-5		Software Clone Detection;Semantic Clones;Method IOE-behavior;Program Understanding	Cloning;Semantics;Syntactics;USA Councils;Java;Educational institutions;Testing	Java;program compilers;software maintenance	semantic clone detection;method IOE-behavior;Java methods;functionally-identical code fragments;input-output behavior;return values		13		8		2 jul. 2012			IEEE	IEEE Conferences
A Simple and Effective Measure for Complex Low-Level Dependencies	a simple and effective measure for complex lowlevel dependencies	10.1109/ICPC.2010.49	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521761	D. Beyer; A. Fararooy	Simon Fraser University, BC, Canada; Simon Fraser University, BC, Canada	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			80	83	The measure dep-degree is a simple indicator for structural problems and complex dependencies on code-level. We model low-level dependencies between program operations as use-def graph, which is generated from reaching definitions of variables. The more dependencies a program operation has, the more different program states have to be considered and the more difficult it is to understand the operation. Dep-degree is simple to compute and interpret, flexible and scalable in its application, and independently complementing other indicators. Preliminary experiments suggest that the measure dep-degree, which simply counts the number of dependency edges in the use-def graph, is a good indicator for readability and understandablity.	1092-8138	978-1-4244-7603-9		Software Measure;Dependency Analysis;Refactoring;Program Understanding	Software measurement;Lab-on-a-chip;Size measurement;Length measurement;Application software;Software systems;Frequency;Stability;Guidelines;Program processors	software metrics	low-level dependency measurement;dep-degree measurement;readability indicator;understandablity indicator		10		22		26 jul. 2010			IEEE	IEEE Conferences
DepDigger: A Tool for Detecting Complex Low-Level Dependencies	depdigger a tool for detecting complex lowlevel dependencies	10.1109/ICPC.2010.52	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521777	D. Beyer; A. Fararooy	Simon Fraser University, BC, Canada; Simon Fraser University, BC, Canada	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			40	41	We present a tool that identifies complex data-flow dependencies on code-level, based on the measure dep-degree. Low-level dependencies between program operations are modeled by the use-def graph, which is generated from reaching definitions of variables. The tool annotates program operations with their dep-degree values, such that 'difficult' program operations are easy to locate. We hope that this tool helps detecting and preventing code degeneration, which is often a challenge in today's software projects, due to the high refactoring and restructuring frequency.	1092-8138	978-1-4244-7603-9		Dependency Analysis;Software Structure;Refactoring;Program Understanding	Software tools;Tree graphs;Software maintenance;Lab-on-a-chip;Frequency measurement;Software measurement;Java;Licenses;Program processors;Optimizing compilers	data flow analysis;software tools	DepDigger tool;complex low-Level dependencies;complex data-flow dependencies;code-level;use-def graph;program operation annotation;dep-degree values;code degeneration prevention;software projects		4		1		26 jul. 2010			IEEE	IEEE Conferences
Pangolin: An SFL-Based Toolset for Feature Localization	pangolin an sflbased toolset for feature localization	10.1109/ASE.2019.00119	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952297	B. Castro; A. Perez; R. Abreu	IST, University of Lisbon, Lisbon, Portugal; Palo Alto Research Center, USA; IST, University of Lisbon and INESC-ID, Lisbon, Portugal	2019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)	9 jan. 2020	2019			1130	1133	Pinpointing the location where a given unit of functionality-or feature-was implemented is a demanding and time-consuming task, yet prevalent in most software maintenance or evolution efforts. To that extent, we present PANGOLIN, an Eclipse plugin that helps developers identifying features among the source code. It borrows Spectrum-based Fault Localization techniques from the software diagnosis research field by framing feature localization as a diagnostic problem. PANGOLIN prompts users to label system executions based on feature involvement, and subsequently presents its spectrum-based feature localization analysis to users with the aid of a color-coded, hierarchic, and navigable visualization which was shown to be effective at conveying diagnostic information to users. Our evaluation shows that PANGOLIN accurately pinpoints feature implementations and is resilient to misclassifications by users. The tool can be downloaded at https://tqrg.github.io/pangolin/.	2643-1572	978-1-7281-2508-4		Spectrum-based Fault Localization;Program Understanding;Maintenance and Evolution	Visualization;Software;Task analysis;Tools;Feature detection;Java;Feature extraction	fault diagnosis;program diagnostics;program testing;software fault tolerance;software maintenance	software diagnosis research field;spectrum-based feature localization analysis;feature implementations;SFL-based toolset;software maintenance;Eclipse plugin;source code;spectrum-based fault localization techniques;Pangolin		3		10		9 jan. 2020			IEEE	IEEE Conferences
CheckDep: A Tool for Tracking Software Dependencies	checkdep a tool for tracking software dependencies	10.1109/ICPC.2010.51	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521774	D. Beyer; A. Fararooy	Simon Fraser University, BC, Canada; Simon Fraser University, BC, Canada	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			42	43	Many software developers use a syntactical `diff' in order to performa quick review before committing changes to the repository. Others are notified of the change by e-mail (containing diffs or change logs), and they review the received information to determine if their work is affected. We lift this simple process from the code level to the more abstract level of dependencies: a software developer can use CheckDep to inspect introduced and removed dependencies before committing new versions, and other developers receive summaries of the changed dependencies via e-mail. We find the tool useful in our software-development activities and now make the tool publicly available.	1092-8138	978-1-4244-7603-9		Dependency Analysis;Software Structure;Refactoring;Program Understanding	Software tools;Visualization;Software performance;Feedback;Uniform resource locators;Concrete;Cement industry;Computer industry;Industrial control;Licenses	software engineering;software tools	CheckDep tool;software dependency tracking;e-mail;code level;software development		2		2		26 jul. 2010			IEEE	IEEE Conferences
Visualizing the Java heap	visualizing the java heap	10.1145/1810295.1810344	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6062172	S. P. Reiss	Department of Computer Science, Brown University, Providence, RI, USA	2010 ACM/IEEE 32nd International Conference on Software Engineering	27 Oct 2011	2010	2		251	254	Many of the problems that occur in long-running systems involve the way that the system uses memory. We have developed a framework for extracting and building a model of the heap from a running Java system. Such a model is only useful if programmers can extract from it the information they need to understand, find, and eventually fix memory-related problems in their system. We demonstrate the tool in action, showing how it works dynamically on running processes and how it is designed to address a variety of specific memory issues.	1558-1225	978-1-60558-719-6		dynamic program understanding;memory management;object ownership;programming tools	Java;Visualization;Memory management;Software;Sun;Debugging;Programming	Java;storage management	Java heap;long-running system;memory-related problem		1		30		27 Oct 2011			IEEE	IEEE Conferences
OSAIFU: A Source Code Factorizer on Android Studio	osaifu a source code factorizer on android studio	10.1109/ICSME.2019.00074	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8918942	M. Hata; M. Nishimoto; K. Nishiyama; H. Kawabata; T. Hironaka	Graduate School of Information Sciences, Hiroshima City University, Hiroshima, Japan; Graduate School of Information Sciences, Hiroshima City University, Hiroshima, Japan; Graduate School of Information Sciences, Hiroshima City University, Hiroshima, Japan; Graduate School of Information Sciences, Hiroshima City University, Hiroshima, Japan; Graduate School of Information Sciences, Hiroshima City University, Hiroshima, Japan	2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)	5 Dec 2019	2019			422	425	Programs written in the event-driven style that are typical of mobile and/or Web applications are not easy to read through. For the purpose of reducing the burden put on software developers, we propose a tool for supporting program understanding, named OSAIFU, implemented as a plugin for Android Studio. OSAIFU automatically factorizes source code at hand, i.e., extracts implemented features from source code by analyzing relations among program elements and shows the summary to the user as a list of clickable tag clouds. The user can check how each feature is implemented by clicking a tag cloud and looking at the corresponding part in the source code that is highlighted to make it easy to spot. The results of preliminary case studies show the effectiveness of OSAIFU. OSAIFU is available at https://imozuru.github.io/OSAIFU/.	2576-3148	978-1-7281-3094-1		program understanding, source code factorizing, tag cloud, event-driven programming, Android Studio	Feature extraction;Tag clouds;Androids;Humanoid robots;Java;Tools;Software	cloud computing;mobile computing;reverse engineering;smart phones;source code (software)	program elements;clickable tag clouds;source code factorizer;Android Studio;event-driven style;mobile Web applications;software developers;program understanding;named OSAIFU				13		5 Dec 2019			IEEE	IEEE Conferences
A visualization tool for Data Structures course	a visualization tool for data structures course	10.1109/ICCSIT.2009.5234389	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5234389	Jauhar Ali	College of Engineering and Computer Science, Abu Dhabi University, Abu Dhabi, UAE	2009 2nd IEEE International Conference on Computer Science and Information Technology	11 Sep 2009	2009			212	216	Data Structures is a core course in almost all Computer Science programs. Textbooks and courses on Data Structures these days are programming-languages-based with those based on object-oriented programming (OOP) in dominance. In many cases, they base their pedagogy on software design patterns. However, because of heavy reliance on abstraction, they place greater demands on learners. In this study, we design and implement a visualization tool that makes it easier for students to understand object-oriented data structures.		978-1-4244-4519-6		visualization;data structures;program understanding;technology in education	Data visualization;Data structures;Object oriented programming;Computer science;Programming profession;Object oriented modeling;Data mining;Educational institutions;Data engineering;Software design	computer science education;data structures;data visualisation;educational courses;object-oriented programming	visualization tool;data structures course;computer science programs;programming-languages;object-oriented programming;software design patterns;object-oriented data structures				22		11 Sep 2009			IEEE	IEEE Conferences
Towards Developing a Meta-model for Comprehending Software Adaptability	towards developing a metamodel for comprehending software adaptability	10.1109/ICPC.2010.50	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521769	M. Amoui; S. Li; E. A. Oliveira Jr.; L. Tahvildari	Department of ECE, University of Waterloo, Waterloo, Canada; Department of ECE, University of Waterloo, Waterloo, Canada; Computing Systems Department, University of São Paulo, Sao Paulo, Brazil; Department of ECE, University of Waterloo, Waterloo, Canada	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			56	57	To modernize legacy software into adaptable software, a program understanding procedure is needed to study software for identifying the mechanisms that support adaptability. Though the procedure can benefit from modeling techniques, current software meta-models do not fully support particular aspects of software adaptability. The goal of this research is to develop a meta-model, which facilitate comprehending applications for adaptability by annotating a set of pre-determined adaptability factors in software models. To this end, we investigate application-level sensing and effecting mechanisms, identify the core adaptability factors, and propose a meta-model for adaptability.	1092-8138	978-1-4244-7603-9		program understanding;adaptability;meta-model	Object oriented modeling;Application software;Runtime;Switches;Turning;Time of arrival estimation;Mechanical factors;Flow graphs;Reflection;Computational modeling	adaptive systems;software reliability	software adaptability;software meta model;program understanding procedure				5		26 jul. 2010			IEEE	IEEE Conferences
Visualizing the Scripts of Data Wrangling with SOMNUS	visualizing the scripts of data wrangling with somnus	10.1109/TVCG.2022.3144975	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9693232	K. Xiong; S. Fu; G. Ding; Z. Luo; R. Yu; W. Chen; H. Bao; Y. Wu	State Key Lab of CAD&CG, Zhejiang University, 12377 Hangzhou, Zhejiang, China, (e-mail: kaixiong@zju.edu.cn); Artificial Intelligence Research Institute, Zhejiang Lab, 559075 Hangzhou, Zhejiang, China, (e-mail: fusiwei339@gmail.com); State Key Lab of CAD&CG, Zhejiang University, 12377 Hangzhou, Zhejiang, China, (e-mail: dinggm@zju.edu.cn); College of Computer Science and Technology, Zhejiang University of Technology, 12624 Hangzhou, Zhejiang, China, (e-mail: rickyluozs@gmail.com); Artificial Intelligence Research Institute, Zhejiang Lab, 559075 Hangzhou, Zhejiang, China, (e-mail: 1721298964@qq.com); State Key Lab of CAD&CG, Zhejiang University, 12377 Hangzhou, Zhejiang, China, (e-mail: chenvis@zju.edu.cn); State Key Lab of CAD&CG, Zhejiang University, 12377 Hangzhou, Zhejiang, China, (e-mail: bao@cad.zju.edu.cn); State Key Lab of CAD&CG, Zhejiang University, 12377 Hangzhou, Zhejiang, China, (e-mail: ycwu@zju.edu.cn)	IEEE Transactions on Visualization and Computer Graphics		2022	PP	99	1	1	Data workers use various scripting languages for data transformation, such as SAS, R, and Python. However, understanding intricate code pieces requires advanced programming skills, which hinders data workers from grasping the idea of data transformation at ease. Program visualization is beneficial for debugging and education and has the potential to illustrate transformations intuitively and interactively. In this paper, we explore visualization design for demonstrating the semantics of code pieces in the context of data transformation. First, to depict individual data transformations, we structure a design space by two primary dimensions, i.e., key parameters to encode and possible visual channels to be mapped. Then, we derive a collection of 23 glyphs that visualize the semantics of transformations. Next, we design a pipeline, named Somnus, that provides an overview of the creation and evolution of data tables using a provenance graph. At the same time, it allows detailed investigation of individual transformations. User feedback on Somnus is positive. Our study participants achieved better accuracy with less time using Somnus, and preferred it over carefully-crafted textual description. Further, we provide two example applications to demonstrate the utility and versatility of Somnus.	1941-0506		National Natural Science Foundation of China(grant numbers:62002331,62072400); 	Program understanding;data transformation;visualization design	Data visualization;Codes;Semantics;Visualization;Debugging;Python;Task analysis							IEEE	25 jan. 2022			IEEE	IEEE Early Access Articles
A New Standard of Choosing Slicing Criterion	a new standard of choosing slicing criterion	10.1109/WCSE.2009.183	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5319415	Q. Zhang; Y. Su	School of Computer and Communication, Lanzhou University of Technology, Lanzhou, China; School of Computer and Communication, Lanzhou University of Technology, Lanzhou, China	2009 WRI World Congress on Software Engineering	10 nov. 2009	2009	3		307	310	In the development of software reverse engineering, program understanding is one of the most important steps. With the brief introductions of several program slicing technologies and their advantages and disadvantages, a new standard, used to choose slicing criterion, is proposed in this paper. By comparison with other methods, the experiment shows that the program slicing which is calculated by this new standard could help software programmer improve the efficiency, shorten cycle and reduce the complexity in the aspect of program understanding.		978-0-7695-3570-8		Reverse engineering;program understanding;object-oriented;Program slicing	Programming profession;Software standards;Reverse engineering;Software engineering;Communication standards;Standards development;Debugging;Testing	program slicing;reverse engineering	software reverse engineering;program slicing technology;software programmer;program understanding				7		10 nov. 2009			IEEE	IEEE Conferences
Shhh!: 12 Practices for Secret Management in Infrastructure as Code	shhh! 12 practices for secret management in infrastructure as code	10.1109/SecDev51306.2021.00024	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9652648	A. Rahman; F. L. Barsha; P. Morrison	Department of Computer Science, Tennessee Tech University, Cookeville, TN, USA; Department of Computer Science, Tennessee Tech University, Cookeville, TN, USA; IBM Research Triangle Park, Durham, NC, USA	2021 IEEE Secure Development Conference (SecDev)	23 Dec 2021	2021			56	62	Despite being beneficial in automated provisioning of computing infrastructure at scale, infrastructure as code (IaC) scripts are susceptible to containing secrets, such as hard-coded passwords. A derivation of practices related to secret management for IaC can help practitioners to secure their secrets, potentially aiding them to securely develop IaC scripts. The goal of the paper is to help practitioners in secure development of infrastructure as code (IaC) scripts by identifying practices for secret management in IaC. We conduct a grey literature review with 38 Internet artifacts to identify 12 practices. We identify practices that are applicable for all IaC languages, e.g., prioritized encryption, as well as language-specific practices, such as state separation for Terraform. Our findings can be beneficial for (i) practitioners who can apply the identified practices to secure secrets in IaC development, and (ii) researchers who can investigate how the secret management process can be improved to facilitate secure development of IaC scripts.		978-1-6654-3170-5	National Science Foundation; 	configuration as code;configuration scripts;devops;devsecops;empirical study;grey literature;infrastructure as code;practices	Codes;Conferences;Bibliographies;Passwords;Internet;Encryption	cryptography;Internet;organisational aspects;security of data	hard-coded passwords;IaC scripts;secure development;language-specific practices;secret management process;infrastructure as code;computing infrastructure;IaC languages;prioritized encryption;terraform state separation		1		40		23 Dec 2021			IEEE	IEEE Conferences
Tarimliq: A new internal metric for software clustering analysis	tarimliq a new internal metric for software clustering analysis	10.1109/IranianCEE.2019.8786745	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8786745	M. Kargar; H. Izadkhah; A. Isazadeh	Dept. computer engineering Qazvin Branch, Islamic Azad University, Qazvin, Iran; Dept. of computer science, University of Tabriz, Tabriz, Iran; Dept. of computer science, University of Tabriz, Tabriz, Iran	2019 27th Iranian Conference on Electrical Engineering (ICEE)	5 Aug 2019	2019			1879	1883	Clustering techniques are utilized in the maintenance process of a software system to understand it. Different clustering algorithms have been proposed for this purpose in the literature. In the field of software clustering, a number of external criteria are presented to evaluate and validate the obtained clusters. External criteria use a reference clustering to evaluate an achieved clustering. Because of the comparison with reference clustering, the validity and accuracy of these methods are reliable in the assessment. When there is no reference clustering, internal criteria are used to validate clustering algorithms. Since there is no internal criterion for evaluating software clustering algorithms, the internal criteria available in data clustering are employed. In this paper, we propose an internal metric for evaluating software clustering algorithms. The results on Mozilla Firefox, as a large-scale software, demonstrate that the proposed internal metric is more accurate than the tested internal criteria and can also be a suitable alternative for external criteria.	2642-9527	978-1-7281-1508-5		clustering algorithms;program understandability;cluster validity;validity indices	Clustering algorithms;Software algorithms;Measurement;Software systems;Indexes;Computer architecture	pattern clustering;search engines;software maintenance	data clustering;large-scale software;software clustering analysis;Tarimliq;maintenance process;Mozilla Firefox		1		18		5 Aug 2019			IEEE	IEEE Conferences
JSummarizer: An automatic generator of natural language summaries for Java classes	jsummarizer an automatic generator of natural language summaries for java classes	10.1109/ICPC.2013.6613855	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613855	L. Moreno; A. Marcus; L. Pollock; K. Vijay-Shanker	Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA; Computer and Information Sciences Department, University of Delaware, Newark, DE, USA; Computer and Information Sciences Department, University of Delaware, Newark, DE, USA	2013 21st International Conference on Program Comprehension (ICPC)	30 Sep 2013	2013			230	232	JSummarizer is an Eclipse plug-in for automatically generating natural language summaries of Java classes. The summary is based on the stereotype of the class, which implicitly encodes the design intent of the class and is automatically inferred by JSummarizer. The tool uses a set of predefined heuristics to determine what information will be reflected in the summary, and it uses natural language processing and generation techniques to form the summary. The generated summaries can be used to re-document the code and to help developers to easier understand large and complex classes.	1092-8138	978-1-4673-3092-3		Source code summarization;program comprehension;documentation generation	Java;Natural languages;Conferences;Documentation;Software engineering;Software maintenance	Java;natural language processing	JSummarizer;automatic generator;natural language summaries;Java classes;Eclipse plug-in;natural language processing;generation techniques		30		12		30 Sep 2013			IEEE	IEEE Conferences
Towards Automatic Generation of Short Summaries of Commits	towards automatic generation of short summaries of commits	10.1109/ICPC.2017.12	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961530	S. Jiang; C. McMillan	Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN, USA; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN, USA	2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC)	29 jun. 2017	2017			320	323	Committing to a version control system means submitting a software change to the system. Each commit can have a message to describe the submission. Several approaches have been proposed to automatically generate the content of such messages. However, the quality of the automatically generated messages falls far short of what humans write. In studying the differences between auto-generated and human-written messages, we found that 82% of the human-written messages have only one sentence, while the automatically generated messages often have multiple lines. Furthermore, we found that the commit messages often begin with a verb followed by an direct object. This finding inspired us to use a "verb+object" format in this paper to generate short commit summaries. We split the approach into two parts: verb generation and object generation. As our first try, we trained a classifier to classify a diff to a verb. We are seeking feedback from the community before we continue to work on generating direct objects for the commits.		978-1-5386-0535-6		program comprehension;commit log;commit message;version control system;code differencing;natural language processing	Data analysis;Software;Grammar;Syntactics;Histograms;Control systems;Training	configuration management;pattern classification	automatic generation;short commit summaries;version control system;software change;message content;auto-generated message;human-written message;classifier training		21		14		29 jun. 2017			IEEE	IEEE Conferences
FLAT3: feature location and textual tracing tool	flat3 feature location and textual tracing tool	10.1145/1810295.1810345	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6062173	T. Savage; M. Revelle; D. Poshyvanyk	Department of Computer Science, College of William and Mary, Williamsburg, VA, USA; Department of Computer Science, College of William and Mary, Williamsburg, VA, USA; Department of Computer Science, College of William and Mary, Williamsburg, VA, USA	2010 ACM/IEEE 32nd International Conference on Software Engineering	27 Oct 2011	2010	2		255	258	Feature location is the process of finding the source code that implements a functional requirement of a software system. It plays an important role in software maintenance activities, but when it is performed manually, it can be challenging and time-consuming, especially for large, long-lived systems. This paper describes a tool called FLAT3 that integrates textual and dynamic feature location techniques along with feature annotation capabilities and a useful visualization technique, providing a complete suite of tools that allows developers to quickly and easily locate the code that implements a feature and then save these annotations for future use.	1558-1225	978-1-60558-719-6		concept location;dynamic analysis;information retrieval;program comprehension;software evolution and maintenance	Visualization;Information retrieval;Software engineering;Software maintenance;Libraries;Computer science	formal specification;software maintenance;software tools	textual tracing tool;source code;functional requirement;software system;software maintenance;FLAT3 tool;dynamic feature location;feature annotation capability;visualization technique		15		20		27 Oct 2011			IEEE	IEEE Conferences
The Concept of Stratified Sampling of Execution Traces	the concept of stratified sampling of execution traces	10.1109/ICPC.2011.17	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970192	H. Pirzadeh; S. Shanian; A. Hamou-Lhadj; A. Mehrabian	Department of Electrical and Computer Engineering, Concordia University, Montreal, QUE, Canada; Department of Computer Science, Laval University, Quebec, QUE, Canada; Department of Electrical and Computer Engineering, Concordia University, Montreal, QUE, Canada; Department of Electrical and Computer Engineering, Concordia University, Montreal, QUE, Canada	2011 IEEE 19th International Conference on Program Comprehension	1 Aug 2011	2011			225	226	Execution traces can be overwhelmingly large. To reduce their size, sampling techniques, especially the ones based on random sampling, have been extensively used. Random sampling, however, may result in samples that are not representative of the original trace. We propose a trace sampling framework based on stratified sampling that not only reduces the size of a trace but also results in a sample that is representative of the original trace by ensuring that the desired characteristics of an execution are distributed similarly in both the sampled and the original trace.	1092-8138	978-0-7695-4398-7		Trace analysis;program comprehension;sampling techniques;stratified sampling;execution phases	Phase detection;Visualization;Psychology;Conferences;Resource management;Software;Computers	program diagnostics;sampling methods	stratified sampling;execution traces;trace sampling framework		14		12		1 Aug 2011			IEEE	IEEE Conferences
jPET: An Automatic Test-Case Generator for Java	jpet an automatic testcase generator for java	10.1109/WCRE.2011.67	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079826	E. Albert; I. Cabanas; A. Flores-Montoya; M. Gomez-Zamalloa; S. Gutierrez	Complutense University of Madrid, Spain; Complutense University of Madrid, Spain; Complutense University of Madrid, Spain; Complutense University of Madrid, Spain; Complutense University of Madrid, Spain	2011 18th Working Conference on Reverse Engineering	17 nov. 2011	2011			441	442	We present jPET, a white box test-case generator (TCG) which can be used during software development of Java applications within the Eclipse environment. jPET builds on top of PET, a TCG which automatically obtains test-cases from the byte code associated to a Java program. jPET performs reverse engineering of the test-cases obtained at the byte code level by PET in order to yield this information to the user at the source code level. This allows understanding the information gathered at the lower level and using it to test source Java programs.	2375-5369	978-1-4577-1948-6		testing;test-case generation;program comprehension	Java;Positron emission tomography;Programming;Concrete;Testing;Software;Generators	automatic programming;Java;program testing;source coding	jPET;whitebox test case generator;software development;Eclipse environment;TCG;bytecode;Java program;reverse engineering;source code		13		8	IEEE	17 nov. 2011			IEEE	IEEE Conferences
Dynamic Analysis of SQL Statements for Data-Intensive Applications Reverse Engineering	dynamic analysis of sql statements for dataintensive applications reverse engineering	10.1109/WCRE.2008.38	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656409	A. Cleve; J. -L. Hainaut	PReCISE Research Center, University of Namurrue, Namur, Belgium; PReCISE Research Center, University of Namurrue, Namur, Belgium	2008 15th Working Conference on Reverse Engineering	24 Oct 2008	2008			192	196	Analyzing SQL statements brings invaluable information that can be used in various applications such as program understanding and database reverse engineering. While static SQL statements are fairly easy to analyze, dynamic SQL statements most often require dynamic analysis techniques that may prove more difficult to implement. This paper addresses the problem of dynamic SQL query analysis in the context of software and database reverse engineering. It explores the use of dynamic analysis techniques such as aspect-based tracing and SQL trace analysis for extracting implicit information about both the program behavior and the database structure.	2375-5369	978-0-7695-3429-9		Dynamic analysis;SQL;aspects;data reverse engineering;program comprehension	Reverse engineering;Databases;Data mining;Cities and towns;Software;Relational databases;Time factors	information retrieval;query processing;reverse engineering;SQL	SQL statements;database reverse engineering;dynamic analysis techniques;dynamic SQL query analysis;software reverse engineering;aspect-based tracing;SQL trace analysis		13	1	12		24 Oct 2008			IEEE	IEEE Conferences
CodeTopics: which topic am I coding now?	codetopics which topic am i coding now	10.1145/1985793.1985988	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032585	M. Gethers; T. Savage; M. Di Penta; R. Oliveto; D. Poshyvanyk; A. De Lucia	Computer Science Department, College of William and Mary, Williamsburg, VA, USA; HCI Institute, Carnegie Mellon University, Pittsburgh, PA, USA; Department of Engineering, University of Sannio, Benevento, Italy; STAT Department, University of Molise, Pesche, Italy; Computer Science Department, College of William and Mary, Williamsburg, VA, USA; Software Engineering Laboratory, University of Salerno, Fisciano, Italy	2011 33rd International Conference on Software Engineering (ICSE)	10 Oct 2011	2011			1034	1036	Recent studies indicated that showing the similarity between the source code being developed and related high-level artifacts (HLAs), such as requirements, helps developers improve the quality of source code identifiers. In this paper, we present CodeTopics, an Eclipse plug-in that in addition to showing the similarity between source code and HLAs also highlights to what extent the code under development covers topics described in HLAs. Such views complement information derived by showing only the similarity between source code and HLAs helping (i) developers to identify functionality that are not implemented yet or (ii) newcomers to comprehend source code artifacts by showing them the topics that these artifacts relate to.	1558-1225	978-1-4503-0445-0		program comprehension;source code lexicon;traceability	Educational institutions;Object oriented modeling;Software;Games;Information retrieval;Java;Monopoly	reverse engineering;software quality;software tools	CodeTopics;high-level artifacts;source code identifier quality;Eclipse plug-in;source code artifacts comprehension		11		9		10 Oct 2011			IEEE	IEEE Conferences
Software Artefact Traceability: the Never-Ending Challenge	software artefact traceability the neverending challenge	10.1109/ICSM.2007.4362664	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362664	R. Oliveto; G. Antoniol; A. Marcus; J. Hayes	Department of Mathematics and Informatics, University of Salerno, Fisciano, Salerno, Italy; Départment dInformatique, École Polytechnique de Montréal, Montreal, QUE, Canada; Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, University of Kentucky, Lexington, KY, USA	2007 IEEE International Conference on Software Maintenance	22 Oct 2007	2007			485	488	Software artefact traceability is widely recognised as an important factor for the effective development and maintenance of a software system. Unfortunately, the lack of automatic or semi-automatic supports makes the task of maintaining links among software artefacts a tedious and time consuming one. For this reason, often traceability information becomes out of date or it is completely absent during software development. In this working session, we discuss problems and challenges related to various aspects of trace-ability in software systems.	1063-6773	978-1-4244-1255-6		software artefact traceability;software maintenance;program comprehension;impact analysis;requirement tracing;information retrieval	Software maintenance;Programming;Software systems;Computer science;Guidelines;Mathematics;Informatics;Information analysis;Information retrieval;Documentation	software maintenance;system monitoring	software artefact traceability;software system;software development		9		19		22 Oct 2007			IEEE	IEEE Conferences
Reverse Engineering PL/SQL Legacy Code: An Experience Report	reverse engineering pl/sql legacy code an experience report	10.1109/ICSME.2014.93	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6976137	M. Habringer; M. Moser; J. Pichler	Voestalpine Stahl GmbH, Linz, Austria; Voestalpine Stahl GmbH, Linz, Austria; Voestalpine Stahl GmbH, Linz, Austria	2014 IEEE International Conference on Software Maintenance and Evolution	6 Dec 2014	2014			553	556	The reengineering of legacy code is a tedious endeavor. Automatic transformation of legacy code from an old technology to a new one preserves potential problems in legacy code with respect to obsolete, changed, and new business cases. On the other hand, manual analysis of legacy code without assistance of original developers is time consuming and error-prone. For the purpose of reengineering PL/SQL legacy code in the steel making domain, we developed tool support for the reverse engineering of PL/SQL code into a more abstract and comprehensive representation. This representation then serves as input for stakeholders to manually analyze legacy code, to identify obsolete and missing business cases, and, finally, to support the re-implementation of a new system. In this paper we briefly introduce the tool and present results of reverse engineering PL/SQL legacy code in the steel making domain. We show how stakeholders are supported in analyzing legacy code by means of general-purpose analysis techniques combined with domain-specific representations and conclude with some of the lessons learned.	1063-6773	978-1-4799-6146-7		reverse engineering;program comprehension;source code analysis	Production;Reverse engineering;Business;Databases;Flow graphs;Software;Steel	reverse engineering;software maintenance;SQL	reverse engineering PL/SQL legacy code;automatic transformation;business cases;legacy code analysis;steel making;general-purpose analysis techniques;domain specific representations		9		6		6 Dec 2014			IEEE	IEEE Conferences
Locating and Understanding Features of Complex Software Systems by Synchronizing Time-, Collaboration- and Code-Focused Views on Execution Traces	locating and understanding features of complex software systems by synchronizing time, collaboration and codefocused views on execution traces	10.1109/ICPC.2008.21	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556142	J. Bohnet; S. Voigt; J. Dollner	University of Potsdam Hasso-Plattner-Institute, Potsdam, Germany; University of Potsdam Hasso-Plattner-Institute, Potsdam, Germany; Hasso-Plattner-Inst., Potsdam Univ., Potsdam	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			268	271	Extending or modifying features of complex software systems is often a highly time-consuming and cost-intensive task as, beforehand, the features have to be located within the code and to be understood in detail. To support developers in performing this task, we propose a technique that takes execution traces and implementation unit structuring as input data and provides various views thereupon. Views focus on different trace characteristics, namely they are time-, collaboration-, and code-focused. Synchronizing the views creates a rich user interface that helps developers to effectively identify and understand feature relevant parts of the implementation.	1092-8138	978-0-7695-3176-2		Software Visualization;Program Comprehension;Feature Location;Feature Comprehension;Reverse Engineering;Dynamic Analysis;Maintenance	Software systems;Collaborative software;User interfaces;Data mining;International collaboration;Information analysis;Control systems;Phase detection;Visualization;Software prototyping	software engineering;user interfaces	complex software systems;code-focused views;execution traces;unit structuring;trace characteristics;user interface		9		14		2 jul. 2008			IEEE	IEEE Conferences
Inferring Hierarchical Motifs from Execution Traces	inferring hierarchical motifs from execution traces	10.1145/3180155.3180216	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453150	S. Alimadadi; A. Mesbah; K. Pattabiraman	Northeastern University, Boston, MA, US; The University of British Columbia Faculty of Medicine, Vancouver, BC, CA; The University of British Columbia Faculty of Medicine, Vancouver, BC, CA	2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)	2 Sep 2018	2018			776	787	Program comprehension is a necessary step for performing many software engineering tasks. Dynamic analysis is effective in producing execution traces that assist comprehension. Traces are rich sources of information regarding the behaviour of a program. However, it is challenging to gain insight from traces due to their overwhelming amount of data and complexity. We propose a generic technique for facilitating comprehension by inferring recurring execution motifs. Inspired by bioinformatics, motifs are patterns in traces that are flexible to small changes in execution, and are captured in a hierarchical model. The hierarchical nature of the model provides an overview of the behaviour at a high-level, while preserving the execution details and intermediate levels in a structured manner. We design a visualization that allows developers to observe and interact with the model. We implement our approach in an open-source tool, called Sabalan, and evaluate it through a user experiment. The results show that using Sabalan improves developers' accuracy in performing comprehension tasks by 54%.	1558-1225	978-1-4503-5638-1		Program comprehension;behavioural model;hierarchical motifs	Tools;Task analysis;Electronic mail;Biological system modeling;Software engineering;Bioinformatics;Data visualization	bioinformatics;object-oriented programming;program visualisation;software engineering;software maintenance	execution traces;program comprehension;software engineering tasks;dynamic analysis;assist comprehension;execution motifs;hierarchical model;hierarchical nature;execution details;comprehension tasks;inferring hierarchical motifs		8				2 Sep 2018			IEEE	IEEE Conferences
A software behaviour analysis framework based on the human perception systems: NIER track	a software behaviour analysis framework based on the human perception systems nier track	10.1145/1985793.1985955	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032559	H. Pirzadeh; A. Hamou-Lhadj	Software Behaviour Analysis Laboratory, Department of Electrical and Computer Engineering, Concordia University, Canada; Software Behaviour Analysis Laboratory, Department of Electrical and Computer Engineering, Concordia University, Canada	2011 33rd International Conference on Software Engineering (ICSE)	10 Oct 2011	2011			948	951	Understanding software behaviour can help in a variety of software engineering tasks if one can develop effective techniques for analyzing the information generated from a system's run. These techniques often rely on tracing. Traces, however, can be considerably large and complex to process. In this paper, we present an innovative approach for trace analysis inspired by the way the human brain and perception systems operate. The idea is to mimic the psychological processes that have been developed over the years to explain how our perception system deals with huge volume of visual data. We show how similar mechanisms can be applied to the abstraction and simplification of large traces. Some preliminary results are also presented.	1558-1225	978-1-4503-0445-0		dynamic analysis;human perception;phase detection;program comprehension;psychological processes;trace analysis	Humans;Visualization;Unified modeling language;Software;Psychology;Software engineering;Phase detection	brain;data analysis;psychology;software engineering;visual databases;visual perception	software engineering;software behaviour analysis;trace analysis;human brain;psychological process;human perception system;visual data;NIER track		7		16		10 Oct 2011			IEEE	IEEE Conferences
Practical Eye Tracking with iTrace	practical eye tracking with itrace	10.1109/EMIP.2019.00015	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8834693	B. Sharif; C. Peterson; D. Guarnera; C. Bryant; Z. Buchanan; V. Zyrianov; J. Maletic	Department of Computer Science and Engineering, University of Nebraska-Lincoln, Lincoln, Nebraska, USA 68588; Department of Computer Science and Engineering, University of Nebraska-Lincoln, Lincoln, Nebraska, USA 68588; Department of Computer Science, Kent State University, Kent, Ohio, USA 44242; Department of Computer Science, Kent State University, Kent, Ohio, USA 44242; Department of Computer Science, Kent State University, Kent, Ohio, USA 44242; Department of Computer Science, Kent State University, Kent, Ohio, USA 44242; Department of Computer Science, Kent State University, Kent, Ohio, USA 44242	2019 IEEE/ACM 6th International Workshop on Eye Movements in Programming (EMIP)	12 Sep 2019	2019			41	42	The evolution and effort in designing and implementing iTrace, an infrastructure for integrating eye tracking into developer environments, is presented. The goal is to make eye tracking practical for various stakeholders in software engineering namely researchers, practitioners, and educators. An overview of iTrace and the general process involved in conducting an eye tracking study with human subjects using iTrace is presented in this tool demo paper. Upcoming features and ongoing plans for community involvement are also presented.		978-1-7281-2243-4		eye tracking, practical solution, integrated development environments, program comprehension, empirical studies	Gaze tracking;Tools;Software;Visualization;Software engineering;Computer bugs;Conferences	eye;gaze tracking;object tracking;software engineering	practical eye tracking;developer environments;iTrace;software engineering		6		4		12 Sep 2019			IEEE	IEEE Conferences
iTrace: Overcoming the Limitations of Short Code Examples in Eye Tracking Experiments	itrace overcoming the limitations of short code examples in eye tracking experiments	10.1109/ICSME.2016.61	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7816534	B. Sharif; J. I. Maletic	Youngstown State University, Youngstown, OH, US; Dept. of Comput. Sci., Kent State Univ. Kent, Kent, OH, USA	2016 IEEE International Conference on Software Maintenance and Evolution (ICSME)	16 jan. 2017	2016			647	647	Summary form only given. Eye trackers are being used by software engineering researchers to study how developers work. In this technical briefing, we give an overview of eye tracking and how it can help researchers to conduct their own studies. Eye tracking studies are done on a single screen of text and there is no support for scrolling or switching between files. This scenario is impractical to study developers as they actually work on large software artifacts. To overcome this an Eclipse plugin, iTrace, is introduced that monitors developers eye movements even in the presence of scrolling and file switching within an IDE. In addition, it automatically maps the eye gaze to source code elements. Existing work using iTrace is presented followed by a scenario of how to setup and run an eye tracking study. Data filtering, data cleaning, and data analysis are also discussed.		978-1-5090-3806-0		eye tracking;program comprehension	Conferences;Software maintenance	data analysis;research and development;software engineering	iTrace;short code examples;eye tracking experiments;software engineering research;Eclipse plugin;software artifacts;source code elements;data filtering;data cleaning;data analysis		5				16 jan. 2017			IEEE	IEEE Conferences
Visual Support for Understanding Product Lines	visual support for understanding product lines	10.1109/ICPC.2010.15	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521778	J. Feigenspan; C. Kästner; M. Frisch; R. Dachselt; S. Apel	University of Magdeburg, Germany; University of Magdeburg, Germany; University of Magdeburg, Germany; University of Magdeburg, Germany; University of Passau, Germany	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			34	35	The C preprocessor is often used in practice to implement variability in software product lines. Using #ifdef statements provokes problems such as obfuscated source code, yet they will still be used in practice at least in the medium-term future. With CIDE, we demonstrate a tool to improve understanding and maintaining code that contains #ifdef statements by visualizing them with colors and providing different views on the code.	1092-8138	978-1-4244-7603-9		Program comprehension;Software product lines;Software visualization	Visualization;Scattering;Humans;Maintenance engineering;Software systems;Time to market;Mass customization;Printers;Microprogramming;Linux	program visualisation;software engineering;software tools;source coding	visual support;C preprocessor;#ifdef statements;software product lines;CIDE		5		9		26 jul. 2010			IEEE	IEEE Conferences
Case Study of Feature Location Using Dependence Graph, after 10 Years	case study of feature location using dependence graph, after 10 years	10.1109/ICPC.2010.40	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521782	K. Chen; V. Rajlich	Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			1	3	This retrospective briefly recapitulates the original paper that was published at IWPC 2000, overviews selected papers that were published in its wake, presents recent clarifications and updates of the topic, and mentions the still unfinished agenda and future work.	1092-8138	978-1-4244-7603-9		Software evolution;program comprehension;dependency analysis;concept location	Cross layer design;Programming profession;Computer science;USA Councils;Inspection	software engineering	feature location;dependence graph;IWPC 2000		5		21		26 jul. 2010			IEEE	IEEE Conferences
An Open Dataset of Abbreviations and Expansions	an open dataset of abbreviations and expansions	10.1109/ICSME.2019.00041	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8919073	C. Newman; M. J. Decker; R. S. AlSuhaibani; A. Peruma; D. Kaushik; E. Hill	Rochester Institute of Technology, Rochester, NY, USA; Bowling Green State University, Bowling Green, OH, USA; Kent State University, Kent, OH, USA; Rochester Institute of Technology, Rochester, NY, USA; Rochester Institute of Technology, Rochester, NY, USA; Drew University, New Jersey, USA	2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)	5 Dec 2019	2019			280	280	We present a data set of abbreviations and expansions, derived from a set of five open source systems, for use by the research and development communities.	2576-3148	978-1-7281-3094-1		Abbreviation Expansion;program comprehension	Tools;Conferences;Software maintenance;Research and development;Indexes;Dictionaries;Natural languages	public domain software	data set;open source systems;abbreviations;expansions		5		1		5 Dec 2019			IEEE	IEEE Conferences
DPDX--Towards a Common Result Exchange Format for Design Pattern Detection Tools	dpdxtowards a common result exchange format for design pattern detection tools	10.1109/CSMR.2010.40	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5714440	G. Kniesel; A. Binun; P. Hegedüs; L. J. Fülöp; A. Chatzigeorgiou; Y. -G. Gueheneuc; N. Tsantalis	University of Bonn, Bonn, Germany; University of Bonn, Bonn, Germany; University of Szeged, Szeged, Hungary; University of Szeged, Szeged, Hungary; University of Macedonia, Thessaloniki, Greece; École Poly technique de Montréal, Québec, Canada; University of Macedonia, Thessaloniki, Greece	2010 14th European Conference on Software Maintenance and Reengineering	17 Feb 2011	2010			232	235	Tools for design pattern detection (DPD) can ease program comprehension, helping programmers understand the design and intention of certain parts of a system's implementation. Many tools have been proposed in the past. However, the many different output formats used by the tools make it difficult to compare their results and to improve their accuracy and performance through data fusion. In addition, all the output formats have been shown to have several limitations in both their forms and contents. Consequently, we develop DPDX, a rich common exchange format for DPD tools, to overcome previous limitations. DPDX provides the basis for an open federation of tools that perform comparison, fusion, visualisation, and-or validation of DPD results.	1534-5351	978-0-7695-4321-5		design pattern;program comprehension;exchange format	Software maintenance;Conferences;Europe;Programming;Visualization;Concrete	object-oriented methods;reverse engineering;sensor fusion;software tools	DPDX;common result exchange format;design pattern detection tools;program comprehension;data fusion;object-oriented design patterns		4		13		17 Feb 2011			IEEE	IEEE Conferences
DynaRIA: A Tool for Ajax Web Application Comprehension	dynaria a tool for ajax web application comprehension	10.1109/ICPC.2010.16	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521772	D. Amalfitano; A. R. Fasolino; A. Polcaro; P. Tramontana	Dipartimento di Informatica e Sistemistica, Università degli Studi di Napoli Federico II, Napoli, Italy; Dipartimento di Informatica e Sistemistica, Università degli Studi di Napoli Federico II, Napoli, Italy; Dipartimento di Informatica e Sistemistica, Università degli Studi di Napoli Federico II, Napoli, Italy; Dipartimento di Informatica e Sistemistica, Università degli Studi di Napoli Federico II, Napoli, Italy	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			46	47	Thanks to Rich Internet Applications (RIAs) with their enhanced interactivity, responsiveness and dynamicity, the user experience in the Web 2.0 is becoming more and more appealing and user-friendly. At the same time, the dynamic nature of RIAs, and the heterogeneous technologies, frameworks, communication models used for implementing them negatively affect their analyzability and understandability, so that specific software techniques and tools are needed for supporting their comprehension. This paper presents DynaRIA, a tool for the comprehension of RIAs implemented in Ajax that is based on dynamic analysis and provides functionalities for recording and analyzing user sessions from several perspectives, and producing various types of abstractions and visualizations about the run-time behaviour of the application.	1092-8138	978-1-4244-7603-9		Rich Internet Applications;Dynamic Analysis;Program Comprehension Tool;Reverse Engineering;AJAX Application	Java;Internet;Runtime;User interfaces;Search engines;US Department of Transportation;Delay;Communications technology;Software tools;Visualization	Internet;program visualisation;software tools;user interfaces	DynaRIA;Ajax Web application comprehension;rich Internet applications;Web 2.0;heterogeneous technologies;communication models;software techniques;software tools;dynamic analysis;user sessions;run-time behaviour		4	1	3		26 jul. 2010			IEEE	IEEE Conferences
Dynamic model design recovery and architecture abstraction of object oriented software	dynamic model design recovery and architecture abstraction of object oriented software	10.1109/CSMR.2005.26	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1402144	Qingshan Li	Software Engineering Institute, Xidian University, Xi'an, China	Ninth European Conference on Software Maintenance and Reengineering	4 Apr 2005	2005			284	287	The paper gives an overview of a Ph.D. thesis and describes the main contents of the thesis. The thesis makes research on reverse engineering of object-oriented software at source codes level. According to the dynamic property of object-oriented software system, a group of models, mechanisms and algorithms that can be used to extract dynamic information and abstract high-level models of such systems are provided in the thesis. A group of systematic experiments are also conducted in the thesis so as to verify the correctness, validity and other related performance of these dynamic model design recovery and architecture abstraction algorithms.	1534-5351	0-7695-2304-8		Reverse Engineering;Design Recovery;Program Comprehension;Architecture Abstraction;Object Orientation	Object oriented modeling;Computer architecture;Instruments;Reverse engineering;Software systems;Software algorithms;Data mining;Reflection;Clustering algorithms;Algorithm design and analysis	reverse engineering;object-oriented programming;data structures;software architecture;formal verification	dynamic model;design recovery;architecture abstraction;object oriented software;reverse engineering;dynamic information		4				4 Apr 2005			IEEE	IEEE Conferences
Toward Comprehension of Side Effects in Framework Applications as Feature Interactions	toward comprehension of side effects in framework applications as feature interactions	10.1109/APSEC.2012.128	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6462732	I. Kume; M. Nakamura; E. Shibayama	Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan; Graduate School of System Informatics, Kobe University, Nada, Kobe, Japan; Information Technology Center, University of Tokyo, Bunkyo, Tokyo, Japan	2012 19th Asia-Pacific Software Engineering Conference	18 Feb 2013	2012	1		713	716	Application frameworks are widely used in order to increase efficiency and reliability in object-oriented software development. In this paper we put a focus on side effects caused by misuse of frameworks. A processes of such a side effect often includes cross-border method invocations between an application and its framework, and is difficult to resolve. This paper proposes an approach to visualizing such a side effect as a feature interaction between a framework and its application. This paper shows a case study to apply our approach to a practical framework application, and discuss its practical usefulness.	1530-1362	978-1-4673-4930-7		feature interactions;side effects;program comprehension	Visualization;Couplings;Receivers;Educational institutions;Software;Java;Electronic mail	object-oriented programming;reverse engineering;software reliability;software reusability	side effect comprehension;feature interaction;application framework;object-oriented software development;cross-border method;program comprehension		4		8		18 Feb 2013			IEEE	IEEE Conferences
A Systematic Analysis of Software Architecture Visualization Techniques	a systematic analysis of software architecture visualization techniques	10.1109/ICPC.2011.40	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970175	Z. Sharafi	SOCCER Laboratory-Ptidej Team, Département Génie Informatique et Génie Logiciel, École Polytechnique de Montréal, Montreal, Canada	2011 IEEE 19th International Conference on Program Comprehension	1 Aug 2011	2011			254	257	The visualization of software systems allows a software developer to build a mental model of the program supporting her to better understand its design and functionality. This research aims at studying current visualization techniques and practices to propose a set of principles for designing effective software architecture visualization techniques, focusing on their support for program comprehension. The research will be carried out in three main phases. First, we will complement current works by proposing a taxonomy of visualization techniques. The second contribution will be to identify different requirements and characteristics of architecture visualization techniques. Finally, to evaluate software visualization's usability and effectiveness in practice, we will measure the performance of developers in terms of their percentage of the correct answers and effort developers spend to answer given questions. To compute the developer's effort, we will use eye-tracker's data.	1092-8138	978-0-7695-4398-7		Software visualization;Software architecture;program comprehension;usability;eye tracking;usability	Visualization;Usability;Software architecture;Computer architecture;Software systems;Measurement	data visualisation;reverse engineering;software architecture;software quality	systematic analysis;software architecture visualization technique;program comprehension		4		37		1 Aug 2011			IEEE	IEEE Conferences
Do You Remember This Source Code?	do you remember this source code	10.1145/3180155.3180215	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453149	J. Krüger; J. Wiemann; W. Fenske; G. Saake; T. Leich	Hochschule Harz - Hochschule fur angewandte Wissenschaften, Wernigerode, DE; Otto von Guericke Universitat Magdeburg, Magdeburg, Sachsen-Anhalt, DE; Otto von Guericke Universitat Magdeburg, Magdeburg, Sachsen-Anhalt, DE; Otto von Guericke Universitat Magdeburg, Magdeburg, Sachsen-Anhalt, DE; Hochschule Harz - Hochschule fur angewandte Wissenschaften, Wernigerode, DE	2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)	2 Sep 2018	2018			764	775	Being familiar with the source code of a program comprises knowledge about its purpose, structure, and details. Consequently, familiarity is an important factor in many contexts of software development, especially for maintenance and program comprehension. As a result, familiarity is considered to some extent in many different approaches, for example, to model costs or to identify experts. Still, all approaches we are aware of require a manual assessment of familiarity and empirical analyses of forgetting in software development are missing. In this paper, we address this issue with an empirical study that we conducted with 60 open-source developers. We used a survey to receive information on the developers' familiarity and analyze the responses based on data we extract from their used version control systems. The results show that forgetting is an important factor when considering familiarity and program comprehension of developers. We find that a forgetting curve is partly applicable for software development, investigate three factors - the number of edits, ratio of owned code, and tracking behavior - that can impact familiarity with code, and derive a general memory strength for our participants. Our findings can be used to scope approaches that have to consider familiarity and they provide insights into forgetting in the context of software development.	1558-1225	978-1-4503-5638-1		familiarity;forgetting;empirical study;maintenance;program comprehension;expert identification;knowledge management	Software;Software engineering;Task analysis;Maintenance engineering;Psychology;Software reliability	configuration management;software development management;software maintenance	source code;software development;owned code;open-source developers		4				2 Sep 2018			IEEE	IEEE Conferences
Using ontology fragments in concept location	using ontology fragments in concept location	10.1109/ICSM.2010.5609555	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609555	L. A. Wilson	Department of Computer Science, Wayne State University, Detroit, MI, USA	2010 IEEE International Conference on Software Maintenance	25 Oct 2010	2010			1	2	Concept location is the process of locating relevant source code fragments where a change must be made. Concept location requires programmers' understanding of the program and their ability to formulate effective concept location queries. This research presents a systematic approach to query formulation that uses ontology fragments. Preliminary results of a case study demonstrate that only small, partial knowledge represented by small ontology fragments is needed for a successful concept location. The ontology fragments also document programmer learning that takes place during the concept location.	1063-6773	978-1-4244-8629-8		concept location;program comprehension;software maintenance	Software maintenance	ontologies (artificial intelligence);query formulation;source coding	ontology fragment;concept location;source code fragment;query formulation		4		8		25 Oct 2010			IEEE	IEEE Conferences
View infinity: a zoomable interface for feature-oriented software development	view infinity a zoomable interface for featureoriented software development	10.1145/1985793.1985987	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032584	M. Stengel; M. Frisch; S. Apel; J. Feigenspan; C. Kastner; R. Dachselt	University of Magdeburg, Germany; University of Magdeburg, Germany; University of Magdeburg, Germany; University of Marburg, Germany; University of Passau, Germany; University of Magdeburg, Germany	2011 33rd International Conference on Software Engineering (ICSE)	10 Oct 2011	2011			1031	1033	Software product line engineering provides efficient means to develop variable software. To support program comprehension of software product lines (SPLs), we developed View Infinity, a tool that provides seamless and semantic zooming of different abstraction layers of an SPL. First results of a qualitative study with experienced SPL developers are promising and indicate that View Infinity is useful and intuitive to use.	1558-1225	978-1-4503-0445-0		program comprehension;semantic zooming;software product lines;variability	Software;Image color analysis;Semantics;Programming;Software engineering;Histograms;Visualization	product development;reverse engineering;software reusability	view infinity;zoomable interface;feature-oriented software development;software product line engineering;program comprehension;semantic zooming;seamless zooming;abstraction layers		4	1	8		10 Oct 2011			IEEE	IEEE Conferences
VisioTM: A Tool for Visualizing Source Code Based on Topic Modeling	visiotm a tool for visualizing source code based on topic modeling	10.1109/COMPSAC.2019.00147	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8754484	S. Reddivari; M. S. Khan	School of Computing, University of North Florida, Jacksonville, USA; School of Computing, University of North Florida, Jacksonville, USA	2019 IEEE 43rd Annual Computer Software and Applications Conference (COMPSAC)	9 jul. 2019	2019	1		932	933	Latent Dirichlet Allocation (LDA) is a statistical topic modeling approach that has been used to support various software engineering activities. However, the main problem is the probabilistic distributions generated by LDA to represent topics and documents are not intuitive and easy to comprehend. In order to address this problem, in this paper, we present VisioTM, a language-independent platform to visualize software systems based on LDA. VisioTM provides several visualizations to represent the basic elements of LDA including words, topics, and documents. We discuss the key features and functionalities of the tool.	0730-3157	978-1-7281-2607-4		Software Visualization;Program Comprehension;Topic Modeling;LDA	Visualization;Tools;Computational modeling;Software engineering;Probabilistic logic;Software systems	program visualisation;source code (software);statistical distributions	software engineering activities;probabilistic distributions;VisioTM;language-independent platform;software systems;statistical topic modeling approach;latent Dirichlet allocation;source code visualization;LDA		3		10		9 jul. 2019			IEEE	IEEE Conferences
Metric Attitude	metric attitude	10.1109/CSMR.2013.59	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6498498	M. Risi; G. Scanniello; G. Tortora	Universitá di Salerno, Italy; University della Basilicata, Italy; Universitá di Salerno, Italy	2013 17th European Conference on Software Maintenance and Reengineering	15 Apr 2013	2013			405	408	We present Metric Attitude, an Eclipse Rich Client Platform application, for the reverse engineering of object-oriented software systems. The approach graphically represents a suite of object-oriented design metrics and "traditional" code-size metrics. To assess the validity of Metric Attitude and its underlying approach, we have conducted a case study on the framework Eclipse 3.5.	1534-5351	978-0-7695-4948-4		Program Comprehension;Reverse Engineering;Software Maintenance;Software Metrics;Software Visualization Tool	Visualization;Measurement;Software;Reverse engineering;Java;Layout;Color	object-oriented methods;reverse engineering;software metrics	metric attitude;Eclipse rich client platform application;reverse engineering;object-oriented software systems;object-oriented design metrics;code-size metrics;Eclipse 3.5 framework		3		9		15 Apr 2013			IEEE	IEEE Conferences
Modeling the Relationship Between Identifier Name and Behavior	modeling the relationship between identifier name and behavior	10.1109/ICSME.2019.00062	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8919135	C. D. Newman; A. Preuma; R. AlSuhaibani	Rochester Institute of Technology, Rochester, NY, USA; Rochester Institute of Technology, Rochester, NY, USA; Kent State University, Kent, OH, USA, Prince Sultan University, Riyadh, Saudi Arabia	2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)	5 Dec 2019	2019			376	378	This paper presents the features of a model that relates the natural language found in identifiers with program semantics. The model takes advantage of part of speech information and static-analysis-based program models to understand how different types of statically-derived semantics correlates with the natural language meaning of identifiers.	2576-3148	978-1-7281-3094-1		Program Comprehension, Identifier Names, Static Analysis	Grammar;Semantics;Natural languages;Conferences;Software maintenance;Europe	natural language processing;program diagnostics	natural language;statically-derived semantics;static-analysis-based program models;speech information;program semantics;identifier name		3		30		5 Dec 2019			IEEE	IEEE Conferences
FireDetective: understanding ajax client/server interactions	firedetective understanding ajax client/server interactions	10.1145/1985793.1985973	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032573	N. Matthijssen; A. Zaidman	Delft University of Technology, Netherlands; Delft University of Technology, Netherlands	2011 33rd International Conference on Software Engineering (ICSE)	10 Oct 2011	2011			998	1000	Ajax-enabled web applications are a new breed of highly interactive, highly dynamic web applications. Although Ajax allows developers to create rich web applications, Ajax applications can be difficult to comprehend and thus to maintain. FireDetective aims to facilitate the understanding of Ajax applications. It uses dynamic analysis at both the client (browser) and server side and subsequently connects both traces for further analysis.	1558-1225	978-1-4503-0445-0		ajax;dynamic analysis;program comprehension;web applications	Fires;Servers;Java;Browsers;Data visualization;Libraries;Visualization	client-server systems;Internet;system monitoring	FireDetective;Ajax client-server interaction;Ajax-enabled Web application;dynamic analysis		2	1	9		10 Oct 2011			IEEE	IEEE Conferences
The ConAn Tool to Identify Crosscutting Concerns in Object Oriented Systems	the conan tool to identify crosscutting concerns in object oriented systems	10.1109/ICPC.2010.34	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521773	M. L. Bernardi; G. A. Di Lucca	Department of Engineering-RCOST, University of Sannio, Benevento, Italy; Department of Engineering-RCOST, University of Sannio, Benevento, Italy	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			48	49	This paper presents the main features of Con An, a tool supporting an approach to find scattered and tangled class members in OO systems and to group them in concerns. The recovered information is useful for refactoring/migration tasks, such as towards Aspect Oriented Programming (AOP).	1092-8138	978-1-4244-7603-9		Aspect Oriented Programming;Program Comprehension;Reverse Engineering	Scattering;Performance analysis;Symmetric matrices;Java;Data mining;Genetic programming;Encapsulation;Helium;Inspection	aspect-oriented programming;software tools	ConAn tool;OO systems;object-oriented systems;aspect oriented programming;refactoring task;migration tasks;crosscutting concern identification		2		2		26 jul. 2010			IEEE	IEEE Conferences
Enhancing Object-Oriented Programming Comprehension Using Optimized Sequence Diagram	enhancing objectoriented programming comprehension using optimized sequence diagram	10.1109/CSEET.2016.37	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7474469	M. Srinivasan; Y. Lee; J. Yang	Electrical Engineering and Computer Science, Texas A&M University-Kingsville, Kingsville, TX, USA; Electrical Engineering and Computer Science, Texas A&M University-Kingsville, Kingsville, TX, USA; Electrical Engineering and Computer Science, Texas A&M University-Kingsville, Kingsville, TX, USA	2016 IEEE 29th International Conference on Software Engineering Education and Training (CSEET)	23 May 2016	2016			81	85	This paper presents how to generate an optimized sequence diagram from static java source code and dynamic execution trace at a web-based educational programming environment. The aim of this research is to help student programmers better understand the dynamic behavior of a java program using optimized sequence diagram, therefore to enhance object-oriented programming learning experience.	2377-570X	978-1-5090-0765-3		sequence diagram;polymorphism;object-oriented;visualization;program comprehension	Shape;Visualization;Java;Unified modeling language;Grammar;Object oriented programming;Complexity theory	computer aided instruction;computer science education;Internet;Java;object-oriented programming;source code (software);Unified Modeling Language	optimized sequence diagram;static Java source code;dynamic execution trace;Web-based educational programming environment;object-oriented programming learning experience		2		18		23 May 2016			IEEE	IEEE Conferences
Automatic comment generation using only source code	automatic comment generation using only source code	10.1109/SIU.2017.7960702	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7960702	E. Yildiz; E. Ekin	Bilgisayar Mühendisliği Bölümü, Işık Üniversitesi, İstanbul, Türkiye; Bilgisayar Mühendisliği Bölümü, Işık Üniversitesi, İstanbul, Türkiye	2017 25th Signal Processing and Communications Applications Conference (SIU)	29 jun. 2017	2017			1	4	In this study, automatic comment generation for Java methods is described. It is sufficient that the codes conform to the syntax rules of the Java programming language, and it is not expected to be runnable. In order to generate comments, source code is examined syntactically. At this stage, only the method signature and its return type is needed. By working on open source Java projects, different templates have been developed for different method types. Using the compiled information which is the result of the examining source code that is currently being developed, the most suitable template is chosen and texts are created. These texts explain the aim of the method. Created texts are added to source code as a comment.		978-1-5090-6494-6		source code summarization;documentation generation;program comprehension	Java;Documentation;Syntactics;Reactive power;Cloning;Two dimensional displays	automatic programming;Java;object-oriented programming	automatic comment generation;source code;Java methods;Java programming language;syntax rule;open source Java project;compiled information		2		9		29 jun. 2017			IEEE	IEEE Conferences
Retrieve and Refine: Exemplar-Based Neural Comment Generation	retrieve and refine exemplarbased neural comment generation	10.1109/ASE.2019.00152	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952536	B. Wei	Key Laboratory of High Confidence Software Technologies, (Peking University) Ministry of Education, China; Software Institute, Peking University, China	2019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)	9 jan. 2020	2019			1250	1252	Code comment generation is a crucial task in the field of automatic software development. Most previous neural comment generation systems used an encoder-decoder neural network and encoded only information from source code as input. Software reuse is common in software development. However, this feature has not been introduced to existing systems. Inspired by the traditional IR-based approaches, we propose to use the existing comments of similar source code as exemplars to guide the comment generation process. Based on an open source search engine, we first retrieve a similar code and treat its comment as an exemplar. Then we applied a seq2seq neural network to conduct an exemplar-based comment generation. We evaluate our approach on a large-scale Java corpus, and experimental results demonstrate that our model significantly outperforms the state-of-the-art methods.	2643-1572	978-1-7281-2508-4		comment generation;program comprehension;deep learning	Java;Neural networks;Task analysis;Software reusability;Search engines;Correlation	decoding;neural nets;public domain software;search engines;software engineering	exemplar-based neural comment generation;code comment generation;automatic software development;encoder-decoder neural network;software reuse;IR-based approaches;similar source code;comment generation process;open source search engine;seq2seq neural network;exemplar-based comment generation;neural comment generation systems		1		21		9 jan. 2020			IEEE	IEEE Conferences
Sound as an Aid in Understanding Low-Level Program Architecture	sound as an aid in understanding lowlevel program architecture	10.1109/ICPC.2010.55	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521766	L. Berman	School of Engineering and Computing Sciences, University of Durham, Durham, UK	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			58	59	A tool and associated sound mapping have been developed for exploring and understanding the static structure of Java programs' packages, classes, interfaces, and methods. The tool supplements visual use of the Eclipse IDE. A sound mapping provides information regarding the identification of, characteristics of, and relationships among the architectural entities.	1092-8138	978-1-4244-7603-9		sonification;program comprehension;auditory display;non-visual representations	Packaging;Java;Birds;Concrete;Satellites;Earth;Feedback;Pattern recognition;Computer architecture;Acoustical engineering	audio acoustics;Java;software architecture	low-level program architecture;sound mapping;Java programs;Eclipse IDE;integrated development environment		1		2		26 jul. 2010			IEEE	IEEE Conferences
SeTransformer: A Transformer-Based Code Semantic Parser for Code Comment Generation	setransformer a transformerbased code semantic parser for code comment generation	10.1109/TR.2022.3154773	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9744328	Z. Li; Y. Wu; B. Peng; X. Chen; Z. Sun; Y. Liu; D. Paul	College of Information Science and Technology, Beijing University of Chemical Technology, Beijing 100013 China.; College of Information Science and Technology, Beijing University of Chemical Technology, Beijing 100013 China.; College of Information Science and Technology, Beijing University of Chemical Technology, Beijing 100013 China.; School of Information Science and Technology, Nantong University, Nantong 226007 China.; School of Electronic Engineering and Computer Science, Peking University, Beijing 100871 China.; College of Information Science and Technology, Beijing University of Chemical Technology, Beijing 100013 China.; School of Computer Science, Technological University Dublin D07 EWV4, Dublin Ireland.	IEEE Transactions on Reliability		2022	PP	99	1	16	Automated code comment generation technologies can help developers understand code intent, which can significantly reduce the cost of software maintenance and revision. The latest studies in this field mainly depend on deep neural networks, such as convolutional neural networks and recurrent neural network. However, these methods may not generate high-quality and readable code comments due to the long-term dependence problem, which means that the code blocks used to summarize information are far from each other. Owing to the long-term dependence problem, these methods forget the previous input data’s feature information during the training process. In this article, to solve the long-term dependence problem and extract both the text and structure information from the program code, we propose a novel improved-Transformer-based comment generation method, named SeTransformer. Specifically, the SeTransformer utilizes the code tokens and an abstract syntax tree (AST) of programs to extract information as the inputs, and then, it leverages the self-attention mechanism to analyze the text and structural features of code simultaneously. Experimental results based on public corpus gathered from large-scale open-source projects show that our method can significantly outperform five state-of-the-art baselines (such as Hybrid-DeepCom and AST-attendgru). Furthermore, we also conduct a questionnaire survey for developers, and the results show that the SeTransformer can generate higher quality comments than those of other baselines.	1558-1721		National Natural Science Foundation of China(grant numbers:61902015 61872026); Nantong Application Research Plan(grant numbers:JC2019106); Beijing University of Chemical Technology; 	Code comment generation;convolutional neural network (CNN);deep learning;program comprehension;Transformer	Codes;Transformers;Computational modeling;Training;Convolutional neural networks;Feature extraction;Convolution				1			IEEE	29 mar. 2022			IEEE	IEEE Early Access Articles
Teaching undergraduate software engineering	teaching undergraduate software engineering	10.1109/ICSM.2010.5609587	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609587	V. Rajlich	Department of Computer Science, Wayne State University, Detroit, MI, USA	2010 IEEE International Conference on Software Maintenance	25 Oct 2010	2010			1	2	During the last decade, software engineering changed rapidly, from the emphasis on waterfall lifecycle to the emphasis on software evolution and agile programming. This tutorial provides a brief introduction and overview of the results of this development. It presents agile programming, Personal and Team Software Process, software change, concept location, refactoring, and so forth. The organizing principle is an outline of an undergraduate software engineering course that is based on these results. The audience interested in this tutorial may be teachers of software engineering, and also software practitioners who want learn how these results fit together and how to apply them in software projects.	1063-6773	978-1-4244-8629-8		Software evolution;program comprehension;software change;concept location;impact analysis;refactoring;agile development		computer science education;software maintenance;software prototyping	undergraduate software engineering course;open-source project;waterfall lifecycle;software evolution;agile programming		1		13		25 Oct 2010			IEEE	IEEE Conferences
On the Properties of Design-Relevant Classes for Design Anomaly Assessment	on the properties of designrelevant classes for design anomaly assessment	10.1109/ICPC.2017.17	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961533	L. N. Vale; M. A. Maia	Computer Science Department, Federal University of Goiás, Catalão, GO, Brazil; Faculty of Computing, Federal University of Uberlândia, Uberlândia, MG, Brazil	2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC)	29 jun. 2017	2017			332	335	Several object-oriented systems have their respective designs documented by using only a few design-relevant classes, which we will refer to as key classes. In this paper, we automatically detect key classes, and investigate some of their properties, and evaluate their role for assessing design. We propose focusing on such classes to make design decisions during maintenance tasks as those classes of this type are, by definition, more relevant than non-key classes. First, we show that key classes are more prone to bad smells than non-key classes. Although, structural metrics of key classes tend to be, in general, higher than non-key classes, there are still a significant set of non-key classes with poor structural metrics, suggesting that prioritizing design anomaly assessment using key classes would likely to be more effective.		978-1-5386-0535-6		key classes;program comprehension;dynamic analysis;structural complexity	Measurement;Couplings;Documentation;Software design;Complexity theory;Software systems	software architecture	design anomaly assessment;design-relevant classes;object-oriented systems;maintenance tasks;design decisions;non-key classes;key classes;structural metrics		1		12		29 jun. 2017			IEEE	IEEE Conferences
Inventive Tool Use to Comprehend Big Code	inventive tool use to comprehend big code	10.1109/MS.2008.118	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4602681	S. Ratanotayanon; S. E. Sim	Athens University of Economics and Business; Department of Informatics, University of California, lrvine	IEEE Software	19 Aug 2008	2008	25	5	91	92	Software developers often need to understand a large body of unfamiliar code with little or no documentation, no experts to consult, and little time to do it. A post appeared in January 2008 on Slashdot, a technology news Web site, asking for tools and techniques that could help. This article analyzes 301 often passionate and sometimes articulate responses to this query, including the themes and the associated tool recommendations. The most common suggestions were to use a code navigation tool, use a design recovery tool, use a debugger to step through the code, create a runtime trace, use problem-based learning, ask people for help, study the code from top down, and print out all the code. This analysis presents an intriguing snapshot of how software developers in industry go about comprehending big code.	1937-4194			software maintenance;program comprehension;navigation and visualization tools	Programming profession;Runtime;Unified modeling language;Application software;Software libraries;Printing;Navigation;Testing				1		2		19 Aug 2008			IEEE	IEEE Magazines
COSS: Comprehension by ontologising software system	coss comprehension by ontologising software system	10.1109/ICSM.2008.4658097	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4658097	H. Zhou	Software Technology Research Laboratory, De Montfort University, Leicester, UK	2008 IEEE International Conference on Software Maintenance	24 Oct 2008	2008			432	435	Ontology has been investigated in the context of knowledge representation among heterogeneous and disparate knowledge base systems. Our study and experiments suggest that ontology also has a great potential for program comprehension. The main idea is to extract the ontological perspective of existing software system, which is a combination of two kinds of ontology: domain ontology and source code ontology. Domain ontology is domain vocabulary which is built by domain experts, while source code ontology is automatically populated from source code, which represents the knowledge in the existing software. Combining these two ontologies will generate a third ontology, application specific ontology, which is used in program comprehension.	1063-6773	978-1-4244-2613-3		Program Comprehension;Domain knowledge;Source Code;Concepts;Properties;Relations	Ontologies;Software;Software systems;Software algorithms;Knowledge based systems;Documentation;Knowledge representation	ontologies (artificial intelligence);reverse engineering;software maintenance	comprehension by ontologising software system;knowledge representation;knowledge base systems;program comprehension;domain ontology;source code ontology;domain vocabulary;software maintenance		1		10		24 Oct 2008			IEEE	IEEE Conferences
SVS, BORS, SVSi: Three Strategies to Relate Problem and Program Domains	svs, bors, svsi three strategies to relate problem and program domains	10.1109/ICPC.2010.24	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521767	M. M. Berón; M. J. V. Pereira; N. Oliveira; D. da Cruz	Universidad Nacional de San Luis, San Luis, Argentina; University of Minho, Braga, Portugal; Polytechnique Institute of Braganca, Braganca, Portugal; University of Minho, Braga, Portugal	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			60	61	Program Comprehension is improved if: i) the Problem and Program Domains can be related, and ii) this relation is shown in a suitable way to the programmer. Currently, there are few strategies for reaching this important goal because it is not easy to: i) Identify meaningful representations of the problem and program domains, and ii) Define a linking procedure. This poster describes three strategies to overcome the difficulties mentioned above. These strategies use static and dynamic information and traditional compilation techniques for relating both domains.	1092-8138	978-1-4244-7603-9		Program Comprehension;Program Domain;Problem Domain;Comprehension Strategies	Programming profession;Visualization;Instruments;Monitoring;Joining processes;Software engineering;Problem-solving;Software performance;Software maintenance;Data mining	software engineering	SVS;BORS;SVSi;program comprehension;program domains;dynamic information;compilation techniques		1		2		26 jul. 2010			IEEE	IEEE Conferences
Locating features in dynamically configured avionics software	locating features in dynamically configured avionics software	10.1109/ICSE.2012.6227068	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227068	M. Ouellet; E. Merlo; N. Sozen; M. Gagnon	Computer and Software Engineering Department, École Polytechnique de Montréal, Montreal, Canada; Computer and Software Engineering Department, École Polytechnique de Montréal, Montreal, Canada; CMC Electronics, Inc., Saint-Laurent, Canada; CMC Electronics, Inc., Saint-Laurent, Canada	2012 34th International Conference on Software Engineering (ICSE)	28 jun. 2012	2012			1453	1454	Locating features in software is an important activity for program comprehension and to support software reengineering. We present a novel automated approach to locate features in source code based on static analysis and model checking. The technique is aimed at dynamically configured software, which is software in which the activation of specific features is controlled by configuration variables. The approach is evaluated on an industrial avionics system.	1558-1225	978-1-4673-1067-3		Feature;Feature Location;Feature Mapping;Reengineering;Program Comprehension	Software;Aerospace electronics;Analytical models;Security;Aircraft;Information retrieval;Feature extraction	avionics;formal verification;program diagnostics;systems re-engineering	feature location;program comprehension;software reengineering;source code;static analysis;model checking;configuration variables;industrial avionics system		1		8		28 jun. 2012			IEEE	IEEE Conferences
Visualizing the "Hidden" Variables in Robot Programs	visualizing the hidden variables in robot programs	10.1109/RoSE.2019.00007	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8823708	D. C. Shepherd; N. A. Kraft; P. Francis	ABB Corporate Research, Raleigh, USA; ABB Corporate Research, Raleigh, USA; ABB Corporate Research, Raleigh, USA	2019 IEEE/ACM 2nd International Workshop on Robotics Software Engineering (RoSE)	5 Sep 2019	2019			13	16	Programs for one-armed industrial robots include many location-centric statements, such as "Move to location AboveSurface." Unfortunately, developers struggle to understand static location variables like AboveSurface, as mapping their seven-coordinate definitions to the real world is time consuming and error prone. Thus these locations, as well as the paths between them, which constitute the heart of any robot program, are effectively invisible to the programmer. To enable effective robot programming this core data must be visualized. There are two potential approaches to visualizing it. The first, visualizing locations one by one (e.g., by automatically moving the robot to each location) is limited to one location at a time. The second, visualizing locations in virtual reality can show all locations and paths at one time, but eliminates the ability to interact with the real world, which has many drawbacks. To avoid these drawbacks we propose using high-precision mixed reality to visualize program locations and paths, all while preserving the natural interaction with the real world workspace and robot. In this paper we demonstrate the feasibility of such an approach, sketch a solution, and discuss the advantages and disadvantages.		978-1-7281-2249-6		robot programming;program comprehension;mixed reality;augmented reality;virtual reality;liveness	Virtual reality;Visualization;Three-dimensional displays;Data visualization;Service robots;Robot programming	control engineering computing;data visualisation;dexterous manipulators;industrial manipulators;path planning;robot programming;virtual reality	effective robot programming;program location visualization;data visualization;virtual reality;high-precision mixed reality;program path visualization;hidden variables;static location variables;location-centric statements;one-armed industrial robots		1		13		5 Sep 2019			IEEE	IEEE Conferences
Effective Exploration and Visualization of Large Execution Traces	effective exploration and visualization of large execution traces	10.1109/VISSOF.2007.4290715	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4290715	A. Hamou-Lhadj	ECE, Concordia University, Montreal, QUE, Canada	2007 4th IEEE International Workshop on Visualizing Software for Understanding and Analysis	20 Aug 2007	2007			152	153	Understanding the behaviour of a software system can be made easier if dynamic analysis techniques are used. Runtime information is typically represented in the form of execution traces. Raw traces, however, can be extremely large - often millions of lines long. In previous work, we presented a tool called SEAT (Software Exploration and Analysis Tool), which is a trace visualization tool that supports several features for rapid exploration of lengthy traces. In this paper, we present the new features supported by SEA T, namely, the ability to plug-in new trace filtering algorithms, a usable control widget called PictureTree for displaying traces, and several new views that display useful information about the trace under study.		1-4244-0599-8		Reverse engineering;dynamic analysis;trace analysis;program comprehension	Visualization;Filtering algorithms;Software systems;Software tools;Displays;User interfaces;Runtime;Reverse engineering;Graphical user interfaces;Navigation	program diagnostics;program visualisation	runtime information;Software Exploration and Analysis Tool;trace visualization tool;trace filtering algorithm;PictureTree				4		20 Aug 2007			IEEE	IEEE Conferences
Towards a Dynamic Visualization of Complex Reverse-Engineered Object Collaboration	towards a dynamic visualization of complex reverseengineered object collaboration	10.1109/APSEC53868.2021.00071	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9712120	A. Hongo; N. Nitta	Graduate School of Natural Science, Konan University, Kobe, Hyogo, Japan; Graduate School of Natural Science, Konan University, Kobe, Hyogo, Japan	2021 28th Asia-Pacific Software Engineering Conference (APSEC)	17 Feb 2022	2021			568	569	UML is useful to model a higher abstraction level concepts of the software in a forward engineering context, but it is still challenging to reverse engineer more complex behavior of realistic object-oriented programs (OOPs) based on such visualization techniques. For example in a sequence diagram, an object appears in quite different ways when it serves as a sender or receiver of some message and as a parameter or return value of another message, and thus compound method invocations such as invocation chains and callbacks cannot be represented directly. In this paper, first, we define a dynamic metrics named alternation complexity that indicates the number of alternations of object roles between sender/receiver and parameter/return value within collaboration. Through experiments with 12 professional programmers, we confirmed that the metrics captures a certain aspect of difficulty in comprehending features. Furthermore, we present a dynamic visualization model to directly represent collaboration where the types of object roles frequently change.	2640-0715	978-1-6654-3784-4		program comprehension;dynamic visualization;UML;dynamic metrics	Measurement;Visualization;Object oriented modeling;Unified modeling language;Collaboration;Receivers;Software	groupware;object-oriented programming;program visualisation;reverse engineering;software metrics;Unified Modeling Language	complex reverse-engineered object collaboration;forward engineering context;object-oriented programs;sequence diagram;invocation chains;callbacks;dynamic metrics;alternation complexity;dynamic visualization;abstraction level concepts;UML;OOPs;object role alternations;professional programmers				4	IEEE	17 Feb 2022			IEEE	IEEE Conferences
[Journal First] Does Syntax Highlighting Help Programming Novices?	[journal first] does syntax highlighting help programming novices	10.1145/3180155.3182554	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453142	C. Hannebauer; M. Hesenius; V. Gruhn	NA; Universitat Duisburg-Essen, Duisburg, Nordrhein-Westfalen, DE; Universitat Duisburg-Essen, Duisburg, Nordrhein-Westfalen, DE	2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)	2 Sep 2018	2018			704	704	Background: Program comprehension is an important skill for programmers - extending and debugging existing source code is part of the daily routine. Syntax highlighting is one of the most common tools used to support developers in understanding algorithms. However, most research in this area originates from a time when programmers used a completely different tool chain. Objective: We examined the influence of syntax highlighting on novices' ability to comprehend source code. Additional analyses cover the influence of task type and programming experience on the code comprehension ability itself and its relation to syntax highlighting. Method: We conducted a controlled experiment with 390 undergraduate students in an introductory Java programming course. We measured the correctness with which they solved small coding tasks. Each test subject received some tasks with syntax highlighting and some without. Results: The data provided no evidence that syntax highlighting improves novices' ability to comprehend source code. Limitations: There are very few similar experiments and it is unclear as of yet which factors impact the effectiveness of syntax highlighting. One major limitation may be the types of tasks chosen for this experiment. Conclusion: The results suggest that syntax highlighting squanders a feedback channel from the IDE to the programmer that can be used more effectively.	1558-1225	978-1-4503-5638-1		Syntax Highlighting;Source Code Typography;Code Colouring;IDE Interface;Program Comprehension	Syntactics;Task analysis;Programming;Software engineering;Visualization;Human computer interaction;Tools	computer science education;educational courses;feedback;Java;programming;programming environments	source code;syntax highlighting squanders;programming novices;code comprehension;undergraduate students;program comprehension;Java programming course;feedback channel;IDE						2 Sep 2018			IEEE	IEEE Conferences
Poster: Path-Based Function Embeddings	poster pathbased function embeddings		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449611	D. DeFreez; A. Thakur; C. Rubio-González	University of California Davis, Davis, CA, US; University of California Davis, Davis, CA, US; University of California Davis, Davis, CA, US	2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion)	30 Aug 2018	2018			430	431	Identifying relationships among program elements, such as functions, is useful for program understanding, debugging, and analysis. We present func2vec, an algorithm that uses static traces to embed functions in a vector space such that related functions are close together, even if they are semantically and syntactically dissimilar. We present applications of func2vec that aid program comprehension.	2574-1934	978-1-4503-5663-3		Embeddings;Program Comprehension;Systems Software	Linux;Vocabulary;File systems;Heuristic algorithms;Kernel;Software engineering	program debugging;program diagnostics;reverse engineering	path-based function embeddings;program elements;program understanding;debugging;func2vec;static traces;vector space;program comprehension;program analysis						30 Aug 2018			IEEE	IEEE Conferences
Mining the Mind, Minding the Mine: Grand Challenges in Comprehension and Mining	mining the mind, minding the mine grand challenges in comprehension and mining		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8595194	A. J. Ko	University of Washington, Seattle, WA, US	2018 IEEE/ACM 15th International Conference on Mining Software Repositories (MSR)	30 Dec 2018	2018			118	118	The program comprehension and mining software repository communities are, in practice, two separate research endeavors. One is concerned with what's happening in a developer's mind, while the other is concerned with what's happening in a team. And yet, implicit in these fields is a common goal to make better software and the common approach of influencing developer decisions. In this keynote, I provide several examples of this overlap, suggesting several grand challenges in comprehension and mining.	2574-3864	978-1-4503-5716-6		Mining software repositories;program comprehension	Data mining;Tools;Software engineering;Human computer interaction;Configuration management;Software maintenance	data mining;software maintenance	program comprehension;software repository communities mining				0		30 Dec 2018			IEEE	IEEE Conferences
WB4SP: A tool to build the word base for specific programs	wb4sp a tool to build the word base for specific programs	10.1109/ICPC.2016.7503748	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7503748	Weisong Sun; Xiaobing Sun; Hui Yang; Bin Li	School of Information Engineering, Yangzhou University, Yangzhou, China; School of Information Engineering, Yangzhou University, Yangzhou, China; School of Information Engineering, Yangzhou University, Yangzhou, China; School of Information Engineering, Yangzhou University, Yangzhou, China	2016 IEEE 24th International Conference on Program Comprehension (ICPC)	7 jul. 2016	2016			1	3	Software becomes increasingly complex with its continuous maintenance activities. Given a system under maintenance, developers used to employing code search techniques to locate the code of their interests. However, they may have difficulties in understanding the source code elements and the relationship among them in the searching results. If there is a word base for a specific system, the developers can refer it to help locate and recover the source code elements and their relationships, which can improve the maintenance efficiency. In this paper, we present a tool, WB4SP(Word Base for Specific Programs), which focuses on building the word base for a specific system. WB4SP can retrieve the words, recover the relationship between them, and display the evolution of these words during the software evolution.		978-1-5090-1428-6		Source code analysis;word base;program comprehension;code search	Software systems;Software engineering;Maintenance engineering;Natural language processing;Sun;Context	software maintenance;source code (software)	WB4SP;word base for specific programs;software maintenance activities;code search techniques;source code elements;software evolution				8		7 jul. 2016			IEEE	IEEE Conferences
An Analysis of Goal Orientation Pattern and Self-Efficacy for Explanation of Programming Plans	an analysis of goal orientation pattern and selfefficacy for explanation of programming plans	10.1109/ICALT.2015.93	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7265269	C. -C. Tseng; P. -Y. Chao; K. R. Lai	Department of Computer Science, Yuan Ze University, Taoyuan, Taiwan; Department of Computer Science, Yuan Ze University, Taoyuan, Taiwan; Department of Computer Science, Yuan Ze University, Taoyuan, Taiwan	2015 IEEE 15th International Conference on Advanced Learning Technologies	17 Sep 2015	2015			76	77	Since typical introductory programming curricula emphasize the features and syntax of a programming language, rather than the application of programming strategies, most novices are incapable of solving programming problems at the end of curricula. The difference between experts and novices is that experts can develop abstract representation of solutions, called the programming plans, for problems through the experiences obtained from past problems and solutions. The experts then use the programming plans to solve similar program problems. In this study, we develop a system to help students comprehend programming plans by explaining program codes as well as investigate the relationship between goal orientation patterns and self-efficacy.	2161-377X	978-1-4673-7334-0		programming plans;program comprehension;intrinsic goal orientation;extrinsic goal orientation	Problem-solving;Programming profession;Computer science education;Syntactics	computer science education;programming	goal orientation patterns;self-efficacy;programming plans;introductory programming curricula;program comprehension				9		17 Sep 2015			IEEE	IEEE Conferences
Towards Classification of Loop Idioms Automatically Extracted from Legacy Systems	towards classification of loop idioms automatically extracted from legacy systems	10.1109/IWSC.2019.8665854	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8665854	J. Okada; T. Ishio; Y. Sakata; K. Inoue	System Engineering HQ, NTT Data Corporation, Tokyo, Japan; Graduate School of Science and Technology, Nara Institute of Science and Technology, Nara, Japan; System Engineering HQ, NTT Data Corporation, Tokyo, Japan; Graduate School of Information Science and Technology, Osaka University, Osaka, Japan	2019 IEEE 13th International Workshop on Software Clones (IWSC)	14 mar. 2019	2019			34	35	Legacy systems are important in business but difficult to maintain. One of the causes of the difficulties is a large number of code clones in the systems; Those clones implement similar functionalities using common loop idioms in a company. Since the loop idioms have been developed to implement popular functionalities, most of them are likely to be translated into simple SQL statements in a new, modernized version of a system. To investigate the feasibility of the approach, we propose a method to automatically extract cloned loop idioms embedded in COBOL program files. We manually classified the extracted idioms and labeled them according to their functionalities. We evaluated the accuracy of our classification result with three experts.	2572-6587	978-1-7281-1805-5		Legacy Migration;Reverse Engineering;Program Comprehension;Clustering;COBOL	Aging;Cloning;Dictionaries;Companies;Data mining;Software	pattern classification;program control structures;software maintenance;SQL	legacy systems;code clones;cloned loop idioms;classification;SQL statements				4		14 mar. 2019			IEEE	IEEE Conferences
Interactive Model Mining from Embedded Legacy Software	interactive model mining from embedded legacy software		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449633	W. Said	Robert Bosch GmbH, Gerlingen-Schillerhohe, Baden-WÃ¼rttemberg, DE	2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion)	30 Aug 2018	2018			484	487	Model mining from software systems can be very helpful for program comprehension. The few existing approaches for extracting high level models from code - when applied to real-world systems written in C - deliver too detailed and complex models that cannot be understood by humans. In my Ph.D. project, I propose an approach that complements fully-automatic model mining approaches with user interaction to get understandable models. The evaluation of this approach includes a controlled experiment with a large number of experts, in order to assess the effectiveness of the interactively mined models for understanding complex legacy software.	2574-1934	978-1-4503-5663-3		model mining;state machines;software analysis;program comprehension;reverse engineering;embedded software	Object oriented modeling;Data mining;Software;Adaptation models;Static analysis;Tools;Analytical models	data mining;embedded systems;software maintenance	fully-automatic model mining approaches;user interaction;interactively mined models;complex legacy software;interactive model mining;embedded legacy software;software systems;program comprehension						30 Aug 2018			IEEE	IEEE Conferences
Mining the Mind, Minding the Mine: Grand Challenges in Comprehension and Mining	mining the mind, minding the mine grand challenges in comprehension and mining		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8973022	A. Ko	University of Washington	2018 IEEE/ACM 26th International Conference on Program Comprehension (ICPC)	30 jan. 2020	2018			1	10	The program comprehension and mining software repository communities are, in practice, two separate research endeavors. One is concerned with what's happening in a developer's mind, while the other is concerned with what's happening in a team. And yet, implicit in these fields is a common goal to make better software and the common approach of influencing developer decisions. In this keynote, I provide several examples of this overlap, suggesting several grand challenges in comprehension and mining.	2643-7171	978-1-4503-5714-2		Mining software repositories;program comprehension		data mining;software maintenance	mining;software repository communities;program comprehension				0		30 jan. 2020			IEEE	IEEE Conferences
MetricAttitude++: Enhancing Polymetric Views with Information Retrieval	metricattitude++ enhancing polymetric views with information retrieval	10.1109/ICPC.2017.15	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961539	R. Francese; M. Risi; G. Tortora	Department of Computer Science, University of Salerno; Department of Computer Science, University of Salerno; Department of Computer Science, University of Salerno	2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC)	29 jun. 2017	2017			368	371	MetricAttitude is a visualization tool based on static analysis that provides a mental picture by viewing an object-oriented software by means of polymetric views. In this tool demonstration paper, we integrate an information retrieval engine in MetricAttitude and name this new version as MetricAttitude++. This new tool allows the software engineer to formulate free-form textual queries and shows results on the polymetric views. In particular, MetricAttitude++ shows on the visual representation of a subject software the elements that are more similar to that query. The navigation among elements of interest can be then driven by the polymetric views of the depicted elements and/or reformulating the query and applying customizable filters on the software view. Due to its peculiarities, MetricAttitude++ can be applicable to many kinds of software maintenance and evolution tasks (e.g., concept location and program comprehension).		978-1-5386-0535-6		Program Comprehension;Reverse Engineering;Software Visualization;Information Retrieval	Software;Visualization;Java;Tools;Engines;Software metrics	object-oriented methods;program diagnostics;program visualisation;query processing;software maintenance	MetricAttitude++;polymetric views enhancement;information retrieval engine;visualization tool;static analysis;object-oriented software;free-form textual queries;customizable filters;software maintenance task;software evolution task;concept location;program comprehension				16		29 jun. 2017			IEEE	IEEE Conferences
Interactive Graph Exploration for Comprehension of Static Analysis Results	interactive graph exploration for comprehension of static analysis results	10.1109/ICSE-Companion52605.2021.00129	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9402426	R. Toledo	University of Waterloo	2021 IEEE/ACM 43rd International Conference on Software Engineering: Companion Proceedings (ICSE-Companion)	7 May 2021	2021			284	286	Static analysis results can be overwhelming depending on their complexity and the total number of results. Interactive graph visualization can help engineers explore the connections between different code entities while visually supporting insights about the code's behaviour. In our doctoral research, we aim to investigate how a graphical model of a program and its analysis results can support the engineer's understanding. We expect that a graphical interface can ease the diagnose of faults and reduce the cognitive load required to comprehend reported control and data flows present in the codebase.	2574-1926	978-1-6654-1219-3		Static Analysis, Program Comprehension, Graph Visualization	Graphical models;Data visualization;Static analysis;Medical services;Complexity theory;Software engineering	cognition;data visualisation;graph theory;program diagnostics	different code entities;interactive graph exploration;static analysis results;overwhelming depending;interactive graph visualization				23		7 May 2021			IEEE	IEEE Conferences
Requirements guided dynamic software clustering	requirements guided dynamic software clustering	10.1109/ICSM.2005.76	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510155	Wei Zhao; Lu Zhang; Hong Mei; Jiasu Sun	Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, China; Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, China; Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, China; Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, China	21st IEEE International Conference on Software Maintenance (ICSM'05)	21 nov. 2005	2005			605	608	In this paper, we propose a requirements guided dynamic approach to address software clustering -which aims at providing the logically meaningful and high-level decompositions of large and complex systems. In our approach, the hierarchical structure of functional requirements are constructed by a text document clustering technique named hierarchical agglomerative clustering (HAC) as a high-level skeleton to facilitate the further decomposition of source code through dynamic analysis. We also perform an experimental study based on a GNU system and present the quantitative and qualitative analysis of the experimental results.	1063-6773	0-7695-2368-4		software clustering;hierarchical agglomerative clustering;program comprehension	Software maintenance;Skeleton;Sun;Computer science;Performance analysis;Software systems;Collaboration;Software performance;Merging;Software measurement	text analysis;formal specification	requirements guided dynamic software clustering;text document clustering technique;hierarchical agglomerative clustering;source code;dynamic analysis;quantitative analysis;qualitative analysis				19		21 nov. 2005			IEEE	IEEE Conferences
Pride: Prioritizing Documentation Effort Based on a PageRank-Like Algorithm and Simple Filtering Rules	pride prioritizing documentation effort based on a pageranklike algorithm and simple filtering rules	10.1109/TSE.2022.3171469	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9765699	W. Pan; H. Ming; D. -K. Kim; Z. Yang	Computer Science and Information Engineering, Zhejiang Gongshang University, 12625 Hangzhou, Zhejiang, China; Computer Science and Engineering, Oakland University, 6918 Rochester, Michigan, United States, 48309-4479; Computer Science and Engineering, Oakland University, Rochester, Michigan, United States, 48309; N.A., Xi'an Jiaotong University, 12480 Xi'an, Shaanxi, China	IEEE Transactions on Software Engineering		2022	PP	99	1	1	please see the attached pdf file of Abstract.	1939-3520		National Natural Science Foundation of China(grant numbers:62032010 & 61832014); Natural Science Foundation of Zhejiang Province China(grant numbers:LY22F020007); the Key RD Program of Zhejiang Province China(grant numbers:2019C01004 & 2019C03123); 	Code documentation;program comprehension;software maintenance;PageRank;software metrics	Codes;Documentation;Couplings;Software;Software metrics;Java;Task analysis							IEEE	29 Apr 2022			IEEE	IEEE Early Access Articles
A Unified Framework to Learn Program Semantics with Graph Neural Networks	a unified framework to learn program semantics with graph neural networks		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9286097	S. Liu	Nanyang Technological University Singapore	2020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)	24 Dec 2020	2020			1364	1366	Program semantics learning is a vital problem in various AI for SE applications e.g., clone detection, code summarization. Learning to represent programs with Graph Neural Networks (GNNs) has achieved state-of-the-art performance in many applications e.g., vulnerability identification, type inference. However, currently, there is a lack of a unified framework with GNNs for distinct applications. Furthermore, most existing GNN-based approaches ignore global relations with nodes, limiting the model to learn rich semantics. In this paper, we propose a unified framework to construct two types of graphs to capture rich code semantics for various SE applications.	2643-1572	978-1-4503-6768-4		Graph Neural Network;Program Analysis;Program Comprehension	Limiting;Semantics;Cloning;Artificial intelligence;Software engineering	graph theory;learning (artificial intelligence);neural nets;program diagnostics	rich code semantics;GNN-based approaches;vulnerability identification;code summarization;clone detection;SE applications;program semantics learning;graph neural networks				33		24 Dec 2020			IEEE	IEEE Conferences
On Software Odysseys and How to Prevent Them	on software odysseys and how to prevent them	10.1109/ICSE-C.2017.157	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7965266	S. Scalabrino	University of Molise, Pesche (IS), Italy	2017 IEEE/ACM 39th International Conference on Software Engineering Companion (ICSE-C)	3 jul. 2017	2017			91	93	Acting on a software system developed by someone else may be difficult. Performing any kind of maintenance task requires knowledge about many parts of the system. Therefore, program comprehension plays a lead role in software maintenance, above all when new resources are added to a project. At the same time, acquiring full knowledge about big codebases can be utopian, because it requires a big effort if no sufficient documentation is provided. In this paper I present TIRESIAS, an approach able to suggest a subset of important software artifacts which are good entry points for newcomers. The suggested artifacts can be used in order to acquire knowledge about the system in an initial stage. TIRESIAS uses a knowledge graph to model the references among source code artifacts and to find (i) the artifacts that lead to acquire the widest knowledge about the system and (ii) the most important artifacts that are worth keeping in mind. The approach is validated through a case study conducted on a software system and three professional software developers.		978-1-5386-1589-8		software maintenance;program comprehension;recommender systems	Software engineering;Software systems;Measurement;Maintenance engineering;Information retrieval;Documentation	graph theory;knowledge acquisition;software maintenance;source code (software)	software odysseys;software system;program comprehension;software maintenance;TIRESIAS;software artifacts;knowledge acquisition;source code artifacts;knowledge graph				12		3 jul. 2017			IEEE	IEEE Conferences
Recovering Workflows from Functional Tests	recovering workflows from functional tests	10.1109/ICPC.2015.41	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181459	C. Khadke; S. Rana; V. Shah	Tata Consultancy Services, Pune, India; Tata Consultancy Services, Pune, India; Tata Consultancy Services, Pune, India	2015 IEEE 23rd International Conference on Program Comprehension	7 Sep 2015	2015			287	288	When enterprises outsource maintenance of IT systems to service providers, thorough knowledge acquisition is critical to the success of the engagement. Program comprehension contributes significantly to acquiring knowledge of the IT systems. It is a common practice to execute test scripts to identify critical scenarios in the system and then trace these as flows in the programs. Instead of executing test scripts, we propose the novel idea of mining workflows from test scripts to construct formal process models. The global view provided by the mined model can not only help transition teams gain high level understanding of the system but also help identify critical flows. We also suggest categorization of test cases using supervised learning to improve comprehension.	1092-8138	978-1-4673-8159-8		Test Script;Knowledge Acquisition;Program Comprehension;Process Mining	Navigation;Data mining;Supervised learning;Accuracy;Entropy;Maintenance engineering;Testing	data mining;information technology;knowledge acquisition;learning (artificial intelligence)	workflow recovery;functional tests;enterprises outsource maintenance;IT systems;service providers;knowledge acquisition;program comprehension;mining workflows;formal process models;supervised learning				5		7 Sep 2015			IEEE	IEEE Conferences
The Effect of Cognitive Load in Code Reading on Non-Programming Specific Environment	the effect of cognitive load in code reading on nonprogramming specific environment	10.1109/COMPSAC48688.2020.0-118	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9202529	H. Azuma; S. Matsumoto; H. Uwano; S. Kusumoto	Osaka University, Japan; Osaka University, Japan; National Institute of Technology, Japan; Osaka University, Japan	2020 IEEE 44th Annual Computers, Software, and Applications Conference (COMPSAC)	22 Sep 2020	2020			1105	1106	Understanding program comprehension is one of the fundamental challenges of supporting software development. Although code writing is usually performed on programming specific environment, code reading is forced to be conducted in general environments such as physical paper. Our main hypothesis is that such a non-programming specific environment has some obstacles for program comprehension in terms of code presentation. The goal of this paper is to understand the effects on cognitive load caused by the obstacles. If our hypothesis will be proved and the goal will be achieved, we can provide the best practice of code presentation in non-programming specific environment.	0730-3157	978-1-7281-7303-0		Program comprehension, syntax highlighting, typeface, EEG	Electroencephalography;Syntactics;Programming;Task analysis;Electrodes;Software;Brain	cognition;program diagnostics;reverse engineering;software maintenance;software tools	cognitive load;code reading;nonprogramming specific environment;program comprehension;code writing;general environments;code presentation				6		22 Sep 2020			IEEE	IEEE Conferences
Blaze	blaze	10.1109/ICSE.2012.6227066	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227066	J. -P. Krämer; J. Kurz; T. Karrer; J. Borchers	RWTH Aachen University, Aachen, Germany; RWTH Aachen University, Aachen, Germany; RWTH Aachen University, Aachen, Germany; RWTH Aachen University, Aachen, Germany	2012 34th International Conference on Software Engineering (ICSE)	28 jun. 2012	2012			1457	1458	Understanding source code is crucial for successful software maintenance. To understand source code, navigation in the call graph has been shown to be particularly important. Programmers often employ a two-phased strategy for effective call graph exploration. We present Blaze, a source code exploration tool designed to explicitly support this strategy. In a study, we show that call graph exploration tools significantly increase success rates in typical software maintenance tasks and that using Blaze significantly reduces task completion times compared to using the Call Hierarchy or Xcode.	1558-1225	978-1-4673-1067-3		Tools and environments;Software visualization;Program comprehension	Navigation;Software maintenance;Visualization;Maintenance engineering;Educational institutions;Computer bugs	reverse engineering;software maintenance	software maintenance;source code understanding;call graph exploration;source code exploration tool;call hierarchy;Blaze;Xcode;two-phased strategy				10		28 jun. 2012			IEEE	IEEE Conferences
Robot ON!: A Serious Game for Improving Programming Comprehension	robot on! a serious game for improving programming comprehension		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7809514	M. A. Miljanovic; J. S. Bradbury	Software Quality Research Lab, University of Ontario Institute of Technology, Oshawa, ON, Canada; Software Quality Research Lab, University of Ontario Institute of Technology, Oshawa, ON, Canada	2016 IEEE/ACM 5th International Workshop on Games and Software Engineering (GAS)	9 jan. 2017	2016			33	36	A number of educational games have been created to help students programming. Many of these games focus on problem solving and the actual act of writing programs, while very few focus on programming comprehension. We introduce a serious game called Robot ON! aimed at players who have never programmed before. Unlike other serious programming games, Robot ON! focuses on comprehension rather than problem-solving challenges; players do not actually write any programs, but are instead given the task of demonstrating their knowledge and understanding of a program's behavior. Robot ON! includes tools that allow players to demonstrate understanding of variable values, data types, program statements, and control flow. We include an evaluation plan to assess Robot ON!'s playability, enjoyment, and benefits to program comprehension.		978-1-4503-4160-8		programming;software engineering;computer science;education;serious games;game-based learning;code walkthrough;code review;program comprehension	Games;Programming profession;Educational robots;Writing	computer aided instruction;computer science education;serious games (computing);software engineering	serious game;Robot ON!;programming comprehension;educational games;student programming;writing programs;program statements				12		9 jan. 2017			IEEE	IEEE Conferences
A business process explorer	a business process explorer	10.1145/1368088.1368227	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4814213	J. Guo; K. Foo; L. Barbour; Y. Zou	School of Computing, Queen's University, Kingston, ONT, Canada; Department of Electrical and Computer Engineering, Queen's University, Kingston, ONT, Canada; Department of Electrical and Computer Engineering, Queen's University, Kingston, ONT, Canada; Department of Electrical and Computer Engineering, Queen's University, Kingston, ONT, Canada	2008 ACM/IEEE 30th International Conference on Software Engineering	14 Apr 2009	2008			871	874	A business process is composed of a set of interrelated tasks which are joined together by control flow elements. E-commerce systems implement business processes to automate the daily operations of an organization. Organizations must continuously modify their e-commerce systems to accommodate changes to business processes. However, modifying e-commerce systems is a time consuming and error prone task. To correctly perform this task, developers require an in-depth understanding of multi-tiered e-commerce systems and the business processes that they implement. In this paper, we present a business process explorer tool which automatically recovers business processes from three tier e-commerce systems. Developers can explore the recovered business processes and browse the corresponding source code. We integrate our tool with IBM WebSphere Business Modeler (WBM), a leading commercial tool for business process management and modeling. Business analysts could then visualize and analyze the recovered processes using WBM. The business process explorer eases the co-evolution of business processes and their e-commerce system implementation.	1558-1225	978-1-60558-079-1		business process;e-commerce;process recovery;program comprehension	Visualization;Documentation;Databases;Books;Automatic control;Electronic commerce;Business communication;Cost function;Merging;User interfaces	business data processing;electronic commerce	e-commerce business processes;control flow elements;multitiered e-commerce systems;business process explorer tool;source code;IBM WebSphere Business Modeler;business process management;business process modeling				7		14 Apr 2009			IEEE	IEEE Conferences
Visualization Techniques for Effective Software Comprehend	visualization techniques for effective software comprehend	10.1109/CSCI.2016.0253	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7881546	E. Aldahari	NA	2016 International Conference on Computational Science and Computational Intelligence (CSCI)	20 mar. 2017	2016			1355	1359	Program comprehension procedure have been attracted a lot of attentions and have been investigated using a variant methodologies such as thinking aloud, summary analysis, and Eye-tracking. Program comprehension tools main objective is understanding source code which is substantial factor in software maintenance activities. Visualization is a popular approach in earning this understanding. This paper present a comprehend analysis of concepts and techniques that have been used in building the visualization tools. Then we display a thorough comparison between two widely visualization tools which are SHriMP and LEONARDO.		978-1-5090-5510-4		Program comprehension;visualization;SHriMP;LEONARDO	Data visualization;Software;Switches;Programming profession;Image color analysis;Context	program visualisation;reverse engineering;software maintenance;source code (software)	visualization techniques;software comprehend;program comprehension procedure;variant methodologies;source code;software maintenance activities;SHriMP;LEONARDO				8		20 mar. 2017			IEEE	IEEE Conferences
Work in progress - evolution of code reusing practices during a sequence of three CS courses	work in progress evolution of code reusing practices during a sequence of three cs courses	10.1109/FIE.2007.4417922	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4417922	O. Clua; M. Feldgen; R. Wachenchauzer	Facultad de Ingeniería, Universidad de Buenos Aires, Argentina; Facultad de Ingeniería, Universidad de Buenos Aires, Argentina; Facultad de Ingeniería, Universidad de Buenos Aires, Argentina	2007 37th Annual Frontiers In Education Conference - Global Engineering: Knowledge Without Borders, Opportunities Without Passports	4 jan. 2008	2007			F2J-3	F2J-4	A certain amount of reuse practices are embedded in the CS courses. Some languages have also incorporated reuse as part of their design. We had the opportunity of teaching a group of students in three sequential programming courses ranging from the first notions (imperative programming) to a medium sized programming project in the third course (Java). During the three courses, different kinds and amounts of reuse were required from students, such as stepwise refinement of instructor's code and the use of design patterns. In this work in progress we present the first results of revisiting the code production of a group of students from the reuse point of view. We linked the reuse quality of students practice to some program comprehension parameters.	2377-634X	978-1-4244-1083-5		software reuse;CS education;reuse practices;program comprehension	Object oriented modeling;Programming profession;Educational programs;Object oriented programming;Microstructure;Problem-solving;Education;Java;Production;Educational products	computer science education;educational courses;programming languages;software reusability	code reusing practices;CS courses;teaching;sequential programming courses;medium sized programming project;stepwise refinement;code production				15		4 jan. 2008			IEEE	IEEE Conferences
Extending Bug Localization Using Information Retrieval and Code Clone Location Techniques	extending bug localization using information retrieval and code clone location techniques	10.1109/WCRE.2011.61	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079872	M. Beard	Computer Science Department, University of Alabama in Huntsville, Huntsville, AL, USA	2011 18th Working Conference on Reverse Engineering	17 nov. 2011	2011			425	428	Bug localization involves the use of information about a bug to assist in locating sections of code that must be modified to fix the bug. Such a task can involve a considerable amount of time and effort on the part of software developers and/or maintainers. Recently, several automated bug localization techniques based on information retrieval (IR) models have been developed to speed the process of bug localization. Another code analysis technique involves locating duplicated sections of code in software projects, called code clones. We examine the application of code clone location techniques in the context of bug localization. We attempt to determine the advantages of extending existing code clone location techniques through the inclusion of IR models in the analysis process. We also examine a technique for extending the use of bug logging repositories and version control systems by analyzing the two using IR techniques.	2375-5369	978-1-4577-1948-6		code clones;bugzilla;bug repository;program comprehension;feature identification;concept location;static analysis;information retrieval;concurrent versions system	Cloning;Software;Computer bugs;Semantics;Information retrieval;Context;Joining processes	information retrieval;program debugging;software engineering	bug localization;information retrieval;code clone location techniques;code analysis technique;software projects;IR models				16		17 nov. 2011			IEEE	IEEE Conferences
Introducing Parameter Sensitivity to Dynamic Code-Clone Analysis Methods	introducing parameter sensitivity to dynamic codeclone analysis methods	10.1109/SANER.2016.111	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7476790	T. Kamiya	Interdisciplinary Graduate School of Science and Engineering, Shimane University, Japan	2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)	23 May 2016	2016	3		19	20	This paper presents topics introducing "parameter sensitivity" in a dynamic code-clone detection. First, this paper briefly describes a dynamic code-clone detection method andpossible implementation of parameter sensitivity in the method. Second, this paper describes three topics of parameter sensitivity: untangling clones, introducing value semantics, and abstract code-block labels, and includes the benefits and possible further directions for these topics.		978-1-5090-1855-0		code clone;program comprehension;program analysis;dynamic analysis;visualization	Cloning;Sensitivity;Semantics;Switches;Software;Libraries;Conferences	program diagnostics;source code (software)	parameter sensitivity;dynamic code-clone analysis methods;value semantics;abstract code-block labels				5		23 May 2016			IEEE	IEEE Conferences
Towards Promoting Design and UML Modeling Practices in the Open Source Community	towards promoting design and uml modeling practices in the open source community		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7883384	A. Aldaeej; O. Badreddin	State University of New York At Albany, Albany, NY; Northern Arizona University, Flagstaff, AZ	2016 IEEE/ACM 38th International Conference on Software Engineering Companion (ICSE-C)	23 mar. 2017	2016			722	724	Despite the emergence of UML as the defacto modeling and design tool for software engineering, its adoption remains dismal. Software development, particularly in the open source community, remains code-centric. Adoption of UML in open source projects represents a significant lost opportunity. In this paper, we present an approach to encourage upfront design practices and the adoption of UML modeling in open source projects. In particular, we demonstrate the approach for small contributions and bug fixes. The approach relies on integrating UML-level abstractions into the code. This integration means that open source developers can continue to use their familiar text-based tools to manage the source code and contributions, while at the same time benefit from UML added value of abstractions and comprehension. Other benefits of this approach include broadening the boundaries of bug fix contribution by including modelers and end-users, and incrementally add UML model diagrams into open source project's documentation.		978-1-4503-4205-6		Umple;Model Oriented Programming;Open Source Projects;UML;Program Comprehension;Bug Fixing;Software Design;Reserve Engineering;Forward Engineering;Code Generation	Unified modeling language;Computer bugs;Object oriented modeling;Open source software;Java;Software engineering	program debugging;public domain software;software engineering;source code (software);system documentation;Unified Modeling Language	UML modeling practices;open source community;design tool;software engineering;software development;UML adoption;bug fixes;UML-level abstractions;open source developers;text-based tools;bug fix contribution;UML model diagrams;open source project documentation;source code				11		23 mar. 2017			IEEE	IEEE Conferences
An Analysis of Some Commercial PL/I Programs	an analysis of some commercial pl/i programs	10.1109/TSE.1976.233538	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1702349	J. L. Elshoff	Computer Science Department, General Motors Research and Development Laboratories, Warren, WI, USA	IEEE Transactions on Software Engineering	18 Sep 2006	1976	SE-2	2	113	120	The source code for 120 production PL/I programs from several General Motors' commercial computing installations has been collected. The programs have been scanned both manually and automatically. Some data from the scanning process are presented and interpreted.	1939-3520			Computer program analysis;program complexity;program readability;program size;programmer discipline;programming language usage;software economics	Production;Programming profession;Computer languages;Guidelines;Personnel;Information analysis;History;Terrorism;Computer science;Computer industry		Computer program analysis;program complexity;program readability;program size;programmer discipline;programming language usage;software economics		90		17		18 Sep 2006			IEEE	IEEE Journals
Improving Source Code Lexicon via Traceability and Information Retrieval	improving source code lexicon via traceability and information retrieval	10.1109/TSE.2010.89	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5601742	A. De Lucia; M. Di Penta; R. Oliveto	Department of Mathematics and Informatics, University of Salerno, Fisciano, Italy; Department of Engineering, University of Sannio, Benevento, Italy; Department of Mathematics and Informatics, University of Salerno, Fisciano, Italy	IEEE Transactions on Software Engineering	24 mar. 2011	2011	37	2	205	227	The paper presents an approach helping developers to maintain source code identifiers and comments consistent with high-level artifacts. Specifically, the approach computes and shows the textual similarity between source code and related high-level artifacts. Our conjecture is that developers are induced to improve the source code lexicon, i.e., terms used in identifiers or comments, if the software development environment provides information about the textual similarity between the source code under development and the related high-level artifacts. The proposed approach also recommends candidate identifiers built from high-level artifacts related to the source code under development and has been implemented as an Eclipse plug-in, called COde Comprehension Nurturant Using Traceability (COCONUT). The paper also reports on two controlled experiments performed with master's and bachelor's students. The goal of the experiments is to evaluate the quality of identifiers and comments (in terms of their consistency with high-level artifacts) in the source code produced when using or not using COCONUT. The achieved results confirm our conjecture that providing the developers with similarity between code and high-level artifacts helps to improve the quality of source code lexicon. This indicates the potential usefulness of COCONUT as a feature for software development environments.	1939-3520			Software traceability;source code comprehensibility;source code identifier quality;information retrieval;software development environments;empirical software engineering.	Documentation;Programming;Large scale integration;Semantics;Software quality;Couplings	information retrieval;program diagnostics;software quality	source code lexicon;information retrieval;textual similarity;high level artifact;software development;candidate identifier;code comprehension nurturant using traceability;COCONUT;bachelor student;master student		44	2	72		14 Oct 2010			IEEE	IEEE Journals
A Usability Analysis of Blocks-based Programming Editors using Cognitive Dimensions	a usability analysis of blocksbased programming editors using cognitive dimensions	10.1109/VLHCC.2018.8506483	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8506483	R. Holwerda; F. Hermans	Academy of Information Technology and Communication, HAN University of Applied Sciences, Arnhem, The Netherlands; Dept. of Software and Computer Technology, Delft University of Technology, Delft, The Netherlands	2018 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)	25 Oct 2018	2018			217	225	Blocks-based programming holds potential for end-user developers. Like all visual programming languages, blocks-based programming languages embody both a language design and a user interface design for the editing environment. For blocks-based languages, these designs are focused on learnability and low error rates, which makes them effective for education. For end-user developers who program as part of their professions, other characteristics of usability, like efficiency of use, will also be important. This paper presents a usability analysis, supported by a user study, of the editor design of current blocks-based programming systems, based on the Cognitive Dimensions of Notations framework, and we present design manoeuvres aimed at improving programming time and effort, program comprehension and programmer comfort.	1943-6106	978-1-5386-4235-1		blocks-based languages;end-user development;programmer experience;cognitive dimensions	Programming profession;Task analysis;Usability;Tools;User interfaces;Interviews	cognition;programming languages;software tools;text editing;user interfaces;visual languages;visual programming	visual programming languages;blocks-based programming languages;language design;user interface design;blocks-based languages;low error rates;end-user developers;usability analysis;editor design;cognitive dimensions;design manoeuvres;programming time;program comprehension;blocks-based programming editors;blocks-based programming systems		13		38		25 Oct 2018			IEEE	IEEE Conferences
Stylized Aesthetic QR Code	stylized aesthetic qr code	10.1109/TMM.2019.2891420	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8604076	M. Xu; H. Su; Y. Li; X. Li; J. Liao; J. Niu; P. Lv; B. Zhou	Zhengzhou University, Zhengzhou, China; Zhengzhou University, Zhengzhou, China; Zhengzhou University, Zhengzhou, China; Zhejiang University, Hangzhou, China; Microsoft Research Lab—Asia, Beijing, China; Beihang University, Beijing, China; Zhengzhou University, Zhengzhou, China; Zhengzhou University, Zhengzhou, China	IEEE Transactions on Multimedia	19 jul. 2019	2019	21	8	1960	1970	With the continued proliferation of smart mobile devices, the Quick Response (QR) code has become one of the most-used types of two-dimensional code in the world. Aiming at beautifying the visual-unpleasant appearance of QR codes, existing works have developed a series of techniques. However, these works still leave much to be desired, such as personalization, artistry, and robustness. To address these issues, in this paper, we propose a novel type of aesthetic QR codes, Stylized aEsthEtic (SEE) QR code, and a three-stage approach to automatically produce such robust style-oriented codes. Specifically, in the first stage, we propose a method to generate an optimized baseline aesthetic QR code, which reduces the visual contrast between the noise-like black/white modules and the blended image. In the second stage, to obtain an art style QR code, we tailor an appropriate neural style transformation network to endow the baseline aesthetic QR code with artistic elements. In the third stage, we design a module-based robustness-optimization mechanism to ensure the performance robust by balancing two competing terms: visual quality and readability. Extensive experiments demonstrate that the SEE QR code has high quality in terms of both visual appearance and robustness and also offers a greater variety of personalized choices to users.	1941-0077		National Natural Science Foundation of China(grant numbers:61822701,61602420,61672469,61472370,61772474,61872324); National Key R&D Program of China(grant numbers:2017YFC0804401); China Postdoctoral Science Foundation(grant numbers:2018M630836); Supporting Plan for Scientific and Technological Innovative Talents in Universities of Henan Province(grant numbers:18HASTIT020); Training Plan of Young Key Teachers in Colleges and Universities of Henan Province(grant numbers:2016GGJS-001); 	QR code;style-oriented;visual aesthetics;robust	Visualization;Art;Encoding;Robustness;Image coding;Optimization;Manuals	image coding;mobile computing;neural nets;optimisation;QR codes	smart mobile devices;two-dimensional code;visual-unpleasant appearance;robust style-oriented codes;visual contrast;noise-like black/white modules;module-based robustness-optimization mechanism;visual quality;SEE QR code;quick response code;stylized aesthetic QR code;neural style transformation network		29		26	IEEE	6 jan. 2019			IEEE	IEEE Journals
Python Coding Style Compliance on Stack Overflow	python coding style compliance on stack overflow	10.1109/MSR.2019.00042	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8816812	N. Bafatakis; N. Boecker; W. Boon; M. Cabello Salazar; J. Krinke; G. Oznacar; R. White	University College London, UK; University College London, UK; University College London, UK; University College London, UK; University College London, UK; University College London, UK; University College London, UK	2019 IEEE/ACM 16th International Conference on Mining Software Repositories (MSR)	29 Aug 2019	2019			210	214	Software developers all over the world use Stack Overflow (SO) to interact and exchange code snippets. Research also uses SO to harvest code snippets for use with recommendation systems. However, previous work has shown that code on SO may have quality issues, such as security or license problems. We analyse Python code on SO to determine its coding style compliance. From 1,962,535 code snippets tagged with 'python', we extracted 407,097 snippets of at least 6 statements of Python code. Surprisingly, 93.87% of the extracted snippets contain style violations, with an average of 0.7 violations per statement and a huge number of snippets with a considerably higher ratio. Researchers and developers should, therefore, be aware that code snippets on SO may not representative of good coding style. Furthermore, while user reputation seems to be unrelated to coding style compliance, for posts with vote scores in the range between -10 and 20, we found a strong correlation (r = -0.87, p <; 10^-7) between the vote score a post received and the average number of violations per statement for snippets in such posts.	2574-3864	978-1-7281-3412-3		Stack Overflow, Style Guides, Code Style, Coding Style, Coding Conventions, SOTorrent, Python	Encoding;Python;Correlation;Java;Tools;Data mining	Python;software engineering;source code (software)	style violations;code snippets;Python code;extracted snippets;Stack Overflow;Python coding style compliance		9		31		29 Aug 2019			IEEE	IEEE Conferences
A Large-Scale Comparison of Python Code in Jupyter Notebooks and Scripts	a largescale comparison of python code in jupyter notebooks and scripts	10.1145/3524842.3528447	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796343	K. Grotov; S. Titov; V. Sotnikov; Y. Golubev; T. Bryksin	JetBrains Research, ITMO University; JetBrains Research; JetBrains Research; JetBrains Research; JetBrains Research	2022 IEEE/ACM 19th International Conference on Mining Software Repositories (MSR)	21 jun. 2022	2022			353	364	In recent years, Jupyter notebooks have grown in popularity in several domains of software engineering, such as data science, machine learning, and computer science education. Their popularity has to do with their rich features for presenting and visualizing data, however, recent studies show that notebooks also share a lot of drawbacks: high number of code clones, low reproducibility, etc. In this work, we carry out a comparison between Python code written in Jupyter Notebooks and in traditional Python scripts. We compare the code from two perspectives: structural and stylistic. In the first part of the analysis, we report the difference in the number of lines, the usage of functions, as well as various complexity metrics. In the second part, we show the difference in the number of stylistic issues and provide an extensive overview of the 15 most frequent stylistic issues in the studied mediums. Overall, we demonstrate that notebooks are characterized by the lower code complexity, however, their code could be perceived as more entangled than in the scripts. As for the style, notebooks tend to have 1.4 times more stylistic issues, but at the same time, some of them are caused by specific coding practices in notebooks and should be considered as false positives. With this research, we want to pave the way to studying specific problems of notebooks that should be addressed by the development of notebook-specific tools, and provide various insights that can be useful in this regard.	2574-3864	978-1-4503-9303-4		jupyter;jupyter notebooks;python;mining software repositories;static analysis;code style	Codes;Data visualization;Machine learning;Data science;Software;Reproducibility of results;Encoding	computer science education;learning (artificial intelligence);software engineering;software maintenance;software metrics	large-scale comparison;Python code;Jupyter Notebooks;Jupyter notebooks;data science;computer science education;presenting visualizing data;code clones;traditional Python scripts;15 most frequent stylistic issues;lower code complexity;specific coding practices;notebook-specific tools				43		21 jun. 2022			IEEE	IEEE Conferences
Impact of Coding Style Checker on Code Review - A Case Study on the OpenStack Projects	impact of coding style checker on code review a case study on the openstack projects	10.1109/IWESEP.2018.00014	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8661217	Y. Ueda; A. Ihara; T. Ishio; K. Matsumoto	Nara Institute of Science and Technology, Japan; Wakayama University, Japan; Nara Institute of Science and Technology, Japan; Nara Institute of Science and Technology, Japan	2018 9th International Workshop on Empirical Software Engineering in Practice (IWESEP)	7 mar. 2019	2018			31	36	Code review is key to ensuring the absence of potential issues in source code. Code review is changing from a costly manual check by reviewer to a cost-efficient automatic check by coding style checkers. So that patch authors can verify the changed code before submitting their patches. Although cost-efficiency, the checkers do not detect all potential issues, requiring reviewers to verify the submitted patches based on their knowledge. It would be most efficient if patch authors will learn potential issues and remove the same type of issues from patches prior to code review. This study investigates potential issues that patch authors have repeatedly introduced in their patch submissions despite receiving feedback. To understand the impact of adopting checkers to patch authors' coding style improvement, this study compares two types of potential issues: Automatically Detected Issues by checkers (ADIs) and Manually Detected Issues by reviewers (MDIs). In a case study using an OpenStack code review dataset, we found that the patch authors have repeatedly introduced the same type of MDIs, while they do not repeat ADIs. This result suggests that the introduction of code style checkers might promote the patch authors' effective potential issues learning.	2573-2021	978-1-7281-0439-3		Code-Review;Maintainability;Source-Code-Analysis;Source-Code-Understanding	Encoding;Tools;Manuals;Software;Bars;Measurement;Syntactics	formal verification;program diagnostics;public domain software;software quality;software tools;source code (software)	patch authors;source code;OpenStack projects;coding style checker;automatically detected issues;code review tools;manually detected issues;software quality		3		13		7 mar. 2019			IEEE	IEEE Conferences
Student Program Classification Using Gated Graph Attention Neural Network	student program classification using gated graph attention neural network	10.1109/ACCESS.2021.3063475	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9367198	M. Lu; Y. Wang; D. Tan; L. Zhao	School of Computer Science and Engineering, Central South University, Changsha, China; School of Computer Science and Engineering, Central South University, Changsha, China; School of Computer Science and Engineering, Central South University, Changsha, China; School of Geosciences and Info-Physics, Central South University, Changsha, China	IEEE Access	22 jun. 2021	2021	9		87857	87868	Source code mining has received increasing attention, among which code classification plays a significant role in code understanding and automatic coding. Most source code mining efforts aim at the source code of projects, which are usually large and standardized, but less for student programs. There are two differences between project codes and student programs. On the one hand, some work on project codes is based on relatively single information, which is far from enough for student programs. Because student programs are relatively small, which makes them contain less information. Consequently, it is necessary to mine as much information as possible in student programs. On the other hand, the variable or function naming and the structure of the student programs are usually irregular, as compared with the source codes of projects. To learn from student programs, we proposed a Graph Neural Network (GNN) based model, which integrates data flow and function call information to the Abstract Syntax Tree (AST), and applies an improved GNN model to the integrated graph to achieve the state-of-art student program classification accuracy. The experiment results have shown that the proposed work can classify student programs with accuracy over 97%.	2169-3536		National Science Foundation of China(grant numbers:61232001,61173169,91646115,60903222); Science Foundation of Hunan(grant numbers:2016JJ2149,018JJ3012); Major Science and Technology Research Program for Strategic Emerging Industry of Hunan(grant numbers:2012GK4054); 	Abstract syntax tree;attention mechanism;code understanding;function call graph;data flow;graph neural network;student program classification	Syntactics;Logic gates;Semantics;Graph neural networks;Task analysis;Predictive models;Natural language processing	computer science education;data flow analysis;data mining;neural nets;source coding;trees (mathematics)	code classification;source code mining;project codes;student program classification accuracy;gated graph attention neural network;automatic coding;variable naming;function naming;GNN;data flow;function call information;abstract syntax tree;AST				27	CCBY	2 mar. 2021			IEEE	IEEE Journals
Adaptive Code Learning for Spark Configuration Tuning	adaptive code learning for spark configuration tuning	10.1109/ICDE53745.2022.00195	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9835695	C. Lin; J. Zhuang; J. Feng; H. Li; X. Zhou; G. Li	School of Informatics, Xiamen University, China; School of Informatics, Xiamen University, China; School of Informatics, Xiamen University, China; School of Informatics, Xiamen University, China; Department of Computer Science, Tsinghua University, China; Department of Computer Science, Tsinghua University, China	2022 IEEE 38th International Conference on Data Engineering (ICDE)	2 Aug 2022	2022			1995	2007	Configuration tuning is vital to optimize the performance of big data analysis platforms like Spark. Existing methods (e.g. auto-tuning relational databases) are not effective for tuning Spark, because the unique characteristics of Spark pose new challenges to configuration tuning. (C1) The Spark applications own various code structures and semantics, and the code features significantly affect Spark performance and configuration selection; (C2) Spark applications are extremely time-consuming on big data. It is infeasible for approaches such as Bayesian Optimization and Reinforcement Learning to collect sufficient training instances or repeatedly execute the applications; (C3) Spark supports various analytical applications and the tuning system needs to adapt to different applications. To address these challenges, we propose a LIghtweighT knob rEcommender system (LITE) for auto-tuning Spark configurations on various analytical applications and large-scale datasets. We first propose a code learning framework that can utilize code features to learn complex correlations between application performance and knob values (addressing C1). We then propose a lightweight auto-tuning method that migrates the knowledge learned from small-scale datasets to large-scale datasets (addressing C2). Next, to generalize to different Spark applications, we propose an adaptive model update approach to fine-tune the model via adversarial learning with newly collected feedback (addressing C3). Extensive experiments showed that LITE achieves much better performance compared with state-of-the-art auto-tuning methods.	2375-026X	978-1-6654-0883-7	Natural Science Foundation of China(grant numbers:61972328); NSF of China(grant numbers:61925205,62072261); Natural Science Foundation of China(grant numbers:62002303); Natural Science Foundation of Fujian Province China(grant numbers:2020J05001); 	spark;automatic configuration tuning;code understanding	Training;Adaptation models;Codes;Correlation;Semantics;Relational databases;Big Data	Bayes methods;Big Data;data analysis;learning (artificial intelligence);recommender systems;relational databases	adaptive code Learning;Spark configuration;configuration tuning;big data analysis;auto-tuning relational databases;code structures;semantics;code features;Spark performance;configuration selection;Bayesian Optimization;Reinforcement Learning;analytical applications;tuning system;LIghtweighT knob rEcommender system;auto-tuning Spark configurations;large-scale datasets;code learning framework;application performance;lightweight auto-tuning method;different Spark applications;adaptive model update approach;adversarial learning;state-of-the-art auto-tuning methods				43	IEEE	2 Aug 2022			IEEE	IEEE Conferences
Inspect4py: A Knowledge Extraction Framework for Python Code Repositories	inspect4py a knowledge extraction framework for python code repositories	10.1145/3524842.3528497	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796219	R. Filgueira; D. Garijo	University of St Andrews, St Andrews, UK; Universidad Politécnica de Madrid, Madrid, Spain	2022 IEEE/ACM 19th International Conference on Mining Software Repositories (MSR)	21 jun. 2022	2022			232	236	This work presents inspect4py, a static code analysis framework designed to automatically extract the main features, metadata and documentation of Python code repositories. Given an input folder with code, inspect4py uses abstract syntax trees and state of the art tools to find all functions, classes, tests, documentation, call graphs, module dependencies and control flows within all code files in that repository. Using these findings, inspect4py infers different ways of invoking a software component. We have evaluated our framework on 95 annotated repositories, obtaining promising results for software type classification (over 95% F1-score). With inspect4py, we aim to ease the understandability and adoption of software repositories by other researchers and developers. Code: https://github.com/SoftwareUnderstanding/inspect4py DOI:https://doi.org/10.5281/zenodo.5907936 License: Open (BSD3-Clause)	2574-3864	978-1-4503-9303-4		Code mining;software code;software classification;software documentation;code understanding	Codes;Documentation;Syntactics;Metadata;Feature extraction;Software documentation	feature extraction;knowledge acquisition;meta data;object-oriented programming;pattern classification;program diagnostics;Python	call graphs;code files;software repositories;knowledge extraction;Python code repositories;static code analysis;metadata;documentation;inspect4py;abstract syntax trees;feature extraction;module dependencies;control flows;software component;software type classification				17		21 jun. 2022			IEEE	IEEE Conferences
An Introduction to QR Code Technology	an introduction to qr code technology	10.1109/ICIT.2016.021	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7966807	S. Tiwari	Dept. of Technical Education, SITS Educators Society, Jabalpur, Madhya Pradesh, India	2016 International Conference on Information Technology (ICIT)	3 jul. 2017	2016			39	44	QR i.e. "Quick Response" code is a 2D matrix code that is designed by keeping two points under consideration, i.e. it must store large amount of data as compared to 1D barcodes and it must be decoded at high speed using any handheld device like phones. QR code provides high data storage capacity, fast scanning, omnidirectional readability, and many other advantages including, error-correction (so that damaged code can also be read successfully) and different type of versions. Different varieties of QR code symbols like logo QR code, encrypted QR code, iQR Code are also available so that user can choose among them according to their need. Now these days, a QR code is applied in different application streams related to marketing, security, academics etc. and gain popularity at a really high pace. Day by day more people are getting aware of this technology and use it accordingly. The popularity of QR code grows rapidly with the growth of smartphone users and thus the QR code is rapidly arriving at high levels of acceptance worldwide.		978-1-5090-3584-7		QR code;Quick Response code;QR code structure;QR Code Encoding;QR Code Decoding	Error correction codes;Encoding;Decoding;Timing;Particle separators;Uniform resource locators;Arrays	bar codes;decoding;error correction codes;QR codes	quick response code;2D matrix code;1D barcode;decoding;data storage capacity;omnidirectional readability;error-correction;logo QR code technology;iQR Code;security		43		10		3 jul. 2017			IEEE	IEEE Conferences
Source-Level Energy Consumption Estimation for Cloud Computing Tasks	sourcelevel energy consumption estimation for cloud computing tasks	10.1109/ACCESS.2017.2778309	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8123619	H. Liu; F. Yan; S. Zhang; T. Xiao; J. Song	School of Metallurgy, Northeastern University, Shenyang, China; School of Metallurgy, Northeastern University, Shenyang, China; Software College, Northeastern University, Shenyang, China; School of Computer Science and Engineering, Northeastern University, Shenyang, China; Software College, Northeastern University, Shenyang, China	IEEE Access	14 Feb 2018	2018	6		1321	1330	In the cloud computing environment, the source-level energy consumption (EC) estimation is employed to approximately measure the EC of a cloud computing task before it is executed. The EC estimation on tasks is critical to task scheduling and source-code improvement in the aspect of EC optimization. The existing studies treat a task as a program, and EC of the task as the simple summation of each statement's EC. However, EC of two tasks consisting of the same statements with different structures is unequal; therefore, the code structure should be highlighted in source-level EC estimation. In this paper, an abstract energy consumption (AEC) model, which is static and runtime-independent, is proposed. For the model, the two quantitative measurements, “cross-degree”and “reuse-degree,”are proposed as the code structure features, and the relationship between EC and the measurements is formulated. Although AEC is not a precise EC measurement, it can properly represent the EC of a task, compare with other tasks, and verify the optimization effect. Experimental results show that the ratios between the EC and AEC with 50 test cases are stable; the standard deviation is 0.0002; and the mean value is 0.005. The regularities of EC and code structures, represented as “cross-degree”and “reuse-degree,”are also validated. Though AEC, it is easier to schedule the cloud computing tasks properly and further reduce the consumed energy.	2169-3536		National Natural Science Foundation of China(grant numbers:61672143,61433008,U1435216,61662057,61502090,61402090); National Research Foundation for the Doctoral Program of Higher Education of China(grant numbers:N161602003); 	Abstract energy consumption;code structure;energy consumption estimation;cloud computing tasks;source-level	Estimation;Cloud computing;Energy consumption;Runtime;Optimization;Monitoring	cloud computing;energy consumption;optimisation;power aware computing;scheduling	code structure features;AEC;precise EC measurement;code structures;cross-degree;reuse-degree;consumed energy;source-level energy consumption estimation;cloud computing task;cloud computing environment;task scheduling;source-code improvement;source-level EC estimation;abstract energy consumption model;quantitative measurements;optimization effect		7		24	OAPA	29 nov. 2017			IEEE	IEEE Journals
A Longitudinal Study of Application Structure and Behaviors in Android	a longitudinal study of application structure and behaviors in android	10.1109/TSE.2020.2975176	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9003217	H. Cai; B. Ryder	School of Electrical Engineering and Computer Science, Washington State University, Pullman, WA, USA; Department of Computer Science, Virginia Tech, Blacksburg, VA, USA	IEEE Transactions on Software Engineering	10 Dec 2021	2021	47	12	2934	2955	With the rise of the mobile computing market, Android has received tremendous attention from both academia and industry. Application programming in Android is known to have unique characteristics, and Android apps be particularly vulnerable to various security attacks. In response, numerous solutions for particular security issues have been proposed. However, there is little broad understanding about Android app code structure and behaviors along with their implications for app analysis and security defense, especially in an evolutionary perspective. To mitigate this gap, we present a longitudinal characterization study of Android apps to systematically investigate how they are built and execute over time. Through lightweight static analysis and method-level tracing, we examined the code and execution of 17,664 apps sampled from the apps developed in each of eight past years, with respect to metrics in three complementary dimensions. Our study revealed that (1) apps functionalities heavily rely on the Android framework/SDK, and the reliance continues to grow, (2) Activity components constantly dominated over other types of components and were responsible for the invocation of most lifecycle callbacks, (3) event-handling callbacks consistently focused more on user-interface events than system events, (4) the overall use of callbacks has been slowly diminishing over time, (5) the majority of exercised inter-component communications (ICCs) did not carry any data payloads, and (6) sensitive data sources and sinks targeted only one/two dominant categories of information or operations, and the ranking of source/sink categories remained quite stable throughout the eight years. We discuss the implications of our empirical findings for cost-effective app analysis and security defense for Android, and make cost-effectiveness improvement recommendations accordingly.	1939-3520		National Science Foundation(grant numbers:#1936522); 	Android;code structure;app behavior;longitudinal study;evolution;app analysis;security;ICC	Androids;Humanoid robots;Computer security;Runtime;Measurement;Codes	Android (operating system);mobile computing;program diagnostics;security of data	mobile computing market;application programming;Android app code structure;security attacks;lightweight static analysis;lifecycle callbacks;event-handling callbacks;intercomponent communications		7		77	IEEE	19 Feb 2020			IEEE	IEEE Journals
Source Code Retrieval for Bug Localization using Bug Report	source code retrieval for bug localization using bug report	10.1109/ICCP48234.2019.8959535	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8959535	K. E. E. Swe; H. M. Oo	University of Computer Studies, Mandalay, Mandalay, Myanmar; University of Computer Studies, Mandalay, Mandalay, Myanmar	2019 IEEE 15th International Conference on Intelligent Computer Communication and Processing (ICCP)	16 jan. 2020	2019			241	247	Bug localization helps software developers to track post-released faulty source files with the help of user's reported bug files. Information retrieval (IR) based bug localization have been widely used in recent years. It recommends relevant faulty source files to fix according to their highest similarity scores. We propose a combined approach of IR-based bug localization by operating previously fixed bug reports and source code structure. From the query, bug report structure is also considered to get more accurate faulty source files. In our approach, three parts in the source code file and two parts in bug report are combined as six combinations score. In some bug localization approach, features are usually linearly combined. Our approach uses linearly combine with the weight value. We perform experiments on three projects, i.e. SWT, AspectJ, and Eclipse. The result shows that the proposed approach achieves the relevance accuracy for bug localization process. According to the evaluation result, using the structure is more localized than no structured approach.		978-1-7281-4914-1		bug localization;information retrieval;source code structure;bug report structure		information retrieval;program debugging;source code (software)	IR-based bug localization;source code structure;bug report structure;source code file;bug localization process;source code retrieval;information retrieval based bug localization		2		16		16 jan. 2020			IEEE	IEEE Conferences
Examples of Usage of Method of Data Errors Correction which are Presented by the Residual Classes	examples of usage of method of data errors correction which are presented by the residual classes	10.1109/ATIT49449.2019.9030512	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9030512	V. Krasnobaev; V. Popenko; T. Kuznetsova; K. Kuznetsova	Department of information systems and technologies security, V. N. Karazin Kharkiv National University, Kharkiv, Ukraine; Department of information systems and technologies security, V. N. Karazin Kharkiv National University, Kharkiv, Ukraine; Department of information systems and technologies security, V. N. Karazin Kharkiv National University, Kharkiv, Ukraine; Department of information systems and technologies security, V. N. Karazin Kharkiv National University, Kharkiv, Ukraine	2019 IEEE International Conference on Advanced Trends in Information Theory (ATIT)	12 mar. 2020	2019			45	50	The method of correction of single errors in the residue class (RC) is considered in this article. The results of analysis of arithmetic code correcting possibilities showed high efficiency of the use of position-independent code structures in RC. Examples of correction of the data single errors which presented by the code of RC are made in the article.		978-1-7281-6144-0		residual class system;data errors correction;non-positional code structure;computational process	Error correction;Information systems;Security;Redundancy;Error correction codes;Periodic structures	arithmetic codes;error correction codes;residue codes	data errors correction;residual classes;arithmetic code correcting possibilities;position-independent code structures;data single errors		2		25		12 mar. 2020			IEEE	IEEE Conferences
An Eye Tracking Study on camelCase and under_score Identifier Styles	an eye tracking study on camelcase and under_score identifier styles	10.1109/ICPC.2010.41	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521745	B. Sharif; J. I. Maletic	Department of Computer Science, Kent University, Kent, OH, USA; Department of Computer Science, Kent University, Kent, OH, USA	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			196	205	An empirical study to determine if identifier-naming conventions (i.e., camelCase and under_score) affect code comprehension is presented. An eye tracker is used to capture quantitative data from human subjects during an experiment. The intent of this study is to replicate a previous study published at ICPC 2009 (Binkley et al.) that used a timed response test method to acquire data. The use of eye-tracking equipment gives additional insight and overcomes some limitations of traditional data gathering techniques. Similarities and differences between the two studies are discussed. One main difference is that subjects were trained mainly in the underscore style and were all programmers. While results indicate no difference in accuracy between the two styles, subjects recognize identifiers in the underscore style more quickly.	1092-8138	978-1-4244-7603-9		identifier styles;eye-tracking study;code readability	Programming profession;Computer science;Humans;Testing;Cognitive science;Computer languages;Java;Keyboards;Writing;Software maintenance	programming	camelCase;under_score identifier styles;code comprehension;eye-tracking equipment		79		27		26 jul. 2010			IEEE	IEEE Conferences
The Expansion of Source Code Abbreviations Using a Language Model	the expansion of source code abbreviations using a language model	10.1109/COMPSAC.2018.10260	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8377888	A. Alatawi; W. Xu; J. Yan	Department of Computer Science, Saudi Electronic University, Riyadh, Saudi Arabia; Department of Computer Science, Bowie State University, Bowie, MD, USA; Department of Computer Science, Bowie State University, Bowie, MD, USA	2018 IEEE 42nd Annual Computer Software and Applications Conference (COMPSAC)	22 jun. 2018	2018	2		370	375	Programmers often abbreviate identifiers names in source code to represent single words, i.e. unigrams, or phrases, i.e. multigrams. However, the difficulty to retrieve the original word(s) of an abbreviation during the maintenance phase makes the source code more problematic to comprehend. Incorrect abbreviations expansion may lead to introducing defects in the code. There are many approaches that that automatically expand abbreviations to their original words, unfortunately, they are based on predefined patterns and single-words dictionaries which cannot address abbreviations that are expandable to phrases. In this paper, we describe a bigram-based inference model which utilizes unigrams statistical properties as evidence to retrieve the original word automatically. We evaluated our approach on a set of 100 abbreviations randomly picked from eight open source projects and found that our approach correctly expands 78% of the set.	0730-3157	978-1-5386-2667-2		Automatic Abbreviation Expansion, Software Comprehension, Code Readability, Software Maintenance	Mathematical model;Dictionaries;Software;Computer science;Bayes methods;Conferences	dictionaries;information retrieval;natural language processing;source coding;statistical analysis;text analysis;word processing	source code abbreviations;language model;maintenance phase;incorrect abbreviations expansion;single-words dictionaries;bigram-based inference model;unigrams statistical properties;open source projects		7		14		22 jun. 2018			IEEE	IEEE Conferences
iSCREAM: a suite for Smart Contract REAdability assessMent	iscream a suite for smart contract readability assessment	10.1109/ICSME52107.2021.00060	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9609171	G. Canfora; A. Di Sorbo; M. Fredella; A. Vacca; C. A. Visaggio	University of Sannio, Italy; University of Sannio, Italy; University of Sannio, Italy; University of Sannio, Italy; University of Sannio, Italy	2021 IEEE International Conference on Software Maintenance and Evolution (ICSME)	24 nov. 2021	2021			579	583	Blockchain is increasingly revolutionizing a variety of sectors, from finance to healthcare. Indeed, the availability of public blockchain platforms, such as Ethereum, has stimulated the development of hundreds of decentralized apps (dApps) that combine smart contract(s) and a front-end user interface. Smart contracts are software, as well, and, as traditional software, they require to be developed and maintained or evolved. Among all the quality properties that must be assessed and guaranteed, readability is a key aspect of source code: a highly readable code facilitates its maintainability, portability, and reusability. This is especially true when considering smart contracts, where code reuse is widely adopted. Indeed, smart contract developers often integrate code portions from other smart contracts in their artifacts. To help developers and researchers more easily estimating and monitoring the code readability of smart contracts, in this demo, we present iSCREAM. iSCREAM automatically inspects Solidity smart contracts and computes a set of metrics that previous research demonstrated being related to code readability. We evaluated iSCREAM on 90 real-world smart contract functions, showing that our tool correctly computes all the aforementioned metrics. Demo webpage: https://github.com/mfredella/iSCREAM	2576-3148	978-1-6654-2882-8		Blockchain;Smart Contracts;Code readability	Measurement;Software maintenance;Codes;Conferences;Smart contracts;Finance;Medical services	blockchains;contracts;distributed processing;software maintenance;user interfaces	code readability;iSCREAM;smart contract developers;Solidity smart contracts;smart contract readability assessment;maintainability;portability;reusability;decentralized apps;front-end user interface		1		23	IEEE	24 nov. 2021			IEEE	IEEE Conferences
What Do We Know About Readability of Test Code? - A Systematic Mapping Study	what do we know about readability of test code a systematic mapping study	10.1109/SANER53432.2022.00135	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9825897	D. Winkler; P. Urbanke; R. Ramler	CDL-SQI, TU Wien, Inst. for Inf. Syst. Eng., Vienna, Austria; CDL-SQI, TU Wien, Inst. for Inf. Syst. Eng., Vienna, Austria; Software Competence Center Hagenberg GmbH (SCCH), Hagenberg, Austria	2022 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)	21 jul. 2022	2022			1167	1174	The readability of software code is a key success criterion for understanding and maintaining software systems and tests. In industry practice, a limited number of guidelines aim for improving and assessing the readability of software (test) code. Although several studies focus on investigating the readability of software code, we observed limited research work that focuses on the readability of software test code. In this paper we focus on systematically investigating the characteristics, factors, and assessment criteria that have an impact on the readability of test code. We build on a Systematic Mapping Study (SMS) to identify key characteristics, factors, and assessment criteria that have an impact on test code readability, legibility, and understandability to support and improve maintenance tasks. The result set includes 16 studies for further analysis. The majority of publications focuses on readability investigations of automatically generated test code (88%), often evaluated with surveys to access the readability of test code (44 %). Although several approaches aim at assessing the readability with focus on isolated factors, a combination of different readability aspects within an assessment framework can help to better assess and justify the readability of test code with focus on improving software and system test maintenance.	1534-5351	978-1-6654-3786-8		Software Testing;Test Code;Readability;Un-derstandability;Maintainability;Systematic Mapping Study	Industries;Codes;Systematics;Conferences;Maintenance engineering;Software systems;Software	program testing;software maintenance	maintaining software systems;software test code;test code readability;readability investigations;automatically generated test code;different readability aspects;system test maintenance;systematic mapping study;SMS;identify key characteristics				38	IEEE	21 jul. 2022			IEEE	IEEE Conferences
Evaluating Essential and Accidental Code Complexity Triggers by Practitioners’ Perception	evaluating essential and accidental code complexity triggers by practitioners’ perception	10.1109/MS.2020.2976072	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9007382	V. Antinyan	Volvo Car Group	IEEE Software	23 Oct 2020	2020	37	6	86	93	Code complexity determines the difficulty of understanding code. Survey results show that many elements influence complexity, most of which are accidental and can be removed. Meanwhile, several elements captured by the traditional complexity metrics have a small influence on complexity.	1937-4194			Code complexity;software metrics;code quality;maintainability;code readability	Complexity theory;Bars;Software;Task analysis;Software measurement;Software engineering	software maintenance;software metrics	code complexity;complexity metrics;software engineering				17	IEEE	24 Feb 2020			IEEE	IEEE Magazines
Generation and consistency checking of design and program structures	generation and consistency checking of design and program structures	10.1109/TSE.1986.6312930	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6312930	Z. L. Lichtman	Department of Computer Science, Brandeis University, Waltham, MA, USA	IEEE Transactions on Software Engineering	26 Sep 2012	1986	SE-12	1	172	181	The author describes a mini methodology for generation and representation of design and program structures and for structural consistency checking between two successive designs or between a design and a program. This methodology comprises a tool (Program Design Language), a representation, and consistency criteria. The Program Design Language (PDL) extracts structure information, in a controlled way, from the top level program design, through layers of detailed designs, down to the source code itself. It generates an actual, complete, concise, and easily comparable structure representation. Structural consistency between levels can be checked, both at the development phase and at the operation and maintenance phase, ensuring continued structural consistency between the design(s) and the program.	1939-3520			Consistency checking;Program Design Language (PDL);program structure;software development;software quality assurance;software tools	Customer relationship management;Computer languages;Aerospace electronics;Nickel;Data mining;Program processors	software reliability;specification languages	software reliability;consistency checking;program structures;structural consistency checking;Program Design Language;structure information;program design;source code;development phase;maintenance phase		6				26 Sep 2012			IEEE	IEEE Journals
Analysis Method of Energy for C Source Program and Its Application	analysis method of energy for c source program and its application	10.1109/GreenCom-iThings-CPSCom.2013.244	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6682256	Y. Yuechuan; Z. Guosun; D. Chunling; W. Wei	Department of Computer Science and Technology, Tongji University, Shanghai, China; Department of Computer Science and Technology, Tongji University, Shanghai, China; Department of Computer Science and Technology, Tongji University, Shanghai, China; Department of Computer Science and Technology, Tongji University, Shanghai, China	2013 IEEE International Conference on Green Computing and Communications and IEEE Internet of Things and IEEE Cyber, Physical and Social Computing	12 Dec 2013	2013			1397	1402	Effective management of energy is the urgent task for high performance computing, but the analysis methods for energy of computer are very lack. This paper presents an analysis method of energy for C source program. Based on the basic operations and structure of C program, we present a classification of atomic operation, and establish an energy database of these atomic operations by means of experiment. Then we propose three kinds of energy calculation method for the sequential statement block, if statement block, for statement block, respectively. After changing the whole C program into a flow analysis tree, we put forward energy prediction algorithm for such a C source program. Finally, some classic algorithms are chosen to test and verify our prediction. The results show that our method has good feasibility and rationality.		978-0-7695-5046-6		Green computing;Analysis of energy consumption;C source program;Atomic operation;C program structure	Atomic measurements;Algorithm design and analysis;Energy measurement;Computers;Databases;Energy consumption;Arrays	C language;green computing;power aware computing	C source program;effective energy management;high performance computing;atomic operation classification;energy database;energy calculation method;sequential statement block;flow analysis tree;energy prediction algorithm		3		12		12 Dec 2013			IEEE	IEEE Conferences
File Structures, Program Structures, and Attributed Grammars	file structures, program structures, and attributed grammars	10.1109/TSE.1983.236735	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1703053	L. Logrippo; D. R. Skuce	Software Reliability Research Group, Department of Computer Science, University of Ottawa, Ottawa, ONT, Canada; Software Reliability Research Group, Department of Computer Science, University of Ottawa, Ottawa, ONT, Canada	IEEE Transactions on Software Engineering	18 Sep 2006	1983	SE-9	3	260	266	A language for defining sequential file structures, characterized as nested sequences of records having in common certain keys and types, is presented. "Input schemata" are defined as program skeletons that contain all the necessary control structure to process a specified file. A method for obtaining an input schema from the corresponding file structure definition is given. The method is based on attributed grammars, and has been implemented in the programming language PROLOG. This constitutes a formalization of some aspects of the data-directed program design method of Jackson and Warnier. Examples of applications of this method to business data processing problems such as file updating and report generation are given.	1939-3520			Attributed grammars;data-directed program design;data processing;logical construction of programs;logic programming;program generation;program structure;PROLOG;sequential file structures;software engineering	Data processing;Business;Computer languages;Application software;Logic programming;Computer science;Skeleton;Process control;Design methodology;Process design		Attributed grammars;data-directed program design;data processing;logical construction of programs;logic programming;program generation;program structure;PROLOG;sequential file structures;software engineering		3		18	IEEE	18 Sep 2006			IEEE	IEEE Journals
A Novel Memory Leak Classification for Evaluating the Applicability of Static Analysis Tools	a novel memory leak classification for evaluating the applicability of static analysis tools	10.1109/PIC.2018.8706142	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8706142	S. Zhang; J. Zhu; A. Liu; W. Wang; C. Guo; J. Xu	College of Computer Science, Nankai University, Tianjin, China; College of Software, Nankai University, Tianjin, China; College of Computer Science, Nankai University, Tianjin, China; College of Computer Science, Nankai University, Tianjin, China; College of Computer Science, Nankai University, Tianjin, China; College of Artificial Intelligence, Nankai University, Tianjin, China	2018 IEEE International Conference on Progress in Informatics and Computing (PIC)	6 May 2019	2018			351	356	Memory leaks in software have proved to be widespread in C programs. Much research has been done to analyze and detect memory leaks statically. However, due to the complexity and variety of memory leak vulnerabilities, it is difficult to propose a static method that can detect all kinds of memory leaks. In this paper, we propose a method to investigate the applicability of static analysis tools to detect various kinds of memory leaks. We first divide memory leak vulnerabilities into 11 categories, from the perspectives of heap memory behaviors and program structures. According to this classification, we design and implement a pattern-based system to generate a program dataset named HPMD (Heap Program Memory Dataset) that contains a variety of memory leaks. Experiments on open source repositories show that compared with existing datasets, HPMD can evaluate current tools in terms of their ability to detect various kinds of memory leaks, and can recommend reasonable tools given a specific program.		978-1-5386-7672-1		memory leak classification;heap memory behavior;program structure;static analysis tool;HPMD	Tools;Periodic structures;Static analysis;Software;Measurement;Resource management;Complexity theory	C language;pattern classification;program control structures;program diagnostics;reachability analysis;storage management	static analysis tools;divide memory leak vulnerabilities;heap memory behaviors;HPMD;program dataset;pattern-based system;program structures;static method;C programs;heap program memory dataset;memory leak classification		2		18		6 May 2019			IEEE	IEEE Conferences
An Argument in Favor of Mechanized Software Production	an argument in favor of mechanized software production	10.1109/TSE.1977.231173	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1702472	G. . -C. Roman	Department of Computer Science, Washington University, Saint Louis, MO, USA	IEEE Transactions on Software Engineering	18 Sep 2006	1977	SE-3	6	406	415	A new software engineering methodology called program control structuring is proposed. Its development is justified by the need to offer the designer the capability to improve the productivity and quality of software development in the conditions of a "highly imperfect" environment. Such an environment is shown to involve the use of transient and inexperienced programmers, frequent alterations to the design specifications, and continuous development. The philosophy behind program control structuring is that of minimizing the probability of error in the design and implementation of large programs by means of language-and problem-dependent standardization. The particular standardization approach used by program control structuring is shown to provide 1) a program structure that is simple and flexible, readily understood, easily developed, and inexpensively maintained, and 2) a high-quality and partially mechanizable structure-oriented documentation scheme. Subsequently, it is suggested that many of the standards are mechanizable in the immediate future as a necessary condition for achieving higher productivity and improved program quality. Finally, the mechanization of software production is proposed as a step needed to precede the development of automatic program generation systems.	1939-3520			Control structure;mechanization;methodology;productivity;programming environment;program structure;transformational components;standardization	Production;Productivity;Standardization;Programming environments;Documentation;Computer science;Humans;Control systems;Software engineering;Programming profession		Control structure;mechanization;methodology;productivity;programming environment;program structure;transformational components;standardization		2		10		18 Sep 2006			IEEE	IEEE Journals
Configurable Structure Tree as a Means to Manage Configurable Business Processes	configurable structure tree as a means to manage configurable business processes	10.1109/WETICE.2017.62	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8003785	W. Benallal; M. Barhamgi; D. Benslimane; Z. Maamar	Lyon 1 University, Lyon, France; Lyon 1 University, Lyon, France; Universite Claude Bernard Lyon 1, Villeurbanne, Auvergne-RhÃ´ne-Alpes, FR; Zayed University, Dubai, UAE	2017 IEEE 26th International Conference on Enabling Technologies: Infrastructure for Collaborative Enterprises (WETICE)	10 Aug 2017	2017			42	47	A configurable Business Process (BP) is an abstract BP that engineers customize with respect to specific requirements. To keep track of the multiple and recurrent customizations that lead to a set of derived BPs, this paper proposes a knowledge-based approach that uses a new Process Structure Tree called configurable PST (cPST). A cPST abstracts a separate variability option of the configurable BP. All cPSTs should be equivalent to the set of all PSTs associated with the derived BPs that could originate from the same configurable BP. This paper also proposes a logic-based configuration model for capturing configuration details on the cBP and describing the cPST computing.		978-1-5386-1759-5		Business Process;Configuration;Program Structure Tree	Computational modeling;Knowledge based systems;Cats;Complexity theory;Connectors;Organizations	business data processing;knowledge based systems	configurable business processes management;recurrent customizations;knowledge-based approach;process structure tree;configurable PST;cPST abstracts;configurable BP;logic-based configuration model;cPST computing		1		23		10 Aug 2017			IEEE	IEEE Conferences
Configurable Refined Structure Tree	configurable refined structure tree	10.1109/SITIS.2017.22	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8334727	W. Benallal; M. Barhamgi; D. Benslimane	Lyon 1 University, Lyon, France; Lyon 1 University, Lyon, France; Lyon 1 University, Lyon, France	2017 13th International Conference on Signal-Image Technology & Internet-Based Systems (SITIS)	12 Apr 2018	2017			69	75	A configurable Business Process (cBP) is a BP that can be individualized to several BP variants corresponding to the BP instantiation needs. This paper proposes a methodology for the fragmentation of the cBPs into different independent blocks extended with the metadata of the variability options they are concerned with, expressed as logical expression. The extended fragments are structured and organized in a tree called configurable Refined Process structure tree (CRPST). The cRPST represents for the cBP what the rpst represents for the conventional BP, a technique for supporting, management, reuse, change of process model, analyzing and checking, etc.		978-1-5386-4283-2		Business Process;Configuration;Refined Program Structure Tree	Computational modeling;Analytical models;Task analysis;Tools;Connectors;Knowledge based systems	business data processing;trees (mathematics)	configurable Refined structure tree;configurable Business Process;cBP;BP variants;BP instantiation needs;fragmentation;variability options;logical expression;extended fragments;configurable Refined Process structure tree;CRPST;cRPST;conventional BP;process model;independent blocks				21		12 Apr 2018			IEEE	IEEE Conferences
A Research and Verification of MFC Framework-aware Virus Infection Technology	a research and verification of mfc frameworkaware virus infection technology	10.1109/CVIDLICCEA56201.2022.9824009	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9824009	W. Guo; Y. Li; Z. Sha; W. Bu	State Key Laboratory of Mathematical Engineering and Advanced Computing, Zhengzhou, China; State Key Laboratory of Mathematical Engineering and Advanced Computing, Zhengzhou, China; State Key Laboratory of Mathematical Engineering and Advanced Computing, Zhengzhou, China; State Key Laboratory of Mathematical Engineering and Advanced Computing, Zhengzhou, China	2022 3rd International Conference on Computer Vision, Image and Deep Learning & International Conference on Computer Engineering and Applications (CVIDL & ICCEA)	18 jul. 2022	2022			1	6	Portable Executable (PE) virus technology is an important threat factor in the field of network security. With continuous upgrading of malware detection technology, virus infection technology will also gradually evolve from infecting the structure of the PE file to infecting the deeper structure of the program, and thus achieve higher level of stealthiness and confrontation. This paper proposes a structure-aware virus infection technology for Microsoft Foundation Classes (MFC) software framework, aiming to explore a new method of virus infection. This research aims to verify the virus infection method of MFC program framework perception through experiments, and then provides a solution to the new PE virus, which can help improve the current level of heuristic malware detection technology.		978-1-6654-5911-2		component;Virus infection technology;Program structure awareness;MFC program framework	Computer viruses;Network security;Viruses (medical)	computer viruses;program diagnostics	MFC framework-aware virus infection technology;threat factor;network security;PE file;structure-aware virus infection technology;Microsoft Foundation Classes software framework;MFC program framework perception;PE virus;heuristic malware detection technology;portable executable virus technology				17	IEEE	18 jul. 2022			IEEE	IEEE Conferences
MisuseHint: A Service for API Misuse Detection Based on Building Knowledge Graph from Documentation and Codebase	misusehint a service for api misuse detection based on building knowledge graph from documentation and codebase	10.1109/ICWS55610.2022.00046	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9885793	Q. Liang; Z. Kuai; Y. Zhang; Z. Zhang; L. Kuang; L. Zhang	School of Computer Science and Engineering, Central South University, Changsha, China; School of Computer Science and Engineering, Central South University, Changsha, China; School of Computer Science and Engineering, Central South University, Changsha, China; School of Computer Science and Engineering, Central South University, Changsha, China; School of Computer Science and Engineering, Central South University, Changsha, China; School of Computer Science and Engineering, Central South University, Changsha, China	2022 IEEE International Conference on Web Services (ICWS)	16 Sep 2022	2022			246	255	Developers often call APIs to improve development efficiency, but they misuse APIs due to lack of understanding of source code logic and other unavoidable reasons, resulting in serious consequences such as program crashes. Many studies that extract API usage constraints from API documentation or codebases expect to get out of this dilemma through API misuse detection. However, low recall remains a hurdle for researchers to overcome. In this work, we make full use of API documentation and codebases to construct constraint knowledge graph, and propose a new API misuse detector, MisuseHint. We precisely define API constraints into seven categories, utilize API caveat knowledge in documentation and API usage patterns in codebases, and fuse knowledge from both to build knowledge graph with rich constraints. To detect API misuses, we obtain API usage constraints in the knowledge graph and analyze static code to propose different strategies to determine whether API misuses exist. Through defect pattern analysis, object variable tracking, and Z3 SAT solver, our detector can identify various complex situations of code at a fine-grained level, especially solving various complex problems of Call Order and State Checking constraints. Experimental results on MUBench show that our recall reaches 39.78%, demonstrating the validity and theoretical feasibility of fusing documentation and codebases using knowledge graphs. MisuseHint achieves a recall of 76.34% when it is always given sufficient API constraints. This detector can practically help developers program effectively.		978-1-6654-8143-4	National Natural Science Foundation of China; 	API Misuse Detection;Static Code Analysis;Knowledge Graph;Codebases;API Documentation;Program Structure Interface	Java;Codes;Web services;Fuses;Documentation;Detectors;Synchronization	application program interfaces;data mining;program diagnostics;security of data	MisuseHint;API misuse detection;building knowledge graph;APIs;source code logic;API usage constraints;API documentation;codebases;constraint knowledge graph;API misuse detector;utilize API;rich constraints;API misuses;State Checking constraints;sufficient API constraints				32	IEEE	16 Sep 2022			IEEE	IEEE Conferences
A new interleaved Bachelor of Electrical Engineering Program	a new interleaved bachelor of electrical engineering program	10.1109/FIE.2008.4720560	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4720560	N. Cox; G. Pellegrin	British Columbia Institute of Technology; British Columbia Institute of Technology	2008 38th Annual Frontiers in Education Conference	22 Dec 2008	2008			F2E-21	F2E-26	This paper describes a new four-year Bachelor of Electrical Engineering program being introduced in British Columbia (BC), Canada at the BC Institute of Technology (BCIT). The program addresses the need in industry for engineering graduates that have a solid practical focus as well as the expected theoretical depth and topical breadth of knowledge. The program works in tandem with a nationally accredited two-year diploma of Electrical and Computer Engineering Technology. The program structure allows both the existing diploma program and the degree program to be optimized based on their respective priorities and market needs, i.e., there is no need to impose major changes on the diploma program in order to accommodate the degree program. The result is a pair of programs that allow students to graduate with either a diploma or a degree, and also to return after receiving their diploma to complete their degree later. This structure provides, in effect, a two-stage entrance evaluation process which allows the program to draw from a broader pool of prospective engineers, thereby providing a path to the profession to people that may otherwise have missed the opportunity. The programpsilas curriculum uses a contextual or spiral approach, where applications are introduced prior to theory, and then revisited once the theory is developed. While the program described here is designed to help address the shortage of electrical engineers in Canada, similar conditions prevail in the United States and elsewhere, and similar programs may be useful in addressing these shortages.	2377-634X	978-1-4244-1969-2		Contextual Curriculum;Spiral Pedagogy;Bachelors Electrical Engineering Program Structure;Diploma Interaction	Electricity supply industry;Spirals;Electrical engineering;North America;Educational products;Educational programs;Knowledge engineering;Solids;Design engineering;Communication industry	electrical engineering education	Bachelor of Electrical Engineering program;diploma program;degree program;entrance evaluation process				14		22 Dec 2008			IEEE	IEEE Conferences
SeTCHi: Selecting Test Cases to Improve History-Guided Fault Localization	setchi selecting test cases to improve historyguided fault localization	10.1109/ISSREW.2018.00007	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8539196	L. Zhang; Z. Zhang	Chinese Academy of Sciences, Institute of Software, Beijing, China; Chinese Academy of Sciences, Institute of Software, Beijing, China	2018 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)	18 nov. 2018	2018			200	207	Many software failures are caused by faults in programs. Fault localization is always a difficult task in program debugging, and the spectrum-based fault localization (SBFL in short) is a popular approach. A SBFL technique collects code coverage of program runs, and estimates to what extent individual program entities correlate to the failed runs. We have empirically reported that referencing debugging history can effectively alleviate the impact of program structure on the accuracy of SBFL techniques. However, referencing all test cases indistinguishably may have adverse effects. In this paper, we propose a novel technique SeTCHi, which differentiates test cases according to their coverage and test outputs, and refines SBFL with the means to select supporting test cases with respect to program entities and history program versions. We also conduct an empirical study, which shows that SeTCHi can significantly improve the accuracy of fault localization based on state-of-the-art techniques.		978-1-5386-9443-5		Software testing, fault localization, debugging history, program structure, test case selection	History;Software;Debugging;Software reliability;Computer science;Task analysis;Computer aided software engineering	fault diagnosis;program debugging;program testing;software fault tolerance;source code (software)	program debugging;spectrum-based fault localization;debugging history;program structure;history-guided fault localization;software failures;SBFL;test cases;SeTCHi;software testing				29		18 nov. 2018			IEEE	IEEE Conferences
Outcome based engineering diploma curriculum - 2012 Gujarat experiment	outcome based engineering diploma curriculum 2012 gujarat experiment	10.1109/FIE.2013.6685159	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6685159	V. K. Agrawal; J. Earnest; S. K. Gupta; J. P. Tegar; S. S. Mathew	National Institute of Technical Teachers' Training and Research (NITTTR), Bhopal, Madhya Pradesh, INDIA; National Institute of Technical Teachers' Training and Research (NITTTR), Bhopal, Madhya Pradesh, INDIA; National Institute of Technical Teachers' Training and Research (NITTTR), Bhopal, Madhya Pradesh, INDIA; National Institute of Technical Teachers' Training and Research (NITTTR), Bhopal, Madhya Pradesh, INDIA; National Institute of Technical Teachers' Training and Research (NITTTR), Bhopal, Madhya Pradesh, INDIA	2013 IEEE Frontiers in Education Conference (FIE)	19 Dec 2013	2013			1864	1870	In India, unlike the Western world, the universities have several engineering institutes affiliated to them that are geographically spread across large provinces. Gujarat Technological University (GTU) is one such example, that caters to the technical education needs of the state of Gujarat (size of Arizona) with a population of 65 million. More than one hundred such institutes offering undergraduate and graduate programs and about same number of `Polytechnics' offering engineering diploma programs are affiliated to GTU. Around 100 thousand students take admissions every year in the 55 different technology programs being offered. Since examination and certification is the main responsibility of the University, it becomes necessary to conduct centrally administered end-of-the-term examinations every semester. This necessitates the curriculum for each program to be same in all the institutes. Hence, curriculum design became a centralized task to address the needs of today's globalized industry and also fulfill the aspirations and capabilities of the students, belonging to different strata of the society. Since curriculum designers and implementers are not the same in this experiment, a need-based curriculum model became imperative to be developed that could convey clearly and uniformly the intentions of the designers in letter and spirit to all curriculum implementers and stakeholders. In this backdrop, NITTTR Bhopal one of the four premium institutes established by the Government of India for quality improvement of the technical education, was assigned the task by GTU in 2012 to completely re-design the curriculum of twenty five engineering diploma programs to produce `work ready' personnel. The authors were the core members of the core team who undertook this task. This paper highlights the challenges and opportunities faced by the engineering education system due to fast changes taking place in society, industry and education, for which an innovative outcome-based curriculum model was evolved to address these challenges and harness the opportunities. This paper discusses the various facets of the philosophy, approach and structure of this curriculum model evolved for this purpose. It also briefly describes the planning, designing, implementation and evaluation of the curriculum development process, as well as some of the strategies adapted in this innovative curriculum model.	2377-634X	978-1-4673-5261-1		Outcome-based Curriculum;Competencies;MMS Type Industry;R&D Type Industry;Program Structure;Programme Outcome;Course Outcome;Domain;GTU;NITTTR Bhopal	Educational institutions;Industries;Engineering education;Government;Civil engineering;Knowledge engineering	certification;engineering education;further education	outcome based engineering diploma curriculum;Gujarat experiment;India;engineering institute;Gujarat Technological University;GTU;technical education;undergraduate programs;engineering diploma programs;technology programs;certification;curriculum design;need-based curriculum model;NITTTR Bhopal;work ready personnel;engineering education system;innovative outcome-based curriculum model;curriculum development process				15		19 Dec 2013			IEEE	IEEE Conferences
Decoding the Representation of Code in the Brain: An fMRI Study of Code Review and Expertise	decoding the representation of code in the brain an fmri study of code review and expertise	10.1109/ICSE.2017.24	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985660	B. Floyd; T. Santander; W. Weimer	University of Virginia; University of Virginia; University of Virginia	2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)	20 jul. 2017	2017			175	186	Subjective judgments in software engineering tasks are of critical importance but can be difficult to study with conventional means. Medical imaging techniques hold the promise of relating cognition to physical activities and brain structures. In a controlled experiment involving 29 participants, we examine code comprehension, code review and prose review using functional magnetic resonance imaging. We find that the neural representations of programming languages vs. natural languages are distinct. We can classify which task a participant is undertaking based solely on brain activity (balanced accuracy 79%, p <; 0.001). Further, we find that the same set of brain regions distinguish between code and prose (near-perfect correlation, r = 0.99, p <; 0.001). Finally, we find that task distinctions are modulated by expertise, such that greater skill predicts a less differentiated neural representation (r = -0.44, p = 0.016) indicating that more skilled participants treat code and prose more similarly at a neural activation level.	1558-1225	978-1-5386-3868-2		medical imaging;code comprehension;prose review	Biomedical imaging;Software engineering;Brain;Software;Computer science;Natural languages;Tools	biomedical MRI;medical image processing;software engineering	fMRI study;software engineering tasks;medical imaging techniques;functional magnetic resonance imaging;code comprehension;code review;prose review;neural representations;programming languages;natural languages		63		85		20 jul. 2017			IEEE	IEEE Conferences
Automated Detection of Test Fixture Strategies and Smells	automated detection of test fixture strategies and smells	10.1109/ICST.2013.45	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6569744	M. Greiler; A. van Deursen; M. -A. Storey	Delft University of Technology, Netherlands; Delft University of Technology, Netherlands; University of Victoria, BC, Canada	2013 IEEE Sixth International Conference on Software Testing, Verification and Validation	29 jul. 2013	2013			322	331	Designing automated tests is a challenging task. One important concern is how to design test fixtures, i.e. code that initializes and configures the system under test so that it is in an appropriate state for running particular automated tests. Test designers may have to choose between writing in-line fixture code for each test or refactor fixture code so that it can be reused for other tests. Deciding on which approach to use is a balancing act, often trading off maintenance overhead with slow test execution. Additionally, over time, test code quality can erode and test smells can develop, such as the occurrence of overly general fixtures, obscure in-line code and dead fields. In this paper, we show that test smells related to fixture set-up occur in industrial projects. We present a static analysis technique to identify fixture related test smells. We implemented this test analysis technique in a tool, called TestHound, which provides reports on test smells and recommendations for refactoring the smelly test code. We evaluate the tool through three industrial case studies and show that developers find that the tool helps them to understand, reflect on and adjust test code.	2159-4848	978-0-7695-4968-2		test code comprehension;maintainability;test fixture;test smells;software testing;test code refactoring	Fixtures;Measurement;Maintenance engineering;Java;Testing;Software systems;Medical services	program diagnostics;program testing;software maintenance	automated detection;test fixture strategies;automated tests design;maintenance overhead;test code quality;static analysis technique;test smells;test analysis technique;TestHound;software refactoring		36		20		29 jul. 2013			IEEE	IEEE Conferences
Effects of Variable Names on Comprehension: An Empirical Study	effects of variable names on comprehension an empirical study	10.1109/ICPC.2017.27	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961504	E. Avidan; D. G. Feitelson	School of Computer Science and Engineering, The Hebrew University, Jerusalem, Israel; School of Computer Science and Engineering, The Hebrew University, Jerusalem, Israel	2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC)	29 jun. 2017	2017			55	65	It is widely accepted that meaningful variable names are important for comprehension. We conducted a controlled experiment in which 9 professional developers try to understand 6 methods from production util classes, either with the original variable names or with names replaced by meaningless single letters. Results show that parameter names are more significant for comprehension than local variables. But, surprisingly, we also found that in 3 of the methods there were no significant differences between the control and experimental groups, due to poor and even misleading variable names. These disturbingly common bad names reflect the subjective nature of naming, and highlight the need for additional research on how variable names are interpreted and how better names can be chosen.		978-1-5386-0535-6		code comprehension;variable names;misleading names;method parameters;local variables	Conferences;Random access memory	professional aspects;software maintenance;source code (software)	variable names effects;proessional developers;parameter names;code comprehension;misleading names		25		27		29 jun. 2017			IEEE	IEEE Conferences
How Developers Choose Names	how developers choose names	10.1109/TSE.2020.2976920	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9018121	D. G. Feitelson; A. Mizrahi; N. Noy; A. B. Shabat; O. Eliyahu; R. Sheffer	Department of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel; Department of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel; Department of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel; Department of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel; Department of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel; Department of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel	IEEE Transactions on Software Engineering	10 jan. 2022	2022	48	1	37	52	The names of variables and functions serve as implicit documentation and are instrumental for program comprehension. But choosing good meaningful names is hard. We perform a sequence of experiments in which a total of 334 subjects are required to choose names in given programming scenarios. The first experiment shows that the probability that two developers would select the same name is low: in the 47 instances in our experiments the median probability was only 6.9 percent. At the same time, given that a specific name is chosen, it is usually understood by the majority of developers. Analysis of the names given in the experiment suggests a model where naming is a (not necessarily cognizant or serial) three-step process: (1) selecting the concepts to include in the name, (2) choosing the words to represent each concept, and (3) constructing a name using these words. A followup experiment, using the same experimental setup, then checked whether using this model explicitly can improve the quality of names. The results were that names selected by subjects using the model were judged by two independent judges to be superior to names chosen in the original experiment by a ratio of two-to-one. Using the model appears to encourage the use of more concepts and longer names.	1939-3520		Israel Science Foundation(grant numbers:407/13,832/18); 	variable naming;code comprehension	Programming profession;Documentation;Natural languages;Unified modeling language	probability;software engineering;source code (software);system documentation	variable naming;program comprehension;implicit documentation;concept selection;word choosing;name construction;median probability		6		41	IEEE	28 Feb 2020			IEEE	IEEE Journals
Recognizing eye tracking traits for source code review	recognizing eye tracking traits for source code review	10.1109/ETFA.2017.8247637	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8247637	K. R. Chandrika; J. Amudha; S. D. Sudarsan	Dept of Computer Science & Engineering, Amrita University, India; Dept of Computer Science & Engineering, Amrita University, India; Industrial Software Systems, ABB Corporate Research, Bengaluru, India	2017 22nd IEEE International Conference on Emerging Technologies and Factory Automation (ETFA)	8 jan. 2018	2017			1	8	Source code review is a core activity in software engineering where a reviewer examines the code with the intention of finding bugs in the program. A lot of research has been carried out in understanding how software engineers perform code comprehension; however contribution of eye tracking traits seems to have not been addressed. This paper outlines a study conducted in an industrial environment of software engineers. It focused on understanding the visual attention of subjects with programming skills and subjects without programming skills and recognize the eye tracking traits required for source code review. The results indicate a significant difference in gaze behaviors of these groups. The key aspects of subjects with programming skills while source code review are required to have certain eye tracking traits like better code coverage, attention span on error lines and comments.	1946-0759	978-1-5090-6505-9		Eye Tracking;Software Engineering;Source Code Review;Source Code Comprehension	Gaze tracking;Programming;Visualization;Computer bugs;Tracking;Debugging	gaze tracking;program debugging;program diagnostics;program testing;software maintenance;source code (software)	eye tracking traits;software engineers;programming skills;source code review;code coverage;software engineering;code comprehension;visual attention;gaze behaviors		6		15		8 jan. 2018			IEEE	IEEE Conferences
Learning a Classifier for Prediction of Maintainability Based on Static Analysis Tools	learning a classifier for prediction of maintainability based on static analysis tools	10.1109/ICPC.2019.00043	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813252	M. Schnappinger; M. H. Osman; A. Pretschner; A. Fietzke	Technical University of Munich, Munich, Germany; Technical University of Munich, Munich, Germany; Technical University of Munich, Munich, Germany; Itestra GmbH, Munich, Germany	2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC)	29 Aug 2019	2019			243	248	Static Code Analysis Tools are a popular aid to monitor and control the quality of software systems. Still, these tools only provide a large number of measurements that have to be interpreted by the developers in order to obtain insights about the actual quality of the software. In cooperation with professional quality analysts, we manually inspected source code from three different projects and evaluated its maintainability. We then trained machine learning algorithms to predict the human maintainability evaluation of program classes based on code metrics. The code metrics include structural metrics such as nesting depth, cloning information and abstractions like the number of code smells. We evaluated this approach on a dataset of more than 115,000 Lines of Code. Our model is able to predict up to 81% of the threefold labels correctly and achieves a precision of 80%. Thus, we believe this is a promising contribution towards automated maintainability prediction. In addition, we analyzed the attributes in our created dataset and identified the features with the highest predictive power, i.e. code clones, method length, and the number of alerts raised by the tool Teamscale. This insight provides valuable help for users needing to prioritize tool measurements.	2643-7171	978-1-7281-1519-1		Software Quality;Software Maintenance;Code Comprehension;Static Code Analysis;Maintenance Tools		learning (artificial intelligence);program diagnostics;program verification;software maintenance;software metrics;software quality;software tools	human maintainability evaluation;code metrics;structural metrics;automated maintainability prediction;code clones;software system quality;Teamscale tool;static code analysis tools;machine learning algorithms		6		24		29 Aug 2019			IEEE	IEEE Conferences
Replicating Novices' Struggles with Coding Style	replicating novices struggles with coding style	10.1109/ICPC.2019.00015	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813294	E. S. Wiese; A. N. Rafferty; D. M. Kopta; J. M. Anderson	School of Computing, University of Utah, Salt Lake City, USA; Computer Science Department, Carleton College, Northfield, USA; School of Computing, University of Utah, Salt Lake City, USA; School of Computing, University of Utah, Salt Lake City, USA	2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC)	29 Aug 2019	2019			13	18	Good style makes code easier for others to read and modify. Control flow is one element of style where experts expect particular structure, such as conjoining conditions rather than nesting if statements. Empirical work is necessary to understand why novices use poor style, so they can be taught to use good style. Previous work shows that many students know what control flows experts prefer, but may say that novice-styled code is more readable. Yet, these same students showed similarly high comprehension across both expert-and novice-styled code. We propose a replication of that work that more fully assesses students' code comprehension and code writing. Our replication focuses on students who are earlier in their computer science courses and are less likely to be majors, to determine whether the pattern of results is particular to students who are relatively attuned to style concerns. Our pilot of the proposed replication finds that: students in this new population are less able to identify expert code; expert style may reduce comprehension for some control flows; and writing with good style does not always predict a preference for reading code with good style.	2643-7171	978-1-7281-1519-1		Computer science education;Novice code comprehension;Programming style		computer aided instruction;computer science education;educational courses;programming	coding style;control flow;poor style;novice-styled code;code writing;style concerns;expert code;expert style		4		10		29 Aug 2019			IEEE	IEEE Conferences
Subtle Bugs Everywhere: Generating Documentation for Data Wrangling Code	subtle bugs everywhere generating documentation for data wrangling code	10.1109/ASE51524.2021.9678520	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9678520	C. Yang; S. Zhou; J. L. C. Guo; C. Kästner	Peking University; University of Toronto; McGill University; Carnegie Mellon University	2021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)	20 jan. 2022	2021			304	316	Data scientists reportedly spend a significant amount of their time in their daily routines on data wrangling, i.e. cleaning data and extracting features. However, data wrangling code is often repetitive and error-prone to write. Moreover, it is easy to introduce subtle bugs when reusing and adopting existing code, which results in reduced model quality. To support data scientists with data wrangling, we present a technique to generate documentation for data wrangling code. We use (1) program synthesis techniques to automatically summarize data transformations and (2) test case selection techniques to purposefully select representative examples from the data based on execution information collected with tailored dynamic program analysis. We demonstrate that a JupyterLab extension with our technique can provide on-demand documentation for many cells in popular notebooks and find in a user study that users with our plugin are faster and more effective at finding realistic bugs in data wrangling code.	2643-1572	978-1-6654-0337-5	Natural Sciences and Engineering Research Council of Canada; 	computational notebook;data wrangling;code comprehension;code summarization	Codes;Runtime;Computer bugs;Documentation;Feature extraction;Minimization;Cleaning	data analysis;document handling;dynamic programming;program compilers;program debugging;program diagnostics;program testing	subtle bugs;generating documentation;data wrangling code;data scientists;daily routines;cleaning data;existing code;reduced model quality;data transformations;on-demand documentation;realistic bugs		3		63	IEEE	20 jan. 2022			IEEE	IEEE Conferences
Visualization of C++ Template Metaprograms	visualization of c++ template metaprograms	10.1109/SCAM.2010.16	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5601850	Z. Borók-Nagy; V. Májer; J. Mihalicza; N. Pataki; Z. Porkolab	Dept. of Programming Languages and Compilers, Eötvös Loránd University, Budapest, Hungary; Dept. of Programming Languages and Compilers, Eötvös Loránd University, Budapest, Hungary; Dept. of Programming Languages and Compilers, Eötvös Loránd University, Budapest, Hungary; Dept. of Programming Languages and Compilers, Eötvös Loránd University, Budapest, Hungary; Dept. of Programming Languages and Compilers, Eötvös Loránd University, Budapest, Hungary	2010 10th IEEE Working Conference on Source Code Analysis and Manipulation	14 Oct 2010	2010			167	176	Template metaprograms have become an essential part of today's C++ programs: with proper template definitions we can force the C++ compiler to execute algorithms at compilation time. Among the application areas of template metaprograms are the expression templates, static interface checking, code optimization with adaptation, language embedding and active libraries. Despite all of its already proven benefits and numerous successful applications there are surprisingly few tools for creating, supporting, and analyzing C++ template metaprograms. As metaprograms are executed at compilation time they are even harder to understand. In this paper we present a code visualization tool, which is utilizing Tem plight, our previously developed C++ template metaprogram debugger. Using the tool it is possible to visualize the instantiation chain of C++ templates and follow the execution of metaprograms. Various presentation layers, filtering of template instances and step-by-step replay of the instantiations are supported. Our tool can help to test, optimize, maintain C++ template metaprograms, and can enhance their acceptance in the software industry.		978-1-4244-8655-7		C++ template metaprogram;code comprehension	Visualization;Data structures;Context;Instruments;Debugging;Libraries;Programming	C++ language;data visualisation;program compilers;program debugging	C++ template metaprogram visualization;C++ compiler;expression templates;static interface checking;code optimization;language embedding;active libraries;code visualization tool;tem plight;C++ template metaprogram debugger		1		28		14 Oct 2010			IEEE	IEEE Conferences
Code Review Knowledge Perception: Fusing Multi-Features for Salient-Class Location	code review knowledge perception fusing multifeatures for salientclass location	10.1109/TSE.2020.3021902	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9186620	Y. Huang; N. Jia; X. Chen; K. Hong; Z. Zheng	School of Data and Computer Science, Sun Yat-sen University, Guangzhou, China; School of Management Science and Engineering, Hebei GEO University, Shijiazhuang, China; Guangdong Key Laboratory for Big Data Analysis and Simulation of Public Opinion, School of Communication and Design, Sun Yat-sen University, Guangzhou, China; School of Data and Computer Science, Sun Yat-sen University, Guangzhou, China; School of Data and Computer Science, Sun Yat-sen University, Guangzhou, China	IEEE Transactions on Software Engineering	16 May 2022	2022	48	5	1463	1479	Code review is a common software engineering practice of practical importance to reduce software defects. Review today is often with the help of specialized tools, such as Gerrit. However, even in a tool-supported code review involves a significant amount of human effort to understand the code change, because the information required to inspect code changes may distribute across multiple files that reviewers are not familiar with. Code changes are often organized as commits for review. In this paper, we found that most of the commits contain a salient class(es), which is saliently modified and causes the modification of the rest classes in a commit. Our user studies confirmed that identifying the salient class in a commit can facilitate reviewers in understanding code change. Inspired by the effectiveness of machine learning techniques in the classification field, we model the salient class identification as a binary classification problem and a number of discriminative features is extracted for a commit and used to characterize the salience of a class. The experiments results show that our approach achieves an accuracy of 88 percent. A user study with industrial developers shows that our approach can really improve the efficiency of reviewers understanding code changes in a reviewing scenario without using comment.	1939-3520		National Key R&D Program of China(grant numbers:2018YFB1004800); National Natural Science Foundation of China(grant numbers:61902441,61722214,61672545); Key-Area Research and Development Program of Guangdong Province(grant numbers:2020B010164002); Basic and Applied Basic Research Foundation of Guangdong Province(grant numbers:2020A1515010973); China Postdoctoral Science Foundation(grant numbers:2018M640855); 	Code review;code comprehension;code change;code discriminative features;code commit	Feature extraction;Semantics;Tools;Couplings;Open source software;Knowledge engineering	learning (artificial intelligence);pattern classification;software maintenance;software metrics;software quality;software tools	code review knowledge perception;salient-class location;software engineering practice;tool-supported code review;commits;rest classes;code change;salient class identification;multifeature fusion;software defect		1		56	IEEE	4 Sep 2020			IEEE	IEEE Journals
From Code to Design: A Reverse Engineering Approach	from code to design a reverse engineering approach	10.1109/ICECCS.2016.030	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7816583	E. Varoy; J. Burrows; J. Sun; S. Manoharan	Department of Electrical and Computer Engineering; Department of Electrical and Computer Engineering; Department of Computer Science, The University of Auckland, New Zealand; Department of Computer Science, The University of Auckland, New Zealand	2016 21st International Conference on Engineering of Complex Computer Systems (ICECCS)	16 jan. 2017	2016			181	186	Understanding existing pieces of software is a challenge faced by many software developers regardless of their experience. This project researches into existing reverse engineering tools used for code comprehension and identifies the limitations of the current approaches. Furthermore, a prototype implementation was developed to extract design models from available source code in order to achieve better program comprehension. The design and implementation of the model extraction tool were defined, with a focus on Java systems and an agile methodology. This tool was realised by extending the existing open source diagrammatic software, UMLet, with a set of features to aid in code comprehension. Finally, the prototype implementation was evaluated against the related tools in the field as well as by a group of professional experts.		978-1-5090-5527-2		Code Comprehension;Design Models;UML	Unified modeling language;Software;Java;Reverse engineering;Measurement;Prototypes;Complexity theory	Java;reverse engineering;software engineering;Unified Modeling Language	software developers;reverse engineering tools;source code;Java systems;agile methodology;open source diagrammatic software;UMLet		1		14		16 jan. 2017			IEEE	IEEE Conferences
Delivering comprehension features into source code editors through LSP	delivering comprehension features into source code editors through lsp	10.23919/MIPRO.2019.8756695	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8756695	M. Mészáros; M. Cserép; A. Fekete	Dept. of Programming Languages And Compilers, Eötvös Loránd University, Budapest, Hungary; Dept. of Software Technology And Methodology, Eötvös Loránd University, Budapest, Hungary; Dept. of Software Technology And Methodology, Eötvös Loránd University, Budapest, Hungary	2019 42nd International Convention on Information and Communication Technology, Electronics and Microelectronics (MIPRO)	11 jul. 2019	2019			1581	1586	The maintenance of large, legacy software often results in higher development time and cost due to increasing size and complexity of the codebase and its documentation, their continuously eroding quality and fluctuation among developers. Code comprehension tools are designed to tackle this issue by providing various textual information, visualization views and source code metrics on multiple abstraction levels. These tools usually process not only the codebase, but also the build information, the version control repository and other available information sources. Meanwhile source code editors and integrated development environments (IDEs) are not performing well in the field of code comprehension as they are optimized for writing new code, not for effective browsing. This can easily result in frequent switching between environments during development, hindering effective programming and raising development cost. Language Server Protocol (LSP) is an open-source protocol to connect source code editors with servers that provide language-specific features. In this research we analyze how LSP can be utilized to improve the code comprehension experience inside code editors by integrating the features of such tools through remote procedure calls. As a prototype solution we showcase the integration of two open-source applications: Visual Studio Code and the Code Compass code comprehension tool.	2623-8764	978-953-233-098-4		code comprehension;software maintenance;language server protocol;source code editor		configuration management;data visualisation;program diagnostics;programming environments;public domain software;remote procedure calls;software maintenance;software metrics	LSP;open-source protocol;source code editors;code comprehension experience;open-source applications;Visual Studio Code;source code metrics;integrated development environments;information sources;code comprehension tools;code compass code comprehension tool;language server protocol		1		11		11 jul. 2019			IEEE	IEEE Conferences
Striffs: Architectural Component Diagrams for Code Reviews	striffs architectural component diagrams for code reviews	10.1109/ICCQ51190.2021.9392939	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9392939	M. Fadhel; E. Sekerinski	HADII Technology, Toronto, Canada; McMaster University, Hamilton, Canada	2021 International Conference on Code Quality (ICCQ)	8 Apr 2021	2021			69	78	Despite recent advancements in automated code quality and defect finding tools, developers spend a significant amount of time completing code reviews. Code understandability is a key contributor to this phenomenon, since engineers need to understand both microscopic and macroscopic level details of the code under review. Existing tools for code reviews including diffing, inline commenting and syntax highlighting provide limited support for the macroscopic understanding needs of reviewers. When reviewing code for architectural and design quality, such tools do not enable reviewers to understand the code from a top-down lens which the original architects of the code would have likely used to design the system. To overcome these limitations and to complement existing approaches, we introduce structure diff (striff) diagrams. Striffs provide reviewers with an architectural understanding of the incoming code in relation to the existing system, allowing reviewers to gain a more complete view of the scope and impact of the proposed code changes in a code review.		978-1-7281-8476-0		code review;software design;object oriented programming;code comprehension;graphs	Microscopy;Tools;Syntactics;Lenses	program testing;software architecture;software maintenance;software quality	automated code quality;code understandability;reviewing code;incoming code;code changes;architectural component diagrams;defect finding tools;time completing code reviews;inline commenting;syntax highlighting				43		8 Apr 2021			IEEE	IEEE Conferences
A Study And Experimental Assessment Of The Cognitive Weight, Base Of The Cognitive Metrics	a study and experimental assessment of the cognitive weight, base of the cognitive metrics	10.1109/CONISOFT.2019.00033	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9105481	A. S. Núñez-Varela; H. G. Pérez-González; F. E. Martínez-Pérez; D. Esqueda-Contreras	Facultad de Ingeniería, Universidad Autónoma de San Luis Potosí, San Luis Potosí, México; Facultad de Ingeniería, Universidad Autónoma de San Luis Potosí, San Luis Potosí, México; Facultad de Ingeniería, Universidad Autónoma de San Luis Potosí, San Luis Potosí, México; Facultad de Ingeniería, Universidad Autónoma de San Luis Potosí, San Luis Potosí, México	2019 7th International Conference in Software Engineering Research and Innovation (CONISOFT)	2 jun. 2020	2019			173	180	Source code metrics have been used as indicators of code comprehension according to its complexity. Shao and Wang proposed a cognitive complexity measure based on the cognitive weight of the basic control structures. This cognitive weight is a fixed value assigned to each control structure, which was calculated by means of a series of empirical experiments. Given the lack of information and incompleteness of the experiments, improvements to these experiments must be made before a measure can be used. In this paper, a study on the overall state of the cognitive weight, including its experiments, is presented, along with an empirical experiment which will help us to assess the validity and accuracy of the cognitive weight. The experiment consists of applying a survey to 114 students. It contains source code complexity and comprehension questions that allow us to obtain conclusions about the validity of the cognitive weight.		978-1-7281-2524-4		Code comprehension;Cognitive weight;Empirical assessment Cognitive metrics;Source code metrics		cognition;computational complexity;software maintenance;software metrics	cognitive weight;cognitive metrics;source code metrics;cognitive complexity measure;empirical experiment;source code complexity				24		2 jun. 2020			IEEE	IEEE Conferences
The Effect of Information Content and Length on Name Recollection	the effect of information content and length on name recollection	10.1145/3524610.3529159	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796372	A. Etgar; R. Friedman; S. Haiman; D. Perez; D. G. Feitelson	The Hebrew University, Jerusalem, Israel; The Hebrew University, Jerusalem, Israel; The Hebrew University, Jerusalem, Israel; The Hebrew University, Jerusalem, Israel; The Hebrew University, Jerusalem, Israel	2022 IEEE/ACM 30th International Conference on Program Comprehension (ICPC)	22 jun. 2022	2022			141	151	Memorable function and variable names are useful for developers: they reduce the need to re-check how objects are named when one wants to use them, and they enhance comprehension when encountered when reading code. We look at the possible interplay between the information contained in names and how memorable they are. We show in two independent experiments involving a total of 190 subjects that informative names are usually easier to recollect than similar-length names which contain less focused information. Interestingly, we find that less-experienced and female participants are better at remembering the less informative names. We also find that short names, which are not just abbreviated but actually contain less information, are significantly more memorable. Hence a good choice would be to use the the shortest name that includes the most focused and pertinent information.	2643-7171	978-1-4503-9298-3		Variable names;function names;name recollection;code comprehension	Codes	reverse engineering;software engineering	similar-length names;informative names;short names;information content;name recollection;memorable function;variable names;code reading;memorable names;code comprehension				43		22 jun. 2022			IEEE	IEEE Conferences
CodeCompass: An Open Software Comprehension Framework for Industrial Usage	codecompass an open software comprehension framework for industrial usage		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8973058	Z. Porkoláb; T. Brunner; D. Krupp; M. Csordás	Eötvös Loránd University, Budapest, Hungary; Eötvös Loránd University, Budapest, Hungary; Ericsson Hungary Ltd., Budapest, Hungary; Ericsson Hungary Ltd., Budapest, Hungary	2018 IEEE/ACM 26th International Conference on Program Comprehension (ICPC)	30 jan. 2020	2018			361	3618	CodeCompass is an open source LLVM/Clang based tool developed by Ericsson Ltd. and the Eötvös Loránd University, Budapest to help understanding large legacy software systems. Based on the LLVM/Clang compiler infrastructure, CodeCompass gives exact information on complex C/C++ language elements like overloading, inheritance, the usage of variables and types, possible uses of function pointers and the virtual functions - features that various existing tools support only partially. Steensgaard's and Andersen's pointer analysis algorithm are used to compute and visualize the use of pointers/references. The wide range of interactive visualizations extends further than the usual class and function call diagrams; architectural, component and interface diagrams are a few of the implemented graphs. To make comprehension more extensive, CodeCompass also utilizes build information to explore the system architecture as well as version control information. CodeCompass is regularly used by hundreds of designers and developers. Having a web-based, pluginable, extensible architecture, the CodeCompass framework can be an open platform to further code comprehension, static analysis and software metrics efforts. The source code and a tutorial is publicly available on GitHub, and a live demo is also available online.	2643-7171	978-1-4503-5714-2		code comprehension;C/C++ programming language;software visualization		C language;C++ language;data visualisation;program compilers;program diagnostics;program verification;software maintenance;software metrics;software tools	open software comprehension framework;industrial usage;Eötvös Loránd University;legacy software systems;exact information;function pointers;virtual functions;tools support;pointer analysis algorithm;function call diagrams;interface diagrams;system architecture;version control information;CodeCompass framework;open platform;static analysis;software metrics efforts				39		30 jan. 2020			IEEE	IEEE Conferences
HaskellCompass: Extending the CodeCompass comprehension framework for Haskell	haskellcompass extending the codecompass comprehension framework for haskell	10.1109/Informatics47936.2019.9119295	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9119295	B. Németh; T. Brunner	Department of Programming Languages and Compilers, Eötvös Loránd University, Budapest, Hungary; Department of Programming Languages and Compilers, Eötvös Loránd University, Budapest, Hungary	2019 IEEE 15th International Scientific Conference on Informatics	17 jun. 2020	2019			149	154	While functional programming is an emerging and efficient way to express complex software, the tool support for functional programming languages, like Haskell, is not always satisfactory. There are no tools that can provide code insight for large Haskell projects that limits the potential of the language’s usability.CodeCompass is an open-source LLVM/Clang-based tool developed by Ericsson Ltd. and Eötvös Loránd University, Budapest to help the understanding of large legacy software systems. Based on the LLVM/Clang compiler infrastructure, CodeCompass gives exact information on complex C/C++ language elements and is regularly used by hundreds of designers and developers.In this paper we present a Haskell plugin for the CodeCompass tool that is able to analyse large Haskell projects and provide useful information for the developers. We suggest useful comprehension queries and actions that enhance developer efficiency. Additionally we show the implementation of such a solution and measure the performance cost of using it.		978-1-7281-3180-1		Code comprehension;CodeCompass;Functional programming;Haskell		C++ language;functional languages;program compilers;public domain software;software maintenance	HaskellCompass;CodeCompass comprehension framework;complex software;tool support;functional programming languages;Haskell projects;legacy software systems;Haskell plugin;CodeCompass tool;comprehension queries;open-source LLVM;Clang-based tool;Clang compiler infrastructure;C++ language elements				13	IEEE	17 jun. 2020			IEEE	IEEE Conferences
Comprehension of Thread Scheduling for the C++ Programming Language	comprehension of thread scheduling for the c++ programming language	10.1109/ICoDSE53690.2021.9648489	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9648489	A. Gyén; N. Pataki	Department of Programming Languages and Compilers, Eötvös Lorand University, Budapest, Hungary; Department of Programming Languages and Compilers, Eötvös Lorand University, Budapest, Hungary	2021 International Conference on Data and Software Engineering (ICoDSE)	22 Dec 2021	2021			1	6	Writing parallel programs – whether it is a multithreaded or multi-processed – can often be a daunting task. Developers need to pay close attention to a lot of things related with threads and processes. It is possible that one of these things will be ignored against their will. If this happens the program easily can go into a faulty state. In many cases, this means all that is left is to terminate the program manually. There may also be cases where a poorly written parallel program, despite the calculations run on multiple cores or on multiple computers such as social network servers for example, the program itself proves to be slower than its sequential counterpart. This paper investigates to find out whether there is an “actual” parallelism between threads or processes or where there are cases when one of them has to wait for the others to finish their execution. This getting to the point that the program could have been solved with a much simpler sequential program. We propose an approach and its implementation that results in the comprehension of thread schedule. We deal with C++ threads therefore we do not mind the different hardware elements, the language constructs provide abstraction over CPUs and operating systems. This approach is based on static analysis and its implementation takes advantage of the Clang compiler infrastructure.	2640-0227	978-1-6654-9453-3		C++;code comprehension;multi-threading;static analysis	Codes;Social networking (online);Instruction sets;C++ languages;Static analysis;Writing;User interfaces	C++ language;multi-threading;processor scheduling;program compilers;program diagnostics;social networking (online)	thread scheduling;C++ programming language;parallel programs;faulty state;multiple cores;multiple computers;social network servers;sequential counterpart;actual parallelism;simpler sequential program;C++ threads;operating systems;static analysis;Clang compiler infrastructure				19	IEEE	22 Dec 2021			IEEE	IEEE Conferences
Towards a tool for visualizing pupil dilation linked with source code artifacts	towards a tool for visualizing pupil dilation linked with source code artifacts	10.1109/VISSOFT51673.2020.00016	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9240494	C. Ioannou; P. Bækgaard; E. Kindler; B. Weber	DTU Compute, Technical University of Denmark, Lyngby, Denmark; DTU Compute, Technical University of Denmark, Lyngby, Denmark; DTU Compute, Technical University of Denmark, Lyngby, Denmark; Institute of Computer Science, University of St. Gallen, St. Gallen, Switzerland	2020 Working Conference on Software Visualization (VISSOFT)	30 Oct 2020	2020			105	109	Recent eye tracking research in the field of software engineering has proposed novel visualizations linking developer's gazes with the source code artifacts to better understand how developers comprehend source code artifacts potentially consisting of several different files. In addition, it is well established that cognitive processes can be monitored by recording the change in pupil dilation. Recent pupillometry studies in the software engineering field have shown that pupil dilation can be used either as an indicator of cognitive load or task difficulty. We envision to create a tool for visualizing pupil dilation linked to source code artifacts that can help to better understand the cognitive processes of a developer during code comprehension tasks in terms of cognitive load. In this paper, we describe a feasibility study we conducted to enable a more fine-grained analysis of pupil dilation and we demonstrate some preliminary results.		978-1-7281-9914-6		pupil dilation;code comprehension;cognitive load	Visualization;Cognitive processes;Tools;Software;Pupils;Task analysis;Software engineering	data visualisation;eye;gaze tracking;hearing;software engineering	eye tracking research;source code artifacts;software engineering field;cognitive load;code comprehension tasks;pupil dilation visualization				29		30 Oct 2020			IEEE	IEEE Conferences
Students’ Misunderstanding of the Order of Evaluation in Conjoined Conditions	students’ misunderstanding of the order of evaluation in conjoined conditions	10.1109/ICPC52881.2021.00055	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463041	E. S. Wiese; A. N. Rafferty; G. Moseke	School of Computing, University of Utah, Salt Lake City, USA; Computer Science Department, Carleton College, Northfield, USA; School of Computing, University of Utah, Salt Lake City, USA	2021 IEEE/ACM 29th International Conference on Program Comprehension (ICPC)	28 jun. 2021	2021			476	484	Experts often use particular control flow structures to make their code easier to read and modify, such as using the logical operator AND to conjoin conditions rather than nesting separate if statements. Within Boolean expressions, experts take advantage of short-circuit evaluation by ordering their conditions to avoid errors (such as checking that an index is within the bounds of an array before examining the value at that index). How well do students understand these structures? We investigate students' use and understanding of conjoined versus separate conditions within a larger assessment of 125 undergraduate students at the end of their second- and third-semester CS courses (in algorithms & data structures and introductory software engineering). The assessment asked students to: write code where an edge case error could be avoided with short-circuit evaluation, revise their code with nudges towards expert structure, and answer comprehension questions involving code tracing. When writing, students frequently forgot to check for a key edge case. When that case was included, the check was often separated in its own if-statement rather than conjoined with the other conditions. This could indicate a stylistic choice or a belief that the check had to be separated for functionality. Notably, students who included all necessary conditions rarely exhibited the error of ordering them incorrectly. However, with code comprehension, students demonstrated significant misunderstandings about the effects of condition ordering. Students were more accurate on comprehension tasks with nested ifs than conjoined conditions, and this effect was most pronounced when the ordering of the conditions would lead to errors. When conditions were conjoined in a single expression, only 35% of students recognized that checking a value at an index before checking that the index was in bounds would lead to an error. However, 54% of students recognized the problem when the conditions were separated into individual if-statements. This demonstrates a subtlety in code execution that intermediate students may not have mastered and emphasizes the challenges in assessing students' understanding solely via the way they write code.	2643-7171	978-1-6654-1403-6		Computer science education;Student code comprehension;Programming style;Discourse rules	Computer science;Software algorithms;Writing;Encoding;Cognitive science;Indexes;Arrays	computer science education;data structures;educational courses;software engineering	control flow structures;logical operator;Boolean expressions;short-circuit evaluation;conjoined versus separate conditions;undergraduate students;third-semester CS courses;data structures;software engineering;edge case error;expert structure;answer comprehension questions;code tracing;key edge case;code comprehension;condition ordering;individual if-statements;code execution;intermediate students;second-semester CS courses				16		28 jun. 2021			IEEE	IEEE Conferences
Metric pictures: The approach and applications	metric pictures the approach and applications	10.1109/ICCES.2010.5674876	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5674876	R. Francese; S. Murad; I. Passero; G. Tortora	Dipartimento di Matematica e Informatica, University of Salerno, Italy; Dipartimento di Matematica e Informatica, University of Salerno, Italy; Dipartimento di Matematica e Informatica, University of Salerno, Italy; Dipartimento di Matematica e Informatica, University of Salerno, Italy	The 2010 International Conference on Computer Engineering & Systems	23 Dec 2010	2010			320	325	Source code metrics evaluate some aspects of software artefacts and provide synthetic measures of examined characteristics. Metrics are broadly adopted for code tracking, analysis and comprehension. In this paper, we present Metric Pictures, raster images obtained from source code metrics. With this method, the paper introduces algebra, derived from Image Elaboration, sounding with metric definitions. Metric Pictures with their operation set can be generally useful for underlining interesting features of analyzed code. As an example, the paper describes the application of the underlying logic and operators to Dead Code detection.		978-1-4244-7042-6		Object oriented metrics;code comprehension;code analysis;metric visualization;image elaboration	Software;Visualization;Data visualization;Image color analysis;Software measurement;Algebra	algebra;software metrics	metric pictures;source code metrics;software artifacts;code tracking;algebra;image elaboration;dead code detection				48		23 Dec 2010			IEEE	IEEE Conferences
Measuring Developers' Expertise Based on Version Control Data	measuring developers expertise based on version control data	10.23919/MIPRO52101.2021.9597103	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9597103	A. Fekete; M. Cserép; Z. Porkoláb	Faculty of Informatics, ELTE Eötvös Loránd University, Budapest, Hungary; Faculty of Informatics, ELTE Eötvös Loránd University, Budapest, Hungary; Faculty of Informatics, ELTE Eötvös Loránd University, Budapest, Hungary	2021 44th International Convention on Information, Communication and Electronic Technology (MIPRO)	15 nov. 2021	2021			1607	1612	Developers' fluctuation in the lifetime of a software product might deteriorate the understanding of the source code to a level where developer expertise of some modules drops to a dangerously low point. It is important for the project management to identify such critical modules to avoid complete knowledge loss. This paper presents a developer-centered static analysis tool that is intended to show individual expertise in large software projects. The expertise value is computed for each file through repository mining of the version control system of the project. The calculated value is based on the quality of commits per developer. The results of the proposed method have been validated on the CodeChecker open-source project, comparing against the findings of a user questionnaire filled by developers of the project on their expertise.	2623-8764	978-953-233-101-1		developer expertise;version control;repository mining;code comprehension	Measurement;Fluctuations;Codes;Project management;Static analysis;Tools;Control systems	configuration management;data mining;program diagnostics;project management;public domain software;software development management;software quality;source code (software)	developer-centered static analysis tool;software projects;expertise value;repository mining;version control system;CodeChecker open-source project;version control data;software product;source code;developer expertise;project management;knowledge loss				21		15 nov. 2021			IEEE	IEEE Conferences
Discovering Programmer Intention Behind Written Source Code	discovering programmer intention behind written source code	10.1109/ICMLA.2019.00081	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8999275	G. Sznaier Camps; N. Bohm Agostini; D. Kaeli	Dept. of Aerospace & Astronautics, Stanford Univ., Palo Alto, CA, USA; Dept. of Electrical and Computer Eng., Northeastern Univ., Boston, MA, USA; Dept. of Electrical and Computer Eng, Northeastern Univ, Boston, MA	2019 18th IEEE International Conference On Machine Learning And Applications (ICMLA)	17 Feb 2020	2019			432	437	The goal of this work is to leverage natural lan-guage processing techniques to assist in the classification andunderstanding of a programmer's intention from inspectingsource code. Our model utilizes well-known machine learningtechniques. We find that we can accurately classify C sourcecode into different classes, distinguishing between benign andmalicious source code with a high degree of accuracy.		978-1-7281-4550-1		source code comprehension, bag of words, malware detection, machine learning	Natural language processing;Data models;Support vector machines;Forestry;Standards;Malware;Decision trees	C++ language;learning (artificial intelligence);natural language processing;pattern classification;program compilers	programmer intention;written source code;natural language;classification;machine learning techniques;malicious source code;C source code				30		17 Feb 2020			IEEE	IEEE Conferences
Feature Location Using Probabilistic Ranking of Methods Based on Execution Scenarios and Information Retrieval	feature location using probabilistic ranking of methods based on execution scenarios and information retrieval	10.1109/TSE.2007.1016	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4181710	D. Poshyvanyk; Y. -G. Gueheneuc; A. Marcus; G. Antoniol; V. Rajlich	Department of Computer Science, Wayne State University, Detroit, MI, USA; Département dinformatique et recherche opérationnelle, Université de Montreal, Montreal, QUE, Canada; Department of Computer Science, Wayne State University, Detroit, MI, USA; Département dinformatique, École Polytechnique de Montréal, Montreal, QUE, Canada; Department of Computer Science, Wayne State University, Detroit, MI, USA	IEEE Transactions on Software Engineering	7 May 2007	2007	33	6	420	432	This paper recasts the problem of feature location in source code as a decision-making problem in the presence of uncertainty. The solution to the problem is formulated as a combination of the opinions of different experts. The experts in this work are two existing techniques for feature location: a scenario-based probabilistic ranking of events and an information-retrieval-based technique that uses latent semantic indexing. The combination of these two experts is empirically evaluated through several case studies, which use the source code of the Mozilla Web browser and the Eclipse integrated development environment. The results show that the combination of experts significantly improves the effectiveness of feature location as compared to each of the experts used independently	1939-3520			Program understanding;feature identification;concept location;dynamic and static analyses;information retrieval;Latent Semantic Indexing;scenario-based probabilistic ranking;open source software.	Information retrieval;Performance analysis;Indexing;Programming profession;Computer Society;Decision making;Uncertainty;Information analysis;Open source software;Computer bugs	decision making;information retrieval;probability;program diagnostics	feature location;information retrieval;decision-making problem;scenario-based probabilistic event ranking;latent semantic indexing;Mozilla Web browser;Eclipse integrated development		305	4	49		7 May 2007			IEEE	IEEE Journals
How effective developers investigate source code: an exploratory study	how effective developers investigate source code an exploratory study	10.1109/TSE.2004.101	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1377187	M. P. Robillard; W. Coelho; G. C. Murphy	School of Computer Science, McGill University, Montreal, QUE, Canada; Department of Computer Science, University of British Columbia, Vancouver, BC, Canada; Department of Computer Science, University of British Columbia, Vancouver, BC, Canada	IEEE Transactions on Software Engineering	10 jan. 2005	2004	30	12	889	903	Prior to performing a software change task, developers must discover and understand the subset of the system relevant to the task. Since the behavior exhibited by individual developers when investigating a software system is influenced by intuition, experience, and skill, there is often significant variability in developer effectiveness. To understand the factors that contribute to effective program investigation behavior, we conducted a study of five developers performing a change task on a medium-size open source system. We isolated the factors related to effective program investigation behavior by performing a detailed qualitative analysis of the program investigation behavior of successful and unsuccessful developers. We report on these factors as a set of detailed observations, such as evidence of the phenomenon of inattention blindness by developers skimming source code. In general, our results support the intuitive notion that a methodical and structured approach to program investigation is the most effective.	1939-3520			Index Terms- Software evolution;empirical software engineering;program investigation;program understanding.	Software systems;Performance analysis;Programming;Software tools;Computer Society;Software performance;Blindness;Software engineering;Scattering;Inspection	software prototyping;reverse engineering;public domain software;open systems;programming environments	source code;software system investigation;program investigation behavior;medium-size open source system;software evolution;empirical software engineering;program understanding		154		35		10 jan. 2005			IEEE	IEEE Journals
I Know What You Did Last Summer - An Investigation of How Developers Spend Their Time	i know what you did last summer an investigation of how developers spend their time	10.1109/ICPC.2015.12	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181430	R. Minelli; A. Mocci; M. Lanza	Faculty of Informatics - University of Lugano, Switzerland; Faculty of Informatics - University of Lugano, Switzerland; Faculty of Informatics - University of Lugano, Switzerland	2015 IEEE 23rd International Conference on Program Comprehension	7 Sep 2015	2015			25	35	Developing software is a complex mental activity, requiring extensive technical knowledge and abstraction capabilities. The tangible part of development is the use of tools to read, inspect, edit, and manipulate source code, usually through an IDE (integrated development environment). Common claims about software development include that program comprehension takes up half of the time of a developer, or that certain UI (user interface) paradigms of IDEs offer insufficient support to developers. Such claims are often based on anecdotal evidence, throwing up the question of whether they can be corroborated on more solid grounds. We present an in-depth analysis of how developers spend their time, based on a fine-grained IDE interaction dataset consisting of ca. 740 development sessions by 18 developers, amounting to 200 hours of development time and 5 million of IDE events. We propose an inference model of development activities to precisely measure the time spent in editing, navigating and searching for artifacts, interacting with the UI of the IDE, and performing corollary activities, such as inspection and debugging. We report several interesting findings which in part confirm and reinforce some common claims, but also disconfirm other beliefs about software development.	1092-8138	978-1-4673-8159-8		interaction data;empirical study;program understanding;user interface	Mice;Keyboards;Navigation;Browsers;Inspection;Software;History	software engineering	software development;IDE;fine-grained IDE interaction dataset;user interface		76	5	37		7 Sep 2015			IEEE	IEEE Conferences
Butterflies: a visual approach to characterize packages	butterflies a visual approach to characterize packages	10.1109/METRICS.2005.15	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1509285	S. Ducasse; M. Lanza; L. Ponisio	Software Composition Group, University of Bern, Switzerland; Faculty of Informatics, University of Lugano, Switzerland; Software Composition Group, University of Bern, Switzerland	11th IEEE International Software Metrics Symposium (METRICS'05)	24 Oct 2005	2005			10 pp.	7	Understanding sets of classes, or packages, is an important activity in the development and reengineering of large object-oriented systems. Packages represent the coarse grained structure of an application. They are artefacts to deploy and structure software, and therefore more than a simple generalization of classes. The relationships between packages and their contained classes are key in the decomposition of an application and its (re)-modularisation. However, it is difficult to quickly grasp the structure of a package and to understand how a package interacts with the rest of the system. We tackle this problem using butterfly visualizations, i.e., dedicated radar charts built from simple package metrics based on a language-independent meta-model. We illustrate our approach on two applications and show how we can retrieve the relevant characteristics of packages.	1530-1435	0-7695-2371-4		Program understanding;package metrics;reverse engineering;software visualization	Packaging;Application software;Software maintenance;Software packages;Visualization;Reverse engineering;Software systems;Java;Informatics;Radar	object-oriented programming;program visualisation;reverse engineering;software metrics;software packages;systems re-engineering	software package characterization;system development;system reengineering;object-oriented systems;class generalization;butterfly visualization;radar charts;package metrics;language-independent metamodel;program understanding;reverse engineering;software visualization		64		30		24 Oct 2005			IEEE	IEEE Conferences
The Programmer's Apprentice: Knowledge Based Program Editing	the programmers apprentice knowledge based program editing	10.1109/TSE.1982.234769	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1702900	R. C. Waters	Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, MA, USA	IEEE Transactions on Software Engineering	18 Sep 2006	1982	SE-8	1	1	12	An initial implementation of an interactive programming assistant system called the programmer's apprentice (PA) is described. The PA is designed to be midway between an improved programming methodology and an automatic programming system. The intention is that the programmer will do the hard parts of design and implementation while the PA will assist him wherever possible. One of the major underpinnings of the PA is a representation (called a plan) for programs which abstracts away from the inessential features of a program, and represents the basic logical properties of the algorithm explicitly.	1939-3520			Computer-aided design;editing;Lisp;plans;program analysis;programmer's apprentice;program modification;program synthesis;program understanding;transformations	Programming profession;Libraries;Automatic programming;Programming environments;Computer languages;Abstracts;Algorithm design and analysis;Program processors;Documentation;Debugging		Computer-aided design;editing;Lisp;plans;program analysis;programmer's apprentice;program modification;program synthesis;program understanding;transformations		64	9	15		18 Sep 2006			IEEE	IEEE Journals
Feature identification: a novel approach and a case study	feature identification a novel approach and a case study	10.1109/ICSM.2005.48	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510131	G. Antoniol; Y. . -G. Gueheneuc	Départment de Génie Informatique, École Polytechnique de Montréal, Canada; Départment de Génie Informatique, École Polytechnique de Montréal, Canada	21st IEEE International Conference on Software Maintenance (ICSM'05)	21 nov. 2005	2005			357	366	Feature identification is a well-known technique to identify subsets of a program source code activated when exercising a functionality. Several approaches have been proposed to identify features. We present an approach to feature identification and comparison for large object-oriented multi-threaded programs using both static and dynamic data. We use processor emulation, knowledge filtering, and probabilistic ranking to overcome the difficulties of collecting dynamic data, i.e., imprecision and noise. We use model transformations to compare and to visualise identified features. We compare our approach with a naive approach and a concept analysis-based approach using a case study on a real-life large object-oriented multi-threaded program, Mozilla, to show the advantages of our approach. We also use the case study to compare processor emulation with statistical profiling.	1063-6773	0-7695-2368-4		Program understanding;dynamic and static analyses;feature analysis;meta-modelling	Computer aided software engineering;Object oriented modeling;Software maintenance;Emulation;Filtering;Performance analysis;Data structures;Uniform resource locators;Visualization;Software performance	program diagnostics;object-oriented programming;multi-threading;program visualisation	feature identification;program source code identification;object-oriented multithreaded programs;processor emulation;knowledge filtering;probabilistic ranking;model transformations;concept analysis-based approach;Mozilla;statistical profiling		58	2	23		21 nov. 2005			IEEE	IEEE Conferences
Feature Identification: An Epidemiological Metaphor	feature identification an epidemiological metaphor	10.1109/TSE.2006.88	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1707664	G. Antoniol; Y. . -G. Gueheneuc	Department dinformatique, Ecole Polytechnique de Montreal, Montreal, QUE, Canada; Department dinformatique et recherche operationelle, Universite de Montreal, Montreal, QUE, Canada	IEEE Transactions on Software Engineering	9 Oct 2006	2006	32	9	627	641	Feature identification is a technique to identify the source code constructs activated when exercising one of the features of a program. We propose new statistical analyses of static and dynamic data to accurately identify features in large multithreaded object-oriented programs. We draw inspiration from epidemiology to improve previous approaches to feature identification and develop an epidemiological metaphor. We build our metaphor on our previous approach to feature identification, in which we use processor emulation, knowledge-based filtering, probabilistic ranking, and metamodeling. We carry out three case studies to assess the usefulness of our metaphor, using the "save a bookmark" feature of Web browsers as an illustration. In the first case study, we compare our approach with three previous approaches (a naive approach, a concept analysis-based approach, and our previous probabilistic approach) in identifying the feature in MOZILLA, a large, real-life, multithreaded object-oriented program. In the second case study, we compare the implementation of the feature in the FIREFOX and MOZILLA Web browsers. In the third case study, we identify the same feature in two more Web browsers, Chimera (in C) and ICEBrowser (in Java), and another feature in JHOTDRAW and XFIG, to highlight the generalizability of our metaphor	1939-3520			Program understanding;dynamic analysis;static analysis;feature identification;epidemiology;Firefox and Mozilla Web browsers.	Microarchitecture;Statistical analysis;Emulation;Filtering;Uniform resource locators;Metamodeling;Java;Software maintenance;Data structures;Documentation	multi-threading;object-oriented programming;program diagnostics;software maintenance;statistical analysis	feature identification;epidemiological metaphor;source code identification;statistical analysis;multithreaded object-oriented program;processor emulation;knowledge-based filtering;probabilistic ranking;metamodeling;Web browser;naive approach;concept analysis-based approach;MOZILLA;FIREFOX;Chimera;ICEBrowser;JHOTDRAW;XFIG;program understanding;dynamic program analysis;static program analysis;software maintenance;legacy software		57	2	45		9 Oct 2006			IEEE	IEEE Journals
A Method for Analyzing Loop Programs	a method for analyzing loop programs	10.1109/TSE.1979.234185	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1702623	R. C. Waters	Artificial Intelligence Laboratory and the Laboratory for Computer Science, Massachusetts Institute of Technology, Cambridge, MA, USA	IEEE Transactions on Software Engineering	18 Sep 2006	1979	SE-5	3	237	247	This paper presents a method for automatically analyzing loops, and discusses why it is a useful way to look at loops. The method is based on the idea that there are four basic ways in which the logical structure of a loop is built up. An experiment is presented which shows that this accounts for the structure of a large class of loops. The paper discusses how the method can be used to automatically analyze the structure of a loop, and how the resulting analysis can be used to guide a proof of correctness for the loop. An automatic system is described which performs this type of analysis. The paper discusses the relationship between the structure building methods presented and programming language constructs. A system is described which is designed to assist a person who is writing a program. The intent is that the system will cooperate with a programmer throughout aUl phases of work on a program and be able to communicate with the programmer about it.	1939-3520			Loops;plans;program analysis;program verification;program understanding	Computer languages;Programming profession;Artificial intelligence;Performance analysis;Writing;Buildings;Abstracts;Contracts;Computer science;Algorithms		Loops;plans;program analysis;program verification;program understanding		49		29		18 Sep 2006			IEEE	IEEE Journals
Part-of-speech tagging of program identifiers for improved text-based software engineering tools	partofspeech tagging of program identifiers for improved textbased software engineering tools	10.1109/ICPC.2013.6613828	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613828	S. Gupta; S. Malik; L. Pollock; K. Vijay-Shanker	Computer and Information Sciences, University of Delaware, Newark, DE, USA; Department of Computer Science, University of Maryland, College Park, MD, USA; Computer and Information Sciences, University of Delaware, Newark, DE, USA; Computer and Information Sciences, University of Delaware, Newark, DE, USA	2013 21st International Conference on Program Comprehension (ICPC)	30 Sep 2013	2013			3	12	To aid program comprehension, programmers choose identifiers for methods, classes, fields and other program elements primarily by following naming conventions in software. These software “naming conventions” follow systematic patterns which can convey deep natural language clues that can be leveraged by software engineering tools. For example, they can be used to increase the accuracy of software search tools, improve the ability of program navigation tools to recommend related methods, and raise the accuracy of other program analyses. After splitting multi-word names into their component words, the next step to extracting accurate natural language information is tagging each word with its part of speech (POS) and then chunking the name into natural language phrases. State-of-theart approaches, most of which rely on “traditional POS taggers” trained on natural language documents, do not capture the syntactic structure of program elements. In this paper, we present a POS tagger and syntactic chunker for source code names that takes into account programmers' naming conventions to understand the regular, systematic ways a program element is named. We studied the naming conventions used in Object Oriented Programming and identified different grammatical constructions that characterize a large number of program identifiers. This study then informed the design of our POS tagger and chunker. Our evaluation results show a significant improvement in accuracy(11%-20%) of POS tagging of identifiers, over the current approaches. With this improved accuracy, both automated software engineering tools and developers will be able to better capture and understand the information available in code.	1092-8138	978-1-4673-3092-3		Program understanding;comprehension;part-of-speech;natural language processing;identifiers	Tagging;Software;Natural languages;Syntactics;Accuracy;Context;Software engineering	natural language processing;object-oriented programming;reverse engineering;software engineering;text analysis	part-of-speech tagging;program identifiers;text-based software engineering tools;program comprehension;method identifier;class identifier;field identifier;program elements;software naming conventions;deep natural language clues;software search tools;program navigation tools;program analysis;multiword name splitting;component words;natural language information extraction;word tagging;part of speech;natural language phrases;natural language documents;syntactic structure;POS tagger;syntactic chunker;source code names;programmer naming convention;object oriented programming;grammatical construction		44		27		30 Sep 2013			IEEE	IEEE Conferences
Understanding Log Lines Using Development Knowledge	understanding log lines using development knowledge	10.1109/ICSME.2014.24	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6976068	W. Shang; M. Nagappan; A. E. Hassan; Z. M. Jiang	School of Computing, Queen's University, Canada; School of Computing, Queen's University, Canada; School of Computing, Queen's University, Canada; Department of Electrical Engineering & Computer Science, York University, Canada	2014 IEEE International Conference on Software Maintenance and Evolution	6 Dec 2014	2014			21	30	Logs are generated by output statements that developers insert into the code. By recording the system behaviour during runtime, logs play an important role in the maintenance of large software systems. The rich nature of logs has introduced a new market of log management applications (e.g., Splunk, XpoLog and log stash) that assist in storing, querying and analyzing logs. Moreover, recent research has demonstrated the importance of logs in operating, understanding and improving software systems. Thus log maintenance is an important task for the developers. However, all too often practitioners (i.e., operators and administrators) are left without any support to help them unravel the meaning and impact of specific log lines. By spending over 100 human hours and manually examining all the email threads in the mailing list for three open source systems (Hadoop, Cassandra and Zookeeper) and performing web search on sampled logging statements, we found 15 email inquiries and 73 inquiries from web search about different log lines. We identified that five types of development knowledge that are often sought from the logs by practitioners: meaning, cause, context, impact and solution. Due to the frequency and nature of log lines about which real customers inquire, documenting all the log lines or identifying which ones to document is not efficient. Hence in this paper we propose an on-demand approach, which associates the development knowledge present in various development repositories (e.g., code commits and issues reports) with the log lines. Our case studies show that the derived development knowledge can be used to resolve real-life inquiries about logs.	1063-6773	978-1-4799-6146-7		Software maintenance;Software Logs;Program understanding	Web search;Electronic mail;Context;Google;Software systems;Knowledge engineering;Engines	Internet;public domain software;software maintenance;system monitoring	log lines;development knowledge;log maintenance;open source systems;Web search		34		37		6 Dec 2014			IEEE	IEEE Conferences
Can Lexicon Bad Smells Improve Fault Prediction?	can lexicon bad smells improve fault prediction	10.1109/WCRE.2012.33	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385119	S. L. Abebe; V. Arnaoudova; P. Tonella; G. Antoniol; Y. -G. Guéhéneuc	Fondazione Bruno Kessler (FBK), Trento, Italy; Fondazione Bruno Kessler (FBK), Trento, Italy; École Polytechnique de Montréal, Montreal, QUE, Canada; École Polytechnique de Montréal, Montreal, QUE, Canada; École Polytechnique de Montréal, Montreal, QUE, Canada	2012 19th Working Conference on Reverse Engineering	20 Dec 2012	2012			235	244	In software development, early identification of fault-prone classes can save a considerable amount of resources. In the literature, source code structural metrics have been widely investigated as one of the factors that can be used to identify faulty classes. Structural metrics measure code complexity, one aspect of the source code quality. Complexity might affect program understanding and hence increase the likelihood of inserting errors in a class. Besides the structural metrics, we believe that the quality of the identifiers used in the code may also affect program understanding and thus increase the likelihood of error insertion. In this study, we measure the quality of identifiers using the number of Lexicon Bad Smells (LBS) they contain. We investigate whether using LBS in addition to structural metrics improves fault prediction. To conduct the investigation, we assess the prediction capability of a model while using i) only structural metrics, and ii) structural metrics and LBS. The results on three open source systems, ArgoUML, Rhino, and Eclipse, indicate that there is an improvement in the majority of the cases.	2375-5369	978-0-7695-4891-3		Fault prediction;lexicon bad smells;structural metrics;program understanding	Measurement;Predictive models;Principal component analysis;Computational modeling;Logistics;Support vector machines;Fault diagnosis	computational complexity;public domain software;software fault tolerance;software metrics;Unified Modeling Language	fault prediction;software development;fault-prone classes;source code structural metrics;faulty classes;structural metrics;code complexity;source code quality;error insertion likelihood;lexicon bad smells;LBS;open source systems;ArgoUML;Rhino;Eclipse		29		33		20 Dec 2012			IEEE	IEEE Conferences
Measuring Code Quality to Improve Specification Mining	measuring code quality to improve specification mining	10.1109/TSE.2011.5	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5680914	C. Le Goues; W. Weimer	Department of Computer Science, University of Virginia, Charlottesville, VA, USA; Department of Computer Science, University of Virginia, Charlottesville, VA, USA	IEEE Transactions on Software Engineering	30 jan. 2012	2012	38	1	175	190	Formal specifications can help with program testing, optimization, refactoring, documentation, and, most importantly, debugging and repair. However, they are difficult to write manually, and automatic mining techniques suffer from 90-99 percent false positive rates. To address this problem, we propose to augment a temporal-property miner by incorporating code quality metrics. We measure code quality by extracting additional information from the software engineering process and using information from code that is more likely to be correct, as well as code that is less likely to be correct. When used as a preprocessing step for an existing specification miner, our technique identifies which input is most indicative of correct program behavior, which allows off-the-shelf techniques to learn the same number of specifications using only 45 percent of their original input. As a novel inference technique, our approach has few false positives in practice (63 percent when balancing precision and recall, 3 percent when focused on precision), while still finding useful specifications (e.g., those that find many bugs) on over 1.5 million lines of code.	1939-3520			Specification mining;machine learning;software engineering;code metrics;program understanding.	Software measurement;Refactoring;Data mining;Maintenance engineering;Cloning;Optimization	data mining;formal specification;program debugging;program testing;software quality	specification mining;formal specifications;program testing;optimization;refactoring;documentation;debugging;repair;automatic mining techniques;temporal-property miner;code quality metrics;software engineering process		27		61		6 jan. 2011			IEEE	IEEE Journals
Bit-Level Taint Analysis	bitlevel taint analysis	10.1109/SCAM.2014.43	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6975659	B. Yadegari; S. Debray	Computer Science Department, University of Arizona; Computer Science Department, University of Arizona	2014 IEEE 14th International Working Conference on Source Code Analysis and Manipulation	6 Dec 2014	2014			255	264	Taint analysis has a wide variety of applications in software analysis, making the precision of taint analysis an important consideration. Current taint analysis algorithms, including previous work on bit-precise taint analyses, suffer from shortcomings that can lead to significant loss of precision (under/over tainting) in some situations. This paper discusses these limitations of existing taint analysis algorithms, shows how they can lead to imprecise taint propagation, and proposes a generalization of current bit-level taint analysis techniques to address these problems and improve their precision. Experiments using a deobfuscation tool indicate that our enhanced taint analysis algorithm leads to significant improvements in the quality of deobfuscation.		978-1-4799-6148-1		Taint Analysis;Reverse Engineering;Program Understanding	Algorithm design and analysis;Semantics;Registers;Standards;Heuristic algorithms;Data handling;Performance analysis	data flow analysis	software analysis;taint analysis algorithms;bit-precise taint analysis;taint propagation;bit-level taint analysis;deobfuscation tool		19		31		6 Dec 2014			IEEE	IEEE Conferences
Automatic Segmentation of Method Code into Meaningful Blocks to Improve Readability	automatic segmentation of method code into meaningful blocks to improve readability	10.1109/WCRE.2011.15	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079773	X. Wang; L. Pollock; K. Vijay-Shanker	Computer and Information Sciences, University of Delaware, Newark, DE, USA; Computer and Information Sciences, University of Delaware, Newark, DE, USA; Computer and Information Sciences, University of Delaware, Newark, DE, USA	2011 18th Working Conference on Reverse Engineering	17 nov. 2011	2011			35	44	With the goal of increasing program readability for easier understanding, coding guidelines often include formatting standards such as indenting loop and conditional branch body statements. Similarly, good programming practice suggests that programmers use blank lines to visibly delineate between code segments that represent different algorithmic steps or high level actions. Unfortunately, programmers do not always follow these guidelines. While editors and IDEs can easily indent code based on syntax, they do not currently support automatic blank line insertion, which presents more significant challenges involving the semantics. This paper presents a heuristic solution to the automatic blank line insertion problem, by leveraging both program structure and naming information to identify "meaningful blocks", consecutive statements that logically implement a high level action. Our tool, SEGMENT, takes as input a Java method, and outputs a segmented version that separates meaningful blocks by vertical spacing. We report on an evaluation of the effectiveness of SEGMENT based on developers' opinions. SEGMENT assists in making users obtain an overall picture of a method's actions and comprehend it quicker r as well as provides hints for internal documentation placement.	2375-5369	978-1-4577-1948-6		program understanding;readability;software tool;automatic formatting	Syntactics;Java;Semantics;Humans;Reverse engineering;Encoding;Compounds	document handling;Java;program compilers;software maintenance;source coding	automatic method code segmentation;program readability;formatting standards;indenting loop;conditional branch body statements;blank lines;IDE;automatic blank line insertion problem;SEGMENT;Java method;internal documentation placement		18		31		17 nov. 2011			IEEE	IEEE Conferences
Cross-Language Code Analysis and Refactoring	crosslanguage code analysis and refactoring	10.1109/SCAM.2012.11	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6392106	P. Mayer; A. Schroeder	Chair for Programming & Software Engineering, Institute for Computer Science Ludwig-Maximilians-Universität München, Germany; Chair for Programming & Software Engineering, Institute for Computer Science Ludwig-Maximilians-Universität München, Germany	2012 IEEE 12th International Working Conference on Source Code Analysis and Manipulation	24 Dec 2012	2012			94	103	Software composed of artifacts written in multiple (programming) languages is pervasive in today's enterprise, desktop, and mobile applications. Since they form one system, artifacts from different languages reference one another, thus creating what we call semantic cross-language links. By their very nature, such links are out of scope of the individual programming language, they are ignored by most language-specific tools and are often only established -- and checked for errors -- at runtime. This is unfortunate since it requires additional testing, leads to brittle code, and lessens maintainability. In this paper, we advocate a generic approach to understanding, analyzing and refactoring cross-language code by explicitly specifying and exploiting semantic links with the aim of giving developers the same amount of control over and confidence in multi-language programs they have for single-language code today.		978-0-7695-4783-1		cross-language;multi-language;analysis;program understanding;refactoring;constraints;tooling;polyglot programming	Semantics;Java;XML;Programming;Software;Layout;Navigation	program diagnostics;software maintenance	cross-language code analysis;mobile applications;desktop applications;enterprise applications;semantic cross-language links;programming language;language-specific tools;brittle code;maintainability;cross-language code refactoring;multilanguage programs;single-language code		16	2	27		24 Dec 2012			IEEE	IEEE Conferences
Building Approximate Calling Context from Partial Call Traces	building approximate calling context from partial call traces	10.1109/CGO.2009.12	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4907666	M. Serrano; X. Zhuang	IBM Thomas J. Watson Research Center, New York, NY, USA; IBM Thomas J. Watson Research Center, New York, NY, USA	2009 International Symposium on Code Generation and Optimization	5 May 2009	2009			221	230	We present an approach for building calling context information useful for program understanding, performance analysis and optimizations. Our approach exploits a lightweight profiling mechanism providing partial call traces. The goal is to reconstruct calling context information as accurately as possible, and to help the user navigate through it. We propose three steps to merge partial call traces into a smaller number of partial calling context trees. We intend to minimize errors such that the final partial contexts represent actual components of the real calling context tree with a very high probability. The first step concatenates call traces based on their common sequences. The second step converts call traces into partial calling context trees, and the last step merges partial context trees through maximal matching. To gauge how well the merged trees represent the full calling context tree, several criteria are presented. Our results indicate that call traces are successfully merged into a small number of large calling context trees. The merged trees are highly accurate.We have also developed a semi-automatic tool to navigate across partial calling context trees for program understanding and performance analysis purposes. Our results for several Java benchmarks show that our merging strategies exhibit a maximum 1% inaccuracy when compared to the exact solution.		978-0-7695-3576-0		Calling Context Tree;Call Context Analysis;Program Understanding	Performance analysis;Legged locomotion;Instruments;Sampling methods;Navigation;Operating systems;Hardware;Java;Merging;Monitoring	optimising compilers;pattern matching;probability;program debugging;program diagnostics;reverse engineering;tree data structures	partial call trace;approximate calling context information building;program understanding;performance analysis;program optimization;lightweight profiling mechanism;partial calling context tree;probability;maximal matching;semi automatic tool		13	1	20		5 May 2009			IEEE	IEEE Conferences
Using Dataflow Information for Concern Identification in Object-Oriented Software Systems	using dataflow information for concern identification in objectoriented software systems	10.1109/CSMR.2008.4493314	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4493314	M. Trifu	FZI Forschungszentrum Informatik, Karlsruhe, Germany	2008 12th European Conference on Software Maintenance and Reengineering	18 Apr 2008	2008			193	202	Improper encapsulation of cross-cutting concerns significantly hinders software understandability and contributes to rising software maintenance costs. Concern identification covers the necessary first step towards separating and encapsulating concerns in existing object-oriented code. Because most of the current approaches rely on syntactic rather than semantic information, they do not provide sufficient support for software understanding. This paper proposes a new semi-automated approach for concern identification specifically designed to support software understanding, which starts from a set of related variables and uses static dataflow information to determine the concern skeleton, a data-oriented abstraction of a concern. We discuss the application of this approach to the JHotDraw case-study, the de facto standard benchmark for concern identification, and show that it can be used to identify a significant number of concerns, including several concerns not previously discussed in the existing literature.	1534-5351	978-1-4244-2157-2		concern identification;program understanding;feature extraction;dataflow analysis	Software systems;Software maintenance;Skeleton;Encapsulation;Costs;Software design;Application software;Feature extraction;Data analysis;Computer science	object-oriented methods;software maintenance	static dataflow information;concern identification;object-oriented software systems;cross-cutting concerns;software understandability;software maintenance costs;data-oriented abstraction;JHotDraw case-study		13		21		18 Apr 2008			IEEE	IEEE Conferences
Syntax, Predicates, Idioms - What Really Affects Code Complexity?	syntax, predicates, idioms what really affects code complexity	10.1109/ICPC.2017.39	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961505	S. Ajami; Y. Woodbridge; D. G. Feitelson	Department of Computer Science, The Hebrew University, Jerusalem, Israel; Department of Statistics, The Hebrew University, Jerusalem, Israel; Department of Computer Science, The Hebrew University, Jerusalem, Israel	2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC)	29 jun. 2017	2017			66	76	Program comprehension concerns the ability to understand code written by others. But not all code is the same. We use an experimental platform fashioned as an online game-like environment to measure how quickly and accurately 222 professional programmers can interpret code snippets with similar functionality but different structures. The results indicate, inter alia, that 'for' loops are significantly harder than 'if's, that some but not all negations make a predicate harder, and that loops counting down are slightly harder than loops counting up. This demonstrates how the effect of syntactic structures, different ways to express predicates, and the use of known idioms can be measured empirically, and that syntactic structures are not necessarily the most important factor. By amassing many more empirical results like these it may be possible to derive better code complexity metrics than we have today.		978-1-5386-0535-6		Code complexity;program understanding;gamification	Complexity theory;Compounds;Syntactics;Programming;Context;Time measurement	computational linguistics;professional aspects;program control structures;program interpreters;reverse engineering;software metrics	program comprehension;online game-like environment;professional programmers;code snippets;code interpretation;loops;syntactic structures;predicates;idioms;code complexity metrics		13		44		29 jun. 2017			IEEE	IEEE Conferences
Things structural clones tell that simple clones don't	things structural clones tell that simple clones dont	10.1109/ICSM.2012.6405283	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6405283	H. A. Basit; U. Ali; S. Haque; S. Jarzabek	School of Science and Engineering, Lahore University of Management Sciences, Lahore, Pakistan; School of Science and Engineering, Lahore University of Management Sciences, Lahore, Pakistan; School of Science and Engineering, Lahore University of Management Sciences, Lahore, Pakistan; School of Computing, National University of Singapore, Singapore	2012 28th IEEE International Conference on Software Maintenance (ICSM)	10 jan. 2013	2012			275	284	In previous work, we described a technique for detecting design-level similar program structures (structural clones) formed from recurring configurations of similar code fragments (simple clones). In this paper, we analyze in detail how frequently these structural clones occur in software systems and how structural clone analysis extends the benefits of analysis based on simple clones only. Our case study of 11 open source systems revealed that over 50% of simple clones are captured by structural clones that often correspond to meaningful design or application domain concepts. Because of their larger size, it is easier for programmers to perceive the similarity situation in a system from structural clone perspective rather than from simple clone perspective only. We also discuss the contribution of structural clone detection towards program understanding, design recovery, maintenance, and refactoring using examples from the case study systems.	1063-6773	978-1-4673-2312-3		code clones;high level similarities;clone analysis;design recovery;program understanding;refactoring	Cloning;FCC;Conferences;Software maintenance;Educational institutions;Software systems;Containers	reverse engineering;software maintenance	structural clone detection;design-level similar program structure;recurring configuration;code fragment;simple clone;software system;open source system;application domain concept;program understanding;design recovery;program maintenance;program refactoring		11		18		10 jan. 2013			IEEE	IEEE Conferences
On State Machine Mining from Embedded Control Software	on state machine mining from embedded control software	10.1109/ICSME.2018.00024	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530024	W. Said; J. Quante; R. Koschke	Robert Bosch GmbH, Renningen, Germany; Robert Bosch GmbH, Renningen, Germany; University of Bremen, Bremen, Germany	2018 IEEE International Conference on Software Maintenance and Evolution (ICSME)	11 nov. 2018	2018			138	148	Program understanding is a time-consuming and tedious activity for software developers. Manually building abstractions from source code requires in-depth analysis of the code in the first place. Model mining can support program comprehension by semi-automatically extracting high-level models from code. One potentially helpful model is a state machine, which is an established formalism for specifying the behavior of a software component. There exist only few approaches for state machine mining, and they either deal with object-oriented systems or expect specific state implementation patterns. Both preconditions are usually not met by real-world embedded control software written in procedural languages. Other approaches extract only API protocols instead of the component's behavior. In this paper, we propose and evaluate several techniques that enable state machine mining from embedded control code: 1) We define criteria for state variables in procedural code based on an empirical study. This enables adaptation of an existing approach for extracting state machines from object-oriented software to embedded control code. 2) We present a refinement of the transition extraction process of that approach by removing infeasible transitions, which on average leads to more than 50% reduction of the number of transitions. 3) We evaluate two approaches to reduce the complexity of transition conditions. 4) An empirical study examines the limits of transition conditions' complexity that can still be understood by humans. These techniques and studies constitute major building blocks towards mining understandable state machines from embedded control software.	2576-3148	978-1-5386-7870-1		software maintenance;program understanding;static analysis;model mining;state machines;boolean minimization;embedded software;legacy code	Software;Object oriented modeling;Data mining;Complexity theory;Switches;Cost accounting;Process control	data mining;embedded systems;finite state machines;object-oriented programming;source code (software)	state machine mining;software developers;source code;model mining;software component;real-world embedded control software;embedded control code;state variables;procedural code;object-oriented software;transition extraction process;program understanding;program comprehension;object-oriented systems		11		36		11 nov. 2018			IEEE	IEEE Conferences
Towards the Extraction of Domain Concepts from the Identifiers	towards the extraction of domain concepts from the identifiers	10.1109/WCRE.2011.19	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079777	S. L. Abebe; P. Tonella	Software Engineering Research Unit, Fondazione Bruno Kessler, Trento, Italy; Software Engineering Research Unit, Fondazione Bruno Kessler, Trento, Italy	2011 18th Working Conference on Reverse Engineering	17 nov. 2011	2011			77	86	Program identifiers represent an invaluable source of information for developers who are not familiar with the code to be evolved. Domain concepts and inter-concept relationships can be automatically extracted by means of natural language processing techniques applied to the program identifiers. However, the ontology produced by this approach tends to be very large and to include implementation details that reduce its usefulness for domain concept understanding. In this paper, we analyze the effectiveness of information retrieval based techniques used to filter domain concepts and relations from the implementation details, so as to obtain a smaller, more informative domain ontology. In particular, we show that fully automated techniques based on keywords or topics have quite poor performance, while a semi-automated approach, requiring limited user involvement, can highly improve the filtering of domain concepts.	2375-5369	978-1-4577-1948-6		Program understanding;ontology extraction;domain concept filtering;information retrieval	Ontologies;Gold;Servers;Manuals;Documentation;Filtering;Natural languages	information filtering;natural language processing;ontologies (artificial intelligence)	domain concept extraction;program identifier;natural language processing technique;domain concept understanding;information retrieval based techniques;domain ontology;domain concept filtering		10	1	26		17 nov. 2011			IEEE	IEEE Conferences
Tracing requirements to tests with high precision and recall	tracing requirements to tests with high precision and recall	10.1109/ASE.2011.6100102	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6100102	C. Ziftci; I. Krueger	Computer Science Department, University of California, San Diego, USA; Computer Science Department, University of California, San Diego, USA	2011 26th IEEE/ACM International Conference on Automated Software Engineering (ASE 2011)	12 Dec 2011	2011			472	475	Requirements traceability is linking requirements to software artifacts, such as source code, test-cases and configuration files. For stakeholders of software, it is important to understand which requirements were tested, whether sufficiently, if at all. Hence tracing requirements in test-cases is an important problem. In this paper, we build on existing research and use features, realization of functional requirements in software [15], to automatically create requirements traceability links between requirements and test-cases. We evaluate our approach on a chat system, Apache Pool [21] and Apache Log4j [11]. We obtain precision/recall levels of more than 90%, an improvement upon currently existing Information Retrieval approaches when tested on the same case studies.	1938-4300	978-1-4577-1639-3		requirements traceability;testing;program understanding;automated analysis	Large scale integration;Documentation;Software engineering;Programming;Testing;Software systems	formal specification;formal verification;information retrieval;program diagnostics;source coding	requirement traceability;software artifacts;source code;software stakeholders;functional software Celal requirements;chat system;Apache Pool;Apache Log4j;information retrieval approaches		9		26		12 Dec 2011			IEEE	IEEE Conferences
Recovering Views of Inter-System Interaction Behaviors	recovering views of intersystem interaction behaviors	10.1109/WCRE.2009.34	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5328697	C. Ackermann; M. Lindvall; R. Cleaveland	Center for Experimental Software Engineering, Fraunhofer USA, College Park, MD, USA; Center for Experimental Software Engineering, Fraunhofer USA, College Park, MD, USA; Center for Experimental Software Engineering, Fraunhofer USA, College Park, MD, USA	2009 16th Working Conference on Reverse Engineering	17 nov. 2009	2009			53	61	This paper presents an approach for recovering application-level views of the interaction behaviors between systems that communicate via networks. Rather than illustrating a single behavior, a sequence diagram is constructed that describes the characteristics of multiple combined behaviors. The approach has several properties that make it particularly suitable for analyzing heterogeneous systems. First, since the interactions are retrieved from observing the network communication, our technique can be applied to systems that are implemented in different languages and run on different platforms. Second, it does not require the availability or modification of source code. After the behaviors are extracted, we employ methods to merge multiple observed behaviors to a single sequence diagram that illustrates the overall behavior.The contributions of this paper are a technique for observing and processing the network communication to derive a model of the behavior. Furthermore, it describes a series of model transformations to construct a sequence diagram view of all observed behaviors.	2375-5369	978-0-7695-3867-9		Program understanding;distributed systems;reliability	Data mining;Reverse engineering;Monitoring;Telecommunication traffic;Software engineering;Educational institutions;Telecommunication network reliability;Software systems;Instruments;Visualization	distributed processing;reverse engineering	intersystem interaction behaviors;sequence diagram;heterogeneous systems;network communication;reverse engineering;distributed systems;program understanding		8		12		17 nov. 2009			IEEE	IEEE Conferences
Teaching software engineering with projects	teaching software engineering with projects	10.1109/EduRex.2012.6225701	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6225701	J. Ludewig; I. Bogicevic	Institute for Software Technology, University of Stuttgart, Germany; Institute for Software Technology, University of Stuttgart, Germany	2012 First International Workshop on Software Engineering Education Based on Real-World Experiences (EduRex)	28 jun. 2012	2012			25	28	The software engineering curriculum offered by the University of Stuttgart emphasizes project work from the first to the last semester. While some of the projects are similar to those in other programs, others are less common. In this paper, we describe an introductory course called “Program Understanding”, and the so called “Consulting Task”. We also give a short description of what we call the First Software Project and the Large Software Project. In the Program Understanding course, new students learn to understand a fairly large, complex program in order to implement some modifications. In the Large Software Project, some ten people work on a serious software development for one year. In the Consulting Task, a group of three students analyses a problem, usually one given by an industrial partner. The students investigate possible solutions, and finally deliver a recommendation. Both our experience and feedback from students, including feedback from alumni, prove that these projects are very successful and highly esteemed.		978-1-4673-1805-1		software projects;Program Understanding;Consulting Task;software engineering curriculum	Software;Software engineering;Educational institutions;Programming;Industries;Companies;Java	project management;reverse engineering;software engineering;teaching	software engineering curriculum;University of Stuttgart;introductory course;consulting task;first software project;large software project;program understanding course;software development;industrial partner;feedback;teaching		6		4		28 jun. 2012			IEEE	IEEE Conferences
iFL: An interactive environment for understanding feature implementations	ifl an interactive environment for understanding feature implementations	10.1109/ICSM.2010.5609669	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609669	S. Hayashi; K. Sekine; M. Saeki	Tokyo Institute of Technology, Tokyo, Japan; Tokyo Institute of Technology, Tokyo, Japan; Tokyo Institute of Technology, Tokyo, Japan	2010 IEEE International Conference on Software Maintenance	25 Oct 2010	2010			1	5	We propose iFL, an interactive environment that is useful for effectively understanding feature implementation by application of feature location (FL). With iFL, the inputs for FL are improved incrementally by interactions between users and the FL system. By understanding a code fragment obtained using FL, users can find more appropriate queries from the identifiers in the fragment. Furthermore, the relevance feedback obtained by partially judging whether or not a fragment is relevant improves the evaluation score of FL. Users can then obtain more accurate results. Case studies with iFL show that our interactive approach is feasible and that it can reduce the understanding cost more effectively than the non-interactive approach.	1063-6773	978-1-4244-8629-8		program understanding;feature/concept location;relevance feedback	Schedules;Java;Biological system modeling;Software;Navigation;Information retrieval;Natural languages	relevance feedback;reverse engineering;software maintenance	interactive environment;iFL;feature location;code fragment understanding;relevance feedback;software maintenance		6		16		25 Oct 2010			IEEE	IEEE Conferences
Understanding Source Code Differences by Separating Refactoring Effects	understanding source code differences by separating refactoring effects	10.1109/APSEC.2011.47	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6130705	S. Thangthumachit; S. Hayashi; M. Saeki	Department of Computer Science, Tokyo Institute of Technology, Meguro, Tokyo, Japan; Department of Computer Science, Tokyo Institute of Technology, Meguro, Tokyo, Japan; Department of Computer Science, Tokyo Institute of Technology, Meguro, Tokyo, Japan	2011 18th Asia-Pacific Software Engineering Conference	16 jan. 2012	2011			339	347	Comparing and understanding differences between old and new versions of source code are necessary in various software development situations. However, if refactoring is applied between those versions, then the source code differences are more complicated, and understanding them becomes more difficult. Although many techniques for extracting refactoring effects from the differences have been studied, it is necessary to exclude the extracted refactorings' effects and reconstruct the differences for meaningful and understandable ones with no refactoring effect. As described in this paper, we propose a novel technique to address this difficulty. Using our technique, we extract the refactoring effects and then apply them to the old version of source code to produce the differences without refactoring effects. We also implemented a support tool that helps separate refactorings automatically. An evaluation of open source software showed that our tool is applicable to all target refactorings. Our technique is therefore useful in real situations. Evaluation testing also demonstrated that the approach reduced the code differences more than 21%, on average, and that developers can understand more changes from the differences using our approach than when using the original one in the same limited time.	1530-1362	978-1-4577-2199-1		source code differencing;program understanding;refactoring	Synchronization;Open source software;Programming;Testing;Java;Data mining;Browsers	program debugging;software engineering;source coding	source code differences;refactoring effect separation;software development;open source software;software testing;software debugging		5		20		16 jan. 2012			IEEE	IEEE Conferences
IoT End User Programming Models	iot end user programming models	10.1109/SERP4IoT.2019.00008	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8900747	S. P. Reiss	Department of Computer Science, Brown University, Providence, RI, USA	2019 IEEE/ACM 1st International Workshop on Software Engineering Research & Practices for the Internet of Things (SERP4IoT)	14 nov. 2019	2019			1	8	The advent of smart devices and sensors (the Internet of Things or IoT) will create increasing demands for the automation of devices based on sensor, time, and other inputs. This is essentially a programming task with all the problems and difficulties that programming entails, for example, modularity, feature interaction, debugging, and understanding. Moreover, much of the programming for smart devices is going to be done not by professional programmers but by end users, often end users without any programming experience or computational literacy. Our research is aimed at exploring the programming space and the associated issues using a case study of a smart sign that can be controlled using a variety of sensors. We have developed a general system for programming smart devices and, in this paper, explore a variety of different user interfaces for programming this system for our smart sign.		978-1-7281-2253-3		Internet of thingws;end-user programming;debugging;program understanding	Programming profession;Debugging;Internet of Things;Smart devices;Sensors;Software	computer literacy;Internet;Internet of Things;program debugging;user interfaces	user interfaces;Internet of Things;programming task;programming entails;feature interaction;end users;programming experience;programming space;smart sign;programming smart devices;IoT end user programming models;smart devices;smart sensors;computational literacy		3		51		14 nov. 2019			IEEE	IEEE Conferences
A Mechanism for Automatically Summarizing Software Functionality from Source Code	a mechanism for automatically summarizing software functionality from source code	10.1109/QRS.2019.00028	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8854713	C. Psarras; T. Diamantopoulos; A. Symeonidis	Electrical and Computer Engineering Dept., Aristotle University of Thessaloniki, Thessaloniki, Greece; Electrical and Computer Engineering Dept., Aristotle University of Thessaloniki, Thessaloniki, Greece; Electrical and Computer Engineering Dept., Aristotle University of Thessaloniki, Thessaloniki, Greece	2019 IEEE 19th International Conference on Software Quality, Reliability and Security (QRS)	3 Oct 2019	2019			121	130	When developers search online to find software components to reuse, they usually first need to understand the container projects/libraries, and subsequently identify the required functionality. Several approaches identify and summarize the offerings of projects from their source code, however they often require that the developer has knowledge of the underlying topic modeling techniques; they do not provide a mechanism for tuning the number of topics, and they offer no control over the top terms for each topic. In this work, we use a vectorizer to extract information from variable/method names and comments, and apply Latent Dirichlet Allocation to cluster the source code files of a project into different semantic topics. The number of topics is optimized based on their purity with respect to project packages, while topic categories are constructed to provide further intuition and Stack Exchange tags are used to express the topics in more abstract terms.		978-1-7281-3927-2		program understanding;topic modeling;reverse engineering;software reuse	Software;Semantics;Libraries;Data mining;Tuning;Java;Clustering algorithms	information retrieval;software maintenance;text analysis	source code files;project packages;topic categories;software components;latent Dirichlet allocation;software functionality;topic modeling techniques		3		21		3 Oct 2019			IEEE	IEEE Conferences
Towards Understandable Guards of Extracted State Machines from Embedded Software	towards understandable guards of extracted state machines from embedded software	10.1109/SANER.2019.8667983	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8667983	W. Said; J. Quante; R. Koschke	Robert Bosch GmbH, Renningen, Germany; Robert Bosch GmbH, Renningen, Germany; University of Bremen, Bremen, Germany	2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)	18 mar. 2019	2019			264	274	The extraction of state machines from complex software systems can be very useful to understand the behavior of a software, which is a prerequisite for other software activities, such as maintenance, evolution and reengineering. However, using static analysis to extract state machines from real-world embedded software often leads to models that cannot be understood by humans: The extracted models contain a high number of states and transitions and very complex guards (transition conditions). Integrating user interaction into the extraction process can reduce these state machines to an acceptable size. However, the problem of highly complex guards remains. In this paper, we present a novel approach to reduce the complexity of guards in such state machines to a degree that is understandable for humans. The conditions are reduced by a combination of heuristic logic minimization, masking of infeasible paths, and using transition priorities. The approach is evaluated with software developers on industrial embedded C code. The results show that the approach is highly effective in making the guards understandable. Our controlled experiment shows that guards reduced by our approach and presented with priorities are easier to understand than guards without priorities.	1534-5351	978-1-7281-0591-8		software reengineering;program understanding;static analysis;model mining;state machines;boolean minimization;embedded software;legacy code	Complexity theory;Minimization;Object oriented modeling;Cost accounting;Embedded software;Analytical models	C language;embedded systems;finite state machines;formal logic;minimisation;program diagnostics;software engineering;source code (software)	software developers;complex software systems;software activities;extraction process;state machines;embedded software;heuristic logic minimization;transition priorities;industrial embedded C code;complex guards		3		29		18 mar. 2019			IEEE	IEEE Conferences
Automatic Extraction of Heap Reference Properties in Object-Oriented Programs	automatic extraction of heap reference properties in objectoriented programs	10.1109/TSE.2008.91	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4693716	B. Demsky; M. Rinard	University of California, Irvine, Irvine, CA, USA; The State Center, MIT Computer Science and Artificial Intelligence Laboratory, Cambridge, MA, USA	IEEE Transactions on Software Engineering	2 jun. 2009	2009	35	3	305	324	We present a new technique for helping developers understand heap referencing properties of object-oriented programs and how the actions of the program affect these properties. Our dynamic analysis uses the aliasing properties of objects to synthesize a set of roles; each role represents an abstract object state intended to be of interest to the developer. We allow the developer to customize the analysis to explore the object states and behavior of the program at multiple different and potentially complementary levels of abstraction. The analysis uses roles as the basis for three abstractions: role transition diagrams, which present the observed transitions between roles and the methods responsible for the transitions; role relationship diagrams, which present the observed referencing relationships between objects playing different roles; and enhanced method interfaces, which present the observed roles of method parameters. Together, these abstractions provide useful information about important object and data structure properties and how the actions of the program affect these properties. We have implemented the role analysis and have used this implementation to explore the behavior of several Java programs. Our experience indicates that, when combined with a powerful graphical user interface, roles are a useful abstraction for helping developers explore and understand the behavior of object-oriented programs.	1939-3520			Program understanding;roles;design recovery.;Requirements/Specifications;Design Tools and Techniques;Software Engineering;Software/Software Engineering;Testing and Debugging	Data structures;Computer Society;Java;Graphical user interfaces;Information analysis;Data mining	data structures;diagrams;graphical user interfaces;Java;object-oriented programming;reverse engineering	automatic extraction;heap reference property;object-oriented program;role transition diagram;enhanced method interface;data structure;Java program;graphical user interface;program understanding;role relationship diagram		3	1	30		2 Dec 2008			IEEE	IEEE Journals
Discovering Comprehension Pitfalls in Class Hierarchies	discovering comprehension pitfalls in class hierarchies	10.1109/CSMR.2009.31	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812734	P. F. Mihancea; R. Marinescu	LOOSE Research Group, Politehnica University of Timişoara, Romania; LOOSE Research Group, Politehnica University of Timişoara, Romania	2009 13th European Conference on Software Maintenance and Reengineering	10 Apr 2009	2009			7	16	Despite many advances in program comprehension, polymorphism and inheritance are still the cause of many misunderstandings in object-oriented code. In this paper, we present a suite of such concrete, recurrent patterns where particular ways of using inheritance and polymorphism can easily mislead developers and maintainers during software understanding activities. We define these as comprehension pitfalls. Furthermore, the paper describes a metric-based approach aimed to automatically detect such situations in code. The experimental results presented in this paper, based on three medium-sized systems, indicate that the identified comprehension pitfalls and the approach used to detect them are a promising support for maintenance.	1534-5351	978-0-7695-3589-0		program understanding;polymorphism;inheritance;metrics	Software maintenance;Costs;Concrete;Computer bugs;Electronic mail;Target tracking;Application software;Software systems;Software engineering;Maintenance engineering	object-oriented methods;reverse engineering;software maintenance	comprehension pitfalls;class hierarchies;program comprehension;object-oriented code;recurrent patterns;software understanding activities;medium-sized systems;program understanding		2		24		10 Apr 2009			IEEE	IEEE Conferences
An XML C Source Code Interchange Format for CASE Tools	an xml c source code interchange format for case tools	10.1109/COMPSAC.2011.102	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032387	N. Atsumi; T. Kobayashi; S. Yamamoto; K. Agusa	Department of Information Engineering, Nagoya University, Japan; Department of Information Engineering, Nagoya University, Japan; Department of Information Science and Technology, Aichi Prefectural University, Japan; Department of Information Engineering, Nagoya University, Japan	2011 IEEE 35th Annual Computer Software and Applications Conference	3 Oct 2011	2011			498	503	We propose an XML C source code representation to support developing CASE tools. Since source code is a main artifact of software development, most CASE tools have some features related to source code editor, static analyzer, profiler, etc. To develop such tools, detailed information related to source code is needed. However, it is quite difficult to reuse program analysis features because they do not have common interfaces even for parsing and data/control-flow analysis that are most common features for such CASE tools. To address this issue, we focus on XML as an intermediate representation for source code information. Existing XML representations only represent structure of syntax trees and lack some important information required for CASE tools. We propose two models for representing source code, one is for intra-file information, which consists of syntax structure, flow, and type information, the other is for inter-file relation, which is cross-reference information. We also introduce CASE tools with our representation and demonstrate the efficacy in CASE tool development. To evaluate the efficacy, we show that a coding rule checker and a cross-referencer can be easily implemented using common XML processing libraries such as XSLT and XPath.	0730-3157	978-0-7695-4439-7		Program Analysis;CASE Tool Program Understanding;Coding Checker	XML;Computer aided software engineering;Syntactics;Encoding;Semantics;Data mining;Switches	data flow analysis;software engineering;XML	XML C source code interchange format;CASE tools;XML C source code representation;software development;source code editor;static analyzer;program analysis feature;parsing;data flow analysis;control flow analysis;source code information;syntax trees;syntax structure;coding rule checker;cross-referencer;XML processing libraries;XSLT;XPath		2		23		3 Oct 2011			IEEE	IEEE Conferences
Identifying Features of Android Apps from Execution Traces	identifying features of android apps from execution traces	10.1109/MOBILESoft.2019.00015	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8816950	Q. Xin; F. Behrang; M. Fazzini; A. Orso	Georgia Institute of Technology, Atlanta, GA, USA; Georgia Institute of Technology, Atlanta, GA, USA; Georgia Institute of Technology, Atlanta, GA, USA; Georgia Institute of Technology, Atlanta, GA, USA	2019 IEEE/ACM 6th International Conference on Mobile Software Engineering and Systems (MOBILESoft)	29 Aug 2019	2019			35	39	Understanding a program and the features it provides is essential for a number of software engineering tasks, including refactoring, debugging, and debloating. Unfortunately, program understanding and feature identification are also extremely challenging and time consuming activities. To support developers when they perform these activities, we propose FeatureFinder, an approach that aims to identify and understand the features of a program by analyzing its executions. Specifically, we defined our approach for Android apps, given their widespread use. Given an app, FeatureFinder generates traces that capture different properties of the app executions through instrumentation. It then leverages the user events in the trace to split the trace into segments, and clusters these segments based on their characteristics, using a classifier. Each identified cluster indicates a feature exercised in the execution. Finally, FeatureFinder suitably labels each identified cluster, so as to provide a human-readable description of the corresponding feature. We performed a case study in which we used FeatureFinder to identify features in two executions of the K-9 MAIL app. In the study, FeatureFinder was able to correctly identify 6 of the 11 manually identified features, which we believe is an encouraging result and motivates further research.		978-1-7281-3395-9		feature identification;program understanding;trace analysis	Clustering algorithms;Instruments;Postal services;Electronic mail;Feature extraction;Task analysis;Password	mobile computing;program diagnostics;program visualisation;reverse engineering;software maintenance	Android apps;execution traces;software engineering tasks;program understanding;feature identification;FeatureFinder;app executions;K-9 MAIL app;human-readable description		2		24		29 Aug 2019			IEEE	IEEE Conferences
Explaining Static Analysis - A Perspective	explaining static analysis a perspective	10.1109/ASEW.2019.00023	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8967437	M. Nachtigall; L. Nguyen Quang Do; E. Bodden	Paderborn University, Germany; Paderborn University, Paderborn, Germany; Fraunhofer IEM, Germany	2019 34th IEEE/ACM International Conference on Automated Software Engineering Workshop (ASEW)	27 jan. 2020	2019			29	32	Static code analysis is widely used to support the development of high-quality software. It helps developers detect potential bugs and security vulnerabilities in a program's source code without executing it. While the potential benefits of static analysis tools are beyond question, their usability is often criticised and prevents software developers from using static analysis to its full potential. In the past decade, researchers have studied developer needs and contrasted them to available static analysis tool functionalities. In this paper, we summarize the main design challenges for building usable static analysis tools, and show that they revolve around the notion of explainability, which is a subarea of usability. We present existing analysis tools and current research in static analysis usability, and detail how they approach those challenges. This leads us to proposing potential lines of future work in explainability for static analysis, namely turning static analysis tools into assistants and teachers.	2151-0830	978-1-7281-4136-7		Program analysis;Static analysis;Explainability;User experience;Program understanding		program debugging;program diagnostics;software quality	static code analysis;high-quality software;potential bugs;security vulnerabilities;software developers;usable static analysis tools;explainability;static analysis usability;static analysis tool functionalities		1		25		27 jan. 2020			IEEE	IEEE Conferences
Program Learning Using Static Information and Dynamic Program Execution Slices	program learning using static information and dynamic program execution slices	10.1109/WAINA.2010.15	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5480864	J. Sawamoto; E. Sugino; N. Segawa; Y. Wada	Faculty of Software and Information Science Department, Iwate Prefectural University, Iwate, Japan; Faculty of Software and Information Science Department, Iwate Prefectural University, Iwate, Japan; Faculty of Software and Information Science Department, Iwate Prefectural University, Iwate, Japan; Department of Information Environment, Tokyo Denki University, Inzai, Chiba, Japan	2010 IEEE 24th International Conference on Advanced Information Networking and Applications Workshops	7 jun. 2010	2010			157	162	Nowadays, we can easily obtain a copy of practically any used program in our open source community for learning. However, the reality is that the level of such practically used programs is often complex and of such a large scale so that it is not as easy to understand them as one might expect. We believe that we do need some kind of environment to help the learner read and understand programs. Learning programs is necessary for other reasons such as program maintenance, reuse of programs. In this research, we built a model to use for program understanding. Using it, we examined possible ways of supporting program learning. Based on that, the objective of this paper is to present our efforts at developing a program learning environment, which helps narrow down the scope of a program to facilitate reading and understanding it while finding the differences of such dynamic information, as found in the program execution history, and also provide an environment in which the learner can use static information. We evaluate the efficiency of the proposed program learning environment through experiments.		978-1-4244-6702-0		program understanding;program learning;execution history;program reuse;program maintenance	History;Large-scale systems;Application software;Conferences;Open source software;Information science;Costs;Programming;Documentation	learning systems;programming environments;public domain software;software maintenance;software reusability	static information;dynamic program execution slices;open source community;practically used programs;program maintenance;program reusability;program understanding;program learning environment;dynamic information;program execution history;learner				9		7 jun. 2010			IEEE	IEEE Conferences
A Framework for Debugging Java Programs in a Bytecode	a framework for debugging java programs in a bytecode	10.1109/iCCECOME.2018.8658589	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8658589	S. Soomro; M. R. Belgaum; Z. Alansari; M. H. Miraz	Department of Computer Studies, AMA International University, Salmabad, Bahrain; Department of Computer Studies, AMA International University, Salmabad, Bahrain; Department of Computer Studies, AMA International University, Salmabad, Bahrain; Centre for Financial Regulations and Economic Development (CFRED), The Chinese University of Hong Kong, Sha Tin, Hong Kong	2018 International Conference on Computing, Electronics & Communications Engineering (iCCECE)	7 mar. 2019	2018			317	322	In the domain of Software Engineering, program analysis and understanding has been considered to be a very challenging task since decade, as it demands dedicated time and efforts. The analysis of source code may occasionally be comparatively easier due to its static nature, however, the back-end code (Bytecode), especially in terms of Java programming, is complicated to be analysed. In this paper, we present a methodological approach towards understanding the Bytecode of Java programs. We put forward a framework for the debugging process of Java Bytecode. Furthermore, we discuss the debugging process of Bytecode understanding from simple to multiple statements with regards to data flow analysis. Finally, we present a comparative analysis of Bytecode along with the simulation of the proposed framework for the debugging process.		978-1-5386-4904-6		Software Maintenance;Bytecode Analysis;Software Testing;Control and Data Flow Analysis;Program Understanding	Java;Debugging;Tools;Computer bugs;Software maintenance;Testing	data flow analysis;Java;program debugging;program diagnostics;software engineering	software engineering;Java bytecode;bytecode understanding;data flow analysis;Java programming;back-end code;source code;program analysis;Java programs;debugging process;comparative analysis				20		7 mar. 2019			IEEE	IEEE Conferences
Prevalence of Confusing Code in Software Projects: Atoms of Confusion in the Wild	prevalence of confusing code in software projects atoms of confusion in the wild		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8595211	D. Gopstein; H. H. Zhou; P. Frankl; J. Cappos	New York University; New York University; New York University; New York University	2018 IEEE/ACM 15th International Conference on Mining Software Repositories (MSR)	30 Dec 2018	2018			281	291	Prior work has shown that extremely small code patterns, such as the conditional operator and implicit type conversion, can cause considerable misunderstanding in programmers. Until now, the real world impact of these patterns - known as 'atoms of confusion' - was only speculative. This work uses a corpus of 14 of the most popular and influential open source C and C++ projects to measure the prevalence and significance of these small confusing patterns. Our results show that the 15 known types of confusing micro patterns occur millions of times in programs like the Linux kernel and GCC, appearing on average once every 23 lines. We show there is a strong correlation between these confusing patterns and bug-ix commits as well as a tendency for confusing patterns to be commented. We also explore patterns at the project level showing the rate of security vulnerabilities is higher in projects with more atoms. Finally, we examine real code examples containing these atoms, including ones that were used to ind and ix bugs in our corpus. In total this work demonstrates that beyond simple misunderstanding in the lab setting, atoms of confusion are both prevalent - occurring often in real projects, and meaningful - being removed by bug-fix commits at an elevated rate.	2574-3864	978-1-4503-5716-6		Programming Languages;Program Understanding	Atomic measurements;Software;Computer bugs;Linux;Computers;Syntactics;Semantics	C++ language;Linux;program debugging;public domain software;security of data;software development management	confusing patterns;confusing micropatterns;project level;confusing code;software projects;extremely small code patterns;implicit type conversion;open source C;C++ projects;Linux kernel;GCC;security vulnerabilities;ind bugs;bug-fix commits				35		30 Dec 2018			IEEE	IEEE Conferences
Pruning the AST with Hunks to Speed up Tree Differencing	pruning the ast with hunks to speed up tree differencing	10.1109/SANER.2019.8668032	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8668032	C. Yang; E. J. Whitehead	School of Computer Science and Technology, QILU University of Technology(Shandong Academy of Sciences), Shandong, China; Dept. of Computational Media, University of California, Santa Cruz, Santa Cruz, USA	2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)	18 mar. 2019	2019			15	25	Inefficiency is a problem in tree-differencing approaches. As textual-differencing approaches are highly efficient and the hunks returned by them reflect the line range of the modified code, we propose a novel approach to prune the AST with hunks. We define the pruning strategies at the declaration level and the statement level, respectively. And, we have designed an algorithm to implement the strategies. Furthermore, we have integrated the algorithm to Change Distiller and GumTree. Through an evaluation on four open source projects, the results show that the approach is very effective in reducing the number of nodes and shortening the running time. On average, with declaration-level pruning, the number of nodes in the two tools is reduced by at least 64%. With statement-level pruning, the number of nodes in both tools is reduced by at least 74%. By using the declaration-level pruning and the statement-level pruning, GumTree's runtime is reduced by at least 70% and 75%, respectively.	1534-5351	978-1-7281-0591-8		tree-differencing;tree pruning;software evolution;program understanding	Tools;Couplings;Software;Filtering algorithms;Runtime;Syntactics;Computer science	public domain software;software engineering;trees (mathematics)	AST;hunks;tree differencing;pruning strategies;open source projects;declaration-level pruning;statement-level pruning;Change Distiller;GumTree;textual-differencing				18		18 mar. 2019			IEEE	IEEE Conferences
Revealing the Semantics of Data Wrangling Scripts With COMANTICS	revealing the semantics of data wrangling scripts with comantics	10.1109/TVCG.2022.3209470	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9904459	K. Xiong; Z. Luo; S. Fu; Y. Wang; M. Xu; Y. Wu	State Key Lab of CAD&CG, Zhejiang University, Hangzhou, China; Zhejiang Lab, Hangzhou, China; Zhejiang Lab, Hangzhou, China; Zhejiang Lab, Hangzhou, China; School of Computer and Artificial Intelligence, Zhengzhou University, Zhengzhou, China; State Key Lab of CAD&CG, Zhejiang University, Hangzhou, China	IEEE Transactions on Visualization and Computer Graphics		1912	PP	99	1	11	Data workers usually seek to understand the semantics of data wrangling scripts in various scenarios, such as code debugging, reusing, and maintaining. However, the understanding is challenging for novice data workers due to the variety of programming languages, functions, and parameters. Based on the observation that differences between input and output tables highly relate to the type of data transformation, we outline a design space including 103 characteristics to describe table differences. Then, we develop COMANTICS, a three-step pipeline that automatically detects the semantics of data transformation scripts. The first step focuses on the detection of table differences for each line of wrangling code. Second, we incorporate a characteristic-based component and a Siamese convolutional neural network-based component for the detection of transformation types. Third, we derive the parameters of each data transformation by employing a “slot filling” strategy. We design experiments to evaluate the performance of COMANTICS. Further, we assess its flexibility using three example applications in different domains.	1941-0506			Data Transformation;Semantic Inference;Program Understanding;Table Comparison	Codes;Semantics;Pipelines;Data visualization;Programming;Debugging;Task analysis							IEEE	27 Sep 2022			IEEE	IEEE Early Access Articles
On the Discovery of Business Processes Orchestration Patterns	on the discovery of business processes orchestration patterns	10.1109/SERVICES-1.2008.58	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4578352	N. M. F. Rodrigues; L. S. Barbosa	DI-CCTC, Universidade do Minho, Braga, Portugal; DI-CCTC, Universidade do Minho, Braga, Portugal	2008 IEEE Congress on Services - Part I	25 jul. 2008	2008			391	398	COORDINSPECTOR is a Software Tool aiming at extracting the coordination layer of a software system. Such a reverse engineering process provides a clear view of the actually invoked services as well as the logic behind such invocations. The analysis process is based on program slicing techniques and the generation of, System Dependence Graphs and Coordination Dependence Graphs. The tool analyzes Common Intermediate Language (CIL), the native language of the Microsoft .Net Framework, thus making suitable for processing systems developed in any .Net Framework compilable language. COORDINSPECTOR generates graphical representations of the coordination layer together with business process orchestrations specified in WSBPEL 2.0.	2378-3818	978-0-7695-3286-8		Service Discovery;Reverse Engineering;Program Understanding;Program Slicing;Sofware Architectures		business data processing;graph theory;program slicing;reverse engineering	business processes orchestration pattern;CoordInspector;reverse engineering process;program slicing technique;system dependence graph;coordination dependence graph;common intermediate language				9		25 jul. 2008			IEEE	IEEE Conferences
The impact of component interconnections on software quality: A network analysis approach	the impact of component interconnections on software quality a network analysis approach	10.1109/ICSMC.2012.6378010	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6378010	L. Jiang; K. M. Carley; M. W. Bigrigg; A. Eberlein; M. Galster	School of Computer Science, University of Adelaide, Australia; Institute of Software Research, Carnegie Mellon University, USA; Institute of Software Research, Carnegie Mellon University, USA; Department of Computer Science & Engineering, American University of Sharjah, UAE; University of Groningen, The Netherlands	2012 IEEE International Conference on Systems, Man, and Cybernetics (SMC)	13 Dec 2012	2012			1865	1872	The growing complexity of software has posed challenges for the design, understanding and maintenance of software. Software developers often spend a lot of effort on understanding how software components are connected. Through analysis of the data obtained from a real software application, this paper demonstrates that network analysis approaches can help understand software component interconnections and their impact on software quality. Additionally, this paper shows that there is a correlation between the number of bugs found in an application and a set of measures used in component (interconnection) networks. Furthermore, a case study showed that the software performance improved over two releases as a result of improving the component network.	1062-922X	978-1-4673-1714-6		Component network;software quality;program understanding;network science;centrality;network measures	Software;Educational institutions;USA Councils;Australia;Computer bugs;Complexity theory;Measurement	network theory (graphs);software maintenance;software metrics;software quality	component interconnection;software quality;network analysis approach;software complexity;software design;software understanding;software maintenance;software component;data analysis;software application;interconnection network;software performance				26		13 Dec 2012			IEEE	IEEE Conferences
An Eclipse Plugin for the Automated Reverse-Engineering of Software Programs	an eclipse plugin for the automated reverseengineering of software programs	10.1109/ITNG.2009.73	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5070631	P. Dugerdil; D. Kony; J. Belmonte	Department of Information Systems, Heg-University of Applied Sciences, Geneva, Switzerland; Department of Information Systems, Heg-University of Applied Sciences, Geneva, Switzerland; Department of Information Systems, Heg-University of Applied Sciences, Geneva, Switzerland	2009 Sixth International Conference on Information Technology: New Generations	10 jun. 2009	2009			284	289	In the reverse engineering of a software program, one of the key difficulties is actually to understand the software. While the published techniques work top down or bottom up, our approach works middle-out: before trying to understand the low level code, we first rebuild a hypothetical analysis model from the use-cases of the system. This model then represents the target of the understanding task. In fact we try to map the code elements to the analysis objects. For this approach to be useable in large industrial software systems, it must be supported by a powerful tool. This paper presents the Eclipse plugin we developed to support our methodology, as well as a reverse engineering scenario using this tool. We then discuss the technology we used and the result we obtained.		978-1-4244-3770-2		reverse engineering;program understanding;unified development process;eclipse plugin	Reverse engineering;Power system modeling;Software tools;Computer industry;Documentation;Information technology;Information systems;Software systems;Engines;User interfaces	programming;reverse engineering;software engineering	Eclipse plugin;automated reverse engineering;software programs				21		10 jun. 2009			IEEE	IEEE Conferences
On the automatic modularization of software systems using the Bunch tool	on the automatic modularization of software systems using the bunch tool	10.1109/TSE.2006.31	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1610610	B. S. Mitchell; S. Mancoridis	Department of Computer Science, Software Engineering Research Group, Drexel University, Philadelphia, PA, USA; Department of Computer Science, Software Engineering Research Group, Drexel University, Philadelphia, PA, USA	IEEE Transactions on Software Engineering	27 mar. 2006	2006	32	3	193	208	Since modern software systems are large and complex, appropriate abstractions of their structure are needed to make them more understandable and, thus, easier to maintain. Software clustering techniques are useful to support the creation of these abstractions by producing architectural-level views of a system's structure directly from its source code. This paper examines the Bunch clustering system which, unlike other software clustering tools, uses search techniques to perform clustering. Bunch produces a subsystem decomposition by partitioning a graph of the entities (e.g., classes) and relations (e.g., function calls) in the source code. Bunch uses a fitness function to evaluate the quality of graph partitions and uses search algorithms to find a satisfactory solution. This paper presents a case study to demonstrate how Bunch can be used to create views of the structure of significant software systems. This paper also outlines research to evaluate the software clustering results produced by Bunch.	1939-3520			Clustering;reverse engineering;reengineering;program comprehension;optimization;maintainability.	Software systems;Software tools;Software maintenance;Clustering algorithms;Reverse engineering;Software quality;Search problems;Software performance;Partitioning algorithms;Chaos	software architecture;software maintenance;reverse engineering;systems re-engineering;software tools;search problems	automatic modularization;Bunch software clustering tool;software system abstraction;software system architectural-level view;graph partition;search algorithm;reverse engineering;software system reengineering;program comprehension;software maintainability		299	5	56		27 mar. 2006			IEEE	IEEE Journals
On the Use of Automated Text Summarization Techniques for Summarizing Source Code	on the use of automated text summarization techniques for summarizing source code	10.1109/WCRE.2010.13	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5645482	S. Haiduc; J. Aponte; L. Moreno; A. Marcus	Department of Computer Science, Wayne State University, Detroit, MI, USA; Department de Ingenieria de Sistemas e Industrial, Universidad Nacional de Colombia, Bogota, Colombia; Department de Ingenieria de Sistemas e Industrial, Universidad Nacional de Colombia, Bogota, Colombia; Department of Computer Science, Wayne State University, Detroit, MI, USA	2010 17th Working Conference on Reverse Engineering	29 nov. 2010	2010			35	44	During maintenance developers cannot read the entire code of large systems. They need a way to get a quick understanding of source code entities (such as, classes, methods, packages, etc.), so they can efficiently identify and then focus on the ones related to their task at hand. Sometimes reading just a method header or a class name does not tell enough about its purpose and meaning, while reading the entire implementation takes too long. We study a solution which mitigates the two approaches, i.e., short and accurate textual descriptions that illustrate the software entities without having to read the details of the implementation. We create such descriptions using techniques from automatic text summarization. The paper presents a study that investigates the suitability of various such techniques for generating source code summaries. The results indicate that a combination of text summarization techniques is most appropriate for source code summarization and that developers generally agree with the summaries produced.	2375-5369	978-1-4244-8911-4		text summarization;program comprehension	Lead;Large scale integration;Semantics;Software systems;Computer science;Correlation	software maintenance	automated text summarization technique;textual description;software entity;source code summarization		190		28		29 nov. 2010			IEEE	IEEE Conferences
Automatic generation of natural language summaries for Java classes	automatic generation of natural language summaries for java classes	10.1109/ICPC.2013.6613830	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613830	L. Moreno; J. Aponte; G. Sridhara; A. Marcus; L. Pollock; K. Vijay-Shanker	Wayne State University, Detroit, MI, USA; Universidad Nacional de Colombia, Bogotá, Colombia; IBM Research India, Bangalore, India; Wayne State University, Detroit, MI, USA; University of Delaware, Newark, DE, USA; University of Delaware, Newark, DE, USA	2013 21st International Conference on Program Comprehension (ICPC)	30 Sep 2013	2013			23	32	Most software engineering tasks require developers to understand parts of the source code. When faced with unfamiliar code, developers often rely on (internal or external) documentation to gain an overall understanding of the code and determine whether it is relevant for the current task. Unfortunately, the documentation is often absent or outdated. This paper presents a technique to automatically generate human readable summaries for Java classes, assuming no documentation exists. The summaries allow developers to understand the main goal and structure of the class. The focus of the summaries is on the content and responsibilities of the classes, rather than their relationships with other classes. The summarization tool determines the class and method stereotypes and uses them, in conjunction with heuristics, to select the information to be included in the summaries. Then it generates the summaries using existing lexicalization tools. A group of programmers judged a set of generated summaries for Java classes and determined that they are readable and understandable, they do not include extraneous information, and, in most cases, they are not missing essential information.	1092-8138	978-1-4673-3092-3		Source code summarization;program comprehension;documentation generation	Java;Production facilities;Context;Documentation;Taxonomy;Natural languages;Educational institutions	Java;natural language processing;software engineering;system documentation	automatic generation;natural language summary;Java classes;software engineering tasks;source code;internal documentation;external documentation;human readable summary;summarization tool;stereotypes;lexicalization tools;essential information		178		23		30 Sep 2013			IEEE	IEEE Conferences
AutoComment: Mining question and answer sites for automatic comment generation	autocomment mining question and answer sites for automatic comment generation	10.1109/ASE.2013.6693113	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693113	E. Wong; Jinqiu Yang; Lin Tan	University of Waterloo, Waterloo, Ontario, Canada; University of Waterloo, Waterloo, Ontario, Canada; University of Waterloo, Waterloo, Ontario, Canada	2013 28th IEEE/ACM International Conference on Automated Software Engineering (ASE)	2 jan. 2014	2013			562	567	Code comments improve software maintainability. To address the comment scarcity issue, we propose a new automatic comment generation approach, which mines comments from a large programming Question and Answer (Q&A) site. Q&A sites allow programmers to post questions and receive solutions, which contain code segments together with their descriptions, referred to as code-description mappings.We develop AutoComment to extract such mappings, and leverage them to generate description comments automatically for similar code segments matched in open-source projects. We apply AutoComment to analyze Java and Android tagged Q&A posts to extract 132,767 code-description mappings, which help AutoComment to generate 102 comments automatically for 23 Java and Android projects. The user study results show that the majority of the participants consider the generated comments accurate, adequate, concise, and useful in helping them understand the code.		978-1-4799-0215-6		automated comment generation;documentation;program comprehension;natural language processing for software engineering	Java;Software;Androids;Humanoid robots;Databases;Cloning;Natural language processing	Android (operating system);data mining;Java;public domain software;question answering (information retrieval);software maintenance	AutoComment;programming question-and-answer site mining;automatic comment generation;code comments;software maintainability improvement;comment scarcity issue;code segments;open-source projects;Java tagged Q&A post analysis;Android tagged Q&A post analysis;code-description mapping extraction;program comprehension;natural language processing;software engineering		131	2	23		2 jan. 2014			IEEE	IEEE Conferences
Source Code Retrieval for Bug Localization Using Latent Dirichlet Allocation	source code retrieval for bug localization using latent dirichlet allocation	10.1109/WCRE.2008.33	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656405	S. K. Lukins; N. A. Kraft; L. H. Etzkorn	University of Alabama Huntsville, USA; University of Alabama Huntsville, USA; University of Alabama Huntsville, USA	2008 15th Working Conference on Reverse Engineering	24 Oct 2008	2008			155	164	In bug localization, a developer uses information about a bug to locate the portion of the source code to modify to correct the bug. Developers expend considerable effort performing this task. Some recent static techniques for automatic bug localization have been built around modern information retrieval (IR) models such as latent semantic indexing (LSI); however, latent Dirichlet allocation (LDA), a modular and extensible IR model, has significant advantages over both LSI and probabilistic LSI (pLSI). In this paper we present an LDA-based static technique for automating bug localization. We describe the implementation of our technique and three case studies that measure its effectiveness. For two of the case studies we directly compare our results to those from similar studies performed using LSI. The results demonstrate our LDA-based technique performs at least as well as the LSI-based techniques for all bugs and performs better, often significantly so, than the LSI-based techniques for most bugs.	2375-5369	978-0-7695-3429-9		bug localization;latent Dirichlet allocation;LDA;information retrieval;program comprehension;latent semantic indexing;LSI	Large scale integration;Computer bugs;Software systems;Software;Indexing;Probabilistic logic;Resource management	indexing;information retrieval;software engineering	source code retrieval;latent Dirichlet allocation;automatic bug localization;information retrieval;latent semantic indexing;LDA-based static technique;automating bug localization		122	1	34		24 Oct 2008			IEEE	IEEE Conferences
How do professional developers comprehend software?	how do professional developers comprehend software	10.1109/ICSE.2012.6227188	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227188	T. Roehm; R. Tiarks; R. Koschke; W. Maalej	Technical University of München, Munich, Germany; Technical University of München, Munich, Germany; Technical University of München, Munich, Germany; Technical University of München, Munich, Germany	2012 34th International Conference on Software Engineering (ICSE)	28 jun. 2012	2012			255	265	Research in program comprehension has considerably evolved over the past two decades. However, only little is known about how developers practice program comprehension under time and project pressure, and which methods and tools proposed by researchers are used in industry. This paper reports on an observational study of 28 professional developers from seven companies, investigating how developers comprehend software. In particular we focus on the strategies followed, information needed, and tools used. We found that developers put themselves in the role of end users by inspecting user interfaces. They try to avoid program comprehension, and employ recurring, structured comprehension strategies depending on work context. Further, we found that standards and experience facilitate comprehension. Program comprehension was considered a subtask of other maintenance tasks rather than a task by itself. We also found that face-to-face communication is preferred to documentation. Overall, our results show a gap between program comprehension research and practice as we did not observe any use of state of the art comprehension tools and developers seem to be unaware of them. Our findings call for further careful analysis and for reconsidering research agendas.	1558-1225	978-1-4673-1067-3		program comprehension;empirical studies;software documentation;maintenance;context awareness	Software;Interviews;Companies;Documentation;Java;Content management;Visualization	reverse engineering;software maintenance	professional developers;program comprehension;project pressure;user interfaces;structured comprehension strategies;work context;maintenance tasks;face-to-face communication;comprehension tools		101		24		28 jun. 2012			IEEE	IEEE Conferences
Summarizing the Content of Large Traces to Facilitate the Understanding of the Behaviour of a Software System	summarizing the content of large traces to facilitate the understanding of the behaviour of a software system	10.1109/ICPC.2006.45	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631120	A. Hamou-Lhadj; T. Lethbridge	University of Ottawa, SITE, Ottawa, ONT, Canada; University of Ottawa, SITE, Ottawa, ONT, Canada	14th IEEE International Conference on Program Comprehension (ICPC'06)	26 jun. 2006	2006			181	190	In this paper, we present a semi-automatic approach for summarizing the content of large execution traces. Similar to text summarization, where abstracts can be extracted from large documents, the aim of trace summarization is to take an execution trace as input and return a summary of its main content as output. The resulting summary can then be converted into a UML sequence diagram and used by software engineers to understand the main behavioural aspects of the system. Our approach to trace summarization is based on the removal of implementation details such as utilities from execution traces. To achieve our goal, we have developed a metric based on fan-in and fan-out to rank the system components according to whether they implement key system concepts or they are mere implementation details. We applied our approach to a trace generated from an object-oriented system called Weka that initially contains 97413 method calls. We succeeded to extract a summary from this trace that contains 453 calls. According to the developers of the Weka system, the resulting summary is an adequate high-level representation of the main interactions of the traced scenario	1092-8138	0-7695-2601-2		Reverse engineering;Dynamic analysis;Design;recovery;Program comprehension	Software systems;Abstracts;Unified modeling language;Reverse engineering;Software tools;Software performance;Performance analysis;Debugging	object-oriented programming;program diagnostics;reverse engineering;software maintenance;Unified Modeling Language	software system;text summarization;execution trace summarization;UML sequence diagram;object-oriented system;Weka system;program comprehension;reverse engineering;dynamic analysis		67	1	23		26 jun. 2006			IEEE	IEEE Conferences
Evaluating source code summarization techniques: Replication and expansion	evaluating source code summarization techniques replication and expansion	10.1109/ICPC.2013.6613829	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613829	B. P. Eddy; J. A. Robinson; N. A. Kraft; J. C. Carver	Department of Computer Science, University of Alabama, Tuscaloosa, AL, USA; Department of Computer Science, University of Alabama, Tuscaloosa, AL, USA; Department of Computer Science, University of Alabama, Tuscaloosa, AL, USA; Department of Computer Science, University of Alabama, Tuscaloosa, AL, USA	2013 21st International Conference on Program Comprehension (ICPC)	30 Sep 2013	2013			13	22	During software evolution a developer must investigate source code to locate then understand the entities that must be modified to complete a change task. To help developers in this task, Haiduc et al. proposed text summarization based approaches to the automatic generation of class and method summaries, and via a study of four developers, they evaluated source code summaries generated using their techniques. In this paper we propose a new topic modeling based approach to source code summarization, and via a study of 14 developers, we evaluate source code summaries generated using the proposed technique. Our study partially replicates the original study by Haiduc et al. in that it uses the objects, the instruments, and a subset of the summaries from the original study, but it also expands the original study in that it includes more subjects and new summaries. The results of our study both support the findings of the original and provide new insights into the processes and criteria that developers use to evaluate source code summaries. Based on our results, we suggest future directions for research on source code summarization.	1092-8138	978-1-4673-3092-3		Program comprehension;text summarization;topic modeling;source code summarization;replication study	Vectors;Large scale integration;Indexing;Software;Semantics;Matrix decomposition;Probability distribution	reverse engineering;software maintenance;text analysis	source code summarization technique evaluation;replication;software evolution;software development;source code investigation;text summarization based approach;automatic class summary generation;method summary generation;topic modeling based approach		64		24		30 Sep 2013			IEEE	IEEE Conferences
REPENT: Analyzing the Nature of Identifier Renamings	repent analyzing the nature of identifier renamings	10.1109/TSE.2014.2312942	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6776542	V. Arnaoudova; L. M. Eshkevari; M. D. Penta; R. Oliveto; G. Antoniol; Y. -G. Guéhéneuc	Polytechnique Montréal, Québec, Canada; Polytechnique Montréal, Québec, Canada; University of Sannio, Benevento, Italy; University of Molise, Pesche, IS, Italy; Polytechnique Montréal, Québec, Canada; Polytechnique Montréal, Québec, Canada	IEEE Transactions on Software Engineering	14 May 2014	2014	40	5	502	532	Source code lexicon plays a paramount role in software quality: poor lexicon can lead to poor comprehensibility and even increase software fault-proneness. For this reason, renaming a program entity, i.e., altering the entity identifier, is an important activity during software evolution. Developers rename when they feel that the name of an entity is not (anymore) consistent with its functionality, or when such a name may be misleading. A survey that we performed with 71 developers suggests that 39 percent perform renaming from a few times per week to almost every day and that 92 percent of the participants consider that renaming is not straightforward. However, despite the cost that is associated with renaming, renamings are seldom if ever documented-for example, less than 1 percent of the renamings in the five programs that we studied. This explains why participants largely agree on the usefulness of automatically documenting renamings. In this paper we propose REanaming Program ENTities (REPENT), an approach to automatically document-detect and classify-identifier renamings in source code. REPENT detects renamings based on a combination of source code differencing and data flow analyses. Using a set of natural language tools, REPENT classifies renamings into the different dimensions of a taxonomy that we defined. Using the documented renamings, developers will be able to, for example, look up methods that are part of the public API (as they impact client applications), or look for inconsistencies between the name and the implementation of an entity that underwent a high risk renaming (e.g., towards the opposite meaning). We evaluate the accuracy and completeness of REPENT on the evolution history of five open-source Java programs. The study indicates a precision of 88 percent and a recall of 92 percent. In addition, we report an exploratory study investigating and discussing how identifiers are renamed in the five programs, according to our taxonomy.	1939-3520			Identifier renaming;refactoring;program comprehension;mining software repositories;empirical study	Taxonomy;Semantics;Java;Grammar;Software;History;Documentation	data flow analysis;pattern classification;software fault tolerance;software quality;source code (software)	identifier renaming analysis;REPENT;source code lexicon;software quality;software fault-proneness;program entity renaming;entity identifier;software evolution;reanaming program entities;data flow analysis;natural language tools;taxonomy dimensions;public API;open-source Java programs		63		58	IEEE	20 mar. 2014			IEEE	IEEE Journals
CloCom: Mining existing source code for automatic comment generation	clocom mining existing source code for automatic comment generation	10.1109/SANER.2015.7081848	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7081848	E. Wong; Taiyue Liu; L. Tan	Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, Ontario, Canada; Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, Ontario, Canada; Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, Ontario, Canada	2015 IEEE 22nd International Conference on Software Analysis, Evolution, and Reengineering (SANER)	9 Apr 2015	2015			380	389	Code comments are an integral part of software development. They improve program comprehension and software maintainability. The lack of code comments is a common problem in the software industry. Therefore, it is beneficial to generate code comments automatically. In this paper, we propose a general approach to generate code comments automatically by analyzing existing software repositories. We apply code clone detection techniques to discover similar code segments and use the comments from some code segments to describe the other similar code segments. We leverage natural language processing techniques to select relevant comment sentences. In our evaluation, we analyze 42 million lines of code from 1,005 open source projects from GitHub, and use them to generate 359 code comments for 21 Java projects. We manually evaluate the generated code comments and find that only 23.7% of the generated code comments are good. We report to the developers the good code comments, whose code segments do not have an existing code comment. Amongst the reported code comments, seven have been confirmed by the developers as good and committable to the software repository while the rest await for developers' confirmation. Although our approach can generate good and committable comments, we still have to improve the yield and accuracy of the proposed approach before it can be used in practice with full automation.	1534-5351	978-1-4799-8469-5		comment generation;documentation;program comprehension	Cloning;Software;Databases;Java;Data mining;Context;Pattern matching	data mining;Java;natural language processing;public domain software;software maintenance;source code (software)	CloCom;existing source code mining;automatic comment generation;software development;program comprehension;software maintainability;software industry;code comments;software repositories;code clone detection techniques;similar code segments;natural language processing techniques;relevant comment sentences;open source projects;GitHub;Java projects;software repository		61	1	34		9 Apr 2015			IEEE	IEEE Conferences
Automatically detecting and describing high level actions within methods	automatically detecting and describing high level actions within methods	10.1145/1985793.1985808	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032449	G. Sridhara; L. Pollock; K. Vijay-Shanker	Department of Computer and Information Sciences, University of Delaware, Newark, DE, USA; Department of Computer and Information Sciences, University of Delaware, Newark, DE, USA; Department of Computer and Information Sciences, University of Delaware, Newark, DE, USA	2011 33rd International Conference on Software Engineering (ICSE)	10 Oct 2011	2011			101	110	One approach to easing program comprehension is to reduce the amount of code that a developer has to read. Describing the high level abstract algorithmic actions associated with code fragments using succinct natural language phrases potentially enables a newcomer to focus on fewer and more abstract concepts when trying to understand a given method. Unfortunately, such descriptions are typically missing because it is tedious to create them manually. We present an automatic technique for identifying code fragments that implement high level abstractions of actions and expressing them as a natural language description. Our studies of 1000 Java programs indicate that our heuristics for identifying code fragments implementing high level actions are widely applicable. Judgements of our generated descriptions by 15 experienced Java programmers strongly suggest that indeed they view the fragments that we identify as representing high level actions and our synthesized descriptions accurately express the abstraction.	1558-1225	978-1-4503-0445-0		documentation;program comprehension	Natural languages;Pragmatics;Java;Syntactics;Documentation;Semantics;Software	Java;natural language processing;program compilers;program diagnostics	high level actions;program comprehension;high level abstract algorithmic actions;code fragments;succinct natural language phrases;abstract concepts;automatic technique;natural language description;Java programs;Java programmers		59	1	24		10 Oct 2011			IEEE	IEEE Conferences
Mining source code descriptions from developer communications	mining source code descriptions from developer communications	10.1109/ICPC.2012.6240510	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240510	S. Panichella; J. Aponte; M. Di Penta; A. Marcus; G. Canfora	Department of Engineering-RCOST, University of Sannio, Italy; Universidad Nacional de Colombia, Bogota, Colombia; Department of Engineering-RCOST, University of Sannio, Italy; Wayne State University, Detroit, USA; Department of Engineering-RCOST, University of Sannio, Italy	2012 20th IEEE International Conference on Program Comprehension (ICPC)	16 jul. 2012	2012			63	72	Very often, source code lacks comments that adequately describe its behavior. In such situations developers need to infer knowledge from the source code itself or to search for source code descriptions in external artifacts. We argue that messages exchanged among contributors/developers, in the form of bug reports and emails, are a useful source of information to help understanding source code. However, such communications are unstructured and usually not explicitly meant to describe specific parts of the source code. Developers searching for code descriptions within communications face the challenge of filtering large amount of data to extract what pieces of information are important to them. We propose an approach to automatically extract method descriptions from communications in bug tracking systems and mailing lists. We have evaluated the approach on bug reports and mailing lists from two open source systems (Lucene and Eclipse). The results indicate that mailing lists and bug reports contain relevant descriptions of about 36% of the methods from Lucene and 7% from Eclipse, and that the proposed approach is able to extract such descriptions with a precision of up to 79% for Eclipse and 87% for Lucene. The extracted method descriptions can help developers in understanding the code and could also be used as a starting point for source code re-documentation.	1092-8138	978-1-4673-1216-5		Code re-documentation;mining e-mails;program comprehension	Electronic mail;Data mining;Java;Syntactics;Context;Filtering;Educational institutions	data mining;program compilers;program debugging;source coding	mining source code descriptions;developer communications;external artifacts;bug reports;emails;information source;code descriptions;bug tracking systems;mailing lists;open source systems;source code redocumentation		56		22		16 jul. 2012			IEEE	IEEE Conferences
SMURF: A SVM-based Incremental Anti-pattern Detection Approach	smurf a svmbased incremental antipattern detection approach	10.1109/WCRE.2012.56	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385142	A. Maiga; N. Ali; N. Bhattacharya; A. Sabané; Y. -G. Guéhéneuc; E. Aimeur	Ptidej Team, École Polytechnique de Montréal, Canada; Ptidej Team, Soccer Laboratory, DGIGL, École Polytechnique de Montréal, Canada; Ptidej Team, Soccer Laboratory, DGIGL, École Polytechnique de Montréal, Canada; Ptidej Team, Soccer Laboratory, DGIGL, École Polytechnique de Montréal, Canada; Ptidej Team, École Polytechnique de Montréal, Canada; Heron Laboratory, DIRO, Université de Montréal, Canada	2012 19th Working Conference on Reverse Engineering	20 Dec 2012	2012			466	475	In current, typical software development projects, hundreds of developers work asynchronously in space and time and may introduce anti-patterns in their software systems because of time pressure, lack of understanding, communication, and-or skills. Anti-patterns impede development and maintenance activities by making the source code more difficult to understand. Detecting anti-patterns incrementally and on subsets of a system could reduce costs, effort, and resources by allowing practitioners to identify and take into account occurrences of anti-patterns as they find them during their development and maintenance activities. Researchers have proposed approaches to detect occurrences of anti-patterns but these approaches have currently four limitations: (1) they require extensive knowledge of anti-patterns, (2) they have limited precision and recall, (3) they are not incremental, and (4) they cannot be applied on subsets of systems. To overcome these limitations, we introduce SMURF, a novel approach to detect anti-patterns, based on a machine learning technique - support vector machines - and taking into account practitioners' feedback. Indeed, through an empirical study involving three systems and four anti-patterns, we showed that the accuracy of SMURF is greater than that of DETEX and BDTEX when detecting anti-patterns occurrences. We also showed that SMURF can be applied in both intra-system and inter-system configurations. Finally, we reported that SMURF accuracy improves when using practitioners' feedback.	2375-5369	978-0-7695-4891-3		Anti-pattern;program comprehension;program maintenance;empirical software engineering	Support vector machines;Accuracy;Measurement;Training;Maintenance engineering;Kernel	learning (artificial intelligence);program diagnostics;software development management;software maintenance;support vector machines	SMURF;SVM-based incremental antipattern detection approach;software development projects;maintenance activities;development activities;source code;machine learning technique;support vector machines;DETEX;BDTEX;intersystem configurations;intrasystem configurations		54		32		20 Dec 2012			IEEE	IEEE Conferences
Normalizing Source Code Vocabulary	normalizing source code vocabulary	10.1109/WCRE.2010.10	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5645479	D. Lawrie; D. Binkley; C. Morrell	Loyola University Maryland, Baltimore, MD, USA; Loyola University Maryland, Baltimore, MD, USA; Loyola University Maryland, Baltimore, MD, USA	2010 17th Working Conference on Reverse Engineering	29 nov. 2010	2010			3	12	Information Retrieval (IR) based tools complement traditional static and dynamic analysis tools by exploiting the natural language found within a program's text. Tools incorporating IR have tackled problems, such as feature location, that previously required considerable human effort. However, to reap the full benefit of IR-based techniques, the language used across all software artifacts (e.g., requirement and design documents, test plans, as well as the source code) must be consistent. Vocabulary normalization aligns the vocabulary found in source code with that found in other software artifacts. Normalization both splits an identifier into its constituent parts and expands each part into a full dictionary word to match vocabulary in other artifacts. An algorithm for normalization is presented. Its current implementation incorporates a greatly improved splitter that exploits a collection of resources including several dictionaries, frequency distributions derived from the corpus of programs, and co-occurrence data. Empirical study of this new splitter, GenTest, on almost 8000 identifiers finds that it correctly splits 82%, outperforming the current state-of-the-art. A preliminary experiment with the normalization algorithm finds it improving the FLAT ̂ 3 feature locator's scores of relevant code from 0.60 to 0.95 on a scale from 0 to 1.	2375-5369	978-1-4244-8911-4		source code analysis tools;information retrieval;program comprehension	Dictionaries;Measurement;Google;Vocabulary;Software;Documentation;Natural languages	information retrieval;natural languages;software engineering;source coding	source code vocabulary normalization;information retrieval;software artifact;GenTest;natural language		50		36		29 nov. 2010			IEEE	IEEE Conferences
Expanding identifiers to normalize source code vocabulary	expanding identifiers to normalize source code vocabulary	10.1109/ICSM.2011.6080778	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6080778	D. Lawrie; D. Binkley	Loyola University Maryland, Baltimore, MD, USA; Loyola University Maryland, Baltimore, MD, USA	2011 27th IEEE International Conference on Software Maintenance (ICSM)	17 nov. 2011	2011			113	122	Maintaining modern software requires significant tool support. Effective tools exploit a variety of information and techniques to aid a software maintainer. One area of recent interest in tool development exploits the natural language information found in source code. Such Information Retrieval (IR) based tools compliment traditional static analysis tools and have tackled problems, such as feature location, that otherwise require considerable human effort. To reap the full benefit of IR-based techniques, the language used across all software artifacts (e.g., requirements, design, change requests, tests, and source code) must be consistent. Unfortunately, there is a significant proportion of invented vocabulary in source code. Vocabulary normalization aligns the vocabulary found in the source code with that found in other software artifacts. Most existing work related to normalization has focused on splitting an identifier into its constituent parts. The next step is to expand each part into a (dictionary) word that matches the vocabulary used in other software artifacts. Building on a successful approach to splitting identifiers, an implementation of an expansion algorithm is presented. Experiments on two systems find that up to 66% of identifiers are correctly expanded, which is within about 20% of the current system's best-case performance. Not only is this performance comparable to previous techniques, but the result is achieved in the absence of special purpose rules and not limited to restricted syntactic contexts. Results from these experiments also show the impact that varying levels of documentation (including both internal documentation such as the requirements and design, and external, or user-level, documentation) have on the algorithm's performance.	1063-6773	978-1-4577-0664-6		source code analysis tools;natural language processing;program comprehension	Context;Vocabulary;Software;Documentation;Natural languages;Dictionaries	information retrieval;natural language processing;program diagnostics;software maintenance;source coding;vocabulary	identifier expansion;source code vocabulary normalization;software maintenance;natural language information;information retrieval based tools;static analysis tools;feature location;IR-based techniques;software artifacts;splitting identifiers		42	1	31		17 nov. 2011			IEEE	IEEE Conferences
Developers ask reachability questions	developers ask reachability questions	10.1145/1806799.1806829	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6062086	T. D. LaToza; B. A. Myers	Institute for Software Research, School of Computer Science, Carnegie Mellon University, USA; Human Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, USA	2010 ACM/IEEE 32nd International Conference on Software Engineering	27 Oct 2011	2010	1		185	194	A reachability question is a search across feasible paths through a program for target statements matching search criteria. In three separate studies, we found that reachability questions are common and often time consuming to answer. In the first study, we observed 13 developers in the lab and found that half of the bugs developers inserted were associated with reachability questions. In the second study, 460 professional software developers reported asking questions that may be answered using reachability questions more than 9 times a day, and 82% rated one or more as at least somewhat hard to answer. In the third study, we observed 17 developers in the field and found that 9 of the 10 longest activities were associated with reachability questions. These findings suggest that answering reachability questions is an important source of difficulty understanding large, complex codebases.	1558-1225	978-1-60558-719-6		code navigation;developer questions;empirical study;program comprehension;software maintenance	Navigation;Cognition;Software;Encoding;Concrete;Educational institutions;Libraries	program debugging;reachability analysis;software engineering	reachability questions;bug developers;software developers;program debugging		40	1	22		27 Oct 2011			IEEE	IEEE Conferences
Visualization of fine-grained code change history	visualization of finegrained code change history	10.1109/VLHCC.2013.6645254	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6645254	Y. Yoon; B. A. Myers; S. Koo	Institute for Software Research School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA; Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA; Human-Computer Interaction Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA	2013 IEEE Symposium on Visual Languages and Human Centric Computing	24 Oct 2013	2013			119	126	Conventional version control systems save code changes at each check-in. Recently, some development environments retain more fine-grain changes. However, providing tools for developers to use those histories is not a trivial task, due to the difficulties in visualizing the history. We present two visualizations of fine-grained code change history, which actively interact with the code editor: a timeline visualization, and a code history diff view. Our timeline and filtering options allow developers to navigate through the history and easily focus on the information they need. The code history diff view shows the history of any particular code fragment, allowing developers to move through the history simply by dragging the marker back and forth through the timeline to instantly see the code that was in the snippet at any point in the past. We augment the usefulness of these visualizations with richer editor commands including selective undo and search, which are all implemented in an Eclipse plug-in called “Azurite”. Azurite helps developers with answering common questions developers ask about the code change history that have been identified by prior research. In addition, many of users' backtracking tasks can be achieved using Azurite, which would be tedious or error-prone otherwise.	1943-6106	978-1-4799-0369-6		program comprehension;software visualization;integrated development environments;selective undo	History;Visualization;Software;Filtering;Layout;Navigation;Real-time systems	data visualisation;software engineering	fine-grained code change history visualization;code editor interaction;timeline visualization;code history diff view;Eclipse plug-in;Azurite;user backtracking tasks		40		47		24 Oct 2013			IEEE	IEEE Conferences
Automatic identification of class stereotypes	automatic identification of class stereotypes	10.1109/ICSM.2010.5609703	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609703	N. Dragan; M. L. Collard; J. I. Maletic	Department of Computer Science, Kent University, Kent, OH, USA; Department of Computer Science, University of Akron, Akron, OH, USA; Department of Computer Science, Kent University, Kent, OH, USA	2010 IEEE International Conference on Software Maintenance	25 Oct 2010	2010			1	10	An approach is presented to automatically determine a class's stereotype. The stereotype is based on the frequency and distribution of method stereotypes in the class. Method stereotypes are automatically determined using a defined taxonomy given in previous work. The stereotypes, boundary, control and entity are used as a basis but refined based on an empirical investigation of 21 systems. A number of heuristics, derived from empirical evidence, are used to determine a class's stereotype. For example, the prominence of certain types of methods can indicate a class's main role. The approach is applied to five open source systems and evaluated. The results show that 95% of the classes are stereotyped by the approach. Additionally, developers (via manual inspection) agreed with the approach's results.	1063-6773	978-1-4244-8629-8		method stereotypes;class stereotypes;program comprehension;reverse engineering	Taxonomy;Production facilities;Measurement;Libraries;Computer science;Software systems;Data models	public domain software;reverse engineering;system documentation	automatic identification;class stereotype;method stereotype;taxonomy;heuristics;empirical evidence;open source system;program comprehension;reverse engineering;documentation		39		22		25 Oct 2010			IEEE	IEEE Conferences
Visualizing call graphs	visualizing call graphs	10.1109/VLHCC.2011.6070388	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6070388	T. D. LaToza; B. A. Myers	School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA; School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA	2011 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)	10 nov. 2011	2011			117	124	Developers navigate and reason about call graphs throughout investigation and debugging activities. This is often difficult: developers can spend tens of minutes answering a single question, get lost and disoriented, and erroneously make assumptions, causing bugs. To address these problems, we designed a new form of interactive call graph visualization - REACHER. Instead of leaving developers to manually traverse the call graph, REACHER lets developers search along control flow. The interactive call graph visualization encodes a number of properties that help developers answer questions about causality, ordering, type membership, repetition, choice, and other relationships. And developers remain oriented while navigating. To evaluate REACHER'S benefits, we conducted a lab study in which 12 participants answered control flow questions. Compared to an existing IDE, participants with REACHER were over 5 times more successful in significantly less time. All enthusiastically preferred REACHER, with many positive comments.	1943-6106	978-1-4577-1247-0		code exploration;call graphs;control flow;program visualization;program comprehension	Visualization;Navigation;Context;Joining processes;Debugging;Vegetation;Upper bound	program debugging;program visualisation;reverse engineering	interactive call graph visualization;REACHER;program visualization;program comprehension;control flow		37	1	25		10 nov. 2011			IEEE	IEEE Conferences
Recognizing Words from Source Code Identifiers Using Speech Recognition Techniques	recognizing words from source code identifiers using speech recognition techniques	10.1109/CSMR.2010.31	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5714421	N. Madani; L. Guerrouj; M. Di Penta; Y. -G. Gueheneuc; G. Antoniol	SOCCER Laboratory-DGIGL, École Polytechnique de Montréal, QUE, Canada; SOCCER Laboratory-DGIGL, École Polytechnique de Montréal, QUE, Canada; Department of Engineering, University of Sannio, Benevento, Italy; Ptidej Team-DGIGL, École Polytechnique de Montréal, QUE, Canada; SOCCER Laboratory-DGIGL, École Polytechnique de Montréal, QUE, Canada	2010 14th European Conference on Software Maintenance and Reengineering	17 Feb 2011	2010			68	77	The existing software engineering literature has empirically shown that a proper choice of identifiers influences software understandability and maintainability. Researchers have noticed that identifiers are one of the most important source of information about program entities and that the semantic of identifiers guide the cognitive process. Recognizing the words forming identifiers is not an easy task when naming conventions (e.g., Camel Case) are not used or strictly followed and-or when these words have been abbreviated or otherwise transformed. This paper proposes a technique inspired from speech recognition, i.e., dynamic time warping, to split identifiers into component words. The proposed technique has been applied to identifiers extracted from two different applications: JHotDraw and Lynx. Results compared to manually-built oracles and with Camel Case algorithm are encouraging. In fact, they show that the technique successfully recognizes words composing identifiers (even when abbreviated) in about 90% of cases and that it performs better than Camel Case. Furthermore, it was able to spot mistakes in the manually-built oracle.	1534-5351	978-0-7695-4321-5		Source code identifiers;program comprehension	Dictionaries;Speech recognition;Particle separators;Heuristic algorithms;Context;Feature extraction;Manuals	software maintenance;source coding;speech recognition;text analysis;time warp simulation	word recognition;source code identifiers;speech recognition techniques;software engineering;software understandability;software maintainability;information source;cognitive process;dynamic time warping;split identifiers;JHotDraw;Lynx;manually-built oracles;Camel Case algorithm		36		27		17 Feb 2011			IEEE	IEEE Conferences
Identifying Code Smells with Multiple Concern Views	identifying code smells with multiple concern views	10.1109/SBES.2010.21	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5629742	G. d. F. Carneiro; M. Silva; L. Mara; E. Figueiredo; C. Sant'Anna; A. Garcia; M. Mendonça	NA; Informatics Department, Pontifical Catholic University of Rio de Janeiro, Brazil; Informatics Department, Pontifical Catholic University of Rio de Janeiro, Brazil; Computer Science Department, Federal University of Minas Gerais, Brazil; Cornputer Science Department, Federal University of Bahia, Brazil; Informatics Department, Pontifical Catholic University of Rio de Janeiro, Brazil; Cornputer Science Department, Federal University of Bahia, Brazil	2010 Brazilian Symposium on Software Engineering	11 nov. 2010	2010			128	137	Code smells are anomalies often caused by the way concerns are realized in the source code. Their identification might depend on properties governing the structure of individual concerns and their inter-dependencies in the system implementation. Although code visualization tools are increasingly applied to support anomaly detection, they are mostly limited to represent modular structures, such as methods, classes and packages. This paper presents a multiple views approach that enriches four categories of code views with concern properties, namely: (i) concern’s package-class method structure, (ii) concern’s inheritance-wise structure, (iii)concern dependency, and (iv) concern dependency weight. An exploratory study was conducted to assess the extent to which visual views support code smell detection. Developers identified a set of well-known code smells on five versions of an open source system. Two important results came out of this study. First, the concern-driven views provided useful support to identify God Class and Divergent Change smells. Second, strategies for smell detection supported by the multiple concern views were uncovered.		978-1-4244-8917-6		software visualization;code smells;concerns;program comprehension	Visualization;Color;Spirals;Couplings;Complexity theory;Software;Tutorials	object-oriented methods;program visualisation	code smell identification;multiple concern view;code visualization tool;anomaly detection;modular structure representation;concern inheritance wise structure;concern package class method structure;concern dependency weight;open source system;concern driven view;God Class;divergent change smell		36		41		11 nov. 2010			IEEE	IEEE Conferences
The effectiveness of source code obfuscation: An experimental assessment	the effectiveness of source code obfuscation an experimental assessment	10.1109/ICPC.2009.5090041	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090041	M. Ceccato; M. Di Penta; J. Nagra; P. Falcarin; F. Ricca; M. Torchiano; P. Tonella	Fondazione Bruno Kessler (FBK), Trento, Italy; Department of Engineering, University of Sannio, Benevento, Italy; University of Trento, Italy; Politecnico di Torino, Italy; Unità CINI, Genoa, Italy; Politecnico di Torino, Italy; Fondazione Bruno Kessler (FBK), Trento, Italy	2009 IEEE 17th International Conference on Program Comprehension	19 jun. 2009	2009			178	187	Source code obfuscation is a protection mechanism widely used to limit the possibility of malicious reverse engineering or attack activities on a software system. Although several code obfuscation techniques and tools are available, little knowledge is available about the capability of obfuscation to reduce attackers' efficiency, and the contexts in which such an efficiencymay vary.	1092-8138	978-1-4244-3998-0		Empirical studies;Software Obfuscation;Program comprehension	Protection;Reverse engineering;Application software;Software systems;Java;Performance analysis;Data structures;Encoding;Automatic control;Software measurement	Java;security of data	source code obfuscation techniques;protection mechanism;software system;Java code;software protection		35		13		19 jun. 2009			IEEE	IEEE Conferences
LINSEN: An efficient approach to split identifiers and expand abbreviations	linsen an efficient approach to split identifiers and expand abbreviations	10.1109/ICSM.2012.6405277	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6405277	A. Corazza; S. Di Martino; V. Maggio	Dipartimento di Scienze Fisiche - Sezione Informatica University of Naples “Federico II”; Dipartimento di Scienze Fisiche - Sezione Informatica University of Naples “Federico II”; Dipartimento di Scienze Fisiche - Sezione Informatica University of Naples “Federico II”	2012 28th IEEE International Conference on Software Maintenance (ICSM)	10 jan. 2013	2012			233	242	Information Retrieval (IR) techniques are being exploited by an increasing number of tools supporting Software Maintenance activities. Indeed the lexical information embedded in the source code can be valuable for tasks such as concept location, clustering or recovery of traceability links. The application of such IR-based techniques relies on the consistency of the lexicon available in the different artifacts, and their effectiveness can worsen if programmers introduce abbreviations (e.g: rect) and/or do not strictly follow naming conventions such as Camel Case (e.g: UTFtoASCII). In this paper we propose an approach to automatically split identifiers in their composing words, and expand abbreviations. The solution is based on a graph model and performs in linear time with respect to the size of the dictionary, taking advantage of an approximate string matching technique. The proposed technique exploits a number of different dictionaries, referring to increasingly broader contexts, in order to achieve a disambiguation strategy based on the knowledge gathered from the most appropriate domain. The approach has been compared to other splitting and expansion techniques, using freely available oracles for the identifiers extracted from 24 C/C++ and Java open source systems. Results show an improvement in both splitting and expanding performance, in addition to a strong enhancement in the computational efficiency.	1063-6773	978-1-4673-2312-3		Source Code Identifiers;Program Comprehension;Splitting;Expansion	Dictionaries;Software algorithms;Approximation algorithms;Context;Software maintenance;Conferences	C++ language;information retrieval;Java;pattern clustering;public domain software;software maintenance	LINSEN;identifier splitting;abbreviation expansion;information retrieval techniques;software maintenance activities;lexical information;concept location;traceability links clustering;traceability links recovery;IR-based techniques;camel case;dictionary;approximate string matching technique;disambiguation strategy;C-C++;Java open source systems;oracles		34	1	20		10 jan. 2013			IEEE	IEEE Conferences
Extracting Meaning from Abbreviated Identifiers	extracting meaning from abbreviated identifiers	10.1109/SCAM.2007.17	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362915	D. Lawrie; H. Feild; D. Binkley	Loyola College, Baltimore, MD, USA; Loyola College, Baltimore, MD, USA; Loyola College, Baltimore, MD, USA	Seventh IEEE International Working Conference on Source Code Analysis and Manipulation (SCAM 2007)	29 Oct 2007	2007			213	222	Informative identifiers are made up of full (natural language) words and (meaningful) abbreviations. Readers of programs typically have little trouble understanding the purpose of identifiers composed of full words. In addition, those familiar with the code can (most often) determine the meaning of abbreviations used in identifiers. However, when faced with unfamiliar code, abbreviations often carry little useful information. Furthermore, tools that focus on the natural language used in the code have a hard time in the presence of abbreviations. One approach to providing meaning to programmers and tools is to translate (expand) abbreviations into full words. This paper presents a methodology for expanding identifiers and evaluates the process on a code based of just over 35 million lines of code. For example, using phrase extraction, fs_exists is expanded to file_status_exists illustrating how the expansion process can facilitate comprehension. On average, 16 percent of the identifiers in a program are expanded. Finally, as an example application, the approach is used to improve the syntactic identification of violations to Deissenbock and Pizka's rules for concise and consistent identifier construction.		978-0-7695-2880-9		Software Quality;Program Identifiers;Program Comprehension	Natural languages;Software quality;Dictionaries;Information retrieval;Software engineering;Libraries;Documentation;Educational institutions;USA Councils;Programming profession	reverse engineering;software quality	abbreviated program identifier meaning extraction;program understandability;program comprehension;syntactic violation identification;software quality		34	3	27		29 Oct 2007			IEEE	IEEE Conferences
The Role of Experience and Ability in Comprehension Tasks Supported by UML Stereotypes	the role of experience and ability in comprehension tasks supported by uml stereotypes	10.1109/ICSE.2007.86	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4222599	F. Ricca; M. Di Penta; M. Torchiano; P. Tonella; M. Ceccato	ITC IRST, Trento, Italy; RCOST, University of Sannio, Benevento, Italy; Politecnico di Turino, Italy; ITC IRST, Trento, Italy; ITC IRST, Trento, Italy	29th International Conference on Software Engineering (ICSE'07)	4 jun. 2007	2007			375	384	Proponents of design notations tailored for specific application domains or reference architectures, often available in the form of UML stereotypes, motivate them by improved understandability and modifiability. However, empirical studies that tested such claims report contradictory results, where the most intuitive notations are not always the best performing ones. This indicates the possible existence of relevant influencing factors, other than the design notation itself. In this work we report the results of a family of three experiments performed at different locations and with different subjects, in which we assessed the effectiveness of UML stereotypes for Web design in support to comprehension tasks. Replications with different subjects allowed us to investigate whether subjects' ability and experience play any role in the comprehension of stereotyped diagrams. We observed different behaviors of users with different degrees of ability and experience, which suggests alternative comprehension strategies of (and tool support for) different categories of users.	1558-1225	0-7695-2828-7		UML stereotypes;program comprehension;empirical study;developers' experience	Unified modeling language;Testing;Navigation;Performance evaluation;Web design;Code standards;Information resources;Software engineering;Impedance	Internet;program testing;software architecture;Unified Modeling Language	UML stereotypes;reference architectures;understandability;modifiability;Web design;Unified Modeling Language		33		22		4 jun. 2007			IEEE	IEEE Conferences
Comparing Programming Language Comprehension between Novice and Expert Programmers Using EEG Analysis	comparing programming language comprehension between novice and expert programmers using eeg analysis	10.1109/BIBE.2016.30	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7790010	S. Lee; A. Matteson; D. Hooshyar; S. Kim; J. Jung; G. Nam; H. Lim	Computer Science and Engineering department, Korea University, Seoul, South Korea; Computer Science and Engineering department, Korea University, Seoul, South Korea; Korea University, Seongbuk-gu, Seoul, KR; Psychology department Seoul, South Korea; Psychology department Seoul, South Korea; Psychology department, Korea University, Seoul, South Korea; Psychology department, Korea University, Seoul, South Korea	2016 IEEE 16th International Conference on Bioinformatics and Bioengineering (BIBE)	19 Dec 2016	2016			350	355	For programming language comprehension, high cognitive skills (e.g., reading, writing, working memory, etc.) and information processing are required. However, there are few papers that approach this from a neuroscientific perspective. In this paper, we examine program comprehension neuroscientifically and also observe the differences between novice and expert programmers. We designed an EEG (electroencephalogram) experiment and observed 18 participants during a series of program comprehension tasks. We found clear differences in program comprehension ability between novice and expert programmers. Experts exhibited higher brainwave activation than novices in electrodes F3 and P8. These results indicate that experts have outstanding program comprehension-associated abilities such as digit encoding, coarse coding, short-term memory, and subsequent memory effect. Our findings can serve as a foundation for future research in this pioneering field.	2471-7819	978-1-5090-3834-3		program comprehension;electroencephalogram;neuroscientific;human factors;empirical study	Electroencephalography;Programming profession;Brain;Time factors;Information processing;Java	cognition;computer literacy;electroencephalography;medical signal processing	programming language comprehension;EEG analysis;electroencephalogram;program comprehension tasks;brainwave activation;F3 electrode;P8 electrode		31		16		19 Dec 2016			IEEE	IEEE Conferences
Software Clustering Using Dynamic Analysis and Static Dependencies	software clustering using dynamic analysis and static dependencies	10.1109/CSMR.2009.62	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812736	C. Patel; A. Hamou-Lhadj; J. Rilling	Department of Computer Science and Software Engineering, Concordia University, Montreal, QUE, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, QUE, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, QUE, Canada	2009 13th European Conference on Software Maintenance and Reengineering	10 Apr 2009	2009			27	36	Decomposing a software system into smaller, more manageable clusters is a common approach to support the comprehension of large systems. In recent years, researchers have focused on clustering techniques to perform such architectural decomposition, with the most predominant clustering techniques relying on the static analysis of source code. We argue that these static structural relationships are not sufficient for software clustering due to the increased complexity and behavioral aspects found in software systems. In this paper, we present a novel software clustering approach that combines dynamic and static analysis to identify component clusters. We introduce a two-phase clustering technique that combines software features to build a core skeleton decomposition with structural information to further refine these clusters. A case study is presented to evaluate the applicability and effectiveness of our approach.	1534-5351	978-0-7695-3589-0		Software clustering;architecture recovery;program comprehension;software maintenance	Software maintenance;Skeleton;Data mining;Software systems;Computer science;Software engineering;Conference management;Engineering management;Performance analysis;Computer architecture	pattern clustering;program diagnostics;software architecture;software maintenance	software clustering techniques;dynamic analysis;static dependencies;software system;architectural decomposition;static analysis;core skeleton decomposition;software maintenance		31		30		10 Apr 2009			IEEE	IEEE Conferences
Structural information based term weighting in text retrieval for feature location	structural information based term weighting in text retrieval for feature location	10.1109/ICPC.2013.6613841	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613841	B. Bassett; N. A. Kraft	Department of Computer Science, The University of Alabama, Tuscaloosa, AL, USA; Department of Computer Science, The University of Alabama, Tuscaloosa, AL, USA	2013 21st International Conference on Program Comprehension (ICPC)	30 Sep 2013	2013			133	141	Many recent feature location techniques (FLTs) apply text retrieval (TR) techniques to corpora built from text embedded in source code. Term weighting is a standard preprocessing step in TR and is used to adjust the importance of a term within a document or corpus. Common term weighting schemes such as tf-idf may not be optimal for use with source code, because they originate from a natural language context and were designed for use with unstructured documents. In this paper we propose a new approach to term weighting in which term weights are assigned using the structural information from the source code. We then evaluate the proposed approach by conducting an empirical study of a TR-based FLT. In all, we study over 400 bugs and features from five open source Java systems and find that structural term weighting can cause a statistically significant improvement in the accuracy of the FLT.	1092-8138	978-1-4673-3092-3		Program comprehension;feature location;static analysis;text retrieval;latent Dirichlet allocation	Accuracy;Large scale integration;Indexing;Probability distribution;Java;Benchmark testing;Computational modeling	feature extraction;information retrieval;Java;natural language processing;public domain software;source coding;text analysis	structural term weighting;open source Java system;TR-based FLT;term weight assignment;unstructured document;natural language;term weighting scheme;corpus;text embedding;source code;feature location technique;text retrieval		30		30		30 Sep 2013			IEEE	IEEE Conferences
Measuring the Impact of Code Dependencies on Software Architecture Recovery Techniques	measuring the impact of code dependencies on software architecture recovery techniques	10.1109/TSE.2017.2671865	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7859416	T. Lutellier; D. Chollak; J. Garcia; L. Tan; D. Rayside; N. Medvidović; R. Kroeger	University of Waterloo, Waterloo, ON, Canada; University of Waterloo, Waterloo, ON, Canada; University of California, Irvine, CA; University of Waterloo, Waterloo, ON, Canada; University of Waterloo, Waterloo, ON, Canada; University of Southern California, Los Angeles, CA; Google Inc., Mountain View, CA	IEEE Transactions on Software Engineering	12 Feb 2018	2018	44	2	159	181	Many techniques have been proposed to automatically recover software architectures from software implementations. A thorough comparison among the recovery techniques is needed to understand their effectiveness and applicability. This study improves on previous studies in two ways. First, we study the impact of leveraging accurate symbol dependencies on the accuracy of architecture recovery techniques. In addition, we evaluate other factors of the input dependencies such as the level of granularity and the dynamic-bindings graph construction. Second, we recovered the architecture of a large system, Chromium, that was not available previously. Obtaining the ground-truth architecture of Chromium involved two years of collaboration with its developers. As part of this work, we developed a new submodule-based technique to recover preliminary versions of ground-truth architectures. The results of our evaluation of nine architecture recovery techniques and their variants suggest that (1) using accurate symbol dependencies has a major influence on recovery quality, and (2) more accurate recovery techniques are needed. Our results show that some of the studied architecture recovery techniques scale to very large systems, whereas others do not.	1939-3520		Natural Sciences and Engineering Research Council of Canada; Google Faculty Research Award; Ontario Ministry of Research and Innovation; U.S. National Science Foundation(grant numbers:1117593,1218115,1321141); Infosys Technologies, Ltd.; 	Software architecture;empirical software engineering;maintenance and evolution;program comprehension	Computer architecture;Software architecture;Software;Heuristic algorithms;Chromium;Software algorithms;Manuals	software architecture;software quality;system recovery	symbol dependencies;accurate recovery techniques;recovery quality;submodule-based technique;ground-truth architecture;input dependencies;software implementations;software architectures;software architecture recovery techniques;code dependencies		29		72	OAPA	20 Feb 2017			IEEE	IEEE Journals
Automated Identification of Tasks in Development Sessions	automated identification of tasks in development sessions	10.1109/ICPC.2008.16	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556133	I. D. Coman; A. Sillitti	Free University of Bolzano-Bozen, Italy; Free University of Bolzano-Bozen, Italy	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			212	217	Task switching occurs frequently during the work of software developers. While there are already several approaches aiming at assisting developers in recovering their contexts of previous tasks, they generally rely on the developer to identify the beginning of each task. We propose a new technique for automatically splitting a development session into task-related subsections, based on the interaction of the developer with the IDE. The technique also shows potential benefits for automatic concern detection and for suggestions for code investigation. We present the technique, the results of a study conducted for its initial validation, and we discuss the additional potential benefits under investigation.	1092-8138	978-0-7695-3176-2		Task Detection;Program Comprehension;Concerns	Switches;History;Visualization;Programming;Packaging;Hydrogen	software engineering	automated identification;development sessions tasks;task switching;software developers;automatic concern detection		29		11		2 jul. 2008			IEEE	IEEE Conferences
Improving Feature Location by Enhancing Source Code with Stereotypes	improving feature location by enhancing source code with stereotypes	10.1109/ICSM.2013.41	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6676901	N. Alhindawi; N. Dragan; M. L. Collard; J. I. Maletic	Department of Computer Science, Kent State University, Kent, Ohio, USA; Department of Computer Science, Kent State University, Kent, Ohio, USA; Department of Computer Science, Kent State University, Kent, Ohio, USA; Department of Computer Science, Kent State University, Kent, Ohio, USA	2013 IEEE International Conference on Software Maintenance	2 Dec 2013	2013			300	309	A novel approach to improve feature location by enhancing the corpus (i.e., source code) with static information is presented. An information retrieval method, namely Latent Semantic Indexing (LSI), is used for feature location. Adding stereotype information to each method/function enhances the corpus. Stereotypes are terms that describe the abstract role of a method, for example get, set, and predicate are well-known method stereotypes. Each method in the system is automatically stereotyped via a static-analysis approach. Experimental comparisons of using LSI for feature location with, and without, stereotype information are conducted on a set of open-source systems. The results show that the added information improves the recall and precision in the context of feature location. Moreover, the use of stereotype information decreases the total effort that a developer would need to expend to locate relevant methods of the feature.	1063-6773	978-0-7695-4981-1		software maintenance;information retrieval;feature location;method stereotypes;program comprehension	Large scale integration;Taxonomy;Standards;Feature extraction;Semantics;Open source software;Context	indexing;information retrieval;program diagnostics;public domain software;source coding	feature location;source code;information retrieval;latent semantic indexing;LSI;static-analysis approach;open-source systems		27		33		2 Dec 2013			IEEE	IEEE Conferences
Using the Kleinberg Algorithm and Vector Space Model for Software System Clustering	using the kleinberg algorithm and vector space model for software system clustering	10.1109/ICPC.2010.17	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521746	G. Scanniello; A. D'Amico; C. D'Amico; T. D'Amico	Dipartimento di Matematica e Informatica, University of Basilicata, Italy; Dipartimento di Matematica e Informatica, University of Basilicata, Italy; Dipartimento di Matematica e Informatica, University of Basilicata, Italy; Dipartimento di Matematica e Informatica, University of Basilicata, Italy	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			180	189	Clustering based approaches are generally difficult to use in practice since they need a significant human interaction for recovering software architectures, are conceived for a specific programming language, and very often do not use design knowledge (e.g., the implemented architectural model). In this paper we present a clustering based approach to recover the implemented architecture of software systems with a hierarchical structure and implemented with any object oriented programming language. The approach is based on the combination of structural and lexical dimensions. The structural dimension is used to decompose a software system into layers (i.e., horizontal decomposition), while the lexical dimension is then employed to partition each layer (i.e., vertical decomposition) into software modules. Layers are identified using a well known and widely employed link analysis algorithm, i.e., the Kleinberg algorithm, while Vector Space Model is used to vertically decompose the layers. To assess the approach and the underlying techniques, we also present a prototype of a supporting tool and the results from a case study conducted on subsequent versions of three open source Java software systems.	1092-8138	978-1-4244-7603-9		Architecture Recovery;Clustering;Link Analysis;Reverse Engineering;Program Comprehension	Clustering algorithms;Software algorithms;Software systems;Object oriented modeling;Partitioning algorithms;Humans;Software architecture;Computer languages;Computer architecture;Object oriented programming	Java;object-oriented programming;pattern clustering;programming languages;public domain software;software architecture	Kleinberg Algorithm;vector space model;software system clustering approach;software architectures;specific programming language;hierarchical structure;object oriented programming language;software modules;open source Java software systems		27		34		26 jul. 2010			IEEE	IEEE Conferences
The Influence of the Task on Programmer Behaviour	the influence of the task on programmer behaviour	10.1109/ICPC.2011.35	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970161	A. T. T. Ying; M. P. Robillard	School of Computer Science, McGill University, Montreal, QUE, Canada; School of Computer Science, McGill University, Montreal, QUE, Canada	2011 IEEE 19th International Conference on Program Comprehension	1 Aug 2011	2011			31	40	Programmers performing a change task must understand the existing software in addition to performing the actual change. This process is likely to be affected by characteristics of the task. We investigated whether the nature of a task has any relationship with when a programmer edits code during a programming session. We characterized differences in editing behaviour with three types of editing styles: edit-first, edit-last, and edit-throughout. We based our analysis on the interaction history of over 4000 programming sessions collected as part of the development history of open source projects. Our results showed that an enhancement task (as opposed to a bug fix) was less likely to be associated with a high fraction of source code edit events at the beginning of the programming session. To our surprise, we also found that the presence of a stack trace in a bug report did not significantly effect the editing style of the programming session.	1092-8138	978-0-7695-4398-7		Program comprehension;Development interaction history;Mining software archives	History;Programming;Monitoring;Clustering algorithms;Software;Couplings;Navigation	behavioural sciences;program debugging;programming;software engineering	programmer behaviour;programming session;editing behaviour;editing style;edit-first style;edit-last style;edit-throughout style;interaction history;development history;open source projects;enhancement task;bug fix;source code editing;stack trace;bug report		26		35		1 Aug 2011			IEEE	IEEE Conferences
Multi-dimensional exploration of API usage	multidimensional exploration of api usage	10.1109/ICPC.2013.6613843	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613843	C. De Roover; R. Lämmel; E. Pek	Software Languages Lab, Vrije Universiteit Brussel, Belgium; Software Languages Team, University of Koblenz-Landau, Germany; ADAPT Lab, University of Koblenz-Landau, Germany	2013 21st International Conference on Program Comprehension (ICPC)	30 Sep 2013	2013			152	161	This paper is concerned with understanding API usage in a systematic, explorative manner for the benefit of both API developers and API users. There exist complementary, less explorative methods, e.g., based on code search, code completion, or API documentation. In contrast, our approach is highly interactive and can be seen as an extension of what IDEs readily provide today. Exploration is based on multiple dimensions: i) the hierarchically organized scopes of projects and APIs; ii) metrics of API usage (e.g., number of project classes extending API classes); iii) metadata for APIs; iv) project- versus API-centric views. We also provide the QUAATLAS corpus of Java projects which enhances the existing QUALITAS corpus to enable API-usage analysis. We implemented the exploration approach in an open-source, IDE-like, Web-enabled tool EXAPUS.	1092-8138	978-1-4673-3092-3		API usage;code exploration;metadata;program comprehension;reverse engineering;QUAATLAS;EXAPUS;QUALITAS	Java;Libraries;XML;Measurement;Abstracts;Software;Graphical user interfaces	application program interfaces;Java;meta data;public domain software	IDE;Web-enabled tool EXAPUS;open-source exploration approach;API-usage analysis;Java projects;QUAATLAS corpus;API metadata;API users;API developers;API usage metrics;multidimensional exploration		26		32		30 Sep 2013			IEEE	IEEE Conferences
A Tool for Visual Understanding of Source Code Dependencies	a tool for visual understanding of source code dependencies	10.1109/ICPC.2008.23	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556140	M. Pinzger; K. Grafenhain; P. Knab; H. C. Gall	Department of Informatics, University of Zurich, Switzerland; Universitat Zurich, Zurich, ZH, CH; Department of Informatics, University of Zurich, Switzerland; Department of Informatics, University of Zurich, Switzerland	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			254	259	Many program comprehension tools use graphs to visualize and analyze source code. The main issue is that existing approaches create graphs overloaded with too much information. Graphs contain hundreds of nodes and even more edges that cross each other. Understanding these graphs and using them for a given program comprehension task is tedious, and in the worst case developers stop using the tools. In this paper we present DA4Java, a graph-based approach for visualizing and analyzing static dependencies between Java source code entities. The main contribution of DA4Java is a set of features to incrementally compose graphs and remove irrelevant nodes and edges from graphs. This leads to graphs that contain significantly fewer nodes and edges and need less effort to understand.	1092-8138	978-0-7695-3176-2		Incremental Source Code Analysis;Program Comprehension;Software Visualization;Source Code Dependencies	Visualization;Java;Information filtering;Information filters;Packaging;Software systems;Informatics;Data mining;Costs;Software maintenance	graph theory;Java;program visualisation;reverse engineering	source code dependencies;program comprehension tools;DA4Java;graph-based approach;Java source code;visual understanding		25	2	16		2 jul. 2008			IEEE	IEEE Conferences
Do Code Smells Impact the Effort of Different Maintenance Programming Activities?	do code smells impact the effort of different maintenance programming activities	10.1109/SANER.2016.103	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7476660	Z. Soh; A. Yamashita; F. Khomh; Y. -G. Guéhéneuc	Department of Computer and Software Engineering, Polytechnique de Montreal; Department of Information Technology, Oslo and Akershus University, Oslo, Norway; Department of Computer and Software Engineering, Polytechnique de Montreal; Department of Computer and Software Engineering, Polytechnique de Montreal	2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)	23 May 2016	2016	1		393	402	Empirical studies have shown so far that code smells have relatively low impact over maintenance effort at file level. We surmise that previous studies have found low effects of code smells because the effort considered is a "sheer-effort" that does not distinguish between the kinds of developers' activities. In our study, we investigate the effects of code smells at the activity level. Examples of activities are: reading, editing, searching, and navigating, which are performed independently over different files during maintenance. We conjecture that structural attributes represented in the form of different code smells do indeed have an effect on the effort for performing certain kinds of activities. To verify this conjecture, we revisit a previous study about the impact of code smell on maintenance effort, using the same dataset, but considering activity effort. Six professional developers were hired to perform three maintenance tasks on four functionally equivalent Java Systems. Each developer performs two maintenance tasks. During maintenance task, we monitor developers' logs. Then, we define an annotation schema to identify developers' activities and assess whether code smells affect different maintenance activities. Results show that different code smells affect differently activity effort. Yet, the size of the changes performed to solve the task impacts the effort of all activities more than code smells and file size. While code smells impact the editing and navigating effort more than file size, the file size impacts the reading and searching activities more than code smells. One major implication of these results is that if code smells indeed affect the effort of certain kinds of activities, it means that their effects are contingent on the type of maintenance task at hand, where some kinds of activities will become more predominant than others.		978-1-5090-1855-0		code smells;programming activity;maintenance effort;program comprehension;software quality	Maintenance engineering;Navigation;Java;Programming;Software;Companies;Software engineering	file organisation;Java;software maintenance;software quality	maintenance programming activities;code smells;file level;structural attributes;maintenance effort;functionally equivalent Java systems;developer log monitoring;annotation schema;file size		25		40		23 May 2016			IEEE	IEEE Conferences
The Effect of Lexicon Bad Smells on Concept Location in Source Code	the effect of lexicon bad smells on concept location in source code	10.1109/SCAM.2011.18	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6065171	S. L. Abebe; S. Haiduc; P. Tonella; A. Marcus	Software Engineering Research Unit, Fondazione Bruno Kessler, Trento, Italy; Department of Computer Science, Wayne State University, Detroit, MI, USA; Software Engineering Research Unit, Fondazione Bruno Kessler, Trento, Italy; Department of Computer Science, Wayne State University, Detroit, MI, USA	2011 IEEE 11th International Working Conference on Source Code Analysis and Manipulation	3 nov. 2011	2011			125	134	Experienced programmers choose identifier names carefully, in the attempt to convey information about the role and behavior of the labeled code entity in a concise and expressive way. In fact, during program understanding the names given to code entities represent one of the major sources of information used by developers. We conjecture that lexicon bad smells, such as, extreme contractions, inconsistent term use, odd grammatical structure, etc., can hinder the execution of maintenance tasks which rely on program understanding. We propose an approach to determine the extent of this impact and instantiate it on the task of concept location. In particular, we conducted a study on two open source software systems where we investigated how lexicon bad smells affect Information Retrieval-based concept location. In this study, the classes changed in response to past modification requests are located before and after lexicon bad smells are identified and removed from the source code. The results indicate that lexicon bad smells impact concept location when using IR-based techniques.		978-1-4577-0932-6		lexicon bad smells;program comprehension;concept location;text retrieval;software lexicon;code smells	Software systems;Maintenance engineering;Computer bugs;Filtering;Containers;Terminology	grammars;object-oriented programming;public domain software;reverse engineering;software maintenance	lexicon bad smell;source code concept location;identifier name;labeled code entity;program understanding;extreme contraction;inconsistent term use;odd grammatical structure;maintenance task execution;open source software system;information retrieval;modification request;object-oriented software system		23		29		3 nov. 2011			IEEE	IEEE Conferences
Using stereotypes in the automatic generation of natural language summaries for C++ methods	using stereotypes in the automatic generation of natural language summaries for c++ methods	10.1109/ICSM.2015.7332514	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7332514	N. J. Abid; N. Dragan; M. L. Collard; J. I. Maletic	Department of Computer Science Kent State University, Kent, Ohio, USA; Department of Mang. and Info Systems Kent State University, Kent, Ohio, USA; Department of Computer Science The University of Akron, Akron, Ohio; Department of Computer Science Kent State University, Kent, Ohio, USA	2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)	23 nov. 2015	2015			561	565	An approach to automatically generate natural language documentation summaries for C++ methods is presented. The approach uses prior work by the authors on stereotyping methods along with the source code analysis framework srcML. First, each method is automatically assigned a stereotype(s) based on static analysis and a set of heuristics. Then, the approach uses the stereotype information, static analysis, and predefined templates to generate a natural-language summary for each method. This summary is automatically added to the code base as a comment for each method. The predefined templates are designed to produce a generic summary for specific method stereotypes. Static analysis is used to extract internal details about the method (e.g., parameters, local variables, calls, etc.). This information is used to specialize the generated summaries.		978-1-4673-7532-0		source-code summarization;program comprehension;method stereotypes;static analysis	Documentation;Java;Taxonomy;Maintenance engineering;Natural language processing	C++ language;program diagnostics;source code (software);system documentation	natural language summaries automatic generation;C++ methods;natural language documentation summaries;stereotyping methods;source code analysis framework;srcML;static analysis		23		22		23 nov. 2015			IEEE	IEEE Conferences
Using Network Analysis for Recommendation of Central Software Classes	using network analysis for recommendation of central software classes	10.1109/WCRE.2012.19	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385105	D. Steidl; B. Hummel; E. Juergens	Technische Universität München, Garching bei Munchen, Germany; Technische Universität München, Garching bei Munchen, Germany; CQSE GmbH, Garching bei Munchen, Germany	2012 19th Working Conference on Reverse Engineering	20 Dec 2012	2012			93	102	As a new developer, getting to know a large unknown software system is a challenging task. If experienced developers are available, they can suggest which classes to read first, helping new developers to quickly grasp the system's most fundamental concepts. In practice, however, experienced developers often are no longer available. In these cases, the set of most important classes must be reverse engineered. This paper presents a thorough analysis of using different network analysis metrics on dependency graphs to retrieve central classes. An empirical study on four open source projects evaluates the results based on a survey among the systems' core developers. It demonstrates that the algorithmic results can compete with the suggestions of experienced developers.	2375-5369	978-0-7695-4891-3		network analysis;program comprehension;dependency graph	Algorithm design and analysis;Software systems;Measurement;Software algorithms;Indexes;Markov processes	network theory (graphs);public domain software;reverse engineering;software development management	software system;software developement;reverse engineering;network analysis metrics;dependency graph;open source project;central software class retrieval		23		14		20 Dec 2012			IEEE	IEEE Conferences
An Analysis of Machine Learning Algorithms for Condensing Reverse Engineered Class Diagrams	an analysis of machine learning algorithms for condensing reverse engineered class diagrams	10.1109/ICSM.2013.25	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6676885	M. H. Osman; M. R. V. Chaudron; P. v. d. Putten	Leiden Institute of Advanced Computer Science Leiden University, Leiden, The Netherlands; Leiden Institute of Advanced Computer Science Leiden University, Leiden, The Netherlands; NA	2013 IEEE International Conference on Software Maintenance	2 Dec 2013	2013			140	149	There is a range of techniques available to reverse engineer software designs from source code. However, these approaches generate highly detailed representations. The condensing of reverse engineered representations into more high-level design information would enhance the understandability of reverse engineered diagrams. This paper describes an automated approach for condensing reverse engineered diagrams into diagrams that look as if they are constructed as forward designed UML models. To this end, we propose a machine learning approach. The training set of this approach consists of a set of forward designed UML class diagrams and reverse engineered class diagrams (for the same system). Based on this training set, the method 'learns' to select the key classes for inclusion in the class diagrams. In this paper, we study a set of nine classification algorithms from the machine learning community and evaluate which algorithms perform best for predicting the key classes in a class diagram.	1063-6773	978-0-7695-4981-1		Software Engineering;UML;Reverse Engineering;Machine Learning;Program Comprehension	Prediction algorithms;Algorithm design and analysis;Unified modeling language;Measurement;Machine learning algorithms;Software;Couplings	learning (artificial intelligence);software maintenance;systems re-engineering;Unified Modeling Language	machine learning algorithms;reverse engineered class diagrams;reverse engineer software designs;source code;UML models;forward designed UML class diagrams;classification algorithms;key classes prediction;program comprehension;software engineering;development phase;maintenance phase		23		33		2 Dec 2013			IEEE	IEEE Conferences
Autofolding for Source Code Summarization	autofolding for source code summarization	10.1109/TSE.2017.2664836	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7843666	J. Fowkes; P. Chanthirasegaran; R. Ranca; M. Allamanis; M. Lapata; C. Sutton	School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK; Tractable, Oval Office, London, UK; School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK	IEEE Transactions on Software Engineering	8 Dec 2017	2017	43	12	1095	1109	Developers spend much of their time reading and browsing source code, raising new opportunities for summarization methods. Indeed, modern code editors provide code folding, which allows one to selectively hide blocks of code. However this is impractical to use as folding decisions must be made manually or based on simple rules. We introduce the autofolding problem, which is to automatically create a code summary by folding less informative code regions. We present a novel solution by formulating the problem as a sequence of AST folding decisions, leveraging a scoped topic model for code tokens. On an annotated set of popular open source projects, we show that our summarizer outperforms simpler baselines, yielding a 28 percent error reduction. Furthermore, we find through a case study that our summarizer is strongly preferred by experienced developers. More broadly, we hope this work will aid program comprehension by turning code folding into a usable and valuable tool.	1939-3520		Engineering and Physical Sciences Research Council(grant numbers:EP/K024043/1); 	Source code summarization, program comprehension, topic modelling	Software development;Natural languages;Source coding;Feature extraction;Complexity theory	public domain software;source code (software)	source code summarization;modern code editors;code folding;autofolding problem;informative code regions;AST folding decisions;code tokens;open source projects		23		62	IEEE	6 Feb 2017			IEEE	IEEE Journals
Consistent Layout for Thematic Software Maps	consistent layout for thematic software maps	10.1109/WCRE.2008.45	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656412	A. Kuhn; P. Loretan; O. Nierstrasz	Software Composition Group, University of Bern, Switzerland; Software Composition Group, University of Bern, Switzerland; Software Composition Group, University of Bern, Switzerland	2008 15th Working Conference on Reverse Engineering	24 Oct 2008	2008			209	218	Software visualizations can provide a concise overview of a complex software system. Unfortunately, since software has no physical shape, there is no ``natural'' mapping of software to a two-dimensional space. As a consequence most visualizations tend to use a layout in which position and distance have no meaning, and consequently layout typical diverges from one visualization to another. We propose a consistent layout for software maps in which the position of a software artifact reflects its vocabulary, and distance corresponds to similarity of vocabulary. We use latent semantic indexing (LSI) to map software artifacts to a vector space, and then use multidimensional scaling (MDS) to map this vector space down to two dimensions.The resulting consistent layout allows us to develop a variety of thematic software maps that express very different aspects of software while making it easy to compare them. The approach is especially suitable for comparing views of evolving software, since the vocabulary of software artifacts tends to be stable over time.	2375-5369	978-0-7695-3429-9		software visualization;program comprehension	Software;Layout;Distance measurement;Vocabulary;Visualization;Large scale integration;Software systems	data visualisation	thematic software maps;software visualizations;complex software system;software artifact;latent semantic indexing;multidimensional scaling		23		31		24 Oct 2008			IEEE	IEEE Conferences
Support vector machines for anti-pattern detection	support vector machines for antipattern detection	10.1145/2351676.2351723	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6494935	A. Maiga; N. Ali; N. Bhattacharya; A. Sabané; Y. -G. Guéhéneuc; G. Antoniol; E. Aïmeur	Université de Montréal, QUE, Canada; École Polytechnique de Montréal, QUE, Canada; École Polytechnique de Montréal, QUE, Canada; École Polytechnique de Montréal, QUE, Canada; École Polytechnique de Montréal, QUE, Canada; École Polytechnique de Montréal, QUE, Canada; Université de Montréal, QUE, Canada	2012 Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering	8 Apr 2013	2012			278	281	Developers may introduce anti-patterns in their software systems because of time pressure, lack of understanding, communication, and--or skills. Anti-patterns impede development and maintenance activities by making the source code more difficult to understand. Detecting anti-patterns in a whole software system may be infeasible because of the required parsing time and of the subsequent needed manual validation. Detecting anti-patterns on subsets of a system could reduce costs, effort, and resources. Researchers have proposed approaches to detect occurrences of anti-patterns but these approaches have currently some limitations: they require extensive knowledge of anti-patterns, they have limited precision and recall, and they cannot be applied on subsets of systems. To overcome these limitations, we introduce SVMDetect, a novel approach to detect anti-patterns, based on a machine learning technique---support vector machines. Indeed, through an empirical study involving three subject systems and four anti-patterns, we showed that the accuracy of SVMDetect is greater than of DETEX when detecting anti-patterns occurrences on a set of classes. Concerning, the whole system, SVMDetect is able to find more anti-patterns occurrences than DETEX.		978-1-4503-1204-2		Anti-pattern;empirical software engineering;program comprehension;program maintenance		learning (artificial intelligence);software maintenance;support vector machines	support vector machines;antipattern detection;software systems;source code;parsing time;manual validation;SVMDetect;machine learning technique;DETEX		22		13		8 Apr 2013			IEEE	IEEE Conferences
Analysis and visualization of predicate dependence on formal parameters and global variables	analysis and visualization of predicate dependence on formal parameters and global variables	10.1109/TSE.2004.78	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1359767	D. Binkley; M. Harman	Loyola College, Baltimore, MD, USA; King''s College, London, UK	IEEE Transactions on Software Engineering	22 nov. 2004	2004	30	11	715	735	Empirical data concerning the qualitative and quantitative nature of program dependence is presented for a set of 20 programs ranging from 600 lines of code to 167,000 lines of code. The sources of dependence considered are global variables and formal parameters and the targets considered are a program's predicate nodes. The results show that as the number of formal parameters available to a predicate increases, there is a decrease in the proportion of these formal parameters which are depended upon by the predicate. No such correlation was found for global variables. Results from theoretical and actual computation time analysis indicate that the computation of dependence information is practical, suggesting that the analysis may be beneficial to several application areas. The paper also presents results concerning correlations that provide strong evidence that the global and formal dependence sources are independent of one another and that the numbers of globals and formals are independent of the size of the procedure that contains them. Finally, two visualization techniques for displaying dependence information are introduced. Illustrations show how these visualizations and predicate dependence analysis can assist in activities such as testing, comprehension, and evolution.	1939-3520			Index Terms- Dependence analysis;program slicing;program comprehension;software maintenance.	Humans;Information analysis;Independent component analysis;Data visualization;Software maintenance;Software engineering;Application software;Automatic testing;Logic;Software testing	program testing;program slicing;software maintenance;formal specification;program visualisation	predicate dependence visualization;formal parameter;global variable;program dependence;program predicate node		22		79		22 nov. 2004			IEEE	IEEE Journals
Inferring semantically related words from software context	inferring semantically related words from software context	10.1109/MSR.2012.6224276	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6224276	J. Yang; L. Tan	University of Waterloo, Waterloo, ONT, Canada; University of Waterloo, Waterloo, ONT, Canada	2012 9th IEEE Working Conference on Mining Software Repositories (MSR)	25 jun. 2012	2012			161	170	Code search is an integral part of software development and program comprehension. The difficulty of code search lies in the inability to guess the exact words used in the code. Therefore, it is crucial for keyword-based code search to expand queries with semantically related words, e.g., synonyms and abbreviations, to increase the search effectiveness. However, it is limited to rely on resources such as English dictionaries and WordNet to obtain semantically related words in software, because many words that are semantically related in software are not semantically related in English. This paper proposes a simple and general technique to automatically infer semantically related words in software by leveraging the context of words in comments and code. We achieve a reasonable accuracy in seven large and popular code bases written in C and Java. Our further evaluation against the state of art shows that our technique can achieve a higher precision and recall.	2160-1860	978-1-4673-1761-0		Semantically related words;code search;program comprehension	Context;Dictionaries;Gold;Linux;Java;Kernel	C language;Java;query processing;software engineering;word processing	semantically related word inference;software context;code search;software development;program comprehension;keyword-based code search;abbreviations;synonyms;English dictionaries;WordNet;C language;Java		22	3	48		25 jun. 2012			IEEE	IEEE Conferences
An Approach for Mapping Features to Code Based on Static and Dynamic Analysis	an approach for mapping features to code based on static and dynamic analysis	10.1109/ICPC.2008.35	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556137	A. Rohatgi; A. Hamou-Lhadj; J. Rilling	Department of Computer Science and Software Engineering, Concordia University, Montreal West, QUE, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal West, QUE, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal West, QUE, Canada	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			236	241	System evolution depends greatly on the ability of a maintainer to locate source code that is specific to feature implementation. Existing feature location techniques require either exercising several features of the system, or rely heavily on domain experts to guide the feature location process. In this paper, we present a novel approach for feature location that combines static and dynamic analysis techniques. An execution trace is generated by exercising the feature under study (dynamic analysis). A component dependency graph (static analysis) is used to rank the components invoked in the trace according to their relevance to the feature. Our ranking technique is based on the impact of a component modification on the rest of the system. The proposed approach is automatic to a large extent relieving users from any decision that would otherwise require extensive domain knowledge of the system. A case study is presented to support and evaluate the applicability of our approach.	1092-8138	978-0-7695-3176-2		Feature location;dynamic analysis;static analysis;program comprehension	Software maintenance;Information analysis;Computer science;Software engineering;Indexing;Unified modeling language;Information resources;Performance analysis;Software performance;Reconnaissance	data flow analysis;software maintenance	mapping features;static analysis;dynamic analysis;system evolution;feature location;component dependency graph		21	1	13		2 jul. 2008			IEEE	IEEE Conferences
Object-centric debugging	objectcentric debugging	10.1109/ICSE.2012.6227167	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227167	J. Ressia; A. Bergel; O. Nierstrasz	Software Composition Group, University of Bern, Switzerland; PLEIAD Lab, Department of Computer Science (DCC), University of Chile, Chile; Software Composition Group, University of Bern, Switzerland	2012 34th International Conference on Software Engineering (ICSE)	28 jun. 2012	2012			485	495	During the process of developing and maintaining a complex software system, developers pose detailed questions about the runtime behavior of the system. Source code views offer strictly limited insights, so developers often turn to tools like debuggers to inspect and interact with the running system. Unfortunately, traditional debuggers focus on the runtime stack as the key abstraction to support debugging operations, though the questions developers pose often have more to do with objects and their interactions. We propose object-centric debugging as an alternative approach to interacting with a running software system. We show how, by focusing on objects as the key abstraction, natural debugging operations can be defined to answer developer questions related to runtime behavior. We present a running prototype of an object-centric debugger, and demonstrate, with the help of a series of examples, how object-centric debugging offers more effective support for many typical developer tasks than a traditional stack-oriented debugger.	1558-1225	978-1-4673-1067-3		debugging;object-oriented programming;reflection;program comprehension	Debugging;Runtime;Data structures;Indexes;Software systems;Monitoring	object-oriented programming;program debugging;software maintenance	object-centric debugging;software system development;software system maintenance;system runtime behavior;source code views;runtime stack;key abstraction;natural debugging operations;stack-oriented debugger		21		37		28 jun. 2012			IEEE	IEEE Conferences
Software Clustering: Unifying Syntactic and Semantic Features	software clustering unifying syntactic and semantic features	10.1109/WCRE.2012.21	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385107	J. Misra; K. M. Annervaz; V. Kaulgud; S. Sengupta; G. Titus	Accenture Technology Laboratories, Bangalore, India; Accenture Technology Laboratories, Bangalore, India; Accenture Technology Laboratories, Bangalore, India; Accenture Technology Laboratories, Bangalore, India; Accenture Technology Laboratories, Bangalore, India	2012 19th Working Conference on Reverse Engineering	20 Dec 2012	2012			113	122	Software clustering is an important technique for extracting high level component architecture from the underlying source code. One of the limitations of the existing approaches is that most of the proposed techniques use only similar types of features for estimating distance between source code elements. Therefore, in cases, where the selected features are poorly present in the source code, these techniques may not produce good quality results in absence of adequate inputs to work on. In this paper we propose an approach to overcome this limitation. Proposed approach uses a combination of multiple types of features together and applies automated weighing on the extracted features to enhance their information quality and to reduce noise. We define a way to estimate distance between code elements in terms of combination of multiple types of features. Weighted graph partitioning with a multi-objective global modularity criterion is used to select the clusters as architectural components. We describe methods for automated labeling of the extracted components and for generating inter-component interactions. We further discuss how the suggested approach extends to clustering at multiple hierarchical levels, to application portfolios, and even for improving precision for the feature location problem.	2375-5369	978-0-7695-4891-3		software clustering;architectural recovery;component discovery;program comprehension;lexical analysis;vector space model;latent semantic indexing	Reverse engineering	feature extraction;graph theory;object-oriented programming;pattern clustering;program diagnostics;software architecture	software clustering;syntactic features;semantic features;high level component architecture extraction;distance estimation;source code elements;feature extraction;information quality enhancement;noise reduction;weighted graph partitioning;multiobjective global modularity criterion;cluster selection;automated component labeling;inter-component interaction generation;multiple hierarchical levels;application portfolios;feature location problem		21	2	28		20 Dec 2012			IEEE	IEEE Conferences
Developer Reading Behavior While Summarizing Java Methods: Size and Context Matters	developer reading behavior while summarizing java methods size and context matters	10.1109/ICSE.2019.00052	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812039	N. J. Abid; B. Sharif; N. Dragan; H. Alrasheed; J. I. Maletic	Department of Computer Science, Taibah University, Madinah, Kingdom of Saudi Arabia; Department of Computer Science and Engineering, University of Nebraska-Lincoln, Lincoln, Nebraska, USA; Department of Computer Science, Kent State University, Kent, Ohio, USA; Department of Information Technology, King Saud University, Riyadh, Kingdom of Saudi Arabia; Department of Computer Science, Kent State University, Kent, Ohio, USA	2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)	26 Aug 2019	2019			384	395	An eye-tracking study of 18 developers reading and summarizing Java methods is presented. The developers provide a written summary for methods assigned to them. In total, 63 methods are used from five different systems. Previous studies on this topic use only short methods presented in isolation usually as images. In contrast, this work presents the study in the Eclipse IDE allowing access to all the source code in the system. The developer can navigate via scrolling and switching files while writing the summary. New eye-tracking infrastructure allows for this improvement in the study environment. Data collected includes eye gazes on source code, written summaries, and time to complete each summary. Unlike prior work that concluded developers focus on the signature the most, these results indicate that they tend to focus on the method body more than the signature. Moreover, both experts and novices tend to revisit control flow terms rather than reading them for a long period. They also spend a significant amount of gaze time and have higher gaze visits when they read call terms. Experts tend to revisit the body of the method significantly more frequently than its signature as the size of the method increases. Moreover, experts tend to write their summaries from source code lines that they read the most.	1558-1225	978-1-7281-0869-8		source code summarization;eye tracking;program comprehension;empirical study	Java;Gaze tracking;Task analysis;Natural languages;Software engineering;Switches	gaze tracking;human factors;Java	Java methods;written summary;gaze time;source code lines;eye gazes;eye tracking infrastructure;developer reading behavior;Eclipse IDE;control flow		20		48		26 Aug 2019			IEEE	IEEE Conferences
Multiscale visual comparison of execution traces	multiscale visual comparison of execution traces	10.1109/ICPC.2013.6613833	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613833	J. Trümper; J. Döllner; A. Telea	Hasso Plattner Institute, University of Potsdam, Germany; Hasso Plattner Institute, University of Potsdam, Germany; Johann Bernoulli Institute, University of Groningen, The Netherlands	2013 21st International Conference on Program Comprehension (ICPC)	30 Sep 2013	2013			53	62	Understanding the execution of programs by means of program traces is a key strategy in software comprehension. An important task in this context is comparing two traces in order to find similarities and differences in terms of executed code, execution order, and execution duration. For large and complex program traces, this is a difficult task due to the cardinality of the trace data. In this paper, we propose a new visualization method based on icicle plots and edge bundles. We address visual scalability by several multiscale visualization metaphors, which help users navigating from the main differences between two traces to intermediate structural-difference levels, and, finally fine-grained function call levels. We show how our approach, implemented in a tool called TRACEDIFF, is applicable in several scenarios for trace difference comprehension on real-world trace datasets.	1092-8138	978-1-4673-3092-3		Trace analysis;Software visualization;Program comprehension	Electron tubes;Visualization;Data visualization;Vegetation;Bars;Shape;Image edge detection	program diagnostics;program visualisation;reverse engineering	multiscale visual comparison;execution traces;program execution understanding;program traces;software comprehension;executed code;execution order;execution duration;icicle plots;edge bundles;visual scalability;multiscale visualization metaphors;intermediate structural-difference levels;fine-grained function call levels;TRACEDIFF;trace difference comprehension		20		38		30 Sep 2013			IEEE	IEEE Conferences
Flexible design pattern detection based on feature types	flexible design pattern detection based on feature types	10.1109/ASE.2011.6100060	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6100060	G. Rasool; P. Mäder	Comsats Institute of Information Technoglogy, Lahore, Pakistan; Institute of Systems Engineering and Automation (SEA), Johannes Kepler University, Linz, Austria	2011 26th IEEE/ACM International Conference on Automated Software Engineering (ASE 2011)	12 Dec 2011	2011			243	252	Accurately recovered design patterns support development related tasks like program comprehension and reengineering. Researchers proposed a variety of recognition approaches already. Though, much progress was made, there is still a lack of accuracy and flexibility in recognition. A major problem is the large variety of variants for implementing the same pattern. Furthermore, the integration of multiple search techniques is required to provide more accurate and effective pattern detection. In this paper, we propose variable pattern definitions composed of reusable feature types. Each feature type is assigned to one of multiple search techniques that is best fitting for its detection. A prototype implementation was applied to three open source applications. For each system a baseline was determined and used for comparison with the results of previous techniques. We reached very good results with an improved pattern catalog, but also demonstrated the necessity for customizations on new inspected systems. These results demonstrate the importance of customizable pattern definitions and multiple search techniques in order to overcome accuracy and flexibility issues of previous approaches.	1938-4300	978-1-4577-1639-3		Design Pattern Recognition;Pattern Detection;Pattern Definition;Feature-Based Pattern Recognition;Program Comprehension;Code Analysis;Regular Expressions	Feature extraction;Pattern recognition;Catalogs;Production facilities;Analytical models;Accuracy;Java	pattern recognition;program diagnostics;search problems;software prototyping;software reusability	flexible design pattern detection;program comprehension;reengineering;recognition approaches;multiple search techniques;variable pattern definitions;reusable feature types;prototype implementation;pattern catalog;customizable pattern definitions		20		18		12 Dec 2011			IEEE	IEEE Conferences
Program Behavior Discovery and Verification: A Graph Grammar Approach	program behavior discovery and verification a graph grammar approach	10.1109/TSE.2010.3	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5383371	C. Zhao; J. Kong; K. Zhang	Department of Computer Science, University of Texas, Dallas, Richardson, TX, USA; Department of Computer Science, North Dakota State University, Fargo, ND, USA; Department of Computer Science, University of Texas, Dallas, Richardson, TX, USA	IEEE Transactions on Software Engineering	27 May 2010	2010	36	3	431	448	Discovering program behaviors and functionalities can ease program comprehension and verification. Existing program analysis approaches have used text mining algorithms to infer behavior patterns or formal models from program execution. When one tries to identify the hierarchical composition of a program behavior at different abstraction levels, textual descriptions are not informative and expressive enough. To address this, we present a semi-automatic graph grammar approach to retrieving the hierarchical structure of the program behavior. The hierarchical structure is built on recurring substructures in a bottom-up fashion. We formulate the behavior discovery and verification problem as a graph grammar induction and parsing problem, i.e., automatically iteratively mining qualified patterns and then constructing graph rewriting rules. Furthermore, using the induced grammar to parse the behavioral structure of a new program could verify if the program has the same behavioral properties specified by the grammar.	1939-3520			Visual language;graph grammar induction;program comprehension;reengineering.	Software maintenance;Reverse engineering;Learning automata;Software systems;Data mining;Clustering algorithms;Pattern analysis;Algorithm design and analysis;Text mining;Documentation	data mining;graph grammars;program verification	program behavior discovery;program behavior verification;program comprehension;text mining algorithms;behavior patterns;formal models;program execution;semi-automatic graph grammar approach;graph rewriting rules;mining qualified patterns		20		60		15 jan. 2010			IEEE	IEEE Journals
Package patterns for visual architecture recovery	package patterns for visual architecture recovery	10.1109/CSMR.2006.39	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1602370	M. Lungu; M. Lanza; T. Girba	University of Lugano, Switzerland; University of Lugano, Switzerland; Software Composition Group, University of Bern, Switzerland	Conference on Software Maintenance and Reengineering (CSMR'06)	10 Apr 2006	2006			10 pp.	196	Recovering the architecture is the first step towards reengineering a software system. Many reverse engineering tools use top-down exploration as a way of providing a visual and interactive process for architecture recovery. During the exploration process, the user navigates through various views on the system by choosing from several exploration operations. Although some sequences of these operations lead to views which, from the architectural point of view, are mode relevant than others, current tools do not provide a way of predicting which exploration paths are worth taking and which are not. In this article, we propose a set of package patterns which are used for augmenting the exploration process with information about the worthiness of the various exploration paths. The patterns are defined based on the internal package structure and on the relationships between the package and the other packages in the system. To validate our approach, we verify the relevance of the proposed patterns for real-world systems by analyzing their frequency of occurrence in six open-source software projects	1534-5351	0-7695-2536-9		Software exploration;architecture recovery;reverse engineering;program comprehension;visualization	Packaging;Computer architecture;Open source software;Software systems;Reverse engineering;Navigation;Pattern analysis;Frequency;Visualization;Informatics	object-oriented programming;program visualisation;reverse engineering;software architecture;software maintenance;systems re-engineering	package patterns;visual architecture recovery;software system reengineering;reverse engineering tools;top-down exploration;visual process;interactive process;internal package structure;open-source software projects;software exploration;program comprehension;program visualization		18		34		10 Apr 2006			IEEE	IEEE Conferences
Meaningful Identifier Names: The Case of Single-Letter Variables	meaningful identifier names the case of singleletter variables	10.1109/ICPC.2017.18	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961503	G. Beniamini; S. Gingichashvili; A. K. Orbach; D. G. Feitelson	School of Computer Science and Engineering, The Hebrew University of Jerusalem, Jerusalem, Israel; School of Computer Science and Engineering, The Hebrew University of Jerusalem, Jerusalem, Israel; School of Computer Science and Engineering, The Hebrew University of Jerusalem, Jerusalem, Israel; School of Computer Science and Engineering, The Hebrew University of Jerusalem, Jerusalem, Israel	2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC)	29 jun. 2017	2017			45	54	It is widely accepted that variable names in computer programs should be meaningful, and that this aids program comprehension. "Meaningful" is commonly interpreted as favoring long descriptive names. However, there is at least some use of short and even single-letter names: using 'i' in loops is very common, and we show (by extracting variable names from 1000 popular github projects in 5 languages) that some other letters are also widely used. In addition, controlled experiments with different versions of the same functions (specifically, different variable names) failed to show significant differences in ability to modify the code. Finally, an online survey showed that certain letters are strongly associated with certain types and meanings. This implies that a single letter can in fact convey meaning. The conclusion from all this is that single letter variables can indeed be used beneficially in certain cases, leading to more concise code.		978-1-5386-0535-6		Program comprehension;meaningful identifier names;single-letter names	Data mining;Programming;Encoding;Standards;Syntactics;Java	software maintenance;source code (software)	variable names;program comprehension;long descriptive names;single letter variables;meaningful identifier names		18		18		29 jun. 2017			IEEE	IEEE Conferences
SArF map: Visualizing software architecture from feature and layer viewpoints	sarf map visualizing software architecture from feature and layer viewpoints	10.1109/ICPC.2013.6613832	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613832	K. Kobayashi; M. Kamimura; K. Yano; K. Kato; A. Matsuo	Software Systems Laboratories Fujitsu Laboratories Ltd, Kawasaki, Japan; Software Systems Laboratories Fujitsu Laboratories Ltd, Kawasaki, Japan; Software Systems Laboratories Fujitsu Laboratories Ltd, Kawasaki, Japan; Software Systems Laboratories Fujitsu Laboratories Ltd, Kawasaki, Japan; Software Systems Laboratories Fujitsu Laboratories Ltd, Kawasaki, Japan	2013 21st International Conference on Program Comprehension (ICPC)	30 Sep 2013	2013			43	52	To facilitate understanding the architecture of a software system, we developed SArF Map technique that visualizes software architecture from feature and layer viewpoints using a city metaphor. SArF Map visualizes implicit software features using our previous study, SArF dependency-based software clustering algorithm. Since features are high-level abstraction units of software, a generated map can be directly used for high-level decision making such as reuse and also for communications between developers and non-developer stakeholders. In SArF Map, each feature is visualized as a city block, and classes in the feature are laid out as buildings reflecting their software layer. Relevance between features is represented as streets. Dependency links are visualized lucidly. Through open source and industrial case studies, we show that the architecture of the target systems can be easily overviewed and that the quality of their packaging designs can be quickly assessed.	1092-8138	978-1-4673-3092-3		Software visualization;city metaphor;software architecture;program comprehension;software clustering;dependency graph	Software;Cities and towns;Layout;Buildings;Software algorithms;Clustering algorithms;Visualization	decision making;program visualisation;reverse engineering;software architecture	SArF map;software architecture visualization;software feature viewpoints;software layer viewpoints;software system architecture understanding;city metaphor;SArF dependency-based software clustering algorithm;high-level abstraction units;high-level decision making;reuse;city block;dependency links		17		25		30 Sep 2013			IEEE	IEEE Conferences
Physical and conceptual identifier dispersion: Measures and relation to fault proneness	physical and conceptual identifier dispersion measures and relation to fault proneness	10.1109/ICSM.2010.5609748	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609748	V. Arnaoudova; L. Eshkevari; R. Oliveto; Y. -G. Guéhéneuc; G. Antoniol	SOCCER Lab.-DGIGL, École Polytechnique de Montréal, Québec, Québec, Canada; SOCCER Lab.-DGIGL, École Polytechnique de Montréal, Québec, Québec, Canada; SE@SA Lab-DMI, University of Salerno, Salerno, Italy; Ptidej Team-DGIGL, École Polytechnique de Montréal, Québec, Canada; SOCCER Lab.-DGIGL, École Polytechnique de Montréal, Québec, Québec, Canada	2010 IEEE International Conference on Software Maintenance	25 Oct 2010	2010			1	5	Poorly-chosen identifiers have been reported in the literature as misleading and increasing the program comprehension effort. Identifiers are composed of terms, which can be dictionary words, acronyms, contractions, or simple strings. We conjecture that the use of identical terms in different contexts may increase the risk of faults. We investigate our conjecture using a measure combining term entropy and term context coverage to study whether certain terms increase the odds ratios of methods to be fault-prone. Entropy measures the physical dispersion of terms in a program: the higher the entropy, the more scattered across the program the terms. Context coverage measures the conceptual dispersion of terms: the higher their context coverage, the more unrelated the methods using them. We compute term entropy and context coverage of terms extracted from identifiers in Rhino 1.4R3 and ArgoUML 0.16. We show statistically that methods containing terms with high entropy and context coverage are more fault-prone than others.	1063-6773	978-1-4244-8629-8		Source Code Identifiers;Program Comprehension;Fault Models;Information Retrieval;Entropy	Entropy;Context;Measurement;Correlation;Presses;Software engineering;Conferences	entropy;software fault tolerance;software metrics;statistical analysis;Unified Modeling Language	conceptual identifier dispersion;physical identifier dispersion;fault proneness;program comprehension;term entropy;term context coverage;Rhino 1.4R3;ArgoUML 0.16		17		28		25 Oct 2010			IEEE	IEEE Conferences
Debugging Revisited: Toward Understanding the Debugging Needs of Contemporary Software Developers	debugging revisited toward understanding the debugging needs of contemporary software developers	10.1109/ESEM.2013.43	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6681382	L. Layman; M. Diep; M. Nagappan; J. Singer; R. Deline; G. Venolia	Fraunhofer Center for Experimental Software Eng., Maryland, USA; Fraunhofer Center for Experimental Software Eng., Maryland, USA; Software Analysis and Intelligence Lab (SAIL) School of Computing, Queen's University Kingston, Ontario, Canada; National Research Council Ottawa, Ontario, Canada; Microsoft Research Redmond, WA, USA; Microsoft Research Redmond, WA, USA	2013 ACM / IEEE International Symposium on Empirical Software Engineering and Measurement	12 Dec 2013	2013			383	392	We know surprisingly little about how professional developers define debugging and the challenges they face in industrial environments. To begin exploring professional debugging challenges and needs, we conducted and analyzed interviews with 15 professional software engineers at Microsoft. The goals of this study are: 1) to understand how professional developers currently use information and tools to debug, 2) to identify new challenges in debugging in contemporary software development domains (web services, multithreaded/multicore programming), and 3) to identify the improvements in debugging support desired by these professionals that are needed from research. The interviews were coded to identify the most common information resources, techniques, challenges, and needs for debugging as articulated by the developers. The study reveals several debugging challenges faced by professionals, including: 1) the interaction of hypothesis instrumentation and software environment as a source of debugging difficulty, 2) the impact of log file information on accurate debugging of web services, and 3) the mismatch between the sequential human thought process and the non-sequential execution of multithreaded environments as source of difficulty. The interviewees also describe desired improvements to tools to support debugging, many of which have been discussed in research but not transitioned to practice.	1949-3789	978-0-7695-5056-5		debugging;software engineering;interview;professionals;qualitative analysis;program comprehension	Debugging;Interviews;Encoding;Computer bugs;Web services;Testing	multi-threading;program debugging;Web services	debugging needs;contemporary software developers;professional developers;industrial environments;professional software engineers;Microsoft;information resources;hypothesis instrumentation;software environment;Web services;log file information;sequential human thought process;nonsequential multithreaded environments execution		17		21		12 Dec 2013			IEEE	IEEE Conferences
Monitoring user interactions for supporting failure reproduction	monitoring user interactions for supporting failure reproduction	10.1109/ICPC.2013.6613835	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613835	T. Roehm; N. Gurbanova; B. Bruegge; C. Joubert; W. Maalej	Technische Universität München, Munich, Germany; Technische Universität München, Munich, Germany; Technische Universität München, Munich, Germany; Prodevelop, Valencia, Spain; University of Hamburg, Hamburg, Germany	2013 21st International Conference on Program Comprehension (ICPC)	30 Sep 2013	2013			73	82	The first step to comprehend and fix a software bug is usually to reproduce the corresponding failure. Reproducing a failure requires information about steps to reproduce, i.e. the steps necessary to make a failure occur in the development environment. In case of an application with a user interface, steps to reproduce consist of the interactions between a user and the application that precede the failure. Unfortunately, bug reports typically lack this information. Users are either unaware of its importance to developers, are unable to describe it, or simply do not have time to report it. In this paper, we present a simple but effective and resource efficient approach to monitor interactions between users and their applications selectively at a high level of abstraction, e.g. editing operations and commands. This minimizes the monitoring overhead and enables developers to analyze user interaction traces. We map monitored interactions to a taxonomy of user interactions to help developers comprehend user behavior. Further, we present the Timeline Tool that visualizes monitored interaction traces preceding failures. To evaluate our approach we conducted an experiment with 12 participants and asked them to reproduce bug reports from an open-source project. We found that developers are able to derive steps to reproduce from monitored interaction traces. In particular, inexperienced developers profit from the Timeline Tool, as they are able to reproduce failures that they cannot reproduce without it. The monitoring overhead is rather small (approx. 5% CPU and 2-5% memory) and users feel it does not influence their work in a negative way.	1092-8138	978-1-4673-3092-3		Bug fixing;Failure reproduction;Steps to reproduce;User monitoring;Application instrumentation;Trace analysis;Program comprehension;Software maintenance;Software evolution	Monitoring;Sensors;Taxonomy;Unified modeling language;Visualization;Servers;Software	data visualisation;program debugging;public domain software;software fault tolerance;user interfaces	user interactions monitoring;failure reproduction;software bug;development environment;user interface;resource efficient approach;abstraction level;editing operations;editing commands;timeline tool;monitored interaction traces;open-source project		16		23		30 Sep 2013			IEEE	IEEE Conferences
Autumn Leaves: Curing the Window Plague in IDEs	autumn leaves curing the window plague in ides	10.1109/WCRE.2009.18	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5328777	D. Roethlisberger; O. Nierstrasz; S. Ducasse	Universitat Bern, Bern, BE, CH; Software Composition Group, University of Bern, Switzerland; INRIA-Lille Nord Europe, France	2009 16th Working Conference on Reverse Engineering	17 nov. 2009	2009			237	246	Navigating large software systems is difficult as the various artifacts are distributed in a huge space, while the relationships between different artifacts often remain hidden and obscure. As a consequence, developers using a modern interactive development environment (IDE) are forced to open views on numerous source artifacts to reveal these hidden relationships, leading to a crowded workspace with many opened windows or tabs. Developers often lose the overview in such a cluttered workspace as IDEs provide little support to get rid of unused windows. AutumnLeaves automatically selects windows unlikely for future use to be closed or grayed out while important ones are displayed more prominently. This reduces the number of windows opened at a time and adds structure to the developer’s workspace. We validate AutumnLeaves with a benchmark evaluation using recorded navigation data of various developers to determine the prediction quality of the employed algorithms.	2375-5369	978-0-7695-3867-9		development environments;software navigation;developer activity analysis;productivity;program comprehension	Curing;Navigation;Reverse engineering;Europe;Software systems;Open source software;Productivity;Scattering;Application software;Programming	software engineering;user interfaces	Autumn Leaves;window plague;IDE;interactive development environment;source artifacts;software navigation		15		22		17 nov. 2009			IEEE	IEEE Conferences
JStereoCode: automatically identifying method and class stereotypes in Java code	jstereocode automatically identifying method and class stereotypes in java code	10.1145/2351676.2351747	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6494955	L. Moreno; A. Marcus	Wayne State University, Detroit, MI, USA; Wayne State University, Detroit, MI, USA	2012 Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering	8 Apr 2013	2012			358	361	Object-Oriented (OO) code stereotypes are low-level patterns that reveal the design intent of a source code artifact, such as, a method or a class. They are orthogonal to the problem domain of the software and they reflect the role of a method or class from the OO problem solving point of view. However, the research community in automated reverse engineering has focused more on higher-level design information, such as design patterns. Existing work on reverse engineering code stereotypes is scarce and focused on C++ code, while no tools are freely available as of today. We present JStereoCode, a tool that automatically identifies the stereotypes of methods and classes in Java systems. The tool is integrated with Eclipse and for a given Java project will classify each method and class in the system based on their stereotypes. Applications of JStereoCode include: program comprehension, defect prediction, etc.		978-1-4503-1204-2		Code stereotypes;Java;Program comprehension		C++ language;Java;object-oriented programming;reverse engineering	JStereoCode;identifying method;class stereotypes;object-oriented code stereotypes;OO code stereotypes;low-level patterns;source code artifact;automated reverse engineering;design patterns;reverse engineering code stereotypes;C++ code;Java systems;Eclipse;Java project;program comprehension;defect prediction		15		9		8 Apr 2013			IEEE	IEEE Conferences
Connecting Traces: Understanding Client-Server Interactions in Ajax Applications	connecting traces understanding clientserver interactions in ajax applications	10.1109/ICPC.2010.14	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521743	N. Matthijssen; A. Zaidman; M. -A. Storey; I. Bull; A. van Deursen	Software Engineering Research Group, Delft University of Technnology, Netherlands; Software Engineering Research Group, Delft University of Technnology, Netherlands; Department of Computer Science, University of Victoria, Victoria, BC, Canada; Department of Computer Science, University of Victoria, Victoria, BC, Canada; Software Engineering Research Group, Delft University of Technnology, Netherlands	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			216	225	Ajax-enabled web applications are a new breed of highly interactive, highly dynamic web applications. Although Ajax allows developers to create rich web applications, Ajax applications can be difficult to comprehend and thus to maintain. For this reason, we have created FireDetective, a tool that uses dynamic analysis at both the client (browser) and server side to facilitate the understanding of Ajax applications. Using an exploratory pre-experimental user study, we see that web developers encounter problems when understanding Ajax applications. We also find preliminary evidence that the FireDetective tool allows web developers to understand Ajax applications more effectively, more efficiently and with more confidence.	1092-8138	978-1-4244-7603-9		Ajax;dynamic analysis;web applications;program comprehension;understanding	Joining processes;Application software;Java;Software maintenance;Software engineering;Computer science;XML;Runtime;HTML;Visualization	client-server systems;Internet;Java;software tools;XML	client-server interactions;Ajax-enabled Web applications;FireDetective tool;dynamic Web analysis;asynchronous Javascript and XML		15		20		26 jul. 2010			IEEE	IEEE Conferences
On the Effect of the Query in IR-based Concept Location	on the effect of the query in irbased concept location	10.1109/ICPC.2011.48	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5970170	S. Haiduc; A. Marcus	Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA	2011 IEEE 19th International Conference on Program Comprehension	1 Aug 2011	2011			234	237	Concept location is an essential task during software maintenance and in particular program comprehension activities. One of the approaches to this task is the based on leveraging the lexical information found in the source code by means of Information Retrieval techniques. All IR-based approaches to concept location are highly dependent on the queries written by the users. An IR approach, even though good on average, might fail when the input query is poor. Currently there is no way to tell when a query leads to poor results for IR-based concept location, unless a considerable effort is put into analyzing the results after the fact. We propose an approach based on recent advances in the field of IR research, which aims at automatically determining the difficulty a query poses to an IR-based concept location technique. We plan to evaluate several models and relate them to IR performance metrics.	1092-8138	978-0-7695-4398-7		program comprehension;concept location;search;source code;information retrieval;query	Prediction algorithms;Correlation;Conferences;Estimation;Measurement;Search engines	query processing;software maintenance;software metrics;software performance evaluation	IR-based concept location;software maintenance;program comprehension activity;lexical information;source code;information retrieval techniques;IR performance metrics		14		16		1 Aug 2011			IEEE	IEEE Conferences
ClDiff: Generating Concise Linked Code Differences	cldiff generating concise linked code differences	10.1145/3238147.3238219	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9000085	K. Huang; B. Chen; X. Peng; D. Zhou; Y. Wang; Y. Liu; W. Zhao	School of Computer Science and Shanghai Key Laboratory of Data Science, Fudan University, China; School of Computer Science and Shanghai Key Laboratory of Data Science, Fudan University, China; School of Computer Science and Shanghai Key Laboratory of Data Science, Fudan University, China; School of Computer Science and Shanghai Key Laboratory of Data Science, Fudan University, China; School of Computer Science and Shanghai Key Laboratory of Data Science, Fudan University, China; Shanghai Institute of Intelligent Electronics & Systems, China; School of Computer Science and Shanghai Key Laboratory of Data Science, Fudan University, China	2018 33rd IEEE/ACM International Conference on Automated Software Engineering (ASE)	17 Feb 2020	2018			679	690	Analyzing and understanding source code changes is important in a variety of software maintenance tasks. To this end, many code differencing and code change summarization methods have been proposed. For some tasks (e.g. code review and software merging), however, those differencing methods generate too fine-grained a representation of code changes, and those summarization methods generate too coarse-grained a representation of code changes. Moreover, they do not consider the relationships among code changes. Therefore, the generated differences or summaries make it not easy to analyze and understand code changes in some software maintenance tasks. In this paper, we propose a code differencing approach, named ClDiff, to generate concise linked code differences whose granularity is in between the existing code differencing and code change summarization methods. The goal of ClDiff is to generate more easily understandable code differences. ClDiff takes source code files before and after changes as inputs, and consists of three steps. First, it pre-processes the source code files by pruning unchanged declarations from the parsed abstract syntax trees. Second, it generates concise code differences by grouping fine-grained code differences at or above the statement level and describing high-level changes in each group. Third, it links the related concise code differences according to five pre-defined links. Experiments with 12 Java projects (74,387 commits) and a human study with 10 participants have indicated the accuracy, conciseness, performance and usefulness of ClDiff.	2643-1572	978-1-4503-5937-5		Code Differencing;Program Comprehension;AST		software maintenance;source code (software);trees (mathematics)	software maintenance tasks;code change summarization methods;code differencing approach;CLDIFF;source code files;fine-grained code differences;concise linked code differences;source code changes;parsed abstract syntax trees		13		59		17 Feb 2020			IEEE	IEEE Conferences
The SEXTANT Software Exploration Tool	the sextant software exploration tool	10.1109/TSE.2006.94	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1707671	T. Schafer; M. Eichberg; M. Haupt; M. Mezini	Software Technology Group, Darmstadt University of Technology, Darmstadt, Germany; Software Technology Group, Darmstadt University of Technology, Darmstadt, Germany; Software Technology Group, Darmstadt University of Technology, Darmstadt, Germany; Software Technology Group, Darmstadt University of Technology, Darmstadt, Germany	IEEE Transactions on Software Engineering	9 Oct 2006	2006	32	9	753	768	In this paper, we discuss a set of functional requirements for software exploration tools and provide initial evidence that various combinations of these features are needed to effectively assist developers in understanding software. We observe that current tools for software exploration only partly support these features. This has motivated the development of SEXTANT, a software exploration tool tightly integrated into the Eclipse IDE that has been developed to fill this gap. By means of case studies, we demonstrate how the requirements fulfilled by SEXTANT are conducive to an understanding needed to perform a maintenance task	1939-3520			Software exploration;program comprehension;reverse engineering;software maintenance;software visualization.	Software tools;Visualization;Navigation;Software maintenance;Cognition;Computer architecture;Reverse engineering	formal specification;program visualisation;programming environments;reverse engineering;software maintenance	functional requirement;SEXTANT software exploration tool;software understanding;Eclipse IDE;software maintenance;program comprehension;reverse engineering;software visualization		13		60		9 Oct 2006			IEEE	IEEE Journals
On the Optimal Order of Reading Source Code Changes for Review	on the optimal order of reading source code changes for review	10.1109/ICSME.2017.28	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8094433	T. Baum; K. Schneider; A. Bacchelli	FG Software Engineering Leibniz Universität Hannover, Hannover, Germany; FG Software Engineering Leibniz Universität Hannover, Hannover, Germany; ZEST-Zurich Empirical Software engineering Team University of Zurich, Zürich, Switzerland	2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)	7 nov. 2017	2017			329	340	Change-based code review, e.g., in the form of pull requests, is the dominant style of code review in practice. An important option to improve review's efficiency is cognitive support for the reviewer. Nevertheless, review tools present the change parts under review sorted in alphabetical order of file path, thus leaving the effort of understanding the construction, connections, and logic of the changes on the reviewer. This leads to the question: How should a code review tool order the parts of a code change to best support the reviewer? We answer this question with a middle-range theory, which we generated inductively in a mixed methods study, based on interviews, an online survey, and existing findings from related areas. Our results indicate that an optimal order is mainly an optimal grouping of the change parts by relatedness. We present our findings as a collection of principles and formalize them as a partial order relation among review orders.		978-1-5386-0992-7		Change-based code review;Modern code review;Pull-based development;Cognitive support review tools;Program comprehension	Interviews;Tools;Software;Navigation;Industries;Software engineering	program diagnostics;public domain software;software quality;source code (software)	optimal order;reviewer;review tools;change parts;alphabetical order;partial order relation;review orders;optimal grouping;middle-range theory;code review tool;review efficiency;change-based code review;source code change reading		13		75		7 nov. 2017			IEEE	IEEE Conferences
An Empirical Study of Abbreviations and Expansions in Software Artifacts	an empirical study of abbreviations and expansions in software artifacts	10.1109/ICSME.2019.00040	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8918962	C. D. Newman; M. J. Decker; R. S. Alsuhaibani; A. Peruma; D. Kaushik; E. Hill	Rochester Institute of Technology, Rochester, New York, USA; Bowling Green State University, Bowling Green, OH, USA; Kent State University, Kent, OH, USA; Rochester Institute of Tech Rochester, New York, USA; Rochester Institute of Tech Rochester, New York, USA; Drew University, Drew, NJ, USA	2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)	5 Dec 2019	2019			269	279	Expanding abbreviations is an important text normalization technique used for the purpose of either increasing developer comprehension or supporting the application of natural-language-based tools for source code identifiers. This paper closely studies abbreviations and where their expansions occur in different software artifacts. Without abbreviation expansion, developers will spend more time in comprehending the code they need to update, and tools analyzing software may obtain weak or non-generalizable results. There are numerous techniques for expanding abbreviations, most of which struggle to reach an average expansion accuracy of 59-62% on general source code identifiers. In this paper, we reveal some characteristics of abbreviations and their expansions through an empirical study of 861 abbreviation-expansion pairs extracted from 5 open-source systems in addition to analyzing previous literature. We use these characteristics to identify how current approaches may be complementary and how their results should be reported in the future to help maximize both our understanding of how they compare with other expansion techniques and their reproducibility.	2576-3148	978-1-7281-3094-1		Program Comprehension, abbreviation expansion, software maintenance, software evolution	Software;Documentation;Tools;Java;Natural language processing;Dictionaries	natural language processing;public domain software;software maintenance;source code (software);text analysis	average expansion accuracy;general source code identifiers;861 abbreviation-expansion pairs;5 open-source systems;expansion techniques;natural-language-based tools;software artifacts;abbreviation expansion;developer comprehension;text normalization technique		13		32		5 Dec 2019			IEEE	IEEE Conferences
Professional status and expertise for UML class diagram comprehension: An empirical study	professional status and expertise for uml class diagram comprehension an empirical study	10.1109/ICPC.2012.6240484	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240484	Z. Soh; Z. Sharafi; B. Van den Plas; G. C. Porras; Y. -G. Guéhéneuc; G. Antoniol	Department of Computer Engineering, UIT, University of Ngaoundéré, Cameroon; Ptidej Team, SOCCER Laboratory, DGIGL, École Polytechnique de Montréal, Canada; Faculté dInformatique, FUNDP de Namur, Belgium; DIRO, Université de Montreal, Canada; Ptidej Team, SOCCER Laboratory, DGIGL, École Polytechnique de Montréal, Canada; Ptidej Team, SOCCER Laboratory, DGIGL, École Polytechnique de Montréal, Canada	2012 20th IEEE International Conference on Program Comprehension (ICPC)	16 jul. 2012	2012			163	172	Professional experience is one of the most important criteria for almost any job offer in software engineering. Professional experience refers both to professional status (practitioner vs. student) and expertise (expert vs. novice). We perform an experiment with 21 subjects including both practitioners and students, and experts and novices. We seek to understand the relation between the speed and accuracy of the subjects and their status and expertise in performing maintenance tasks on UML class diagrams. We also study the impact of the formulation of the maintenance task. We use an eye-tracking system to gather the fixations of the subjects when performing the task. We measure the subjects' comprehension using their accuracy, the time spent, the search effort, the overall effort, and the question comprehension effort. We found that (1) practitioners are more accurate than students while students spend around 35 percent less time than practitioners, (2) experts are more accurate than novices while novices spending around 33 percent less time than experts, (3) expertise is the most important factor for accuracy and speed, (4) experienced students are more accurate and spend around 37 percent less time than experienced practitioners, and (5) when the description of the task is precise, the novice students can be accurate. We conclude that it is an illusion for project managers to focus on status only when recruiting a software engineer. Our result is the starting point to consider the differences between status and expertise when studying software engineers' productivity. Thus, it can help project managers to recruit productive engineers and motivated students to acquire the experience and ability in the projects.	1092-8138	978-1-4673-1216-5		Program Comprehension;Professional status;Expertise;Eye-tracking	Unified modeling language;Maintenance engineering;Accuracy;Software;Testing;Context;Software engineering	software maintenance;Unified Modeling Language	professional status;professional expertise;UML class diagram comprehension;professional experience;software engineering;maintenance task formulation;eye-tracking system;accuracy;time spent;search effort;overall effort;question comprehension effort;software engineer productivity		13		23		16 jul. 2012			IEEE	IEEE Conferences
A Look into Programmers’ Heads	a look into programmers’ heads	10.1109/TSE.2018.2863303	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8425769	N. Peitek; J. Siegmund; S. Apel; C. Kästner; C. Parnin; A. Bethmann; T. Leich; G. Saake; A. Brechmann	Leibniz Institute for Neurobiology Magdeburg, Magdeburg, Germany; University of Passau, Passau, Germany; University of Passau, Passau, Germany; Carnegie Mellon University, Pittsburgh, USA; NC State University, Raleigh, USA; Leibniz Institute for Neurobiology Magdeburg, Magdeburg, Germany; Metop Research Institute, Magdeburg, Germany; University of Magdeburg, Magdeburg, Germany; Leibniz Institute for Neurobiology Magdeburg, Magdeburg, Germany	IEEE Transactions on Software Engineering	20 Apr 2020	2020	46	4	442	462	Program comprehension is an important, but hard to measure cognitive process. This makes it difficult to provide suitable programming languages, tools, or coding conventions to support developers in their everyday work. Here, we explore whether functional magnetic resonance imaging (fMRI) is feasible for soundly measuring program comprehension. To this end, we observed 17 participants inside an fMRI scanner while they were comprehending source code. The results show a clear, distinct activation of five brain regions, which are related to working memory, attention, and language processing, which all fit well to our understanding of program comprehension. Furthermore, we found reduced activity in the default mode network, indicating the cognitive effort necessary for program comprehension. We also observed that familiarity with Java as underlying programming language reduced cognitive effort during program comprehension. To gain confidence in the results and the method, we replicated the study with 11 new participants and largely confirmed our findings. Our results encourage us and, hopefully, others to use fMRI to observe programmers and, in the long run, answer questions, such as: How should we train programmers? Can we train someone to become an excellent programmer? How effective are new languages and tools for program comprehension?	1939-3520		DFG(grant numbers:SI 2045/2-1,BR 2267/7-1); Bavarian State Ministry of Education, Science; DFG(grant numbers:AP 206/4,AP 206/5,AP 206/6); National Science Foundation(grant numbers:1318808,1552944); AFRL and DARPA(grant numbers:FA8750-16-2-0042); ERC(grant numbers:#203099); National Science Foundation(grant numbers:1755762); 	Functional magnetic resonance imaging;program comprehension	Functional magnetic resonance imaging;Task analysis;Cognition;Brain;Programming;Blood	biomedical MRI;brain;cognition;Java;medical computing;neurophysiology	default mode network;Java;programming language reduced cognitive effort;language processing;working memory;brain regions;fMRI scanner;programming language;program comprehension;functional magnetic resonance imaging		12		112	IEEE	6 Aug 2018			IEEE	IEEE Journals
A Tree Kernel based approach for clone detection	a tree kernel based approach for clone detection	10.1109/ICSM.2010.5609715	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609715	A. Corazza; S. Di Martino; V. Maggio; G. Scanniello	Dipartimento di Scienze Fisiche, Sezione Informatica University of Naples Federico II, Italy; Dipartimento di Scienze Fisiche, Sezione Informatica University of Naples Federico II, Italy; Dipartimento di Scienze Fisiche, Sezione Informatica University of Naples Federico II, Italy; Università della Basilicata, Potenza, Italy	2010 IEEE International Conference on Software Maintenance	25 Oct 2010	2010			1	5	Reusing software by copying and pasting is a common practice in software development. This phenomenon is widely known as code cloning. Problems with clones are mainly due to the need of managing each duplication, thus increasing the effort to maintain software systems. Clone detection approaches generally take into account either the syntactic structure (e.g., Abstract Syntax Tree) or lexical elements (e.g., the signature of a function). In this paper we propose an approach to detect code clones, based on syntactic information enriched by lexical elements. To this end, we have defined a Tree Kernel function to compare Abstract Syntax Trees. A preliminary investigation has been also conducted to assess the validity of the proposed approach.	1063-6773	978-1-4244-8629-8		Clone Detection;Program Comprehension;Software Maintenance;Tree Kernels	Cloning;Kernel;Software systems;Syntactics;Java;Context	reverse engineering;software maintenance;software reusability	tree kernel function;clone detection;software reuse;software development;code cloning;software maintenance;syntactic structure;abstract syntax tree;lexical element;syntactic information;program comprehension		12		25		25 Oct 2010			IEEE	IEEE Conferences
Pattern Recognition Techniques Applied to the Abstraction of Traces of Inter-Process Communication	pattern recognition techniques applied to the abstraction of traces of interprocess communication	10.1109/CSMR.2011.27	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5741263	L. Alawneh; A. Hamou-Lhadj	Software Behaviour Analysis Group, Department of Electrical and Computer Engineering, Concordia University, Montreal, QUE, Canada; Software Behaviour Analysis Group, Department of Electrical and Computer Engineering, Concordia University, Montreal, QUE, Canada	2011 15th European Conference on Software Maintenance and Reengineering	5 Apr 2011	2011			211	220	The large number of processors in high performance computing and distributed applications is becoming a major challenge in the analysis of the way an application's processes communicate with each other. In this paper, we propose an approach that facilitates the understanding of large traces of inter-process communication by extracting communication patterns that characterize their main behavior. Two algorithms are proposed. The first one permits the recognition of repeating patterns in traces of MPI (Message Passing Interface) applications whereas the second algorithm searches if a given communication pattern occurs in a trace. Both algorithms are based on the n-gram extraction technique used in natural language processing. Unlike existing work, our approach operates on the trace as it is generated (i.e. on the fly) and does not require complex and computationally-expensive data structures. We show the effectiveness and efficiency of our approach in detecting communication patterns from large traces generated from two target systems.	1534-5351	978-1-61284-259-2		Trace of Inter-Process Communication;Pattern Recognition;Message Passing Interface;Dynamic Analysis;Program Comprehension	Pattern matching;Software;Algorithm design and analysis;Topology;Detection algorithms;Message passing	message passing;natural language processing;pattern recognition;program diagnostics	processor;high performance computing;distributed application;interprocess communication;repeating pattern recognition;MPI;message passing interface;n-gram extraction;natural language processing;communication pattern detection;trace abstraction		12	28	30		5 Apr 2011			IEEE	IEEE Conferences
Contextualizing Rename Decisions using Refactorings and Commit Messages	contextualizing rename decisions using refactorings and commit messages	10.1109/SCAM.2019.00017	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8930840	A. Peruma; M. W. Mkaouer; M. J. Decker; C. D. Newman	Rochester Institute of Technology, Rochester, NY, USA; Rochester Institute of Technology, Rochester, NY, USA; Bowling Green State University, Bowling Green, OH, USA; Rochester Institute of Technology, Rochester, NY, USA	2019 19th International Working Conference on Source Code Analysis and Manipulation (SCAM)	12 Dec 2019	2019			74	85	Identifier names are the atoms of comprehension; weak identifier names decrease productivity by increasing the chance that developers make mistakes and increasing the time taken to understand chunks of code. Therefore, it is vital to support developers in naming, and renaming, identifiers. In this paper, we study how terms in an identifier change during the application of rename refactorings and contextualize these changes using co-occurring refactorings and commit messages. The goal of this work is to understand how different development activities affect the type of changes applied to names during a rename. Results of this study can help researchers understand more about developers' naming habits and support developers in determining when to rename and what words to use.	2470-6892	978-1-7281-4937-0		Program Comprehension, Identifier Names, Rename Refactoring	Taxonomy;Semantics;Software;Context modeling;Productivity;Static analysis;Analytical models	natural language processing;software maintenance;text analysis	rename decisions;weak identifier names;productivity;identifier change;rename refactorings;development activities		12		71		12 Dec 2019			IEEE	IEEE Conferences
SYNCTRACE: Visual thread-interplay analysis	synctrace visual threadinterplay analysis	10.1109/VISSOFT.2013.6650534	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6650534	B. Karran; J. Trümper; J. Döllner	Hasso Plattner Institute, University of Potsdam, Germany; Hasso Plattner Institute, University of Potsdam, Germany; Hasso Plattner Institute, University of Potsdam, Germany	2013 First IEEE Working Conference on Software Visualization (VISSOFT)	31 Oct 2013	2013			1	10	In software comprehension, program traces are important to gain insight into certain aspects of concurrent runtime behavior, e.g., thread-interplay. Here, key tasks are finding usages of blocking operations, such as synchronization and I/O operations, assessing temporal order of such operations, and analyzing their effects. This is a hard task for large and complex program traces due to their size and number of threads involved. In this paper, we present SYNCTRACE a new visualization technique based on (bended) activity diagrams and edge bundles that allows for parallel analysis of multiple threads and their inter-thread correspondences. We demonstrate how the technique, implemented as a tool, can be applied on real-world trace datasets to support understanding concurrent behavior.		978-1-4799-1457-9		Trace analysis;Software visualization;Program comprehension;Concurrency	Synchronization;Visualization;Context;Color;Instruction sets;Concurrent computing;Data visualization	concurrency control;data flow analysis;parallel processing;software engineering	concurrent behavior;real-world trace datasets;inter-thread correspondences;multiple threads;parallel analysis;edge bundles;bended activity diagrams;visualization technique;complex program traces;large program traces;I/O operations;synchronization;concurrent runtime behavior;software comprehension;visual thread-interplay analysis;SYNCTRACE		12	1	48		31 Oct 2013			IEEE	IEEE Conferences
Understanding Asynchronous Interactions in Full-Stack JavaScript	understanding asynchronous interactions in fullstack javascript	10.1145/2884781.2884864	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886989	S. Alimadadi; A. Mesbah; K. Pattabiraman	University of British Columbia Vancouver, BC, Canada; University of British Columbia Vancouver, BC, Canada; University of British Columbia Vancouver, BC, Canada	2016 IEEE/ACM 38th International Conference on Software Engineering (ICSE)	3 Apr 2017	2016			1169	1180	JavaScript has become one of the most popular languages in practice. Developers now use JavaScript not only for the client-side but also for server-side programming, leading to "full-stack" applications written entirely in JavaScript. Understanding such applications is challenging for developers, due to the temporal and implicit relations of asynchronous and event-driven entities spread over the client and server side. We propose a technique for capturing a behavioural model of full-stack JavaScript applications' execution. The model is temporal and context-sensitive to accommodate asynchronous events, as well as the scheduling and execution of lifelines of callbacks. We present a visualization of the model to facilitate program understanding for developers. We implement our approach in a tool, called Sahand, and evaluate it through a controlled experiment. The results show that Sahand improves developers' performance in completing program comprehension tasks by increasing their accuracy by a factor of three.	1558-1225	978-1-4503-3900-1		Program comprehension;asynchronicity;full-stack JavaScript	Servers;Context modeling;Reactive power;Visualization;Writing;Concurrent computing	Java;object-oriented programming	asynchronous interaction;full-stack JavaScript;server-side programming;asynchronous events;program understanding;Sahand;program comprehension task		12		48		3 Apr 2017			IEEE	IEEE Conferences
TRIS: A Fast and Accurate Identifiers Splitting and Expansion Algorithm	tris a fast and accurate identifiers splitting and expansion algorithm	10.1109/WCRE.2012.20	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385106	L. Guerrouj; P. Galinier; Y. -G. Guéhéneuc; G. Antoniol; M. Di Penta	DGIGL, École Polytechnique de Montréal, Canada; DGIGL, École Polytechnique de Montréal, Canada; DGIGL, École Polytechnique de Montréal, Canada; DGIGL, École Polytechnique de Montréal, Canada; Department of Engineering, University of Sannio, Italy	2012 19th Working Conference on Reverse Engineering	20 Dec 2012	2012			103	112	Understanding source code identifiers, by identifying words composing them, is a necessary step for many program comprehension, reverse engineering, or redocumentation tasks. To this aim, researchers have proposed several identifier splitting and expansion approaches such as Samurai, TIDIER and more recently GenTest. The ultimate goal of such approaches is to help disambiguating conceptual information encoded in compound (or abbreviated) identifiers. This paper presents TRIS, TRee-based Identifier Splitter, a two-phases approach to split and expand program identifiers. First, TRIS pre-compiles transformed dictionary words into a tree representation, associating a cost to each transformation. In a second phase, it maps the identifier splitting/expansion problem into a minimization problem, i.e., the search of the shortest path (optimal split/expansion) in a weighted graph. We apply TRIS to a sample of 974 identifiers extracted from JHotDraw, 3,085 from Lynx, and to a sample of 489 identifiers extracted from 340 C programs. Also, we compare TRIS with GenTest on a set of 2,663 mixed Java, C and C++ identifiers. We report evidence that TRIS split (and expansion) is more accurate than state-of-the-art approaches and that it is also efficient in terms of computation time.	2375-5369	978-0-7695-4891-3		Identifier Splitting/Expansion;Program Comprehension;Linguistic Analysis;Optimal Path;Weighted Acyclic Graph	Dictionaries;Java;Complexity theory;Buildings;Software;Context	identification;program diagnostics;reverse engineering;source coding;trees (mathematics)	identifier splitting algorithm;identifier expansion algorithm;source code identifiers;program comprehension;reverse engineering;redocumentation tasks;Samurai;TIDIER;GenTest;TRIS;tree-based identifier splitter;two-phase approach;transformed dictionary words;tree representation;minimization problem;shortest path;weighted graph;JHotDraw;Lynx;C programs;C++ identifiers;C identifiers;Java identifiers;state-of-the-art approaches		11		13		20 Dec 2012			IEEE	IEEE Conferences
Supporting task-oriented navigation in IDEs with configurable HeatMaps	supporting taskoriented navigation in ides with configurable heatmaps	10.1109/ICPC.2009.5090052	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090052	D. Rothlisberger; O. Nierstrasz; S. Ducasse; D. Pollet; R. Robbes	Software Composition Group, University of Bern, Switzerland; Software Composition Group, University of Bern, Switzerland; INRIA Lille Nord Europe, France; University of Lille 1, France; University of Lugano, Switzerland	2009 IEEE 17th International Conference on Program Comprehension	19 jun. 2009	2009			253	257	Mainstream IDEs generally rely on the static structure of a software project to support browsing and navigation. We propose HeatMaps, a simple but highly configurable technique to enrich the way an IDE displays the static structure of a software system with additional kinds of information. A HeatMap highlights software artifacts according to various metric values, such as bright red or pale blue, to indicate their potential degree of interest. We present a prototype system that implements HeatMaps, and we describe an initial study that assesses the degree to which different HeatMaps effectively guide developers in navigating software.	1092-8138	978-1-4244-3998-0		software analysis;static analysis;development environments;program comprehension	Navigation;History;Collaborative software;Software systems;Frequency;Object oriented modeling;Displays;Performance analysis;Visualization;Europe	object-oriented methods;software engineering	task-oriented navigation;IDE;configurable HeatMaps;software project;software system;software artifacts		11	1	11		19 jun. 2009			IEEE	IEEE Conferences
Developing visual expertise in software engineering: An eye tracking study	developing visual expertise in software engineering an eye tracking study	10.1109/EDUCON.2016.7474614	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7474614	M. Nivala; F. Hauser; J. Mottok; H. Gruber	Department of Educational Science, University of Regensburg, Regensburg; Ostbayerische Technische Hochschule (OTH), Regensburg Laboratory for Safe and Secure Systems LaS3, Regensburg; Ostbayerische Technische Hochschule (OTH), Regensburg Laboratory for Safe and Secure Systems LaS3, Regensburg; Department of Educational Science, University of Regensburg, Regensburg	2016 IEEE Global Engineering Education Conference (EDUCON)	23 May 2016	2016			613	620	Program comprehension and the ability to find program errors are key skills of software engineering. The aim of this pilot study was to examine the visual processes of novice and advanced programmers in authentic tasks. Fifteen novices and eight advanced programmers were given eight short pieces of code. Their task was to either identify an error or give the output of the code. Eye movements and keyboard activity were recorded. On average, the novices spent more time reading the code than composing the response, whereas the more advanced programmers started composing the response sooner and spent more time on it. In general, the advanced programmers had shorter fixations and saccades. The results suggest that the advanced programmers are quicker to grasp the essence of the code and able to see more details in it. The advanced programmers had shorter fixations and saccade lengths during the second phase which might indicate the process of chunking.	2165-9567	978-1-4673-8633-3		program comprehension;debugging;software engineering;visual expertise;eye tracking	Software;Visualization;Programming profession;Gaze tracking;Debugging;Tracking	software engineering	visual expertise;software engineering;eye tracking study;eye movements;keyboard activity		11		27		23 May 2016			IEEE	IEEE Conferences
Exploiting text mining techniques in the analysis of execution traces	exploiting text mining techniques in the analysis of execution traces	10.1109/ICSM.2011.6080789	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6080789	H. Pirzadeh; A. Hamou-Lhadj; M. Shah	Department of Electrical and Computer Engineering, Concordia University; Department of Electrical and Computer Engineering, Concordia University; Accenture Technology Labs, Chicago, IL, USA	2011 27th IEEE International Conference on Software Maintenance (ICSM)	17 nov. 2011	2011			223	232	The analysis of execution traces can be useful in many software engineering activities including debugging, feature enhancement, performance analysis, and any other task that requires some degree of understanding of the way a system behaves. Traces, however, tend to be considerably large, which often hinders effective analysis of their content. There is a need to investigate ways to help software engineers find and understand important information conveyed in a trace despite the trace being massive. Motivated by the work done in the area of text mining, we propose, in this paper, a trace exploration approach based on examining the trace execution phases. The approach consists of automatically identifying relevant information about the phases as well as the ability to provide an efficient representation of the flow of phases by detecting redundant phases using a cosine similarity metric. We applied our approach to large traces generated from two different systems and were able to quickly understand their content and extract higher level views that characterize the essence of the information conveyed in these traces.	1063-6773	978-1-4577-0664-6		Program Comprehension;Dynamic Analysis;Text mining;Software Maintenance	Levee;Bayesian methods	data flow analysis;data mining;program debugging;software maintenance;software metrics;software performance evaluation;text analysis	exploiting text mining techniques;execution trace analysis;software engineering;software debugging;software feature enhancement;software performance analysis;trace exploration approach;trace execution phases;relevant information automatic identification;redundant phase detection;cosine similarity metric		11		33		17 nov. 2011			IEEE	IEEE Conferences
Heuristic-based part-of-speech tagging of source code identifiers and comments	heuristicbased partofspeech tagging of source code identifiers and comments	10.1109/MUD.2015.7327960	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7327960	R. S. Alsuhaibani; C. D. Newman; M. L. Collard; J. I. Maletic	Kent State University, Kent, OH, US; Computer Science Kent State University, Kent, OH, USA; Computer Science The University of Akron, Akron, Ohio, USA; Computer Science Kent State University, Kent, OH, USA	2015 IEEE 5th Workshop on Mining Unstructured Data (MUD)	12 nov. 2015	2015			1	6	An approach for using heuristics and static program analysis information to markup part-of-speech for program identifiers is presented. It does not use a natural language part-ofspeech tagger for identifiers within the code. A set of heuristics is defined akin to natural language usage of identifiers usage in code. Additionally, method stereotype information, which is automatically derived, is used in the tagging process. The approach is built using the srcML infrastructure and adds part-of-speech information directly into the srcML markup.		978-1-4673-7013-4		Natural Language Processing;part-of-speech tagging;identifier analysis;program comprehension	Speech;Object recognition;Tagging;Natural languages;Conferences;Software;Computational linguistics	natural language processing;program diagnostics;source code (software)	heuristic-based part-of-speech tagging;source code identifier;source code comment;static program analysis information;heuristics program analysis information;stereotype information;srcML markup infrastructure		11		36		12 nov. 2015			IEEE	IEEE Conferences
Architecture recovery and abstraction from the perspective of processes	architecture recovery and abstraction from the perspective of processes	10.1109/WCRE.2005.6	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1566146	Li Qingshan; Chu Hua; Hu Shengming; Chen Ping; Zhao Yun	Software Engineering Institute, Xidian University, Xi'an, China; Software Engineering Institute, Xidian University, Xi'an, China; Software Engineering Institute, Xidian University, Xi'an, China; Software Engineering Institute, Xidian University, Xi'an, China; Software Engineering Institute, Xidian University, Xi'an, China	12th Working Conference on Reverse Engineering (WCRE'05)	3 jan. 2006	2005			10 pp.	66	For the increasing complexity of software systems, the main work of software development, maintenance and evolution has been focused on the comprehension of the existing systems. In order to help users comprehend at all aspects and levels of a target system, it is necessary to reversely recover and abstract its high-level architecture, which can reflect the framework and holistic behavioral features of the software system. This paper deals with the problems of architecture recovery from the perspective of process. An approach of extracting process structure graph (PSG) from a target system is presented based on the features of the relations among processes on UNIX platform. First, the static code fragment of a dynamic process can be recognized, then a mapping algorithm that can identify the correspondence between the dynamic process ID and the static process module is given. On the basis of the algorithm, an incremental construction algorithm of PSG and a slicing algorithm for class structure in a process module are implemented respectively. The experimental results show that the extracted PSG is correct, effective and can reflect the high-level structure of the target system in detail at the process level.	2375-5369	0-7695-2474-5		Reverse Engineering;Program Comprehension;Architecture Recovery;Process;Object Orientation	Software systems;Computer architecture;Software maintenance;Costs;Software engineering;Programming;Reverse engineering;Software design;Modular construction;Computer science	software architecture;software reusability;formal specification;program slicing;software maintenance;software metrics;Unix	architecture recovery;architecture abstraction;software system complexity;software development;software maintenance;software evolution;high-level architecture;process structure graph;UNIX platform;static code fragment;mapping algorithm;dynamic process ID;static process module;incremental construction algorithm;slicing algorithm;class structure;reverse engineering;program comprehension		10		26		3 jan. 2006			IEEE	IEEE Conferences
Execution Trace Abstraction Based on Meta Patterns Usage	execution trace abstraction based on meta patterns usage	10.1109/WCRE.2012.26	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385112	K. Noda; T. Kobayashi; K. Agusa	Graduate School of Information Science, Nagoya University, Nagoya, Aichi, Japan; Graduate School of Information Science, Nagoya University, Nagoya, Aichi, Japan; Graduate School of Information Science, Nagoya University, Nagoya, Aichi, Japan	2012 19th Working Conference on Reverse Engineering	20 Dec 2012	2012			167	176	Visualizing object interactions in an execution trace with a sequence diagram is a promising technique for helping developers to comprehend effectively the behavior of an object-oriented system. However, in most cases, the reverse-engineered sequence diagram, which is automatically generated from an execution trace, contains enormous amounts of information, which causes scalability issues. In this paper, we present a method that abstracts the history of object interactions based on Pree's meta patterns usage. We identify objects that are strongly related to each other by focusing on the relation of template-hook structures which are often used in object-oriented programming. Grouping the strongly correlated objects, we visualize the system's behavior in terms of intergroup interactions with a sequence diagram. The sequence diagram that is generated is helpful for grasping the big picture of the overall behavior of the system, and so is a valuable aid for program comprehension. In this research, we implemented a tool to visualize the history of object interactions based on our proposed method and demonstrated the feasibility of our proposed method. We applied the tool to three kinds of open-source software systems and evaluated the effectiveness of our proposed method in program comprehension tasks.	2375-5369	978-0-7695-4891-3		Reverse Engineering;Meta Patterns;Execution Trace Analysis;Dynamic Analysis;Program Comprehension;Sequence Diagram	Visualization;Java;Abstracts;History;Runtime;Software systems;Aggregates	data visualisation;object-oriented programming;program diagnostics;public domain software	execution trace abstraction;meta patterns usage;object interaction visualization;sequence diagram;object-oriented system;scalability issues;template-hook structures;object-oriented programming;open-source software systems;program comprehension tasks		10		25		20 Dec 2012			IEEE	IEEE Conferences
Immediacy through Interactivity: Online Analysis of Run-time Behavior	immediacy through interactivity online analysis of runtime behavior	10.1109/WCRE.2010.17	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5645442	M. Perscheid; B. Steinert; R. Hirschfeld; F. Geller; M. Haupt	Software Architecture Group, Hasso Plattner Institute, University of Potsdam, Germany; Software Architecture Group, Hasso Plattner Institute, University of Potsdam, Germany; Software Architecture Group, Hasso Plattner Institute, University of Potsdam, Germany; Software Architecture Group, Hasso Plattner Institute, University of Potsdam, Germany; Software Architecture Group, Hasso Plattner Institute, University of Potsdam, Germany	2010 17th Working Conference on Reverse Engineering	29 nov. 2010	2010			77	86	Visualizations of actual run-time data support the comprehension of programs, like examples support the explanation of abstract concepts and principles. Unfortunately, the required run-time analysis is often associated with an inconvenient overhead that renders current tools impractical for frequent use. We propose an interactive approach to collect and present run-time data. An initial shallow analysis provides for immediate access to visualizations of run-time information. As users explore this information, it is incrementally refined on-demand. We present an implementation that realizes our proposed approach and enables developers to instantly explore run-time behavior of selected code entities. We evaluate our interactive approach by measuring time and memory overhead in the context of ten different-sized projects. Our empirical results show that run-time data for an initial overview can be collected in less than 300 milliseconds for 95% of cases.	2375-5369	978-1-4244-8911-4		program comprehension;dynamic analysis;object collaboration;test cases;development environments	Observers;Clocks;Instruments;Visualization;Indexes;Concrete	program diagnostics;program visualisation	online analysis;run-time behavior;program visualizations;run-time data;program comprehension;run-time analysis;interactive approach;initial shallow analysis;run-time information;selected code entity;memory overhead		9	1	31		29 nov. 2010			IEEE	IEEE Conferences
Lexical categories for source code identifiers	lexical categories for source code identifiers	10.1109/SANER.2017.7884624	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7884624	C. D. Newman; R. S. AlSuhaibani; M. L. Collard; J. I. Maletic	Computer Science Kent State University, Kent, OH, USA; Computer Science Kent State University, Kent, OH, USA; Computer Science The University of Akron, Akron, Ohio, USA; Computer Science Kent State University, Kent, OH, USA	2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER)	23 mar. 2017	2017			228	239	A set of lexical categories, analogous to part-of-speech categories for English prose, is defined for source-code identifiers. The lexical category for an identifier is determined from its declaration in the source code, syntactic meaning in the programming language, and static program analysis. Current techniques for assigning lexical categories to identifiers use natural-language part-of-speech taggers. However, these NLP approaches assign lexical tags based on how terms are used in English prose. The approach taken here differs in that it uses only source code to determine the lexical category. The approach assigns a lexical category to each identifier and stores this information along with each declaration. srcML is used as the infrastructure to implement the approach and so the lexical information is stored directly in the srcML markup as an additional XML element for each identifier. These lexical-category annotations can then be later used by tools that automatically generate such things as code summarization or documentation. The approach is applied to 50 open source projects and the soundness of the defined lexical categories evaluated. The evaluation shows that at every level of minimum support tested, categorization is consistent at least 79% of the time with an overall consistency (across all supports) of at least 88%. The categories reveal a correlation between how an identifier is named and how it is declared. This provides a syntax-oriented view (as opposed to English part-of-speech view) of developer intent of identifiers.		978-1-5090-5501-2		Natural Language Processing;part-of-speech tagging;identifier analysis;program comprehension	Tagging;Speech;Context;Syntactics;Natural languages;Computer languages	natural language processing;program diagnostics;public domain software;source code (software);text analysis;XML	source code identifiers;English prose;syntactic meaning;programming language;static program analysis;natural-language part-of-speech taggers;lexical information storage;srcML markup;XML element;lexical category annotations;code summarization;code documentation;syntax-oriented view;NLP;open source projects		9		44		23 mar. 2017			IEEE	IEEE Conferences
VT-Revolution: Interactive Programming Video Tutorial Authoring and Watching System	vtrevolution interactive programming video tutorial authoring and watching system	10.1109/TSE.2018.2802916	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8283605	L. Bao; Z. Xing; X. Xia; D. Lo	College of Computer Science and Technology, Zhejiang University, Hangzhou, Zhejiang, China; Research School of Computer Science, Australian National University, Canberra, ACT, Australia; Faculty of Information Technology, Monash University, Clayton, VIC, Australia; School of Information Systems, Singapore Management University, Singapore	IEEE Transactions on Software Engineering	26 Aug 2019	2019	45	8	823	838	Procedural knowledge describes actions and manipulations that are carried out to complete programming tasks. An effective way to document procedural knowledge is programming video tutorials. Unlike text-based software artifacts and tutorials that can be effectively searched and linked using information retrieval techniques, the streaming nature of programming videos limits the ways to explore the captured workflows and interact with files, code and program output in the videos. Existing solutions to adding interactive workflow and elements to programming videos have a dilemma between the level of desired interaction and the efforts required for authoring tutorials. In this work, we tackle this dilemma by designing and building a programming video tutorial authoring system that leverages operating system level instrumentation to log workflow history while tutorial authors are creating programming videos, and the corresponding tutorial watching system that enhances the learning experience of video tutorials by providing programming-specific workflow history and timeline-based browsing interactions. Our tutorial authoring system does not incur any additional burden on tutorial authors to make programming videos interactive. Given a programming video accompanied by synchronously-logged workflow history, our tutorial watching system allows tutorial watchers to freely explore the captured workflows and interact with files, code and program output in the tutorial. We conduct a user study of 135 developers to evaluate the design and effectiveness of our system in helping developers learn programming knowledge in video tutorials.	1939-3520		National Natural Science Foundation of China(grant numbers:61602403,61572426); 	Program comprehension;human-computer interaction;workflow	Tutorials;Programming;Streaming media;Tools;Task analysis;History;Software	authoring systems;computer aided instruction;computer science education;interactive systems;multimedia systems;programming	interactive programming video tutorial authoring;procedural knowledge;video tutorials;text-based software artifacts;authoring tutorials;programming video tutorial authoring system;programming-specific workflow history;programming tasks;tutorial watching system;operating system level instrumentation		9		43	IEEE	6 Feb 2018			IEEE	IEEE Journals
Identifying Code Smells with Collaborative Practices: A Controlled Experiment	identifying code smells with collaborative practices a controlled experiment	10.1109/SBCARS.2016.18	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7789840	R. Oliveira; B. Estácio; A. Garcia; S. Marczak; R. Prikladnicki; M. Kalinowski; C. Lucena	PUC-Rio, Rio de Janeiro, Brazil; PUCRS, Porto Alegre, Brazil; PUC-Rio, Rio de Janeiro, Brazil; PUCRS, Porto Alegre, Brazil; PUCRS, Porto Alegre, Brazil; UFF, Niterói, Brazil; PUC-Rio, Rio de Janeiro, Brazil	2016 X Brazilian Symposium on Software Components, Architectures and Reuse (SBCARS)	19 Dec 2016	2016			61	70	Code smells are often considered as key indicators of software quality degradation. If code smells are not systematically removed from a program, its continuous degradation may lead to either major maintenance effort or the complete redesign of the system. For several reasons, software developers introduce smells in their code as soon as they start to learn programming. If novice developers are ought to become either proficient programmers or skilled code reviewers, they should be early prepared to effectively identify code smells in existing programs. However, effective identification of code smells is often not a non-trivial task in particular to a novice developer working in isolation. Thus, the use of collaborative practices may have the potential to support developers in improving their effectiveness on this task at their early stages of their careers. These practices offer the opportunity for two or more developers analyzing the source code together and collaboratively reason about potential smells prevailing on it. Pair Programming (PP) and Coding Dojo Randori (CDR) are two increasingly adopted practices for improving the effectiveness of developers with limited or no knowledge in software engineering tasks, including code review tasks. However, there is no broad understanding about the impact of these collaborative practices on the effectiveness of code smell identification. This paper presents a controlled experiment involving 28 novice developers, aimed at assessing the effectiveness of collaborative practices in the identification of code smells. We compared PP and CDR with solo programming in order to better distinguish their impact on the effective identification of code smells. Our study is also the first in the literature to observe how novice developers work individually and together to identify smells. Our results suggest that collaborative practices contribute to the effectiveness on the identification of a wide range of code smells. Our findings can also be used in practice to guide educators, researchers or teams on improving detection and training on code smell identification.		978-1-5090-5086-4		Code Smells;Collaborative Practices;Controlled Experiment;Program Comprehension;Software Degradation	Collaboration;Software;Programming profession;Encoding;Degradation;Software engineering	software maintenance;software quality;software reviews;source code (software)	code smell identification;software quality degradation;software maintenance;source code;pair programming;Coding Dojo Randori;CDR;PP;software engineering tasks;code review tasks;solo programming		9		23		19 Dec 2016			IEEE	IEEE Conferences
Exploiting Runtime Information in the IDE	exploiting runtime information in the ide	10.1109/ICPC.2008.32	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556118	D. Röthlisberger; O. Greevy; O. Nierstrasz	Software Composition Group, University of Bern, Switzerland; Software Composition Group, University of Bern, Switzerland; Software Composition Group, University of Bern, Switzerland	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			63	72	Developers rely on the mechanisms provided by their IDE to browse and navigate a large software system. These mechanisms are usually based purely on a system's static source code. The static perspective, however, is not enough to understand an object-oriented program's behavior, in particular if implemented in a dynamic language. We propose to enhance IDEs with a program's runtime information (e.g. message sends and type information) to support program comprehension through precise navigation and informative browsing. To precisely specify the type and amount of runtime data to gather about a system under development, dynamically and on demand, we adopt a technique known as partial behavioral reflection. We implemented navigation and browsing enhancements to an IDE that exploit this runtime information in a prototype called Hermion. We present preliminary validation of our experimental enhanced IDE by asking developers to assess its usefulness to understand an unfamiliar software system.	1092-8138	978-0-7695-3176-2		dynamic analysis;development environments;partial behavioral reflection;reverse engineering;program comprehension	Runtime;Navigation;Reflection;Software systems;Prototypes;Reverse engineering;Switches;Software prototyping;Scattering;Software tools	information retrieval;software engineering;source coding	runtime information;software system;static source code;dynamic language;information navigation;information browsing;partial behavioral reflection		9	2	27		2 jul. 2008			IEEE	IEEE Conferences
Modeling changeset topics for feature location	modeling changeset topics for feature location	10.1109/ICSM.2015.7332453	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7332453	C. S. Corley; K. L. Kashuda; N. A. Kraft	The University of Alabama, Tuscaloosa, AL, USA; The University of Alabama, Tuscaloosa, AL, USA; ABB Corporate Research, Raleigh, NC, USA	2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)	23 nov. 2015	2015			71	80	Feature location is a program comprehension activity in which a developer inspects source code to locate the classes or methods that implement a feature of interest. Many feature location techniques (FLTs) are based on text retrieval models, and in such FLTs it is typical for the models to be trained on source code snapshots. However, source code evolution leads to model obsolescence and thus to the need to retrain the model from the latest snapshot. In this paper, we introduce a topic-modeling-based FLT in which the model is built incrementally from source code history. By training an online learning algorithm using changesets, the FLT maintains an up-to-date model without incurring the non-trivial computational cost associated with retraining traditional FLTs. Overall, we studied over 600 defects and features from 4 open-source Java projects. We also present a historical simulation that demonstrates how the FLT performs as a project evolves. Our results indicate that the accuracy of a changeset-based FLT is similar to that of a snapshot-based FLT, but without the retraining costs.		978-1-4673-7532-0		program comprehension;feature location;topic modeling;mining software repositories;changesets	Feature extraction;Standards;Software;Indexes;Accuracy;Search engines;Computational modeling	Java;public domain software;source code (software);text analysis	modeling changeset topic;feature location;program comprehension activity;source code;feature location technique;text retrieval model;source code snapshot;source code evolution;topic-modeling-based FLT;online learning algorithm;open-source Java project		9		42		23 nov. 2015			IEEE	IEEE Conferences
AutoFocus: Interpreting Attention-Based Neural Networks by Code Perturbation	autofocus interpreting attentionbased neural networks by code perturbation	10.1109/ASE.2019.00014	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952269	N. D. Q. Bui; Y. Yu; L. Jiang	School of Information Systems, Singapore Management University, Singapore, Singapore; School of Computing & Communications, The Open University, Milton Keynes, UK; School of Information Systems, Singapore Management University	2019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)	9 jan. 2020	2019			38	41	Despite being adopted in software engineering tasks, deep neural networks are treated mostly as a black box due to the difficulty in interpreting how the networks infer the outputs from the inputs. To address this problem, we propose AutoFocus, an automated approach for rating and visualizing the importance of input elements based on their effects on the outputs of the networks. The approach is built on our hypotheses that (1) attention mechanisms incorporated into neural networks can generate discriminative scores for various input elements and (2) the discriminative scores reflect the effects of input elements on the outputs of the networks. This paper verifies the hypotheses by applying AutoFocus on the task of algorithm classification (i.e., given a program source code as input, determine the algorithm implemented by the program). AutoFocus identifies and perturbs code elements in a program systematically, and quantifies the effects of the perturbed elements on the network's classification results. Based on evaluation on more than 1000 programs for 10 different sorting algorithms, we observe that the attention scores are highly correlated to the effects of the perturbed code elements. Such a correlation provides a strong basis for the uses of attention scores to interpret the relations between code elements and the algorithm classification results of a neural network, and we believe that visualizing code elements in an input program ranked according to their attention scores can facilitate faster program comprehension with reduced code.	2643-1572	978-1-7281-2508-4		attention mechanisms, neural networks, algorithm classification, interpretability, explainability, code perturbation, program comprehension	Visualization;Biological neural networks;Color;Perturbation methods;Task analysis;Feature extraction	learning (artificial intelligence);neural nets;pattern classification;program verification;program visualisation;sorting;source code (software)	AutoFocus;attention-based neural networks;code perturbation;software engineering tasks;deep neural networks;automated approach;input elements;discriminative scores;program source code;perturbed elements;sorting algorithms;attention scores;perturbed code elements;algorithm classification results;input program;reduced code;code element visualization;program comprehension		9		17		9 jan. 2020			IEEE	IEEE Conferences
Extracting Candidates of Microservices from Monolithic Application Code	extracting candidates of microservices from monolithic application code	10.1109/APSEC.2018.00072	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8719439	M. Kamimura; K. Yano; T. Hatano; A. Matsuo	Software Laboratories, Fujitsu Laboratories Ltd., Kawasaki, Japan; Software Laboratories, Fujitsu Laboratories Ltd., Kawasaki, Japan; Software Laboratories, Fujitsu Laboratories Ltd., Kawasaki, Japan; Software Laboratories, Fujitsu Laboratories Ltd., Kawasaki, Japan	2018 25th Asia-Pacific Software Engineering Conference (APSEC)	23 May 2019	2018			571	580	Technology that facilitates rapid modification of existing business applications is necessary and it has been reported that making the system more adaptable to change is the strongest driver for legacy system modernization. There has been considerable interest in service-oriented architectures or microservices which enables the system to be quickly changed. Refactoring and, in particular, re-modularization operations can be performed to repair the design of a software system. Various approaches have been proposed to support developers during the re-modularization of a software system. The common problem in these efforts is to identify from monolithic applications the candidates of microservices, i.e., the programs or data that can be turned into cohesive, standalone services; this is a tedious manual effort that requires analyzing many dimensions of software architecture views and often heavily relies on the experience and expertise of the expert performing the extraction. To solve this problem, we developed a method that identifies the candidates of microservices from the source code by using software clustering algorithm SArF with the relation of "program groups" and "data" which we defined. Our method also visualizes the extracted candidates to show the relationship between extracted candidates and the whole structure. The candidates and visualization help the developers to capture the overview of the whole system and facilitated a dialogue with customers. We report two case studies to evaluate our results in which we applied our method to an open source application and an industrial application with our results reviewed by developers.	2640-0715	978-1-7281-1970-0		microservice architecture, software clustering, partition, visualization, program comprehension, modernization	Software;Business;Data mining;Data visualization;Clustering algorithms;Computer architecture;Manuals	data visualisation;pattern clustering;service-oriented architecture;software maintenance	monolithic application code;business applications;legacy system modernization;service-oriented architectures;software system;monolithic applications;software architecture views;source code;open source application;SArF software clustering algorithm;remodularization operations		9		27		23 May 2019			IEEE	IEEE Conferences
Empirical Evaluation of Diagrams of the Run-time Structure for Coding Tasks	empirical evaluation of diagrams of the runtime structure for coding tasks	10.1109/WCRE.2012.46	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385132	N. Ammar; M. Abi-Antoun	Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA	2012 19th Working Conference on Reverse Engineering	20 Dec 2012	2012			367	376	With object-oriented design, it is at least as important-possibly more important-to understand the runtime structure, in terms of objects and their relations, as to understand the code structure dealing with source files, classes and packages. Today, many tools and diagrams help developers understand the code structure. Diagrams of the runtime structure, however, are much less mature. One diagram of the run-time structure is a statically extracted, global, hierarchical Ownership Object Graph (OOG). The OOG conveys architectural abstraction by ownership hierarchy by showing architecturally significant objects near the top of the hierarchy and data structures further down. In an OOG, objects are also organized into named, conceptual groups called domains. We evaluate, in a controlled experiment, whether an OOG, as a diagram of the run-time structure, improves comprehension by giving developers the ability to distinguish the role that an object plays, not only by type, but also by named groups (domains) or by position in the run-time structure (ownership). We observed 10 participants, for 3 hours each, perform three feature implementation tasks on a framework application. Our results indicate that, on average, the OOG had a positive effect of varying extents on comprehension that reduced the time spent by 22%-60% and irrelevant code explored by 10%-60%. The difference was significant (p <; 0.05) for two of the tasks.	2375-5369	978-0-7695-4891-3		controlled experiment;program comprehension	Unified modeling language;Games;Navigation;Object oriented modeling;Java;Search problems;Atmospheric measurements	data structures;graph theory;object-oriented methods;reverse engineering;software maintenance	diagram empirical evaluation;run-time structure;coding tasks;object-oriented design;source files;software classes;software packages;statically extracted-global-hierarchical ownership object graph;OOG;architectural abstraction;ownership hierarchy;data structures;conceptual groups;domains;program comprehension		9		35		20 Dec 2012			IEEE	IEEE Conferences
Mining Logical Clones in Software: Revealing High-Level Business and Programming Rules	mining logical clones in software revealing highlevel business and programming rules	10.1109/ICSM.2013.15	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6676875	W. Qian; X. Peng; Z. Xing; S. Jarzabek; W. Zhao	Software School, Fudan University, Shanghai, China; Software School, Fudan University, Shanghai, China; School of Computer Engineering, Nanyang Technological University, Singapore; School of Computing, National University of Singapore, Singapore; Software School, Fudan University, Shanghai, China	2013 IEEE International Conference on Software Maintenance	2 Dec 2013	2013			40	49	Software systems contain many implicit application-specific business and programming rules. These rules represent high-level logical structures and processes for application-specific business and programming concerns. They are crucial for program understanding, consistent evolution, and systematic reuse. However, existing pattern mining and analysis approaches cannot effectively mine such application-specific rules. In this paper, we present an approach for mining logical clones in software that reveal high-level business and programming rules. Our approach extracts a program model from source code, and enriches the program model with code clone information, functional clusters (i.e., a set of methods dealing with similar topics or concerns), and abstract entity classes (representing sibling entity classes). It then analyzes the enriched program model for mining recurring logical structures as logical clones. We have implemented our approach in a tool called MiLoCo (Mining Logical Clone) and conducted a case study with an open-source ERP and CRM software. Our results show that MiLoCo can identify meaningful and useful logical clones for program understanding, evolution and reuse.	1063-6773	978-0-7695-4981-1		logical clone;semantic clustering;program comprehension;evolution;reuse	Cloning;Business;Clustering algorithms;Data mining;Programming;Abstracts;Semantics	commerce;customer relationship management;data mining;enterprise resource planning;public domain software;software reusability	program reuse;CRM software;open-source ERP software;MiLoCo;pattern mining;application-specific business;software systems;programming rules;high-level business;logical clones mining		9		23		2 Dec 2013			IEEE	IEEE Conferences
Towards Prioritizing Documentation Effort	towards prioritizing documentation effort	10.1109/TSE.2017.2716950	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7953505	P. W. McBurney; S. Jiang; M. Kessentini; N. A. Kraft; A. Armaly; M. W. Mkaouer; C. McMillan	Department of Computer and Information Science, University of Pennsylvania, Philadelphia, PA; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer and Information Science, University of Michigan-Dearborn, Dearborn, MI; ABB Corporate Research, Raleigh, NC; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer and Information Science, University of Michigan-Dearborn, Dearborn, MI; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN	IEEE Transactions on Software Engineering	17 Sep 2018	2018	44	9	897	913	Programmers need documentation to comprehend software, but they often lack the time to write it. Thus, programmers must prioritize their documentation effort to ensure that sections of code important to program comprehension are thoroughly explained. In this paper, we explore the possibility of automatically prioritizing documentation effort. We performed two user studies to evaluate the effectiveness of static source code attributes and textual analysis of source code towards prioritizing documentation effort. The first study used open-source API Libraries while the second study was conducted using closed-source industrial software from ABB. Our findings suggest that static source code attributes are poor predictors of documentation effort priority, whereas textual analysis of source code consistently performed well as a predictor of documentation effort priority.	1939-3520		National Science Foundation Graduate Research Fellowship Program(grant numbers:DGE-1313583); National Science Foundation(grant numbers:CCF-1452959,CNS-1510329); 	Code documentation;program comprehension;software maintenance	Documentation;Libraries;Java;Gold;Programming;Software;Neural networks	application program interfaces;program diagnostics;public domain software;software maintenance	prioritizing documentation effort;static source code attributes;open-source API Libraries;closed-source industrial software;documentation effort priority		9		78	IEEE	19 jun. 2017			IEEE	IEEE Journals
Reengineering embedded automotive software	reengineering embedded automotive software	10.1109/ICSM.2012.6405312	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6405312	A. Thums; J. Quante	Corporate Sector Research and Advance Engineering Software, Stuttgart, Germany; Corporate Sector Research and Advance Engineering Software, Stuttgart, Germany	2012 28th IEEE International Conference on Software Maintenance (ICSM)	10 jan. 2013	2012			493	502	The fact that software ages holds for embedded automotive software as well as for any other kind of software. In comparison to IT software, the automotive domain has to deal with different kinds of requirements, such as real time properties, feedback control, and constrained resources. Therefore, used programming languages are C - to meet resource constraints - and data flow oriented graphical languages - to meet the used engineering method and notation of feedback control engineers. This makes the software quite different from what the software maintenance and reengineering community is usually working on, and their results are seldom directly applicable. In this paper, we describe results of a Bosch-internal research project that focused on the adaption of existing reengineering techniques and methods to embedded automotive software development. The goal was to make software maintenance more efficient by a) preventing software ageing and b) supporting program comprehension. Our approach was to make existing reengineering techniques usable for series development in an effective and efficient way. The result is a set of reengineering tools and practices that are specialized for the needs of the automotive domain and usable in practice.	1063-6773	978-1-4673-2312-3		Embedded software;reengineering;maintainability;program comprehension;industrial application	Automotive engineering;Indexes;Measurement;Complexity theory;Software maintenance;Data models	automotive engineering;C language;mechanical engineering computing;parallel languages;software maintenance;visual languages	embedded automotive software reengineering;real time properties;feedback control;constrained resources;C programming language;resource constraints;flow oriented graphical languages;software maintenance community;Bosch-internal research project;embedded automotive software development;software ageing prevention;program comprehension		9		20		10 jan. 2013			IEEE	IEEE Conferences
Measuring the Cognitive Load of Software Developers: A Systematic Mapping Study	measuring the cognitive load of software developers a systematic mapping study	10.1109/ICPC.2019.00018	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813301	L. Gonçales; K. Farias; B. da Silva; J. Fessler	University of Vale do Rio dos Sinos, São Leopoldo, Brazil; University of Vale do Rio dos Sinos, São Leopoldo, Brazil; California Polytechnic State University, San Luis Obispo, United States; California Polytechnic State University, San Luis Obispo, United States	2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC)	29 Aug 2019	2019			42	52	Context: In recent years, several studies explored different facets of the developers' cognitive load while executing tasks related to software engineering. Researchers have proposed and assessed different ways to measure developers' cognitive load at work and some studies have evaluated the interplay between developers' cognitive load and other attributes such as productivity and software quality. Problem: However, the body of knowledge about developers' cognitive load measurement is still dispersed. That hinders the effective use of developers' cognitive load measurements by industry practitioners and makes it difficult for researchers to build new scientific knowledge upon existing results. Objective: This work aims to pinpoint gaps providing a classification and a thematic analysis of studies on the measurement of cognitive load in the context of software engineering. Method: We carried out a Systematic Mapping Study (SMS) based on well-established guidelines to investigate nine research questions. In total, 33 articles (out of 2,612) were selected from 11 search engines after a careful filtering process. Results: The main findings are that (1) 55% of the studies adopted electroencephalogram (EEG) technology for monitoring the cognitive load; (2) 51% of the studies applied machine-learning classification algorithms for predicting cognitive load; and (3) 48% of the studies measured cognitive load in the context of programming tasks. Moreover, a taxonomy was derived from the answers of research questions. Conclusion: This SMS highlighted that the precision of machine learning techniques is low for realistic scenarios, despite the combination of a set of features related to developers' cognitive load used on these techniques. Thus, this gap makes the effective integration of the measure of developers' cognitive load in industry still a relevant challenge.	2643-7171	978-1-7281-1519-1		Cognitive Load;Software Engineering;Program Comprehension;Systematic Mapping Study		cognition;electroencephalography;learning (artificial intelligence);medical signal processing;search engines;software quality	Systematic Mapping Study;software quality;electroencephalogram technology;programming tasks;machine learning techniques;thematic analysis;search engines;filtering process;software engineering;software developers;cognitive load		9		76		29 Aug 2019			IEEE	IEEE Conferences
CrowdSummarizer: Automated Generation of Code Summaries for Java Programs through Crowdsourcing	crowdsummarizer automated generation of code summaries for java programs through crowdsourcing	10.1109/MS.2017.45	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888409	S. Badihi; A. Heydarnoori	Sharif University of Technology; Sharif University of Technology	IEEE Software	28 mar. 2017	2017	34	2	71	80	To perform software maintenance, developers must have a relatively good understanding of the program's source code, which is often written by other developers. Code summaries, which describe a program's entities (for example, its methods), help developers better comprehend code more quickly. However, generating code summaries can be challenging. To mitigate this problem, CrowdSummarizer exploits crowdsourcing, gamification, and natural-language processing to automatically generate high-level summaries of Java program methods. Researchers have implemented it as an Eclipse plug-in together with a Web-based code summarization game that can be played by the crowd. Two empirical studies determined that CrowdSummarizer generates quality results. This article is part of a special issue on Crowdsourcing for Software Engineering.	1937-4194			CrowdSummarizer;crowdsourcing;program comprehension;source code summarization;gamification;software engineering;software development	Software reliability;Crowdsourcing;Java;Software maintenance;Software engineering;Software engineering;Software measurement	computer games;crowdsourcing;Java;natural language processing;software maintenance;source code (software)	Eclipse plug-in;software engineering;Web-based code summarization game;high-level summaries;Java program;gamification;natural-language processing;program source code;software maintenance;code summary automated generation;CrowdSummarizer		9		14		28 mar. 2017			IEEE	IEEE Magazines
A Survey of the Forms of Java Reference Names	a survey of the forms of java reference names	10.1109/ICPC.2015.30	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181448	S. Butler; M. Wermelinger; Y. Yu	Computing and Communications Department, The Open University Milton Keynes MK7 6AA, United Kingdom; Computing and Communications Department, The Open University Milton Keynes MK7 6AA, United Kingdom; Computing and Communications Department, The Open University Milton Keynes MK7 6AA, United Kingdom	2015 IEEE 23rd International Conference on Program Comprehension	7 Sep 2015	2015			196	206	The readability of identifiers is a major factor of program comprehension and an aim of naming convention guidelines. Due to their semantic content, identifiers are also used in feature and bug location, among other software maintenance tasks. Looking at how names are used in practice may lead to insights on potential problems for comprehension and for programming support tools that process identifiers. Class and method names are already well represented in the literature. This paper presents an investigation of Java field, formal argument and local variable names, which we collectively call reference names. These names cannot be ignored because they constitute over half the unique names and almost 70% of the name declarations in the corpus investigated. We analysed the forms of 3.5 million reference name declarations in 60 well known Java projects, examining the phrasal structure of names composed of known words and acronyms. The structures found in practice were evaluated against those given in the literature. The use of unknown abbreviations and words, which may pose a problem for program comprehension, was also identified. Based on our observations of the rich diversity of reference names, we suggest issues to be taken into account for future academic research and for improving tools that rely on names as sources of information.	1092-8138	978-1-4673-8159-8		identifier names;naming conventions;program comprehension;natural language processing;empirical study	Java;Ciphers;Vocabulary;Dictionaries;Guidelines;Tagging	Java;software maintenance	Java reference names;program comprehension;software maintenance tasks;phrasal structure		9		25		7 Sep 2015			IEEE	IEEE Conferences
Towards tool support for analyzing legacy systems in technical domains	towards tool support for analyzing legacy systems in technical domains	10.1109/CSMR-WCRE.2014.6747197	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6747197	C. Klammer; J. Pichler	Software Analytics and Evolution, Software Competence Center Hagenberg GmbH, Hagenberg, Austria; Software Analytics and Evolution, Software Competence Center Hagenberg GmbH, Hagenberg, Austria	2014 Software Evolution Week - IEEE Conference on Software Maintenance, Reengineering, and Reverse Engineering (CSMR-WCRE)	27 Feb 2014	2014			371	374	Software in technical domains contains extensive and complex computations in a highly-optimized and unstructured way. Such software systems developed and maintained over years are prone to become legacy code based on old technology and without accurate documentation. We have conducted several industrial projects to reengineer and re-document legacy systems in electrical engineering and steel making domains by means of self-provided techniques and tools. Based on this experience, we derived requirements for a toolkit to analyze legacy code in technical domains and developed a corresponding toolkit including feature location and static analysis on a multi-language level. We have applied our approach and toolkit for software systems implemented in the C++, Fortran, and PL/SQL programming languages and illustrate main benefits of our approach from these experiences.		978-1-4799-3752-3		Software analytics;legacy code;reverse engineering;source code analysis;feature location;program comprehension	Software systems;Algorithms;Reverse engineering;Computer languages;Syntactics;Aging	C++ language;FORTRAN;program diagnostics;programming languages;reverse engineering;software maintenance;source code (software);SQL;system documentation	tool support;technical domains;software systems;legacy code;documentation;industrial projects;redocument legacy systems;electrical engineering;steel making domains;self-provided techniques;feature location;static analysis;multilanguage level;C++;Fortran;PL/SQL programming languages		8		11		27 Feb 2014			IEEE	IEEE Conferences
Object Oriented Software Clustering Based on Community Structure	object oriented software clustering based on community structure	10.1109/APSEC.2011.33	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6130702	U. Erdemir; U. Tekin; F. Buzluca	Center of Research for Advanced Technologies of Informatics & Information Security, Kocaeli, Turkey; Center of Research for Advanced Technologies of Informatics & Information Security, Kocaeli, Turkey; Computer Engineering Department, Istanbul Technical University, Istanbul, Turkey	2011 18th Asia-Pacific Software Engineering Conference	16 jan. 2012	2011			315	321	Software comprehension plays a critical role in software maintenance. Understanding a software system is not an easy task because in most cases documentation of software design is outdated, incomplete or absent. Therefore support of tools and algorithms are necessary for software developers to understand software quicker and easier. Clustering algorithms have been widely used for software architecture recovery. Their performance depends not only on the algorithm itself but also on the nature of the software system. For example, an algorithm that is successful for a procedural program or a small software system or might be unsuccessful for a large system developed in object-oriented paradigm. In this paper, we propose the adaption of the fast community detection algorithm for object-oriented software clustering and evaluate its performance with other clustering algorithms in the literature. It is an agglomerative hierarchical clustering algorithm that has been introduced to find communities in networks. The algorithm can operate on directed weighted graphs and it has a considerable speed advantage over other algorithms. Experimental results show that the algorithm also performs well for clustering object-oriented systems.	1530-1362	978-1-4577-2199-1		Software Architecture Recovery;Software Clustering;Reverse Engineering;Program Comprehension	Clustering algorithms;Software algorithms;Communities;Software systems;Partitioning algorithms;Algorithm design and analysis	directed graphs;object-oriented methods;pattern clustering;software architecture;software maintenance	object oriented software clustering;community structure;software maintenance;software design;software developers;software architecture recovery;procedural program;software system;fast community detection algorithm;agglomerative hierarchical clustering algorithm;directed weighted graphs		8		31		16 jan. 2012			IEEE	IEEE Conferences
A Toolkit for Visualizing the Runtime Behavior of TinyOS Applications	a toolkit for visualizing the runtime behavior of tinyos applications	10.1109/ICPC.2008.22	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556116	A. R. Dalton; J. O. Hallstrom	School of Computing, Clemson University, USA; School of Computing, Clemson University, USA	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			43	52	TinyOS has proven to be an effective platform for developing reactive embedded network applications. However, the platform's lean programming model and power-efficient operation come at a price: TinyOS applications are notoriously difficult to construct and debug. The development difficulties stem, in large part, from a programming model founded on events and deferred execution. In short, the model introduces non-determinism in the execution ordering of primitive actions (i.e., commands, events, and tasks). The resulting set of possible execution sequences is typically large, and can swamp developers' unaided intellectual ability to reason about program behavior. In this paper, we present a platform-neutral visualization toolkit for TinyOS 2.0 to aid in program comprehension. The goal is to assist developers in reasoning about the computation forest underlying a system under test, and the particular branches chosen during each run. The toolkit design includes (i) a full-featured static analysis and instrumentation library, (ii) a selection-based probe insertion system, (iii) a lightweight event recording service, (iv) a trace extraction and reconstruction tool, and (v) two visualization front-ends. We demonstrate the utility of the toolkit using standard system examples, and present an analysis of the toolkit's resource usage and performance characteristics.	1092-8138	978-0-7695-3176-2		sensor networks;embedded networks;TinyOS;nesC;program visualization;program comprehension;program analysis;program tracing	Visualization;Runtime;Power system modeling;Computer networks;Hardware;Embedded computing;System testing;Instruments;Libraries;Probes	operating systems (computers);program debugging;program diagnostics;program visualisation	runtime behavior;TinyOS;reactive embedded network applications;lean programming model;program debugging;execution sequences;platform-neutral visualization toolkit;system under test;static analysis;instrumentation library;probe insertion system		8	1	21		2 jul. 2008			IEEE	IEEE Conferences
Extracting Interaction-Based Stateful Behavior in Rich Internet Applications	extracting interactionbased stateful behavior in rich internet applications	10.1109/CSMR.2012.53	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6178915	Y. Maezawa; H. Washizaki; S. Honiden	University of Tokyo, Tokyo, Japan; Waseda University, Tokyo, Japan; National Institute of Informatics, University of Tokyo, Tokyo, Japan	2012 16th European Conference on Software Maintenance and Reengineering	5 Apr 2012	2012			423	428	Although asynchronous technologies such as Ajax make Rich Internet Applications (RIAs) responsive, they can result in unexpected behavior due to nondeterministic client-side processing and asynchronous communication. One difficulty in understanding such erroneous behavior lies in the unpredictable contexts of the running system. Dynamic behavior analysis techniques do not help to verify the correctness of certain "blind spots" in the execution path. In this work, we present a static approach for extracting all possible state transitions described in source code from the RIAs. Our approach is based on the assumption that user, server and self interactions with the RIAs can change the states of the application. Our method consists of three steps: (i) annotating interactions and extracting their controls in source code (ii) abstracting a call graph to extract relationships among the interactions and (iii) refining the relationships with interaction controls By extracting the state machines of test scenarios of the correct and wrong behavior, it can help developers to pinpoint the statements in the source code that lead to the erroneous behavior. Our approach has been evaluated against a few experimental cases and we conclude that it can extract comprehensible state machines in a reasonable time.	1534-5351	978-0-7695-4666-7		Rich Internet Applications;Ajax;Reverse Engineering;Program Comprehension	Servers;Internet;Web pages;Reactive power;Libraries;HTML;Context	client-server systems;finite state machines;Internet;Java;program diagnostics;reverse engineering;source coding;user interfaces;XML	interaction-based stateful behavior extraction;rich Internet application;nondeterministic client side processing;asynchronous communication;dynamic behavior analysis;static approach;state transition extraction;source code;RIA;Ajax;call graph abstraction;interaction controls;state machines;erroneous behavior		8		14		5 Apr 2012			IEEE	IEEE Conferences
Using Topic Models to Support Software Maintenance	using topic models to support software maintenance	10.1109/CSMR.2012.51	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6178887	S. Grant; J. R. Cordy; D. B. Skillicorn	School of Computing, Queen's University, Kingston, ONT, Canada; School of Computing, Queen's University, Kingston, ONT, Canada; School of Computing, Queen's University, Kingston, ONT, Canada	2012 16th European Conference on Software Maintenance and Reengineering	5 Apr 2012	2012			403	408	Our recent research has shown that the latent information found by commonly used topic models generally relates to the development history of a software system. While it is not always possible to associate these latent topics with human-oriented concepts, it is demonstrable that they identify historical maintenance relationships in source code. Specifically, when a developer makes a change to a software project, it is common for a significant part of that change to relate to a single latent topic. A significant conclusion can be drawn from this: latent topic models identify co-maintenance relationships with no supervision, and therefore topic models can be used to support the maintenance phase of software development.	1534-5351	978-0-7695-4666-7		software maintenance;topic models;program comprehension	History;Web services;Software systems;Maintenance engineering;Software maintenance;Visualization	project management;software maintenance	latent topic models;software maintenance;software system;historical maintenance relationship identification;source code;software project;co-maintenance relationship identification;software development		8		22		5 Apr 2012			IEEE	IEEE Conferences
Understanding Software Architectures by Visualization--An Experiment with Graphical Elements	understanding software architectures by visualizationan experiment with graphical elements	10.1109/WCRE.2006.54	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4023975	J. Knodel; D. Muthig; M. Naab	Fraunhofer Institute of Experimental Software Engineering (IESE), Kaiserslautern, Germany; Fraunhofer Institute of Experimental Software Engineering (IESE), Kaiserslautern, Germany; Fraunhofer Institute of Experimental Software Engineering (IESE), Kaiserslautern, Germany	2006 13th Working Conference on Reverse Engineering	11 Dec 2006	2006			39	50	The evolution and maintenance of large-scale software systems requires first an understanding of its architecture before delving into lower level details. Tools facilitating the architecture comprehension tasks by visualization provide different sets of graphical elements. We conducted a controlled experiment that exemplifies the critical role of such graphical elements when aiming at understanding the architecture. The results show that a different configuration of graphical elements influences program comprehension tasks significantly. In particular, a gain of effectiveness by 63% in basic architectural analysis tasks was achieved simply by choosing a different set of graphical elements. Based on the results we claim that significant effort should be spent on the configuration of architecture visualization tools	2375-5369	0-7695-2719-1		architecture;experiment;graphical elements;program comprehension;SAVE;visualization.	Software architecture;Visualization;Computer architecture;Large-scale systems;Software systems;Software engineering;Software maintenance;Performance analysis;Monitoring;Information retrieval	program visualisation;reverse engineering;software architecture;software maintenance	software architectures;software evolution;software maintenance;graphical element configuration;program comprehension;architecture visualization tool		8		26		11 Dec 2006			IEEE	IEEE Conferences
Can We Predict Dependencies Using Domain information?	can we predict dependencies using domain information	10.1109/WCRE.2011.17	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079775	A. Aryani; F. Perin; M. Lungu; A. N. Mahmood; O. Nierstrasz	RMIT University, Australia; Software Composition Group, University of Bern, Switzerland; Software Composition Group, University of Bern, Switzerland; RMIT University, Australia; Software Composition Group, University of Bern, Switzerland	2011 18th Working Conference on Reverse Engineering	17 nov. 2011	2011			55	64	Software dependencies play a vital role in program comprehension, change impact analysis and other software maintenance activities. Traditionally, these activities are supported by source code analysis, however, the source code is sometimes inaccessible, and not all stakeholders have adequate knowledge to perform such analysis. For example, non-technical domain experts and consultants raise most maintenance requests, however, they cannot predict the cost and impact of the requested changes without the support of the developers. We propose a novel approach to predict software dependencies by exploiting coupling present in domain-level information. Our approach is independent of the software implementation, hence, it can be used to evaluate architectural dependencies without access to the source code or the database. We evaluate our approach with a case study on a large-scale enterprise system, in which we demonstrate how up to 68% of the source code dependencies and 77% of the database dependencies are predicted solely based on domain information.	2375-5369	978-1-4577-1948-6		Domain-based coupling;Architectural Dependencies;Database Dependencies;Source Code Analysis;Program Comprehension	Couplings;Software;Databases;Mathematical model;Equations;Object oriented modeling;Java	software maintenance	domain-level information;software dependencies;program comprehension;change impact analysis;software maintenance;source code analysis		8		49		17 nov. 2011			IEEE	IEEE Conferences
AudioHighlight: Code Skimming for Blind Programmers	audiohighlight code skimming for blind programmers	10.1109/ICSME.2018.00030	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530030	A. Armaly; P. Rodeghero; C. McMillan	Department of Electrical and Computer Engineering, University of California–Santa Barbara, Santa Barbara, CA, USA; LioniX International BV, AN Enschede, The Netherlands; LioniX International BV, AN Enschede, The Netherlands	2018 IEEE International Conference on Software Maintenance and Evolution (ICSME)	11 nov. 2018	2018			206	216	Blind programmers use a screen reader to read code aloud. Screen readers force blind programmers to read code sequentially one line at a time. In contrast, sighted programmers are able to skim visually to the most important code areas, assisted by syntax highlighting. However, there is a place where there is a widely adopted approach to skimming a structured document: the web. Modern screen readers employ what is known as a virtual cursor to navigate structural information on webpages such as HTML heading tags. These tags can indicate different sections and subsections in the structure of a page. We harness the existing familiarity of blind computer users with this interface in our approach which we call AudioHighlight. AudioHighlight renders the code inside a web view, either as part of the Eclipse IDE or as a web service. It places HTML heading tags on the structural elements of a source file such as classes, functions and control flow statements. We compare AudioHighlight to the state of the art in code skimming represented by a previous code skimming approach called StructJumper. We also compare to the state of practice in reading code on the web as represented by GitHub. We found that AudioHighlight increased the quality and speed of code comprehension as compared to both approaches.	2576-3148	978-1-5386-7870-1		accessibility;visual impairments;program comprehension	Navigation;Task analysis;Licenses;Syntactics;Productivity;Tutorials;Cloning	audio user interfaces;handicapped aids;hypermedia markup languages;Web services	blind programmers;structured document;structural information;HTML heading tags;blind computer users;AudioHighlight;code comprehension;code skimming approach;syntax highlighting;Web pages;user interface;Eclipse IDE;Web service;StructJumper;GitHub		8		40		11 nov. 2018			IEEE	IEEE Conferences
Evaluating Software Inspection Cognition Levels Using Bloom's Taxonomy	evaluating software inspection cognition levels using blooms taxonomy	10.1109/CSEET.2009.15	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812703	D. A. McMeekin; B. R. von Konsky; E. Chang; D. J. A. Cooper	Digital Ecosystems and Business Intelligence Institute, Curtin University of Technology, Bentley, WA, Australia; Digital Ecosystems and Business Intelligence Institute, Curtin University of Technology, Bentley, WA, Australia; Digital Ecosystems and Business Intelligence Institute, Curtin University of Technology, Bentley, WA, Australia; Digital Ecosystems and Business Intelligence Institute, Curtin University of Technology, Bentley, WA, Australia	2009 22nd Conference on Software Engineering Education and Training	10 Apr 2009	2009			232	239	This paper reports on results from a pilot study that used Bloompsilas taxonomy to observe cognition levels during software inspections conducted by undergraduate computer science and software engineering students. Cognition levels associated with three different code inspection techniques were investigated. These were the ad hoc, abstraction driven, and checklist-based reading strategies. Higher cognition levels were observed when using inspection techniques that utilise a more structured reading process. This result highlights the importance of introducing novice programmers to structured code reading strategies. Findings suggest that teaching different software inspection techniques throughout software courses, beginning with structured techniques, is an excellent way to build a studentpsilas critical software reading and analysis skills.	2377-570X	978-1-4244-3431-2		Bloom's taxonoomy;reading techniques;code inspections;program comprehension;cognition levels	Inspection;Cognition;Taxonomy;Writing;Open source software;Software engineering;Software maintenance;Application software;Natural languages;Ecosystems	computer aided instruction;computer science education;inference mechanisms;inspection;taxation	software inspection cognition levels;Bloom taxonomy;undergraduate computer science;software engineering students;code inspection techniques;checklist-based reading strategy;structured code reading strategies		8		16		10 Apr 2009			IEEE	IEEE Conferences
Architecture Recovery Using Latent Semantic Indexing and K-Means: An Empirical Evaluation	architecture recovery using latent semantic indexing and kmeans an empirical evaluation	10.1109/SEFM.2010.19	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5637415	M. Risi; G. Scanniello; G. Tortora	Dipartimento di Matematica e Informatica, University of Basilicata, Potenza, Italy; Dipartimento di Matematica e Informatica, University of Salerno, Fisciano, Salerno, Italy; Dipartimento di Matematica e Informatica, University of Salerno, Fisciano, Salerno, Italy	2010 8th IEEE International Conference on Software Engineering and Formal Methods	15 nov. 2010	2010			103	112	A number of clustering based approaches and tools have been proposed in the past to partition a software system into subsystems. The greater part of these approaches is semiautomatic, thus requiring human decision to identify the best partition of software entities into clusters among the possible partitions. In addition, some approaches are conceived for software systems implemented using a particular programming language (e.g., C and C++). In this paper we present an approach to automate the partitioning of a given software system into subsystems. In particular, the approach first analyzes the software entities (e.g., programs or classes) and then using Latent Semantic Indexing the dissimilarity between these entities is computed. Finally, software entities are grouped using iteratively the k-means clustering algorithm. The approach has been implemented in a prototype of a supporting software system as an Eclipse plug-in. Finally, to assess the approach and the plug-in, we have conducted an empirical investigation on three open source software systems implemented using the programming languages Java and C/C++.	2160-7656	978-1-4244-8289-4		Software Partitioning;Latent Semantic Indexing;Clustering;Program Comprehension;Software Maintenance	Clustering algorithms;Software algorithms;Software systems;Partitioning algorithms;Algorithm design and analysis;Large scale integration	C++ language;indexing;Java;pattern clustering;public domain software;software maintenance	architecture recovery;latent semantic indexing;clustering based approach;k-means clustering algorithm;Eclipse plug-in;open source software systems;programming languages Java;C++		8		38		15 nov. 2010			IEEE	IEEE Conferences
Hidden dependencies in software systems	hidden dependencies in software systems	10.1109/ICSM.2010.5609657	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609657	R. Vanciu; V. Rajlich	Department of Computer Science, Wayne State University, Detroit, MI, USA; Department of Computer Science, Wayne State University, Detroit, MI, USA	2010 IEEE International Conference on Software Maintenance	25 Oct 2010	2010			1	10	In this paper, we study the hidden dependencies that are a special kind of data flows. They play an important role in software maintenance and evolution because they propagate changes among the classes and they are hard to detect. We propose a technique that finds hidden dependencies through the computation of an “execute completely after” relation that is filtered using dynamically generated preconditions and postconditions. We show that these hidden dependencies exist even in well-structured software, like the open source programs JUnit, Drawlets, and Apache FtpServer. We also discuss the precision of this technique.	1063-6773	978-1-4244-8629-8		Software evolution;program comprehension;dependency analysis;execute completely after relation;invariants	Radio frequency;Integrated circuits	public domain software;software maintenance	hidden dependencies;software system;software maintenance;open source programs JUnit;Drawlets;Apache;FtpServer		8		51		25 Oct 2010			IEEE	IEEE Conferences
Building Domain Specific Dictionaries of Verb-Object Relation from Source Code	building domain specific dictionaries of verbobject relation from source code	10.1109/CSMR.2011.15	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5741251	Y. Hayase; Y. Kashima; Y. Manabe; K. Inoue	Faculty of Information Sciences and Arts, Toyo University, Kawagoe, Saitama, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan	2011 15th European Conference on Software Maintenance and Reengineering	5 Apr 2011	2011			93	100	An identifier is an important key in mapping program elements onto domain knowledge for the purpose of program comprehension. Therefore, if identifiers in a program have inappropriate names, developers can waste a lot of time trying to understand the program. This paper proposes a method for extracting and gathering verb-object (V-O) relations, as good examples of naming, from source code written in an object-oriented programming language. For each of several application domains, dictionaries containing the V-O relations are built and evaluated by software developers. The evaluation results confirm that the relations in the dictionaries are adequate in many cases.	1534-5351	978-1-61284-259-2		naming convention;programmer's lexicon;program comprehension	Dictionaries;Pattern matching;Software;Java;XML;Databases;Graphical user interfaces	object-oriented languages;programming languages;software maintenance	domain specific dictionary;verb-object relation;program comprehension;source code;object-oriented programming language		7		13		5 Apr 2011			IEEE	IEEE Conferences
Information foraging as a foundation for code navigation: NIER track	information foraging as a foundation for code navigation nier track	10.1145/1985793.1985911	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032526	N. Niu; A. Mahmoud; G. Bradshaw	Computer Science and Engineering, Mississippi State University, MS, USA; Computer Science and Engineering, Mississippi State University, MS, USA; Department of Psychology, Mississippi State University, MS, USA	2011 33rd International Conference on Software Engineering (ICSE)	10 Oct 2011	2011			816	819	A major software engineering challenge is to understand the fundamental mechanisms that underlie the developer's code navigation behavior. We propose a novel and unified theory based on the premise that we can study developer's information seeking strategies in light of the foraging principles that evolved to help our animal ancestors to find food. Our preliminary study on code navigation graphs suggests that the tenets of information foraging provide valuable insight into software maintenance. Our research opens the avenue towards the development of ecologically valid tool support to augment developers' code search skills.	1558-1225	978-1-4503-0445-0		foraging theory;program comprehension;software maintenance	Navigation;Biological system modeling;Software maintenance;Maintenance engineering;Profitability;Software engineering;Debugging	software maintenance	information foraging;foundation;code navigation;NIER track;software engineering;information seeking		7		15		10 Oct 2011			IEEE	IEEE Conferences
Code Clone Graph Metrics for Detecting Diffused Code Clones	code clone graph metrics for detecting diffused code clones	10.1109/APSEC.2009.53	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5358762	Y. Fukushima; R. Kula; S. Kawaguchi; K. Fushida; M. Nagura; H. Iida	Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan; Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan	2009 16th Asia-Pacific Software Engineering Conference	28 Dec 2009	2009			373	380	Code clones (duplicated source code in a software system) are one of the major factors in decreasing maintainability. Many code clone detection methods have been proposed to find code clones automatically from large-scale software. However, it is still hard to find harmful code clones to improve maintainability because there are many code clones that should remain. Thus, to help find harmful code clones, we propose a code clone visualization method and a metrics application on the visualized information. Our method enables the location of harmful code clones diffused in a software system. We apply our method to three open source software programs and visualize their code clone information.	1530-1362	978-0-7695-3909-6		visualization;software maintenance;program comprehension	Cloning;Visualization;Software maintenance;Costs;Software systems;Large-scale systems;Open source software;Software engineering;Information science;Application software	data visualisation;program verification;software maintenance;software metrics	code clone graph metrics;diffused code clones detection;large-scale software;code clone visualization method;open source software programs		7		12		28 Dec 2009			IEEE	IEEE Conferences
Mining Iterative Generators and Representative Rules for Software Specification Discovery	mining iterative generators and representative rules for software specification discovery	10.1109/TKDE.2010.24	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5416710	D. Lo; J. Li; l. wong; S. -C. Khoo	School of Information Systems, Singapore Management University, Singapore; School of Computer Engineering, Nanyang Technological University, Singapore; School of Computing, National University of Singapore, Singapore; School of Computing, National University of Singapore, Singapore	IEEE Transactions on Knowledge and Data Engineering	20 Dec 2010	2011	23	2	282	296	Billions of dollars are spent annually on software-related cost. It is estimated that up to 45 percent of software cost is due to the difficulty in understanding existing systems when performing maintenance tasks (i.e., adding features, removing bugs, etc.). One of the root causes is that software products often come with poor, incomplete, or even without any documented specifications. In an effort to improve program understanding, Lo et al. have proposed iterative pattern mining which outputs patterns that are repeated frequently within a program trace, or across multiple traces, or both. Frequent iterative patterns reflect frequent program behaviors that likely correspond to software specifications. To reduce the number of patterns and improve the efficiency of the algorithm, Lo et al. have also introduced mining closed iterative patterns, i.e., maximal patterns without any superpattern having the same support. In this paper, to technically deepen research on iterative pattern mining, we introduce mining iterative generators, i.e., minimal patterns without any subpattern having the same support. Iterative generators can be paired with closed patterns to produce a set of rules expressing forward, backward, and in-between temporal constraints among events in one general representation. We refer to these rules as representative rules. A comprehensive performance study shows the efficiency of our approach. A case study on traces of an industrial system shows how iterative generators and closed iterative patterns can be merged to form useful rules shedding light on software design.	1558-2191			Frequent pattern mining;sequence database;iterative patterns;generators;representative rules;software engineering;reverse engineering;program comprehension.	Costs;Software maintenance;Investments;Data mining;Java;Authorization;Software debugging;Software performance;Computer bugs;Iterative algorithms	data mining;formal specification;iterative methods;program diagnostics;reverse engineering;software maintenance	iterative generator mining;representative rules mining;software specification discovery;software-related cost;maintenance tasks;program understanding;program tracing;closed iterative pattern mining;software design		7		37	IEEE	18 Feb 2010			IEEE	IEEE Journals
A Framework for Examining Topical Locality in Object-Oriented Software	a framework for examining topical locality in objectoriented software	10.1109/COMPSAC.2012.32	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6340146	N. Niu; J. Savolainen; T. Bhowmik; A. Mahmoud; S. Reddivari	Department of Computer Science and Engineering, Mississippi State University, USA; Danfoss Power Electronics A/S, Graasten, Denmark; Department of Computer Science and Engineering, Mississippi State University, USA; Department of Computer Science and Engineering, Mississippi State University, USA; Department of Computer Science and Engineering, Mississippi State University, USA	2012 IEEE 36th Annual Computer Software and Applications Conference	10 nov. 2012	2012			219	224	The software entities of an object-oriented system should be organized in such a way that "spatial relatedness entails semantic relatedness". We refer this as the tenet of "topical locality" and argue that it is fundamental for the code base to be navigable. In this paper, we propose a novel experimental framework to test this key tenet and use large-scale open-source projects to assess three relationships. In particular, we find that: (1) class name along with header comments conveys class body's topic; (2) a code line is indicative of its surroundings; and (3) a contiguous code fragment may serve as a snapshot of the entire class. Our work not only shows the foundations necessary for the success of many code navigation approaches, but also opens avenues for further tool enhancements.	0730-3157	978-0-7695-4736-7		program comprehension;code navigation;topical locality;information seeking;experimentation	Software;Semantics;Navigation;Indexing;Software engineering;Correlation;Visualization	object-oriented programming;public domain software;reverse engineering;software maintenance	topical locality;object-oriented software;software entity;object-oriented system;spatial relatedness;semantic relatedness;navigable code base;large-scale open-source project;class name;header comment;class body topic;code line;contiguous code fragment;code navigation;tool enhancement;program comprehension;software maintenance		7		21	IEEE	10 nov. 2012			IEEE	IEEE Conferences
Sequence Diagram Slicing	sequence diagram slicing	10.1109/APSEC.2009.35	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5358692	K. Noda; T. Kobayashi; K. Agusa; S. Yamamoto	Graduate School of Information Science, University of Nagoya, Nagoya, Aichi, Japan; Graduate School of Information Science, University of Nagoya, Nagoya, Aichi, Japan; Graduate School of Information Science, University of Nagoya, Nagoya, Aichi, Japan; Aichi Prefectural University, Aichi, Japan	2009 16th Asia-Pacific Software Engineering Conference	28 Dec 2009	2009			291	298	Software visualization with sequence diagrams is one of the promising techniques aimed at helping developers comprehend the behavior of object-oriented systems effectively. However, it is still difficult to understand this behavior, because the size of automatically generated sequence diagrams tends to be beyond the developer's capacity. In this paper, we propose a sequence diagram slicing method, which is an extension of our previous method based on a dynamic slicing technique using static information. Our proposed method is capable of accurate slice calculation based on high-precision data dependency and can support various programs, including exceptions and multithreading. In addition, our proposed new tool performs slice calculations on the Eclipse platform and we demonstrate the applicability of this method by applying the tool to two Java programs as case studies. The results confirm the effectiveness of our proposed method for understanding the behavior of object-oriented systems.	1530-1362	978-0-7695-3909-6		Sequence Diagram;Program Slicing;Reverse Engineering;Program Comprehension;Program Maintenance;Debugging	Project management;Software engineering;Computer science;Conference management;Engineering management;Programming profession;Component architectures;Computer languages;Instruments;Testing	Java;object-oriented programming;program slicing;program visualisation	sequence diagram slicing method;software visualization;object-oriented systems;dynamic slicing technique;static information;slice calculation;Eclipse platform;Java programs;multithreading		7		13		28 Dec 2009			IEEE	IEEE Conferences
Identifying Core Objects for Trace Summarization Using Reference Relations and Access Analysis	identifying core objects for trace summarization using reference relations and access analysis	10.1109/COMPSAC.2017.142	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8029585	K. Noda; T. Kobayashi; T. Toda; N. Atsumi	Tokyo institute of Technology, Japan; Tokyo institute of Technology, Japan; Nihon Unisys Ltd., Japan; Kyoto University, Japan	2017 IEEE 41st Annual Computer Software and Applications Conference (COMPSAC)	11 Sep 2017	2017	1		13	22	Behaviors of an object-oriented system can be visualized as reverse-engineered sequence diagrams from execution traces. This approach is a valuable tool for program comprehension tasks. However, owing to the massiveness of information contained in an execution trace, a reverse-engineered sequence diagram is often afflicted by a scalability issue. To address this issue, we present in this paper a method for identifying core objects for trace summarization by reference relations and access analysis. We detect and eliminate temporary objects that are trivial for a system, and then estimate the importance of non-trivial objects. By grouping objects with a focus on highly important ones (i.e., core objects), we visualize the system's behavior in terms of intergroup interactions. Consequently, we obtain a readable size of a reverse-engineered sequence diagram containing the system's key behavior. We implemented our technique in our tool and evaluated it by using traces from open-source software systems. The results showed that our reverse-engineered sequence diagrams contained only less than 30 lifelines, whereas the original diagrams (no abstraction methods were applied) contained approximately 1,000 to 3,000 lifelines. Our proposed method achieved significant reduction of the horizontal size of the diagram and is expected to be a valuable tool for program comprehension.	0730-3157	978-1-5386-0367-3		Dynamic Analysis;Reverse-engineered Sequence Diagram;Trace Summarization;Core Object;Program Comprehension	Visualization;Object recognition;Tools;Scalability;Software systems;Open source software;Frequency estimation	object-oriented methods;public domain software;reverse engineering	core objects;trace summarization;reference relations;access analysis;object-oriented system;reverse-engineered sequence diagrams;execution traces;program comprehension tasks;nontrivial objects;intergroup interactions;system key behavior;open-source software systems		7		34		11 Sep 2017			IEEE	IEEE Conferences
Measuring the Accuracy of Information Retrieval Based Bug Localization Techniques	measuring the accuracy of information retrieval based bug localization techniques	10.1109/WCRE.2011.23	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079835	M. Beard; N. Kraft; L. Etzkorn; S. Lukins	Computer Science Department, University of Alabama in Huntsville, Huntsville, AL, USA; University of Alabama, Tuscaloosa, AL, USA; Computer Science Department, University of Alabama in Huntsville, Huntsville, AL, USA; SAIC, Huntsville, AL, USA	2011 18th Working Conference on Reverse Engineering	17 nov. 2011	2011			124	128	Bug localization involves using information about a bug to locate affected code sections. Several automated bug localization techniques based on information retrieval (IR) models have been constructed recently. The "gold standard" of measuring an IR technique's accuracy considers the technique's ability to locate a "first relevant method." However, the question remains -- does finding this single method enable the location of a complete set of affected methods? Previous arguments assume this to be true, however, few analyses of this assumption have been performed. In this paper, we perform a case study to test the reliability of this "gold standard" assumption. To further measure IR accuracy in the context of bug localization, we analyze the relevance of the IR model's "first method returned." We use various structural analysis techniques to extend relevant methods located by IR techniques and determine accuracy and reliability of these assumptions.	2375-5369	978-1-4577-1948-6		program comprehension;feature identification;concept location;static analysis;information retrieval;latent Dirichlet allocation;latent semantic indexing	Accuracy;Computer bugs;Large scale integration;Gold;Magnetic resonance;Semantics;Reliability	information retrieval;program debugging;software maintenance	automated bug localization techniques;information retrieval models;gold standard assumption;first method returned		7		15		17 nov. 2011			IEEE	IEEE Conferences
Clustering and recommending collections of code relevant to tasks	clustering and recommending collections of code relevant to tasks	10.1109/ICSM.2011.6080826	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6080826	S. Lee; S. Kang	Department of Computer Science, KAIST, Daejeon, South Korea; Department of Computer Science, KAIST, Daejeon, South Korea	2011 27th IEEE International Conference on Software Maintenance (ICSM)	17 nov. 2011	2011			536	539	When performing software evolution tasks, programmers spend a significant amount of time exploring the code base to find methods, fields or classes that are relevant to the task at hand. We propose a new clustering approach called NavClus to recommend collections of code relevant to tasks. By gradually aggregating navigation sequences from programmers' interaction history, NavClus clusters pieces of code that are contextually related. The resulting clusters become the basis for NavClus to recommend collections of code that are likely to be relevant to the programmer's given task. We compare NavClus and TeamTracks, the state of the art code recommender for sharing navigation data among programmers. The results show that NavClus recommends pieces of code relevant to tasks considerably better than TeamTracks.	1063-6773	978-1-4577-0664-6		program comprehension;code navigation;data clustering techniques;context aware recommendation systems	Navigation;History;Context;Productivity;Couplings;Software systems	pattern clustering;recommender systems;software maintenance;ubiquitous computing	collection clustering;collection recommendation;software evolution tasks;NavClus clusters;navigation sequences;TeamTracks;software systems;context aware recommendation systems;program comprehension;data clustering techniques		6		13		17 nov. 2011			IEEE	IEEE Conferences
A History Querying Tool and Its Application to Detect Multi-version Refactorings	a history querying tool and its application to detect multiversion refactorings	10.1109/CSMR.2013.44	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6498483	R. Stevens; C. De Roover; C. Noguera; V. Jonckers	Software Languages Laboratory, Vrije Universiteit Brussel, Brussels, Belgium; Software Languages Laboratory, Vrije Universiteit Brussel, Brussels, Belgium; Software Languages Laboratory, Vrije Universiteit Brussel, Brussels, Belgium; Software Languages Laboratory, Vrije Universiteit Brussel, Brussels, Belgium	2013 17th European Conference on Software Maintenance and Reengineering	15 Apr 2013	2013			335	338	Version Control Systems (VCS) have become indispensable in developing software. In order to provide support for change management, they track the history of software projects. Tool builders can exploit this latent historical information to provide insights in the evolution of the project. For example, the information needed to identify when and where a particular refactoring was applied is implicitly present in the VCS. However, tool support for eliciting this information is lacking. So far, no general-purpose history querying tool capable of answering a wide variety of questions about the evolution of software exists. Therefore, we generalize the idea of a program querying tool to a history querying tool. A program querying tool reifies the program's code into a knowledge base, from which it retrieves elements that exhibit characteristics specified through a user-provided program query. Our history querying tool, QwalKeko, enables specifying the evolution of source code characteristics across multiple versions of Java projects versioned in Git. We apply QwalKeko to the problem of detecting refactorings, specified as the code changes induced by each refactoring. These specifications stem from the literature, but are limited to changes between two successive versions. We demonstrate the expressiveness of our tool by generalizing the specifications such that refactorings can span multiple versions.	1534-5351	978-0-7695-4948-4		program comprehension tools;software repositories;refactoring	History;Java;Database languages;Europe;Software maintenance;Control systems	configuration management;Java;query processing;software maintenance	history querying tool;multiversion refactoring detection;VCS;version control system;software development;change management;QwalKeko history querying tool;user-provided program query;Java project		6		12		15 Apr 2013			IEEE	IEEE Conferences
Identifying computational phases from inter-process communication traces of HPC applications	identifying computational phases from interprocess communication traces of hpc applications	10.1109/ICPC.2012.6240481	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240481	L. Alawneh; A. Hamou-Lhadj	Software Behaviour Analysis (SBA) Research Laboratory, Department of Electrical and Computer Engineering, Concordia University, Montreal, QUE, Canada; Software Behaviour Analysis (SBA) Research Laboratory, Department of Electrical and Computer Engineering, Concordia University, Montreal, QUE, Canada	2012 20th IEEE International Conference on Program Comprehension (ICPC)	16 jul. 2012	2012			133	142	Understanding the behaviour of High Performance Computing (HPC) systems is a challenging task due to the large number of processes they involve as well as the complex interactions among these processes. In this paper, we present a novel approach that aims to simplify the analysis of large execution traces generated from HPC applications. We achieve this through a technique that allows semiautomatic extraction of execution phases from large traces. These phases, which characterize the main computations of the traced scenario, can be used by software engineers to browse the content of a trace at different levels of abstraction. Our approach is based on the application of information theory principles to the analysis of sequences of communication patterns found in HPC traces. The results of the proposed approach when applied to traces of a large HPC industrial system demonstrate its effectiveness in identifying the main program phases and their corresponding sub-phases.	1092-8138	978-1-4673-1216-5		program comprehension;dynamic analysis;high performance computing aystems;inter-process communication traces;execution phases	Phase detection;Entropy;Data models;Algorithm design and analysis;Topology;Message passing;Equations	distributed processing;information theory	computational phase identification;interprocess communication traces;HPC applications;high performance computing systems;execution trace analysis;execution phase semiautomatic extraction;information theory principles;communication pattern sequence;HPC industrial system;program phases		6	1	30		16 jul. 2012			IEEE	IEEE Conferences
Visually Analyzing Students' Gaze on C++ Code Snippets	visually analyzing students gaze on c++ code snippets	10.1109/EMIP.2019.00011	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8834703	C. S. Peterson; J. A. Saddler; T. Blascheck; B. Sharif	Department of Computer Science and Engineering, University of Nebraska-Lincoln, Lincoln, Nebraska, USA 68588; Department of Computer Science and Engineering, University of Nebraska-Lincoln, Lincoln, Nebraska, USA 68588; Inria, Saclay, France; Department of Computer Science and Engineering, University of Nebraska-Lincoln, Lincoln, Nebraska, USA 68588	2019 IEEE/ACM 6th International Workshop on Eye Movements in Programming (EMIP)	12 Sep 2019	2019			18	25	The paper presents an eye tracking study with 17 students (12 novices, 5 non-novices) reading C++ methods. The novices were students who participated in the study during the last week of their semester learning C++. The non-novices were senior students who had been exposed to programming before. We report on the reading behavior of three C++ methods that use different language constructs. We analyze fixations at the line level of the code using visualizations to derive insights into code reading. Results show that most transitions were made to code lines that are close to the current line read. We observe that a large percentage of the total fixation duration is made on a small number of lines and that related lines are often viewed together in a series of short fixations.		978-1-7281-2243-4		eye tracking;visual analysis;program comprehension;C++ source code;scanpaths;transitions	Data visualization;C++ languages;Gaze tracking;Programming;Tools;Task analysis;Visualization	computer science education;data visualisation;gaze tracking;human factors	code lines;C++ code;eye tracking study;senior students;reading behavior;code reading;language constructs;student gaze		6		14		12 Sep 2019			IEEE	IEEE Conferences
ComFormer: Code Comment Generation via Transformer and Fusion Method-based Hybrid Code Representation	comformer code comment generation via transformer and fusion methodbased hybrid code representation	10.1109/DSA52907.2021.00013	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9622968	G. Yang; X. Chen; J. Cao; S. Xu; Z. Cui; C. Yu; K. Liu	Computer School, Beijing Information Science and Technology University, China; Ministry of Industry and Information Technology, Key Laboratory of Safety-Critical Software, Nanjing University of Aeronautics and Astronautics, China; Computer School, Beijing Information Science and Technology University, China; Computer School, Beijing Information Science and Technology University, China; Ministry of Industry and Information Technology, Key Laboratory of Safety-Critical Software, Nanjing University of Aeronautics and Astronautics, China; Computer School, Beijing Information Science and Technology University, China; Computer School, Beijing Information Science and Technology University, China	2021 8th International Conference on Dependable Systems and Their Applications (DSA)	1 Dec 2021	2021			30	41	Developers often write low-quality code comments due to the lack of programming experience, which can reduce the efficiency of developers' program comprehension. Therefore, developers hope that code comment generation tools can be developed to illustrate the functionality and purpose of the code. Recently, researchers mainly model this problem as the neural machine translation problem and tend to use deep learning-based methods. In this study, we propose a novel method ComFormer based on Transformer and fusion method-based hybrid code presentation. Moreover, to alleviate OOV (out-of-vocabulary) problem and speed up model training, we further utilize the Byte-BPE algorithm to split identifiers and Sim_SBT method to perform AST Traversal. We compare ComFormer with seven state-of-the-art baselines from code comment generation and neural machine translation domains. Comparison results show the competitiveness of ComFormer in terms of three performance measures. Moreover, we perform a human study to verify that ComFormer can generate high-quality comments.	2767-6684	978-1-6654-4391-3	National Natural Science Foundation of China; Nanjing University of Aeronautics and Astronautics; 	Program Comprehension;Code Comment Generation;Hybrid Code Representation;Transformer;Empirical Study	Training;Learning systems;Codes;Tools;Programming;Transformers;Hybrid power systems	convolutional neural nets;deep learning (artificial intelligence);language translation;natural language processing;program compilers;public domain software;sensor fusion	Transformer;fusion method-based hybrid code representation;low-quality code comments;programming experience;code comment generation tools;neural machine translation problem;deep learning-based methods;fusion method-based hybrid code presentation;Sim_SBT method;ComFormer method;Byte-BPE algorithm;AST traversal		6		56	IEEE	1 Dec 2021			IEEE	IEEE Conferences
Can clone detection support test comprehension?	can clone detection support test comprehension	10.1109/ICPC.2012.6240490	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240490	B. Hauptmann; M. Junker; S. Eder; E. Juergens; R. Vaas	Technische Universität München, Garching Bei Munchen, Germany; Technische Universität München, Garching Bei Munchen, Germany; Technische Universität München, Garching Bei Munchen, Germany; CQSE GmbH, Munchen, Germany; Munich Re Group, Munchen, Germany	2012 20th IEEE International Conference on Program Comprehension (ICPC)	16 jul. 2012	2012			209	218	Tests are central artifacts of software systems. Therefore, understanding tests is essential for activities such as maintenance, test automation, and efficient execution. Redundancies in tests may significantly decrease their understandability. Clone detection is a technique to find similar parts in software artifacts. We suggest using this technique to gain a better understanding of tests and to provide guidance for testing activities. We show the capabilities as well as the limits of this approach by conducting a case study analyzing more than 4000 tests of seven industrial software systems.	1092-8138	978-1-4673-1216-5		Program Comprehension;Software Testing;Software Maintenance;Clone Detection	Cloning;Manuals;Testing;Automation;Inspection;Optimization;Maintenance engineering	program testing	clone detection;test comprehension;software system central artifacts;industrial software systems		6		32		16 jul. 2012			IEEE	IEEE Conferences
Slicing and replaying code change history	slicing and replaying code change history	10.1145/2351676.2351713	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6494927	K. Maruyama; E. Kitsu; T. Omori; S. Hayashi	Department of Computer Science, Ritsumeikan University, Japan; Graduate School of Science and Engineering, Ritsumeikan University, Japan; Department of Computer Science, Ritsumeikan University, Japan; Department of Computer Science, Tokyo Institute of Technology, Japan	2012 Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering	8 Apr 2013	2012			246	249	Change-aware development environments have recently become feasible and reasonable. These environments can automatically record fine-grained code changes on a program and allow programmers to replay the recorded changes in chronological order. However, they do not always need to replay all the code changes to investigate how a particular entity of the program has been changed. Therefore, they often skip several code changes of no interest. This skipping action is an obstacle that makes many programmers hesitate in using existing replaying tools. This paper proposes a slicing mechanism that can extract only code changes necessary to construct a particular class member of a Java program from the whole history of past code changes. In this mechanism, fine-grained code changes are represented by edit operations recorded on source code of a program. The paper also presents a running tool that implements the proposed slicing and replays its resulting slices. With this tool, programmers can avoid replaying edit operations nonessential to the construction of class members they want to understand.		978-1-4503-1204-2		Code change;Integrated development environments;Program comprehension;Program slicing;Software maintenance and evolution		Java;software maintenance	code change history;change-aware development environment;fine-grained code change;skipping action;slicing mechanism;Java program;edit operation;program source code;running tool;software maintenance		6		13		8 Apr 2013			IEEE	IEEE Conferences
Using Grammar Patterns to Interpret Test Method Name Evolution	using grammar patterns to interpret test method name evolution	10.1109/ICPC52881.2021.00039	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463038	A. Peruma; E. Hu; J. Chen; E. A. AlOmar; M. W. Mkaouer; C. D. Newman	Rochester Institute of Technology, Rochester, NY, USA; Tufts University, Medford, MA, USA; Stony Brook University, Stony Brook, NY, USA; Rochester Institute of Technology, Rochester, NY, USA; Rochester Institute of Technology, Rochester, NY, USA; Rochester Institute of Technology, Rochester, NY, USA	2021 IEEE/ACM 29th International Conference on Program Comprehension (ICPC)	28 jun. 2021	2021			335	346	It is good practice to name test methods such that they are comprehensible to developers; they must be written in such a way that their purpose and functionality are clear to those who will maintain them. Unfortunately, there is little automated support for writing or maintaining the names of test methods. This can lead to inconsistent and low-quality test names and increase the maintenance cost of supporting these methods. Due to this risk, it is essential to help developers in maintaining their test method names over time. In this paper, we use grammar patterns, and how they relate to test method behavior, to understand test naming practices. This data will be used to support an automated tool for maintaining test names.	2643-7171	978-1-6654-1403-6	National Science Foundation; 	Program Comprehension;Test Method Names;Rename Refactoring;Part of speech Tags;Grammar Pattern	Tools;Maintenance engineering;Grammar	grammars;program testing;software maintenance;software quality	maintenance cost;test method names;low-quality test names;automated support;test naming practices;grammar patterns		6		75		28 jun. 2021			IEEE	IEEE Conferences
Cognitive task difficulty analysis using EEG and data mining	cognitive task difficulty analysis using eeg and data mining	10.1109/ICEDSS.2017.8073658	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8073658	A. Duraisingam; R. Palaniappan; S. Andrews	Data Science (E-Health) Research Group, University of Kent, Chatham, UK; Data Science (E-Health) Research Group, University of Kent, Chatham, UK; Mahendra Engineering College, Salem, India	2017 Conference on Emerging Devices and Smart Systems (ICEDSS)	19 Oct 2017	2017			52	57	Existing research on task difficulty and program comprehension mainly concentrate on brain areas related to attention and meditation. In this research, an in-depth analysis of Task Difficulty Level (TDL) for program comprehension is proposed with features extracted from different areas of the brain. Two levels of task difficulty were analysed: easy and difficult. Eight students were asked to solve nine Java programs of different difficulty level and the subject's cognitive load was recorded using EEG. Four different feature extraction methods were used for analysis - Energy, Frequency ratio, Event Related De-Synchronization (ERD) and Asymmetry ratio and Naïve Bayes classifier was used for classifying different TDL. The results indicated that the recorded EEG signals could reflect TDL for program comprehension tasks for predicting easy and difficult tasks. The classifier predicted task difficulty (easy/difficult) of a new task with an overall correctly classified accuracy of 76.55% with a precision of 80.03% and recall of 76.66%. This in-depth analysis of TDL for program comprehension tasks using EEG could support in developing future generation learning tools.		978-1-5090-5555-5		Electroencephalogram;Naive Bayes classifier;Program comprehension;Task difficulty	Electroencephalography;Feature extraction;Java;Cognition;Electrodes;Tools	Bayes methods;cognition;data mining;electroencephalography;feature extraction;Java;learning (artificial intelligence);medical signal processing;signal classification	program comprehension tasks;easy tasks;in-depth analysis;cognitive task difficulty analysis;data mining;brain areas;Task Difficulty Level;Java programs;Naïve Bayes classifier;feature extraction methods;cognitive load;frequency ratio;event related desynchronization;asymmetry ratio;learning tools;EEG signal;meditation		5		22		19 Oct 2017			IEEE	IEEE Conferences
Towards Behavioral Reflexion Models	towards behavioral reflexion models	10.1109/ISSRE.2009.27	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5362111	C. Ackermann; M. Lindvall; R. Cleaveland	Center of Experimental Software Engineering, Fraunhofer USA, College Park, MD, USA; Center of Experimental Software Engineering, Fraunhofer USA, College Park, MD, USA; Center of Experimental Software Engineering, Fraunhofer USA, College Park, MD, USA	2009 20th International Symposium on Software Reliability Engineering	28 Dec 2009	2009			175	184	Software architecture has become essential in the struggle to manage today's increasingly large and complex systems. Software architecture views are created to capture important system characteristics on an abstract and, thus, comprehensible level. As the system is implemented and later maintained, it often deviates from the original design specification. Such deviations can have implication for the quality of the system, such as reliability, security, and maintainability. Software architecture compliance checking approaches, such as the reflexion model technique, have been proposed to address this issue by comparing the implementation to a model of the systems' architecture design. However, architecture compliance checking approaches focus solely on structural characteristics and ignore behavioral conformance. This is especially an issue in Systems-of-Systems. Systems-of-Systems (SoS) are decompositions of large systems, into smaller systems for the sake of flexibility. Deviations of the implementation to its behavioral design often reduce the reliability of the entire SoS. An approach is needed that supports the reasoning about behavioral conformance on architecture level.In order to address this issue, we have developed an approach for comparing the implementation of a SoS to an architecture model of its behavioral design. The approach follows the idea of reflexion models and adopts it to support the compliance checking of behaviors. In this paper, we focus on sequencing properties as they play an important role in many SoS. Sequencing deviations potentially have a severe impact on the SoS' correctness and qualities. The desired behavioral specification is defined in UML sequence diagram notation and behaviors are extracted from the SoS implementation. The behaviors are then mapped to the model of the desired behavior and the two are compared. Finally, a reflexion model is constructed that shows the deviations between behavioral design and implementation. This paper discusses the approach and shows how it can be applied to investigate reliability issues in SoS.	2332-6549	978-1-4244-5375-7		Software engineering;software reliability;behavioral analysis;program comprehension;behavior verification	Computer architecture;Software architecture;Documentation;Maintenance;Security;Software reliability;Software engineering;Software quality;Reliability engineering;Educational institutions	large-scale systems;reliability;software architecture;Unified Modeling Language	behavioral reflexion models;software architecture;complex systems;original design specification;reliability;security;maintainability;reflexion model technique;architecture compliance checking;ignore behavioral conformance;systems of systems;behavioral design implementation;behavioral conformance architecture level;compliance checking behaviors;sequencing deviations potentially;UML sequence diagram notation;SoS implementation		5		14		28 Dec 2009			IEEE	IEEE Conferences
Impact of Limited Memory Resources	impact of limited memory resources	10.1109/ICPC.2008.31	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556120	D. Binkley; D. Lawrie; S. Maex; C. Morrell	Loyola College, Baltimore, MD, USA; Loyola College, Baltimore, MD, USA; Loyola College, Baltimore, MD, USA; Loyola College, Baltimore, MD, USA	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			83	92	Since early variable mnemonics were limited to as few as six to eight characters, many early programmers abbreviated concepts in their variable names. The past thirty years has seen a steady increase in permitted name length and, slowly, an increase in the actual length of identifiers. However, in theory names can be too long. Most obviously, in object-oriented programs, names often involve chaining of method calls and field selectors (e.g., class.firstAssignment().name.trim()). While longer names bring the potential for easier comprehension through more embedded sub-words, there are practical limits to length given limited human memory resources. The central hypothesis studied herein is that names used in modern programs have reached this limit. Statistical models derived from an experiment involving 158 programmers of varying degrees of experience show that longer names extracted from production code take more time to process and reduce correctness in a simple recall activity. This has clear negative implications for any attempt to read, and hence comprehend or manipulate, the source code of modern software. The experiment also evaluates the advantage of identifiers having ties to a programmer's persistent memory. Combined these results reinforce past proposals advocating the use of limited, consistent, and regular vocabulary in identifier names. In particular, good naming limits length and reduces the need for specialized vocabulary.	1092-8138	978-0-7695-3176-2		program comprehension;memory;identifier names	Programming profession;Humans;Production;Vocabulary;Computer languages;Educational institutions;USA Councils;Object oriented modeling;Proposals;Natural languages	object-oriented programming;program compilers;resource allocation	object-oriented program;human memory resource;statistical model;modern software;source code;programmer persistent memory;program compiler		5		13		2 jul. 2008			IEEE	IEEE Conferences
Modeling the ownership of source code topics	modeling the ownership of source code topics	10.1109/ICPC.2012.6240485	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240485	C. S. Corley; E. A. Kammer; N. A. Kraft	Department of Computer Science, University of Alabama, Tuscaloosa, AL, USA; Department of Computer Science, University of Alabama, Tuscaloosa, AL, USA; Department of Computer Science, University of Alabama, Tuscaloosa, AL, USA	2012 20th IEEE International Conference on Program Comprehension (ICPC)	16 jul. 2012	2012			173	182	Exploring linguistic topics in source code is a program comprehension activity that shows promise in helping a developer to become familiar with an unfamiliar software system. Examining ownership in source code can reveal complementary information, such as who to contact with questions regarding a source code entity, but the relationship between linguistic topics and ownership is an unexplored area. In this paper we combine software repository mining and topic modeling to measure the ownership of linguistic topics in source code. We conduct an exploratory study of the relationship between linguistic topics and ownership in source code using 10 open source Java systems. We find that classes that belong to the same linguistic topic tend to have similar ownership characteristics, which suggests that conceptually related classes often share the same owner(s). We also find that similar topics tend to share the same ownership characteristics, which suggests that the same developers own related topics.	1092-8138	978-1-4673-1216-5		program comprehension;mining software repositories;ownership;topic modeling;pachinko allocation model	Pragmatics;Software;Data mining;Correlation;Java;Probability distribution;Resource management	data mining;Java;linguistics;public domain software;reverse engineering;source coding	ownership modelling;source code topics;linguistic topics;program comprehension activity;ownership examination;software repository mining;topic modeling;open source Java systems		5		36		16 jul. 2012			IEEE	IEEE Conferences
Locating the Meaning of Terms in Source Code Research on "Term Introduction"	locating the meaning of terms in source code research on term introduction	10.1109/WCRE.2011.21	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079832	J. Nonnen; D. Speicher; P. Imhoff	Computer Science III, University of Bonn, Bonn, Germany; Computer Science III, University of Bonn, Bonn, Germany; Computer Science III, University of Bonn, Bonn, Germany	2011 18th Working Conference on Reverse Engineering	17 nov. 2011	2011			99	108	Software developers are often facing the challenge of understanding a large code base. Program comprehension is not only achieved by looking at object interactions, but also by considering the meaning of the identifiers and the contained terms. Ideally, the source code should exemplify this meaning. We propose to call the source code locations that define the meaning of a term term introduction. We further derive a heuristic to determine the introduction location with the help of an explorative study. This study was performed on 8000 manually evaluated samples gained from 30 open source projects. To support reproducibility, all samples and classifications are also available online. The achieved results show a precision of 75% for the heuristic.	2375-5369	978-1-4577-1948-6		identifier analysis;name meaning;empirical evaluation;explorative approach;program comprehension;source code analysis	Context;Dictionaries;Libraries;Vocabulary;Speech;Algorithm design and analysis;Measurement	reverse engineering	source code analysis;term introduction;program comprehension		5		31	IEEE	17 nov. 2011			IEEE	IEEE Conferences
CoRA: Decomposing and Describing Tangled Code Changes for Reviewer	cora decomposing and describing tangled code changes for reviewer	10.1109/ASE.2019.00101	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952413	M. Wang; Z. Lin; Y. Zou; B. Xie	Key Laboratory of High Condence Software Technologies, Ministry of Education, Beijing, China and the School of Electronics Engineering and Computer Science, Peking University, Beijing, China; Microsoft Research, Beijing, China; Key Laboratory of High Condence Software Technologies, Ministry of Education, Beijing, China and the School of Electronics Engineering and Computer Science, Peking University, Beijing, China; Key Laboratory of High Condence Software Technologies, Ministry of Education, Beijing, China and the School of Electronics Engineering and Computer Science, Peking University, Beijing, China	2019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)	9 jan. 2020	2019			1050	1061	Code review is an important mechanism for code quality assurance both in open source software and industrial software. Reviewers usually suffer from numerous, tangled and loosely related code changes that are bundled in a single commit, which makes code review very difficult. In this paper, we propose CoRA (Code Review Assistant), an automatic approach to decompose a commit into different parts and generate concise descriptions for reviewers. More specifically, CoRA can decompose a commit into independent parts (e.g., bug fixing, new feature adding, or refactoring) by code dependency analysis and tree-based similar-code detection, then identify the most important code changes in each part based on the PageRank algorithm and heuristic rules. As a result, CoRA can generate a concise description for each part of the commit. We evaluate our approach in seven open source software projects and 50 code commits. The results indicate that CoRA can improve the accuracy of decomposing code changes by 6.3% over the state-ofart practice. At the same time, CoRA can identify the important part from the fine-grained code changes with a mean average precision (MAP) of 87.7%. We also conduct a human study with eight participants to evaluate the performance and usefulness of CoRA, the user feedback indicates that CoRA can effectively help reviewers.	2643-1572	978-1-7281-2508-4		Code review;Code changes decomposition;Code changes description;Program comprehension	Natural languages;Computer bugs;Tools;Clustering algorithms;Java;Open source software	program debugging;public domain software;quality assurance;software quality	reviewer;code quality assurance;industrial software;tangled related code changes;Code Review Assistant;concise description;CoRA;code dependency analysis;tree-based similar-code detection;open source software projects;decomposing code changes;fine-grained code changes;tangled code changes		5		53		9 jan. 2020			IEEE	IEEE Conferences
An Android Security Case Study with Bauhaus	an android security case study with bauhaus	10.1109/WCRE.2011.29	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079840	B. J. Berger; M. Bunke; K. Sohr	Center of Computing Technologies (TZI), Universität Bremen, Germany; Center of Computing Technologies (TZI), Universität Bremen, Germany; Center of Computing Technologies (TZI), Universität Bremen, Germany	2011 18th Working Conference on Reverse Engineering	17 nov. 2011	2011			179	183	Software security has made great progress, code analysis tools are widely-used in industry for detecting common implementation-level security bugs. However, given the fact that we must deal with legacy code we plead to employ the techniques long been developed in the research area of program comprehension for software security. In cooperation with a security expert, we carried out a case study with the mobile phone platform Android, and employed the reverse engineering tool-suite Bauhaus for this security assessment. During the investigation we found some inconsistencies in the implementation of the Android security concepts. Based on the lessons learned from the case study, we propose several research topics in the area of reverse engineering that would support a security analyst during security assessments.	2375-5369	978-1-4577-1948-6		program comprehension;security assessment;software security;Android	Security;Software;Bluetooth;Androids;Humanoid robots;Smart phones;Documentation	mobile computing;program debugging;reverse engineering;security of data	Android security;Bauhaus;software security;code analysis tool;implementation-level security bug;legacy code;program comprehension;mobile phone;reverse engineering tool		5		35		17 nov. 2011			IEEE	IEEE Conferences
On the proactive and interactive visualization for feature evolution comprehension: An industrial investigation	on the proactive and interactive visualization for feature evolution comprehension an industrial investigation	10.1109/ICSE.2012.6227115	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227115	R. Novais; C. Nunes; C. Lima; E. Cirilo; F. Dantas; A. Garcia; M. Mendonça	Software Engineering Lab, Computer Science Department, Federal University of Bahia, Bahia, Brazil; Opus Research Group, Software Engineering Lab, Informatics Department, PUC-Rio, Rio de Janeiro, Brazil; Software Engineering Lab, Computer Science Department, Federal University of Bahia, Bahia, Brazil; Opus Research Group, Software Engineering Lab, Informatics Department, PUC-Rio, Rio de Janeiro, Brazil; Opus Research Group, Software Engineering Lab, Informatics Department, PUC-Rio, Rio de Janeiro, Brazil; Opus Research Group, Software Engineering Lab, Informatics Department, PUC-Rio, Rio de Janeiro, Brazil; Software Engineering Lab, Computer Science Department, Federal University of Bahia, Bahia, Brazil	2012 34th International Conference on Software Engineering (ICSE)	28 jun. 2012	2012			1044	1053	Program comprehension is a key activity through maintenance and evolution of large-scale software systems. The understanding of a program often requires the evolution analysis of individual functionalities, so-called features. The comprehension of evolving features is not trivial as their implementations are often tangled and scattered through many modules. Even worse, existing techniques are limited in providing developers with direct means for visualizing the evolution of features' code. This work presents a proactive and interactive visualization strategy to enable feature evolution analysis. It proactively identifies code elements of evolving features and provides multiple views to present their structure under different perspectives. The novel visualization strategy was compared to a lightweight visualization strategy based on a tree-structure. We ran a controlled experiment with industry developers, who performed feature evolution comprehension tasks on an industrial-strength software. The results showed that the use of the proposed strategy presented significant gains in terms of correctness and execution time for feature evolution comprehension tasks.	1558-1225	978-1-4673-1067-3		program comprehension;feature evolution;software visualization;experimental evaluation	Visualization;Color;Industries;Software systems;History;Context	data visualisation;software maintenance	interactive visualization;proactive visualization;feature evolution comprehension;industrial investigation;program comprehension;large-scale software systems;evolution analysis;individual functionalities;lightweight visualization;tree structure		5		33		28 jun. 2012			IEEE	IEEE Conferences
RepoVis: Visual Overviews and Full-Text Search in Software Repositories	repovis visual overviews and fulltext search in software repositories	10.1109/VISSOFT.2018.00009	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530126	J. Feiner; K. Andrews	FH JOANNEUM University of Applied Sciences, Austria; Graz University of Technology, Austria	2018 IEEE Working Conference on Software Visualization (VISSOFT)	11 nov. 2018	2018			1	11	Project managers and software developers often have difficulty maintaining an overview of the structure, evolution, and status of collaborative software projects. Some tools are available for typical source code management systems, which provide summary statistics or simple visual representations of merge-branch graphs. However, comprehensive visual overview and search facilities for such repositories are lacking. RepoVis is a new tool which provides comprehensive visual overviews and full-text search for projects maintained in Git repositories. The overview shows folders, files, and lines of code colour-coded according to last modification, developer, file type, or associated issues. Full-text searches can be performed for terms of interest within source code files, commit messages, or any associated metadata or usability findings, with matches displayed visually in the overview. The utility of the RepoVis approach is illustrated with three use cases of real-world software inspection. Insights are presented into the utility of full-text search and visual presentation of matches for program comprehension.		978-1-5386-8292-0		software visualisation, program comprehension, usability, metrics, visual overview, full-text search, git repositories.	Visualization;Usability;Inspection;Metadata;Security;Libraries	data visualisation;groupware;meta data;project management;software development management;software maintenance;source code (software);text analysis	collaborative software projects;typical source code management systems;simple visual representations;merge-branch graphs;search facilities;full-text search;Git repositories;source code files;RepoVis approach;real-world software inspection;visual presentation;visual overviews;software repositories;project managers;software developers;code colour;summary statistics;commit messages;metadata		5		76		11 nov. 2018			IEEE	IEEE Conferences
Viewing Object-Oriented Software with MetricAttitude: An Empirical Evaluation	viewing objectoriented software with metricattitude an empirical evaluation	10.1109/IV.2014.42	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6902881	R. Francese; M. Risi; G. Scanniello; G. Tortora	University of Salerno, Italy; University of Salerno, Italy; University of Basilicata, Italy; University of Salerno, Italy	2014 18th International Conference on Information Visualisation	22 Sep 2014	2014			59	64	MetricAttitude is a visualization tool based on static analysis that provides a mental picture by viewing an object-oriented software system by means of polymetric views. In this paper, we present a preliminary empirical investigation based on a questionnaire-based survey to assess Metric Attitude with respect to source code comprehension tasks. Participants involved in this study were Computer Science students and software professionals. The results suggest that Metric Attitude is a viable means to comprehend source code and that both kinds of participants in the empirical investigation considered it to be appropriate in source code comprehension.	2375-0138	978-1-4799-4103-2		Program Comprehension;Reverse Engineering;Software Maintenance;Software Metrics;Software Visualization Tool	Measurement;Visualization;Software systems;Layout;Color;Abstracts	object-oriented methods;program diagnostics;program visualisation;source code (software)	MetricAttitude;static analysis;object-oriented software system;polymetric views;preliminary empirical investigation;questionnaire-based survey;source code comprehension tasks;computer science students;software professionals;source code comprehension;software visualization tool		5		22		22 Sep 2014			IEEE	IEEE Conferences
A lightweight visualization of interprocedural data-flow paths for source code reading	a lightweight visualization of interprocedural dataflow paths for source code reading	10.1109/ICPC.2012.6240506	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240506	T. Ishio; S. Etsuda; K. Inoue	Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan	2012 20th IEEE International Conference on Program Comprehension (ICPC)	16 jul. 2012	2012			37	46	To understand the behavior of a program, developers must read source code fragments in various modules. For developers investigating data-flow paths among modules, a call graph is too abstract since it does not visualize how parameters of method calls are related to each other. On the other hand, a system dependence graph is too fine-grained to investigate interprocedural data-flow paths. In this research, we propose an intermediate-level of visualization; we visualize interprocedural data-flow paths among method parameters and fields with summarized intraprocedural data-flow paths. We have implemented our visualization as an Eclipse plug-in for Java. The tool comprises a lightweight data-flow analysis and an interactive graph viewer using fractal value to extract a small subgraph of data-flow related to variables specified by a developer. A case study has shown our visualization enabled developers to investigate more data-flow paths in a fixed time slot. In addition, we report our lightweight data-flow analysis can generate precise data-flow paths for 98% of Java methods.	1092-8138	978-1-4673-1216-5		data-flow analysis;static analysis;software visualization;program comprehension	Visualization;Java;Approximation methods;Arrays;Control systems;Software;Data visualization	data flow analysis;data flow graphs;data visualisation;Java;reverse engineering;source coding	lightweight visualization;interprocedural data-flow paths;source code reading;program behavior understanding;source code fragments;call graph;system dependence graph;visualization intermediate-level;Eclipse plug-in;data-flow analysis;interactive graph viewer;fractal value;data-flow subgraph;Java methods		5	7	23		16 jul. 2012			IEEE	IEEE Conferences
Automatically detecting the quality of the query and its implications in IR-based concept location	automatically detecting the quality of the query and its implications in irbased concept location	10.1109/ASE.2011.6100144	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6100144	S. Haiduc	Department of Computer Science, Wayne State University, Detroit, MI, USA	2011 26th IEEE/ACM International Conference on Automated Software Engineering (ASE 2011)	12 Dec 2011	2011			637	640	Concept location is an essential task during software maintenance and in particular program comprehension activities. One of the approaches to this task is based on leveraging the lexical information found in the source code by means of Information Retrieval techniques. All IR-based approaches to concept location are highly dependent on the queries written by the users. An IR approach, even though good on average, might fail when the input query is poor. Currently there is no way to tell when a query leads to poor results for IR-based concept location, unless a considerable effort is put into analyzing the results after the fact. We propose an approach based on recent advances in the field of IR research, which aims at automatically determining the difficulty a query poses to an IR-based concept location technique. We plan to evaluate several models and relate them to IR performance metrics.	1938-4300	978-1-4577-1639-3		program comprehension;concept location;search;source code;information retrieval;query	Prediction algorithms;Correlation;Estimation;Conferences;Measurement;Search engines	query processing;software maintenance	information retrieval-based concept location;software maintenance;program comprehension activities;lexical information;source code;query quality		5		16		12 Dec 2011			IEEE	IEEE Conferences
My Repository Runneth Over: An Empirical Study on Diversifying Data Sources to Improve Feature Search	my repository runneth over an empirical study on diversifying data sources to improve feature search	10.1109/ICPC.2010.33	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521742	S. Ratanotayanon; H. J. Choi; S. E. Sim	Department of Informatics, University of California, Irvine, Irvine, USA; Department of Informatics, University of California, Irvine, Irvine, USA; Department of Informatics, University of California, Irvine, Irvine, USA	2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			206	215	Research on feature location that applies information retrieval techniques have experimented the kinds of inputs to the corpus and the algorithms that could be used. At first, only source code was used. Later extraction techniques were improved, and data from other software tools and analyses were used to expand or augment the repository. But, does having more diverse data in the repository always produce better results? In this paper, we report on an empirical study to examine the effect of increasing data diversity to improve feature location through search. In particular, we looked at the effect of including: i) change sets from revision control system, ii) tickets from issue trackers, and iii) elements from a Static Dependency Graph (SDG). We searched for three features of Jajuk, an open source Java jukebox, and two features of jEdit, an open source Java text editor. We used four different corpuses built with a combination of the above data. We used Eclipse's code search and an index built with source code as baseline conditions. We found that it is not always better to have more diverse data. Adding SDG data to change sets increased recall, but drove down precision. Adding data from issue trackers had little effect and in one case lowered recall. We also found that large-scale refactoring of the code decreases the effectiveness using change sets for feature location.	1092-8138	978-1-4244-7603-9		component;feature location;code search;program comprehension;change sets	Information retrieval;Control systems;Data mining;Software tools;Java;Vocabulary;Informatics;USA Councils;Large-scale systems;Software performance	data analysis;information retrieval;Java;public domain software;software maintenance	data source analysis;information retrieval techniques;source code;extraction techniques;software tools;data diversity;revision control system;static dependency graph;open source Java jukebox;Jajuk;open source Java text editor;jEdit;Eclipse code search;large-scale refactoring;feature location set research		5	1	27		26 jul. 2010			IEEE	IEEE Conferences
A Context-Driven Software Comprehension Process Model	a contextdriven software comprehension process model	10.1109/SOFTWARE-EVOLVABILITY.2006.1	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4032448	W. J. Meng; J. Rilling; Y. Zhang; R. Witte; S. Mudur; P. Charland	Department of Computer Science and Software Engineering, Concordia University, Montreal, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, Canada; System of Systems Section, Defence Research and Development Canada, Val-Belair, QUE, Canada	2006 Second International IEEE Workshop on Software Evolvability (SE'06)	19 Dec 2006	2006			50	57	Comprehension is an essential part of software evolution. Only software that is well understood can evolve in a controlled manner. In this paper, we present a formal process model to support the comprehension of software systems by using ontology and description logic. This formal representation supports the use of reasoning services across different knowledge resources and therefore, enables us to provide users with guidance during the comprehension process that is context sensitive to their particular comprehension task. As part of the process model, we also adopt a new interactive story metaphor, to represent the interactions between users and the comprehension process		0-7695-2698-5		Software evolution;program comprehension;process modeling;story metaphor;ontological reasoning	Context modeling;Ontologies;Logic;Software maintenance;Information resources;Computer science;Software engineering;Research and development;Software systems;Context-aware services	formal logic;ontologies (artificial intelligence);software architecture;software prototyping	context-driven software comprehension process model;software evolution;software systems;ontology;description logic;reasoning services;interactive story metaphor		5		29		19 Dec 2006			IEEE	IEEE Conferences
A Framework Profile of .NET	a framework profile of .net	10.1109/WCRE.2011.25	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6079837	R. Lammel; R. Linke; E. Pek; A. Varanovich	Software Languages Team & ADAPT Laboratory, Universität Koblenz-Landau, Germany; Software Languages Team & ADAPT Laboratory, Universität Koblenz-Landau, Germany; Software Languages Team & ADAPT Laboratory, Universität Koblenz-Landau, Germany; Software Languages Team & ADAPT Laboratory, Universität Koblenz-Landau, Germany	2011 18th Working Conference on Reverse Engineering	17 nov. 2011	2011			141	150	We develop a basic form of framework comprehension which is based on simple, reuse-related metrics for the as-implemented design and usage of frameworks. To this end, we provide a framework profile which incorporates potential reuse characteristics (e.g., specializability of types in a framework) as well as actual reuse characteristics (e.g., evidence of specialization of framework types in projects). We apply framework comprehension in an empirical study of the Microsoft. NET Framework. The approach is helpful in several contexts of software reverse and re-engineering.	2375-5369	978-1-4577-1948-6		framework;.NET;framework design;framework usage;framework profile;reuse;type specialization;late binding;polymorphism;inheritance;program comprehension;software metrics;dynamic program analysis	Measurement;Libraries;Concrete;Performance analysis;Open source software;Context	network operating systems;reverse engineering;software metrics;software reusability;systems re-engineering	framework profile;framework comprehension;reuse-related metrics;Microsoft;.NET framework;software reverse;software reengineering		5		24		17 nov. 2011			IEEE	IEEE Conferences
Understanding Large-Scale Software – A Hierarchical View	understanding largescale software – a hierarchical view	10.1109/ICPC.2019.00047	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813291	O. Levy; D. G. Feitelson	Department of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel; Department of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel	2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC)	29 Aug 2019	2019			283	293	Program comprehension accounts for a large portion of software development costs and effort. The academic literature contains research on program comprehension of short code snippets, but comprehension at the system level is no less important. We claim that comprehending a software system is a distinct activity that differs from code comprehension. We interview experienced developers, architects, and managers in the software industry and open-source community, to uncover the meaning of program comprehension at the system level. The interviews demonstrate, among other things, that system comprehension is detached from code and programming language, and includes scope that is not captured in the code. It focuses on the structure of the system and less on the code itself. This is a continuous, iterative process, which mixes white-box and black-box approaches at different layers of the system, and combines both bottom-up and top-down comprehension strategies.	2643-7171	978-1-7281-1519-1		system comprehension;program comprehension;top down;bottom up;white box;black box;design;architecture;source code;documentation;interview;large scale software	Interviews;Companies;Software systems;Unified modeling language;Programming profession	DP industry;project management;public domain software;reverse engineering;software development management;software engineering;software maintenance	academic literature;software development costs;program comprehension accounts;large-scale software;comprehension strategies;programming language;system comprehension;open-source community;software industry;interview experienced developers;code comprehension;distinct activity;software system;system level;short code snippets		5		35		29 Aug 2019			IEEE	IEEE Conferences
Towards Open Source Software System Architecture Recovery Using Design Metrics	towards open source software system architecture recovery using design metrics	10.1109/PCI.2011.36	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6065045	E. Constantinou; G. Kakarontzas; I. Stamelos	Computer Science Department, Aristotle University of Thessaloniki, Thessaloniki, Greece; Computer Science Department, Aristotle University of Thessaloniki, Thessaloniki, Greece; Computer Science Department, Aristotle University of Thessaloniki, Thessaloniki, Greece	2011 15th Panhellenic Conference on Informatics	3 nov. 2011	2011			166	170	Over the past years, software development practices include open source code reuse. Since documentation gives little or no information about the system architecture, a prohibitive amount of effort is required to comprehend the source code and the overall system architecture. In this paper, we investigate how design metrics can reveal architectural information about a software system and more specifically, how architectural layers are correlated to design metrics. Finally, we present an empirical study on two large open source systems written in Java, attempting to identify metrics revealing information about the system architecture.		978-1-61284-962-1		system understanding;program comprehension;object-oriented;reuse;architecture layer;design metrics	Measurement;Computer architecture;Correlation;Software architecture;Java;Software	Java;public domain software;software architecture;software metrics	open source software system architecture recovery;design metrics;software system architectural information;Java		5		13		3 nov. 2011			IEEE	IEEE Conferences
Feature Maps: A Comprehensible Software Representation for Design Pattern Detection	feature maps a comprehensible software representation for design pattern detection	10.1109/SANER.2019.8667978	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8667978	H. Thaller; L. Linsbauer; A. Egyed	Institute for Software Systems Engineering, Johannes Kepler University Linz, Austria; Institute for Software Systems Engineering, Johannes Kepler University Linz, Austria; Institute for Software Systems Engineering, Johannes Kepler University Linz, Austria	2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)	18 mar. 2019	2019			207	217	Design patterns are elegant and well-tested solutions to recurrent software development problems. They are the result of software developers dealing with problems that frequently occur, solving them in the same or a slightly adapted way. A pattern's semantics provide the intent, motivation, and applicability, describing what it does, why it is needed, and where it is useful. Consequently, design patterns encode a well of information. Developers weave this information into their systems whenever they use design patterns to solve problems. This work presents Feature Maps, a flexible human-and machine-comprehensible software representation based on micro-structures. Our algorithm, the Feature-Role Normalization, presses the high-dimensional, in homogeneous vector space of micro-structures into a feature map. We apply these concepts to the problem of detecting instances of design patterns in source code. We evaluate our methodology on four design patterns, a wide range of balanced and imbalanced labeled training data, and compare classical machine learning (Random Forests) with modern deep learning approaches (Convolutional Neural Networks). Feature maps yield robust classifiers even under challenging settings of strongly imbalanced data distributions without sacrificing human comprehensibility. Results suggest that feature maps are an excellent addition in the software analysis toolbox that can reveal useful information hidden in the source code.	1534-5351	978-1-7281-0591-8		feature maps;micro-structures;design patterns;machine learning;random forest;deep learning;convolutional neural networks;program comprehension;reverse engineering	Software;Machine learning;Graphics;Feature extraction;Semantics;Convolutional neural networks;Correlation	convolutional neural nets;learning (artificial intelligence);object-oriented methods;pattern classification;software engineering	Feature Maps;design pattern detection;recurrent software development problems;software developers;classical machine learning;random forests;deep learning approach;convolutional neural networks;feature-role normalization algorithm;human-machine-comprehensible software representation;software analysis toolbox		5		41		18 mar. 2019			IEEE	IEEE Conferences
Effectiveness of Flowcharting as a Scaffolding Tool to Learn Python	effectiveness of flowcharting as a scaffolding tool to learn python	10.1109/FIE.2018.8658891	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8658891	C. Cabo	Departments of Computer Systems, New York City College of Technology/CUNY, New York City, USA	2018 IEEE Frontiers in Education Conference (FIE)	7 mar. 2019	2018			1	7	This Research to Practice Full Paper evaluates the effectiveness of flowcharting as a scaffolding tool to learn a programming language like Python in the setting of an urban institution that serves mostly underrepresented minority students. We found that the abilities of students to solve problems using flowcharts is a good predictor of their ability to solve problems with Python (r-squared = 0.68). This means that the majority of students who perform well using flowcharts will perform well in Python. A majority of students found flowcharting easier than Python (63%), and reported that flowcharting helped them understand how to write programs in Python (73%). However, flowcharting is not a magic bullet for learning programming because about 31% of students have difficulty solving problems with a flowcharting tool (and Python). We also found that the ability of students to read code is not highly correlated with their ability to write code in Python. In conclusion: 1) For a majority of students flowcharting is an effective scaffolding tool to learn Python; 2) The ability to read and trace code is not predictive of the ability of students to solve problems and write viable programs in Python.	2377-634X	978-1-5386-1174-6		Flowcharting, Python, program comprehension, program generation, novice programmers, computer science education	Python;Flowcharts;Programming profession;Tools;Problem-solving	computer aided instruction;computer science education;educational institutions;flowcharting;programming languages;Python	Python;flowcharting tool;scaffolding tool;programming language;urban institution		5		23		7 mar. 2019			IEEE	IEEE Conferences
Reflexion Models for State Machine Extraction and Verification	reflexion models for state machine extraction and verification	10.1109/ICSME.2018.00025	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530025	W. Said; J. Quante; R. Koschke	Robert Bosch GmbH, Renningen, Germany; Robert Bosch GmbH, Renningen, Germany; University of Bremen, Bremen, Germany	2018 IEEE International Conference on Software Maintenance and Evolution (ICSME)	11 nov. 2018	2018			149	159	High-level design models are often used for describing the behavior or structure of a software system. It is generally much easier and more adequate to understand a software system on this level than on the level of individual code lines. Such models are also created by developers as they gain an understanding of the software. Unfortunately, these models often do not correspond to what is really in the code. Murphy et al. introduced the idea of reflexion models in 1995 to overcome this problem. Their approach is today widely used for architecture conformance checking and reconstruction. In this paper, we introduce reflexion models for state machines. Our approach allows to check the correspondence of a hypothetical state machine model with the code. It returns information about convergence, partial convergence, divergence, or absence of the specified states and transitions. Similar to the original reflexion model, the approach can be used for conformance checking as well as interactive reverse engineering of state machine models. We concentrate on the latter and show the potential of the approach in several case studies.	2576-3148	978-1-5386-7870-1		Software maintenance;program comprehension;state machines;reflexion model;model checking	Software;Computer architecture;Analytical models;Model checking;Cost accounting;Object oriented modeling;Tools	conformance testing;finite state machines;program verification;reverse engineering;software architecture;software maintenance	reflexion models;state machine extraction;high-level design models;software system;individual code lines;architecture conformance checking;state machines;hypothetical state machine model;specified states;original reflexion model;state machine models;interactive reverse engineering		4		31		11 nov. 2018			IEEE	IEEE Conferences
Ensuring Well-Behaved Usage of APIs through Syntactic Constraints	ensuring wellbehaved usage of apis through syntactic constraints	10.1109/ICPC.2008.12	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556139	M. Feilkas; D. Ratiu	Institut fur Informatik, Technische Universitat Munchen, Garching, Germany; Institut fur Informatik, Technische Universitat Munchen, Garching, Germany	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			248	253	Libraries are the most widespreaded form of software reuse. In order to properly use a library API, its clients should fulfill a series of (many times implicit) assumptions made by the API programmers. Failing to fulfill these assumptions leads to a misuse of the library and thereby to defects in the client's code. In this paper we present a method for checking a well-behaved usage of an API through a set of context-sensitive syntactic constraints over the API clients. These constraints restrict the set of programs that can be written with an API only to programs that fulfill the API assumptions and thereby represent a well-behaved and valid usage of the API. In this paper we present a set of typical assumption classes made by API providers about their clients. We define a framework for formalizing the context- sensitive constraints over the API client code and propose a typical constraint for each class of assumptions. Thereby we provide a mechanism that allows the provider of an API to describe the knowledge of how an API is intended to be used in an automatically checkable form. We present our experience with parts of the Java Standard APIs.	1092-8138	978-0-7695-3176-2		Syntactic Constraints;Static Analysis;Program Comprehension	Java;Software libraries;Packaging;Programming profession;Documentation;Testing;Computer bugs;Computer languages;Writing	application program interfaces	context-sensitive syntactic constraint;API client;application program interfaces		4		11		2 jul. 2008			IEEE	IEEE Conferences
Towards Better Symbol Resolution for C/C++ Programs: A Cluster-Based Solution	towards better symbol resolution for c/c++ programs a clusterbased solution	10.1109/SCAM.2017.15	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8090143	R. Szalay; Z. Porkoláb; D. Krupp	Faculty of Informatics, Eötvös Loránd University; NA; Ericsson Ltd.	2017 IEEE 17th International Working Conference on Source Code Analysis and Manipulation (SCAM)	2 nov. 2017	2017			101	110	Resolving symbol references is an important part of many application areas from development environments to various static analyser tools, especially when it is used for code comprehension purposes. Different occurrences of the same program elements, like function definitions and their call sites, variable declarations and their usage, or type definitions and their applications should be connected. In case of the C++ programming language, the most current tools use mangled names to correlate symbols, e.g. when implementing actions like "go to definition" or "list all references". However, for large projects, where multiple binaries are created, symbol resolution based on mangled names can be, and usually is, ambiguous. This leads to inaccurate behaviour even in major development tools. In this paper we explore the reason of this ambiguity, and propose our clustering algorithm based on essential build information to improve the accuracy of symbol resolution. We implemented our method as part of the CodeCompass open source code comprehension tool and measured its efficiency.	2470-6892	978-1-5386-3238-3		static analysis;program comprehension;code navigation;C++ programming language	Tools;C++ languages;Libraries;Correlation;Software systems	C++ language;object-oriented programming;pattern clustering;program diagnostics;public domain software;software maintenance	cluster-based solution;symbol references;development environments;static analyser tools;code comprehension purposes;program elements;function definitions;variable declarations;type definitions;mangled names;list all references;symbol resolution;development tools;clustering algorithm;CodeCompass open source code comprehension tool;C programs;call sites;C++ programming language;C++ programs		4		30		2 nov. 2017			IEEE	IEEE Conferences
A Taxonomy for Program Metamodels in Program Reverse Engineering	a taxonomy for program metamodels in program reverse engineering	10.1109/ICSME.2016.82	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7816453	H. Washizaki; Y. -G. Guéhéneuc; F. Khomh	National Institute of Informatics, Tokyo, Japan; PTIDEJ-SWAT, DGIGL Polytechnique Montréal, Quebec, Canada; PTIDEJ-SWAT, DGIGL Polytechnique Montréal, Quebec, Canada	2016 IEEE International Conference on Software Maintenance and Evolution (ICSME)	16 jan. 2017	2016			44	55	To support program comprehension, maintenance, and evolution, metamodels are frequently used during program reverse engineering activities to describe and analyze constituents of a program and their relations. Reverse engineering tools often define their own metamodels according to the intended purposes and features. Although each metamodel has its own advantages, its limitations may be addressed by other metamodels. Existing works have evaluated and compared metamodels and tools, but none have considered all the possible characteristics and limitations to provide a comprehensive guideline for classifying, comparing, reusing, and extending program metamodels. To aid practitioners and researchers in classifying, comparing, reusing, and extending program metamodels and their corresponding reverse engineering tools according to the intended goals, we establish a conceptual framework with definitions of program metamodels and related concepts. Then this framework is used to provide a comprehensive taxonomy, named Program Metamodel TAxonomy (ProMeTA), which incorporates newly identified characteristics into those stated in previous works, which were identified via a systematic literature survey on program metamodels, while keeping the orthogonality of the entire taxonomy. Additionally, we validate the taxonomy in terms of its orthogonality and usefulness through the classification of popular metamodels.		978-1-5090-3806-0		reverse engineering;program metamodels;program comprehension and analysis;taxonomy	Reverse engineering;Taxonomy;Unified modeling language;Biological system modeling;Syntactics;Grammar;Data mining	pattern classification;program diagnostics;reverse engineering;software maintenance	program reverse engineering tools;program comprehension;program maintenance;program evolution;comprehensive taxonomy;program metamodel taxonomy;ProMeTA		4		93		16 jan. 2017			IEEE	IEEE Conferences
Automated Documentation of Android Apps	automated documentation of android apps	10.1109/TSE.2018.2890652	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8598894	E. Aghajani; G. Bavota; M. Linares-Vásquez; M. Lanza	Università della Svizzera italiana (USI), Lugano, Switzerland; Università della Svizzera italiana (USI), Lugano, Switzerland; Universidad de los Andes, Bogotá, Colombia; Università della Svizzera italiana (USI), Lugano, Switzerland	IEEE Transactions on Software Engineering	8 jan. 2021	2021	47	1	204	220	Developers do not always have the knowledge needed to understand source code and must refer to different resources (e.g., teammates, documentation, the web). This non-trivial process, called program comprehension, is very time-consuming. While many approaches support the comprehension of a given code at hand, they are mostly focused on defining extractive summaries from the code (i.e., on selecting from a given piece of code the most important statements/comments to comprehend it). However, if the information needed to comprehend the code is not there, their usefulness is limited. We present ADANA, an approach to automatically inject comments describing a given piece of Android code. ADANA reuses the descriptions of similar and well-documented code snippets retrieved from various online resources. Our evaluation has shown that ADANA is able to aid the program comprehension process.	1939-3520		Schweizerischer Nationalfonds zur Förderung der Wissenschaftlichen Forschung(grant numbers:172799); 	Program comprehension;documentation;Android	Knowledge based systems;Documentation;Java;Cloning;Asia;Task analysis;Data mining	Android (operating system);document handling;Internet;mobile computing;program diagnostics;query processing;reverse engineering;software maintenance	program comprehension process;online resources;well-documented code snippets;Android code;ADANA;given piece;defining extractive summaries;given code;called program comprehension;nontrivial process;teammates;source code;android apps;automated documentation		4		71	IEEE	1 jan. 2019			IEEE	IEEE Journals
Debugging Data Flows in Reactive Programs	debugging data flows in reactive programs	10.1145/3180155.3180156	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453148	H. Banken; E. Meijer; G. Gousios	Delft University of Technology, Delft, The Netherlands; Delft University of Technology, Delft, The Netherlands; Delft University of Technology, Delft, The Netherlands	2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)	2 Sep 2018	2018			752	763	Reactive Programming is a style of programming that provides developers with a set of abstractions that facilitate event handling and stream processing. Traditional debug tools lack support for Reactive Programming, leading developers to fallback to the most rudimentary debug tool available: logging to the console. In this paper, we present the design and implementation of RxFiddle, a visualization and debugging tool targeted to Rx, the most popular form of Reactive Programming. RxFiddle visualizes the dependencies and structure of the data flow, as well as the data inside the flow. We evaluate RxFiddle with an experiment involving 111 developers. The results show that RxFiddle can help developers finish debugging tasks faster than with traditional debugging tools.	1558-1225	978-1-4503-5638-1		reactive programming;debugging;visualization;program comprehension	Debugging;Programming;Tools;Observers;Libraries;Companies;Interviews	program debugging;program visualisation	debugging tool;RxFiddle;data flow;debugging tasks;traditional debugging tools;stream processing;traditional debug tools;rudimentary debug tool;reactive programming		4		52		2 Sep 2018			IEEE	IEEE Conferences
Using Structured Queries for Source Code Search	using structured queries for source code search	10.1109/ICSME.2014.68	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6976112	B. P. Eddy; N. A. Kraft	University of Alabama, Tuscaloosa, AL, USA; ABB Corporate Research, Raleigh, NC, USA	2014 IEEE International Conference on Software Maintenance and Evolution	6 Dec 2014	2014			431	435	Software maintenance tasks such as feature location and traceability link recovery are search-oriented. Most of the recently proposed approaches for automation of search-oriented tasks are based on a traditional text retrieval (TR) model in which documents are unstructured representations of text and queries consist only of keywords. Because source code has structure, approaches based on a structured retrieval model may yield improved performance. Indeed, Saha et al. Recently proposed a feature location technique based on structured retrieval that offers improved performance relative to a technique based on traditional TR. Although they use abstract syntax tree (AST) information to structure documents, they nonetheless use content-only (keyword) queries to retrieve documents. In this paper we propose an approach to source code search using AST information to structure queries in addition to documents. Such queries, known as content and structure (CAS) queries, allow developers to search for source code entities based not only on content relevance, but also on structural similarity. After introducing the structured retrieval model, we provide examples that illustrate the trade-off between the simplicity of content-only queries and the power of CAS queries.	1063-6773	978-1-4799-6146-7		Software maintenance;program comprehension;text retrieval;structured document retrieval;static analysis	Accuracy;Software;Context;Computer bugs;Database languages;Search engines	computational linguistics;query processing;software maintenance;source code (software);text analysis	CAS queries;structural similarity;source code entities;AST information;abstract syntax tree;feature location technique;structured retrieval model;unstructured representations;TR model;text retrieval;search-oriented tasks;automation;traceability link recovery;software maintenance tasks;source code search;structured queries		4		9		6 Dec 2014			IEEE	IEEE Conferences
A New Software Maintenance Scenario Based on Refactoring Techniques	a new software maintenance scenario based on refactoring techniques	10.1109/CSMR.2012.41	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6178877	G. Villavicencio	Facultad de Matemática Aplicada, Universidad Católica de Santiago del Estero, Santiago del Estero, Argentina	2012 16th European Conference on Software Maintenance and Reengineering	5 Apr 2012	2012			341	346	This research line proposes the classification of refactoring techniques according to two opposite program properties: understanding and efficiency, being the former useful for maintenance while the latter for executing. Understanding-oriented refactoring and efficiency-oriented refactoring are considered the inverses of each other. Thus, through the application of the first sort of refactoring, understanding can be improved but efficiency can be affected. On the other hand, by applying the second sort of refactoring, efficiency can be improved but understanding can be damaged. So, the challenge to be faced here is to transform a software artifact through the application of a sequence of understanding-oriented refactoring, and to execute maintenance with the most appropriate version obtained. After that, we plan to restore its original efficiency by the application of the opposite sequence of refactorings, i.e. efficiency-oriented refactoring. In this way, a new maintenance scenario is outlined. Up to now, this ongoing research is being carried out in the functional setting.	1534-5351	978-0-7695-4666-7		Program transformation;reverse and forward refactorings;program comprehension and maintenance	Maintenance engineering;Equations;Particle separators;Radiation detectors;Mathematical model;Context;Reverse engineering	software maintenance	software maintenance scenario;understanding-oriented refactoring technique;efficiency-oriented refactoring technique;software artifact;maintenance execution;program comprehension;software comprehension		4		21		5 Apr 2012			IEEE	IEEE Conferences
A Visualization Framework for Parallelization	a visualization framework for parallelization	10.1109/VISSOFT.2016.35	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780161	A. Wilhelm; V. Savu; E. Amadasun; M. Gerndt; T. Schuele	Technische Unversität München; Technische Unversität München; Technische Unversität München; Technische Unversität München; Siemens Corporate Technology	2016 IEEE Working Conference on Software Visualization (VISSOFT)	12 Dec 2016	2016			81	85	Since the advent of multicore processors, developers struggle with the parallelization of legacy software. Automatic methods are only appropriate to identify parallelism at instruction level or within simple loops. For most applications, however, a scalable redesign require profound comprehension of the underlying software architecture and its dynamic aspects. This leads to an increasing demand for interactive tools that foster parallelization at various granularity levels. To cope with this problem, we propose a visualization framework, and three tailored views for parallelism detection. The framework is part of Parceive, a tool that utilizes dynamic binary instrumentation to trace C/C++ and C# programs. The cooperative views allow identification and analysis of potential parallelism scenarios using seamless navigation, abstraction, and filtering. In this paper, we motivate our approach, illustrate the architecture of the visualization framework, and highlight the key features of the views. A case study demonstrates the usefulness of Parceive.		978-1-5090-3850-3		Parallelization;Trace analysis;Software visualization;Program comprehension	Software;Data visualization;Optimization;Runtime;Loading;Pipeline processing	data visualisation;multiprocessing systems;parallel programming;software architecture;software maintenance;software tools	visualization framework;multicore processors;legacy software parallelization;software architecture;dynamic aspects;interactive tools;granularity levels;parallelism detection;Parceive;dynamic binary instrumentation;C# programs;seamless navigation		4		12		12 Dec 2016			IEEE	IEEE Conferences
Enhancing Software Visualization with Information Retrieval	enhancing software visualization with information retrieval	10.1109/iV.2015.42	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7272600	R. Francese; M. Risi; G. Scanniello	University of Salerno, Italy; University of Salerno, Italy; University of Basilicata, Italy	2015 19th International Conference on Information Visualisation	21 Sep 2015	2015			189	194	I have enhanced Metric Attitude. It is a visualization tool based on static analysis that provides a mental picture by viewing an object-oriented software system by means of polymetric views. In particular, we have integrated an Information Retrieval engine and named this new version of visualization tool as Metric Attitude++. It allows the user to formulate a textual query and to show on the visual representation of the subject software the elements that are more similar to that query. This could be useful in all those cases in which a user needs to identify (or to localize) features implemented in the source code. Several filters are also available to hide possibly irrelevant details and to ease the browsing and then the comprehension of a software system. Finally, we have applied Metric Attitude++ on a number of object-oriented software systems. In this paper, we report preliminary results of a quantitative study on a widely studied open-source software, namely JEdit. On the basis of our results it seems that Metric Attitude++ can be effectively applied to different kinds of source code comprehension tasks and to concept location in source code, in particular.	2375-0138	978-1-4673-7568-9		Information Retrieval;Program Comprehension;Reverse Engineering;Software Evolution;Software Mainte-nance;Software Metrics;Software Visualization	Visualization;Measurement;Software systems;Context;Color;Navigation	object-oriented programming;program diagnostics;program visualisation;public domain software;query processing;source code (software)	software visualization;information retrieval;static analysis;object-oriented software system;visualization tool;Metric Attitude++;textual query formulation;source code;open-source software;JEdit		4		25		21 Sep 2015			IEEE	IEEE Conferences
Visualizing Software Structure Understandability	visualizing software structure understandability	10.1109/ASWEC.2014.17	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6824115	P. Dugerdil; M. Niculescu	Geneva School of Business Administration, Univ. of Applied Sciences of Western Switzerland, Geneva, Switzerland; Geneva School of Business Administration, Univ. of Applied Sciences of Western Switzerland, Geneva, Switzerland	2014 23rd Australian Software Engineering Conference	5 jun. 2014	2014			110	119	Software architecture design is known to be driven by the quality attributes we may want to satisfy. Among them, modifiability plays an important role since software maintenance takes the lion's share in the software development costs. However, to successfully maintain a legacy system, the latter must be sufficiently understood so that the maintenance team will not introduce new bugs when correcting others. Then we present a software metric that we called the Autonomy Ratio (AR). We show this dynamic metric to be a good indicator of the system's structure understandability. Since we end up with hundreds of values for a single system, we represent these values as a hierarchical map: the "Autonomy Ratio Map". The contribution of the paper is to link the AR metric with theories of software comprehension, to show how the AR Map helps in assessing software structure understand-debility, and to present an empirical validation of it.	2377-5408	978-1-4799-3149-1		program comprehension;software metrics;software visualization;dynamic analysis;software architecture	Software;Measurement;Collaboration;Couplings;Maintenance engineering;Color;Business	data visualisation;software architecture;software maintenance;software metrics;software quality	software structure understandability visualization;software architecture design;quality attributes;modifiability;software maintenance;software development costs;legacy system;software metric;autonomy ratio map;dynamic metric;system structure understandability;hierarchical map;AR metric;software comprehension;AR map;software structure understand-debility assessment		4		39		5 jun. 2014			IEEE	IEEE Conferences
The Evaluation of an Approach for Automatic Generated Documentation	the evaluation of an approach for automatic generated documentation	10.1109/ICSME.2017.76	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8094431	N. Abid; N. Dragan; M. L. Collard; J. I. Maletic	Department of Computer Science, Kent State University, Kent, Ohio; Department of Management and Information Systems, Kent State University, Kent, Ohio, USA; Department of Computer Science, The University of Akron, Akron, Ohio; Department of Management and Information Systems, Kent State University, Kent, Ohio, USA	2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)	7 nov. 2017	2017			307	317	Two studies are conducted to evaluate an approach to automatically generate natural language documentation summaries for C++ methods. The documentation approach relies on a method's stereotype information. First, each method is automatically assigned a stereotype(s) based on static analysis and a set of heuristics. Then, the approach uses the stereotype information, static analysis, and predefined templates to generate a natural-language summary/documentation for each method. This documentation is automatically added to the code base as a comment for each method. The result of the first study reveals that the generated documentation is accurate, does not include unnecessary information, and does a reasonable job describing what the method does. Based on statistical analysis of the second study, the most important part of the documentation is the short description as it describes the intended behavior of a method.		978-1-5386-0992-7		source-code summarization;program comprehension;method stereotypes;static analysis	Documentation;Static analysis;Java;Pragmatics;C++ languages	C++ language;natural language processing;program diagnostics;statistical analysis;system documentation	automatic generated documentation;natural language documentation summaries;C++ methods;stereotype information;static analysis;statistical analysis		4		29		7 nov. 2017			IEEE	IEEE Conferences
Towards a Taxonomy of Programming-Related Difficulties during Maintenance	towards a taxonomy of programmingrelated difficulties during maintenance	10.1109/ICSM.2013.63	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6676923	A. Yamashita; L. Moonen	Mesan AS & Simula Research Laboratory, Oslo, Norway; Simula Research Laboratory, Oslo, Norway	2013 IEEE International Conference on Software Maintenance	2 Dec 2013	2013			424	427	Empirical studies that investigate the relationship between source code characteristics and maintenance outcomes rarely use causal models to explain the relations between the code characteristics and the outcomes. We conjecture that the lack of a comprehensive catalogue of programming-related difficulties and their effects on different maintenance outcomes is one of the reasons behind this. This paper takes the first step in addressing this situation based on empirical evidence collected in a longitudinal maintenance study on four systems. Professional developers were hired to implement a number of changes in each of the systems. These activities were observed in detail over a period of 7 weeks, during which we recorded on a daily basis what specific problems they faced. The collected data was transcribed and analyzed using open and axial coding. Based on an analysis of these results, we propose a preliminary taxonomy to describe the programming-related difficulties that developers face during maintenance. Our intention is not to replace the existing categorizations/taxonomies, but to take the first steps towards an integrated, comprehensive catalogue by aligning our empirical observations and the earlier literature.	1063-6773	978-0-7695-4981-1		maintainability;maintenance difficulties;maintenance problems;program comprehension;empirical study	Maintenance engineering;Taxonomy;Software maintenance;Programming;Complexity theory;Encoding	data analysis;software maintenance	programming-related difficulties taxonomy;source code characteristics;source code maintenance outcomes;data collection;open coding;axial coding;software system;software engineering		4		21		2 Dec 2013			IEEE	IEEE Conferences
Studying the Advancement in Debugging Practice of Professional Software Developers	studying the advancement in debugging practice of professional software developers	10.1109/ISSREW.2014.36	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6983851	B. Siegmund; M. Perscheid; M. Taeumel; R. Hirschfeld	Hasso Plattner Institute University Potsdam, Potsdam, Germany; SAP Innovation Center, Potsdam, Germany; Hasso Plattner Institute University Potsdam, Potsdam, Germany; Hasso Plattner Institute University Potsdam, Potsdam, Germany	2014 IEEE International Symposium on Software Reliability Engineering Workshops	15 Dec 2014	2014			269	274	In 1997, Henry Lieberman stated that debugging is the dirty little secret of computer science. Since then, several promising debugging technologies have been developed such as back-in-time debuggers and automatic fault localization methods. However, the last study about the state-of-the-art in debugging is still more than 15 years old and so it is not clear whether these new approaches have been applied in practice or not. For that reason, we investigate the current state of debugging in a new comprehensive study. First, we review the available literature and learn about current approaches and study results. Second, we observe several professional developers while debugging and interview them about their experiences. Based on these results, we create a questionnaire that should serve as the basis for a large-scale online debugging survey later on. With these results, we expect new insights into debugging practice that help to suggest new directions for future research.		978-1-4799-7377-4		Debugging;Survey;Empirical Study;Program Comprehension	Debugging;Companies;Software;Computer bugs;Navigation;Java;Education	computer operating procedures;computer science;DP management;program debugging;software engineering	debugging practice;professional software developers;computer science;debugging technologies;back-in-time debuggers;automatic fault localization methods;large-scale online debugging		4		41		15 Dec 2014			IEEE	IEEE Conferences
Documenting and sharing knowledge about code	documenting and sharing knowledge about code	10.1109/ICSE.2012.6227043	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227043	A. Guzzi	Software Engineering Research Group, Delft University of Technology, Delft, Netherlands	2012 34th International Conference on Software Engineering (ICSE)	28 jun. 2012	2012			1535	1538	Software engineers spend a considerable amount of time on program comprehension. Current research has primarily focused on assisting the developer trying to build up his understanding of the code. This knowledge remains only in the mind of the developer and, as time elapses, often “disappears”. In this research, we shift the focus to the developer who is using her Integrated Development Environment (IDE) for writing, modifying, or reading the code, and who actually understands the code she is working with. The objective of this PhD research is to seek ways to support this developer to document and share her knowledge with the rest of the team. In particular, we investigate the full potential of micro-blogging integrated into the IDE for addressing the program comprehension problem.	1558-1225	978-1-4673-1067-3		Program comprehension;micro-blogging;IDEs;recommender systems;CSCW	Software;USA Councils;Recommender systems;History;Context;Programming;Prototypes	groupware;recommender systems;reverse engineering;software maintenance;Web sites	software engineers;program comprehension;integrated development environment;IDE;micro-blogging;recommender systems;CSCW;knowledge documentation;knowledge sharing;software maintenance		4		19		28 jun. 2012			IEEE	IEEE Conferences
An Interprocedural Aspect Control Flow Graph to Support the Maintenance of Aspect Oriented Systems	an interprocedural aspect control flow graph to support the maintenance of aspect oriented systems	10.1109/ICSM.2007.4362656	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362656	M. L. Bernardi; G. A. di Lucca	Research Center on Software Technology (RCOST), University of Sannio, Italy; Research Center on Software Technology (RCOST), University of Sannio	2007 IEEE International Conference on Software Maintenance	22 Oct 2007	2007			435	444	Aspect oriented programming (AOP) supports the cross-cutting of concerns by means of aspects. The maintenance of AO systems may be more difficult than 'traditional' ones, due to the large impact that aspects have on the static structure and dynamic behavior of the overall system. In this paper an inter-procedural aspect control flow graph is proposed to represent the interactions among the aspects and the object oriented (OO) components of an AO system. The graph allows an easier identification of the impact between aspects and the OO components. It helps the maintainer to identify sources of undesired side and ripple effects in the code and avoid the introduction of new ones when modifying an AOP system.	1063-6773	978-1-4244-1255-6		Software maintenance;Aspect Oriented Programming;program comprehension;reverse engineering	Control systems;Flow graphs;Weaving;Software maintenance;Dynamic programming;Reverse engineering;Logic;Software systems;Joining processes	flow graphs;object-oriented programming;software maintenance	interprocedural aspect control flow graph;aspect oriented programming;AOP system maintenance;object oriented components		4		22		22 Oct 2007			IEEE	IEEE Conferences
D-Cube: Tool for Dynamic Design Discovery from Multi-threaded Applications Using PIN	dcube tool for dynamic design discovery from multithreaded applications using pin	10.1109/QRS.2016.13	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7589781	S. Majumdar; N. Chatterjee; S. R. Sahoo; P. P. Das	Advanced Technology Development Centre, Indian Institute of Technology, Kharagpur; A. K. Choudhury School of Information Technology, University of Calcutta, Kolkata; School of Information Technology, Indian Institute of Technology, Kharagpur; Department of Computer Science and Engineering, Indian Institute of Technology, Kharagpur	2016 IEEE International Conference on Software Quality, Reliability and Security (QRS)	13 Oct 2016	2016			25	32	Program comprehension is a major challenge for system maintenance. Reverse engineering has been employed for control-flow analysis of applications but not much work has been done for comprehending concurrent non-deterministic behavior of multi-threaded applications. We present D-CUBE, built using dynamic instrumentation APIs, which plugs in during execution and infers various thread models like concurrency, safety, data access, thread-pool state, exception model etc. for multi-threaded applications at runtime. We extract run-time events traced according to pre-specified logic and feed them to decision trees for inference. We use 3 benchmark suites (LOC: 50-3200) -- CDAC Pthreads benchmark [1] (18 Cases), Open POSIX Test-Suites [2] (21 Cases) and PARSEC 3.0 benchmarks [3] (3 Cases) for accuracy and volume testing and validate our approach by comparing the documented behavior of test-suites with D-CUBE's output models. We achieve over 90% accuracy. D-CUBE produces graphical event-traces with every inference for quick and effective comprehension of large code.		978-1-5090-4127-5		Concurrency Models;Multi-threaded Program Analysis;Dynamic Instrumentation;Execution Patterns;Program Comprehension;Reverse-Engineering	Concurrent computing;Feature extraction;Instruction sets;Benchmark testing;Pins;Data models;Instruments	application program interfaces;concurrency (computers);decision trees;multi-threading;program testing;reverse engineering;software maintenance	D-Cube;dynamic design discovery;multithreaded applications;PIN;program comprehension;system maintenance;reverse engineering;control-flow analysis;dynamic instrumentation APIs;decision trees;CDAC Pthreads benchmark;Open POSIX Test-Suites;PARSEC 3.0 benchmarks;volume testing;graphical event-traces		3		23		13 Oct 2016			IEEE	IEEE Conferences
Automated Slicing of Aspect-Oriented Programs Using Bytecode Analysis	automated slicing of aspectoriented programs using bytecode analysis	10.1109/COMPSAC.2015.98	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7273618	D. Munjal; J. Singh; S. Panda; D. P. Mohapatra	Department of CSE, NIT, Rourkela, INDIA; Department of CSE, NIT, Rourkela, INDIA; Department of CSE, NIT, Rourkela, INDIA; Department of CSE, NIT, Rourkela, INDIA	2015 IEEE 39th Annual Computer Software and Applications Conference	24 Sep 2015	2015	2		191	199	Program slicing has numerous applications in software engineering activities like debugging, testing, maintenance, model checking etc. The main objective of this paper is to automate the generation of System Dependency Graphs (SDG) for aspect-oriented programs to efficiently compute accurate slices. The construction of SDG is automated by analysing the byte code of aspect-oriented programs that incorporates the representation of aspect-oriented features. After constructing the SDG, we propose a slicing algorithm that uses the intermediate graph and computes slices for a given AOP. To implement our proposed slicing technique, we have developed a prototype tool that takes an AOP as input and compute its slices using our proposed slicing algorithm. To evaluate our proposed technique, we have considered some case studies by taking open source projects. The comparative study of our proposed slicing algorithm with some existing algorithms show that our approach is an efficient and scalable approach of slicing for different applications with respect to aspect-oriented programs.	0730-3157	978-1-4673-6564-2		Program Slicing;intermediate graph;aspects;Aspect-Oriented Program;weaving;program comprehension	Weaving;Algorithm design and analysis;Debugging;Complexity theory;Programming;Heuristic algorithms;Computers	aspect-oriented programming;graph theory;program slicing;public domain software;systems analysis	program slicing;aspect-oriented program;bytecode analysis;system dependency graph;SDG;open source project		3		16		24 Sep 2015			IEEE	IEEE Conferences
Labeling Feature-Oriented Software Clusters for Software Visualization Application	labeling featureoriented software clusters for software visualization application	10.1109/APSEC.2015.32	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7467321	K. Yano; A. Matsuo	Information Systems Technologies Laboratory, Fujitsu Laboratories, Kawasaki, Japan; Information Systems Technologies Laboratory, Fujitsu Laboratories, Kawasaki, Japan	2015 Asia-Pacific Software Engineering Conference (APSEC)	12 May 2016	2015			354	361	Software clustering techniques have been used to analyze the reality of software structure. The visualization of the detected clusters has also been studied. However, the features implemented by the detected clusters are not obvious and understanding them is a crucial part of the industrial use of software clustering. In this study, we examined the existing information retrieval method and found three major issues it has. We developed technical solutions for each of them: using hierarchical labeling, weighing the words likely representing the feature by considering an architectural convention, and modifying the idf score by the scale of the cluster. The effectiveness of our approach is validated through case studies using actual software products including a COBOL business application. Also, we faced two additional practical problems: effectiveness of the method words and plural and conjugated forms of the words. We found the method name words were less useful than the class name words, and lemmatization was successfully used to normalize the form of the words even in the case of program identifiers.	1530-1362	978-1-4673-9644-8		software maintenance;software clustering;program comprehension;software visualization	Visualization;Labeling;Urban areas;Feature extraction;Business;Software systems	COBOL;feature extraction;information retrieval;pattern clustering;program visualisation;software engineering;software maintenance	program identifiers;class name words;conjugated forms;COBOL business application;software products;idf score;architectural convention;hierarchical weighing;hierarchical labeling;information retrieval method;software structure reality;software clustering techniques;software visualization application;feature-oriented software cluster labeling		3		16		12 May 2016			IEEE	IEEE Conferences
Measuring the Complexity of Traces Using Shannon Entropy	measuring the complexity of traces using shannon entropy	10.1109/ITNG.2008.169	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4492527	A. Hamou-Lhadj	Department of Electrical and Computer Engineering, Concordia University, Montreal, QUE, Canada	Fifth International Conference on Information Technology: New Generations (itng 2008)	18 Apr 2008	2008			489	494	Exploring the content of large execution traces can be a tedious task without efficient tool support. Building efficient trace analysis tools, however, requires a good understanding of the complexity embedded in traces. Trace complexity has traditionally been measured using the file size or the number of lines in the trace. In this paper, we argue that these metrics provide limited indication of the effort required to understand the content of a trace. We address this issue by introducing new trace complexity metrics based on the concept of entropy. Our metrics measure two important aspects of an execution trace: repeatability and variability. We present a case study where we apply the metrics to several execution traces. A discussion on how we can reduce the complexity of a trace based on these metrics is also presented.		978-0-7695-3099-4		Dynamic analysis;trace complexity;Shannon entropy;program comprehension;software maintenance	Entropy;Size measurement;Information technology;Electric variables measurement;Software maintenance;Information theory;Filtering;Software systems	information theory;program diagnostics;software metrics	trace complexity measures;Shannon entropy;trace analysis tools;repeatability aspect;variability aspect;information theory		3		15		18 Apr 2008			IEEE	IEEE Conferences
From Obfuscation to Comprehension	from obfuscation to comprehension	10.1109/ICPC.2015.27	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181445	E. Avidan; D. G. Feitelson	School of Computer Science and Engineering The Hebrew University of Jerusalem, Jerusalem, Israel; School of Computer Science and Engineering The Hebrew University of Jerusalem, Jerusalem, Israel	2015 IEEE 23rd International Conference on Program Comprehension	7 Sep 2015	2015			178	181	Code obfuscation techniques are widely used in industry to increase protection of source code and intellectual property. The idea is that even if attackers gain hold of source code, it will be hard for them to understand what it does and how. Thus obfuscation techniques are specifically targeted at human comprehension of code. We suggest that the ideas and experience embedded in obfuscations can be used to learn about comprehension. In particular, we survey known obfuscation techniques and use them in an attempt to derive metrics for code (in) comprehensibility. This leads to emphasis on issues such as identifier naming, which are typically left on the sidelines in discussions of code comprehension, and motivates increased efforts to measure their effect.	1092-8138	978-1-4673-8159-8		Code obfuscation;Code complexity metrics;Program comprehension	Measurement;Complexity theory;Software;Layout;Context;Java;Conferences	program compilers;software metrics;source code (software)	code obfuscation techniques;source code;intellectual property;human comprehension;derive metrics;code comprehensibility		3		17		7 Sep 2015			IEEE	IEEE Conferences
Toward Automatic Summarization of Arbitrary Java Statements for Novice Programmers	toward automatic summarization of arbitrary java statements for novice programmers	10.1109/ICSME.2018.00063	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530061	M. Hassan; E. Hill	Drew University, Madison, NJ; Drew University, Madison, NJ	2018 IEEE International Conference on Software Maintenance and Evolution (ICSME)	11 nov. 2018	2018			539	543	Novice programmers sometimes need to understand code written by others. Unfortunately, most software projects lack comments suitable for novices. The lack of comments have been addressed through automated techniques of generating comments based on program statements. However, these techniques lacked the context of how these statements function since they were aimed toward experienced programmers. In this paper, we present a novel technique towards automatically generating comments for Java statements suitable for novice programmers. Our technique not only goes beyond existing approaches to method summarization to meet the needs of novices, it also leverages API documentation when available. In an experimental study of 30 computer science undergraduate students, we observed explanations based on our technique to be preferred over an existing approach.	2576-3148	978-1-5386-7870-1		Java;Automatic Summarization;Novice Program Comprehension	Documentation;Java;Computer bugs;Current measurement;Switches;Conferences;Software maintenance	application program interfaces;Java;software engineering	program statements;experienced programmers;generating comments;novice programmers;toward automatic summarization;arbitrary Java statements;automated techniques		3		20		11 nov. 2018			IEEE	IEEE Conferences
SourceMiner Evolution: A Tool for Supporting Feature Evolution Comprehension	sourceminer evolution a tool for supporting feature evolution comprehension	10.1109/ICSM.2013.83	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6676944	R. L. Novais; C. Nunes; A. Garcia; M. Mendonça	Inf. Technol. Dept., Fed. Inst. of Bahia, Santo Amaro, Brazil; Informatics Department-PUC-Rio, Software Engineering Lab, Rio de Janeiro, Brazil; Pontificia Universidade Catolica do Rio de Janeiro, Rio de Janeiro, RJ, BR; Fraunhofer Project Center for Software and Systems Engineering, UFBA, Brazil	2013 IEEE International Conference on Software Maintenance	2 Dec 2013	2013			508	511	Program comprehension is an essential activity to perform software maintenance and evolution. Comprehensibility often encompasses the analysis of individual logical units, called features, which are often scattered through many program modules. Understanding how the feature code is implemented along the software evolution history is essential, for instance, to perform refactoring activities. However, existing tools do not provide means to comprehend the feature code evolution. To overcome this shortcoming, this paper presents a tool called Source Miner Evolution (SME) that provides multiple interactive and coordinated views to comprehend feature code evolution. SME implements a feature-sensitive comparison of multiple program versions. Our usability assessment with experienced developers indicated that SME allows them to efficiently perform recurring comprehension tasks on evolving feature code. The developers' performance was influenced by the combination of visual SME mechanisms, such as colors, tool tips and menu-popup interactions over the features' code elements.	1063-6773	978-0-7695-4981-1		program comprehension;feature evolution;software visualization	Visualization;Color;Software systems;Feature extraction;Couplings;History	software maintenance;software reusability	usability assessment;SME;source miner evolution;software evolution;software maintenance;program comprehension;feature evolution comprehension		3		16		2 Dec 2013			IEEE	IEEE Conferences
Feature Location Using Data Mining on Existing Test-Cases	feature location using data mining on existing testcases	10.1109/WCRE.2012.25	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385111	C. Ziftci; I. Krüger	Department of Computer Science and Engineering, University of California, San Diego, La Jolla, CA, USA; Department of Computer Science and Engineering, University of California, San Diego, La Jolla, CA, USA	2012 19th Working Conference on Reverse Engineering	20 Dec 2012	2012			155	164	Feature location is the mapping of features onto static artifacts such as source code and configuration files. Recent effective feature location methods use dynamic-analysis and scenarios, i.e. executable use-cases that represent features in source code. Almost all of these techniques require that a distinct scenario is created for every feature, which puts a great burden on developers due to the inherent manual work that needs to be carried out. First, since scenarios are typically created and exercised manually, the act of locating features is not easily repeatable as software evolves. Second, there may be dependencies between features, which will be reflected on the collected execution traces during scenario execution. For existing feature location methods to perform well, developers typically need to mark the execution traces manually to specify which parts of it exactly represent each feature. In this work, we free developers of the manual process of creating scenarios by using association rule learning on a set of labeled test-cases, i.e. test-cases labeled with the features they exercise in the existing test-suite of the system, to locate features in source code. We also provide an evaluation of our method on three case studies and compare it with a well-known feature location technique that uses probabilistic ranking. Our method achieves results within 83-97% of the probabilistic ranking method on the case studies without any need to create scenarios as in the existing dynamic-analysis based feature location techniques.	2375-5369	978-0-7695-4891-3		feature location;program features;data mining;program comprehension;software maintenance;reverse engineering	Association rules;Graphical user interfaces;Software;Reliability;Manuals;Servers	data mining;probability;software maintenance;system monitoring	feature location;data mining;test-cases;feature mapping;static artifact;source code;configuration file;dynamic analysis;software evolution;association rule learning;probabilistic ranking		3		27		20 Dec 2012			IEEE	IEEE Conferences
Exploring Theory of Cognition for General Theory of Software Engineering	exploring theory of cognition for general theory of software engineering	10.1109/GTSE.2015.9	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7169390	P. Johnson; M. Ekstedt	KTH Royal Institute of Technology, Stockholm, Sweden; KTH Royal Institute of Technology, Stockholm, Sweden	2015 IEEE/ACM 4th SEMAT Workshop on a General Theory of Software Engineering	30 jul. 2015	2015			15	24	In recent years, there has been significant interest in general theories of software engineering. In this article, we explore the utility of a theory of cognition, ACT-R, as a component of such a general theory. The ACT-R theory was instantiated to predict the effort of programming language comprehension for two cases: (i) a C program, and (ii) the corresponding Assembly program. An experiment was then conducted to generate empirical data on the two comprehension tasks. The theoretical predictions were compared to the empirical results. The theoretical model predicted that the effort of understanding the considered program in C is 37% of the effort of understanding a comparable program written in Assembly. The experiment generated 33% as the corresponding percentage number. The concordance between theoretical model and experimental data was surprisingly high, encouraging further investigations into the utility of cognitive theories in software engineering.		978-1-4673-7052-3		ACT-R;Programming Language;General Theory of Software Engineering;Program Comprehension	Production;Computer languages;Assembly;Software engineering;Cognition;Computers;Predictive models	assembly language;C language;cognitive systems;program assemblers	cognition theory;software engineering;ACT-R;programming language comprehension;C program;Assembly program		3		23		30 jul. 2015			IEEE	IEEE Conferences
STAN: Towards Describing Bytecodes of Smart Contract	stan towards describing bytecodes of smart contract	10.1109/QRS51102.2020.00045	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9282282	X. Li; T. Chen; X. Luo; T. Zhang; L. Yu; Z. Xu	Department of Computing, The Hong Kong Polytechnic University, China; Center for Cybersecurity, University of Electronic Science and Technology of China, Chengdu, China; Department of Computing, The Hong Kong Polytechnic University, China; Faculty of Information Technology, Macau University of Science and Technology, China; Department of Computing, The Hong Kong Polytechnic University, China; School of Big Data and Software Engineering, Chongqing University, Chongqing, China	2020 IEEE 20th International Conference on Software Quality, Reliability and Security (QRS)	11 Dec 2020	2020			273	284	More than eight million smart contracts have been deployed into Ethereum, which is the most popular blockchain that supports smart contract. However, less than 1% of deployed smart contracts are open-source, and it is difficult for users to understand the functionality and internal mechanism of those closed-source contracts. Although a few decompilers for smart contracts have been recently proposed, it is still not easy for users to grasp the semantic information of the contract, not to mention the potential misleading due to decompilation errors. In this paper, we propose the first system named Stan to generate descriptions for the bytecodes of smart contracts to help users comprehend them. In particular, for each interface in a smart contract, Stan can generate four categories of descriptions, including functionality description, usage description, behavior description, and payment description, by leveraging symbolic execution and NLP (Natural Language Processing) techniques. Extensive experiments show that Stan can generate adequate, accurate and readable descriptions for contract's bytecodes, which have practical value for users.		978-1-7281-8913-0	National Natural Science Foundation of China; 	Smart contract;Ethereum;Program comprehension	Smart contracts;Semantics;Software quality;Tools;Natural language processing;Software reliability;Security	blockchains;contracts;information retrieval;Internet;Java;natural language processing;public domain software	smart contract;closed-source contracts;STAN;Ethereum;NLP technique;natural language processing;symbolic execution;functionality description;usage description;behavior description;payment description;blockchain		3		64		11 Dec 2020			IEEE	IEEE Conferences
Automatic Derivation of Concepts Based on the Analysis of Source Code Identifiers	automatic derivation of concepts based on the analysis of source code identifiers	10.1109/WCRE.2010.45	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5645490	L. Guerrouj	DGIGL-SOCCER Laboratory, Ptidej Team, Ecole Polytechnique de Montrèal, Quebec, Canada	2010 17th Working Conference on Reverse Engineering	29 nov. 2010	2010			301	304	The existing software engineering literature has empirically shown that a proper choice of identifiers influences software understandability and maintainability. Indeed, identifiers are developers' main up-to-date source of information and guide their cognitive processes during program understanding when the high-level documentation is scarce or outdated and when the source code is not sufficiently commented. Deriving domain terms from identifiers using high-level and domain concepts is not an easy task when naming conventions (e.g., Camel Case) are not used or strictly followed and-or when these words have been abbreviated or otherwise transformed. Our thesis is to develop an approach that overcomes the shortcomings of the existing approaches and maps identifiers to domain concepts even in the absence of naming conventions and-or the presence of abbreviations. Our approach uses a thesaurus of words and abbreviations to map terms or transformed words composing identifiers to dictionary words. It relies on an oracle that we manually build for the validation of our results. To evaluate our technique, we apply it to derive concepts from identifiers of different systems and open source projects. We also enrich it by the use of domain knowledge and context-aware dictionaries to analyze how sensitive are its performances to the use of contextual information and specialized knowledge.	2375-5369	978-1-4244-8911-4		Identifier Splitting;Program Comprehension;Linguistic Analysis;Software Quality	Dictionaries;Software;Conferences;Thesauri;Presses;Buildings;Speech recognition	software maintenance;system documentation	automatic derivation;source code identifiers;software engineering;software understandability;software maintainability;cognitive processes;program understanding;high-level documentation;maps identifiers;domain concepts;naming conventions		3		21		29 nov. 2010			IEEE	IEEE Conferences
Towards intelligent search support for web services evolution identifying the right abstractions	towards intelligent search support for web services evolution identifying the right abstractions	10.1109/WSE.2011.6081819	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6081819	T. Reichherzer; E. El-Sheikh; N. Wilde; L. White; J. Coffey; S. Simmons	University of West Florida, Pensacola, FL, USA; University of West Florida, Pensacola, FL, USA; University of West Florida, Pensacola, FL, USA; University of West Florida, Pensacola, FL, USA; University of West Florida, Pensacola, FL, USA; Department of Computer Science, James Madison University, Harrisonburg, VA, USA	2011 13th IEEE International Symposium on Web Systems Evolution (WSE)	17 nov. 2011	2011			53	58	Services Oriented Architecture (SOA) is becoming a popular style for building complex systems-of-systems that allow businesses to work together across organizational boundaries. However concerns have been raised about the comprehensibility and maintainability of SOA composite applications. Integrating and deploying SOA applications requires artifacts in a variety of web-based languages (WSDL, XSD, BPEL, etc.) often produced by code-generation tools. It becomes difficult for a human to discover and understand the dependencies between these artifacts in an existing system. In this paper, we describe ongoing research on using search techniques to facilitate SOA maintenance by allowing users to query collections of artifacts making up a SOA composite application. The main focus in this paper is a case study using our prototype search tool SOAMiner to identify a set of abstractions that extract useful and critical information for maintainers, thereby bridging the heterogeneity of SOA artifacts while opportunistically exploiting their structure. Results of the study indicate that the highest priority abstractions for SOA are datatype summaries, service invocation (calling) relationships, and data usage relationships.	1550-4441	978-1-4577-0700-1		Services Oriented Architecture;SOA;Web Services;Evolution;Maintenance;Program Comprehension;Search	Service oriented architecture;Semiconductor optical amplifiers;Maintenance engineering;XML;Search problems	program compilers;service-oriented architecture;software maintenance;Web services	intelligent search support;Web service evolution;service oriented architecture;SOA composite application;Web-based language;code-generation tool;SOA maintenance;SOAMiner search tool		3		15		17 nov. 2011			IEEE	IEEE Conferences
Reducing Maintenance Effort through Software Operation Knowledge: An Eclectic Empirical Evaluation	reducing maintenance effort through software operation knowledge an eclectic empirical evaluation	10.1109/CSMR.2011.26	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5741262	H. v. d. Schuur; S. Jansen; S. Brinkkemper	NA; Department of Information and Computing Sciences, Utrecht University, Utrecht, The Netherlands; Department of Information and Computing Sciences, Utrecht University, Utrecht, The Netherlands	2011 15th European Conference on Software Maintenance and Reengineering	5 Apr 2011	2011			201	210	Knowledge of in-the-field software operation is acquired unsophisticatedly: acquisition processes are implemented ad hoc, application-specific and are only triggered when end-users experience severe failures. Vendors that do acquire such knowledge structurally from their software applications, often are unsuccessful in visualizing it in a consistent and uniform manner. A generic approach to acquisition and presentation of software operation knowledge reduces the time vendors need to integrate acquisition logic into their applications, as well as the time needed to analyze, compare and present uniform software operation data resulting from in-the-field software operation. This paper proposes a technique for software operation knowledge acquisition and presentation through generic recording and visualization of software operation. A prototype tool implementing this technique is presented, as well as an extensive empirical evaluation of the tool using an eclectic set of instruments (an experiment, two case studies and expert focus group discussions) involving three widely-used software applications. Results show that the technique is expected to reduce software maintenance effort and increase comprehension of end-user software operation.	1534-5351	978-1-61284-259-2		software maintenance;bug localization;program comprehension;software process improvement;binary instrumentation;software feedback;empirical study	Assembly;Weaving;Data visualization;Software maintenance;Instruments;Data mining	knowledge acquisition;software maintenance	software maintenance effort reduction;in-the-field software operation knowledge acquisition;software operation recording;software operation visualization;eclectic instrument set		3		20		5 Apr 2011			IEEE	IEEE Conferences
Comprehending Test Code: An Empirical Study	comprehending test code an empirical study	10.1109/ICSME.2019.00084	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8918999	C. S. Yu; C. Treude; M. Aniche	Department of Software Technology, Delft University of Technology, Delft, Netherlands; School of Computer Science, University of Adelaide, Adelaide, SA, Australia; Department of Software Technology, Delft University of Technology, Delft, Netherlands	2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)	5 Dec 2019	2019			501	512	Developers spend a large portion of their time and effort on comprehending source code. While many studies have investigated how developers approach these comprehension tasks and what factors influence their success, less is known about how developers comprehend test code specifically, despite the undisputed importance of testing. In this paper, we report on the results of an empirical study with 44 developers to understand which factors influence developers when comprehending Java test code. We measured three dependent variables: the total time spent reading a test suite, the ability to identify the overall purpose of a test suite, and the ability to produce additional test cases to extend a test suite. The main findings of our study, with several implications for future research and practitioners, are that (i) prior knowledge of the software project decreases the total reading time, (ii) experience with Java affects the proportion of time spent on the Arrange and Assert sections of test cases, (iii) experience with Java and prior knowledge of the software project positively influence the ability to produce additional test cases of certain categories, and (iv) experience with automated tests is an influential factor towards understanding and extending an automated test suite.	2576-3148	978-1-7281-3094-1		Software Testing;Program Comprehension	Software;Task analysis;Java;Complexity theory;Natural languages;Measurement	Java;program testing;source code (software)	additional test cases;total reading time;automated tests;automated test suite;comprehending source code;comprehending Java test code		3		56		5 Dec 2019			IEEE	IEEE Conferences
Attention in Software Maintenance: An Eye Tracking Study	attention in software maintenance an eye tracking study	10.1109/EMIP.2019.00009	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8834695	M. Ahrens; K. Schneider; M. Busch	Software Engineering Group, Leibniz Universität Hannover, Hannover, Germany; Software Engineering Group, Leibniz Universität Hannover, Hannover, Germany; Software Engineering Group, Leibniz Universität Hannover, Hannover, Germany	2019 IEEE/ACM 6th International Workshop on Eye Movements in Programming (EMIP)	12 Sep 2019	2019			2	9	In software projects, people often continue working on programs that others created. This is especially the case in agile development. Therefore, developers often need to understand unfamiliar code in order to expand, change, fix or review it. Navigating through code and searching for relevant information requires a lot of developer time. This paper introduces an approach to use eye tracking to record and transfer developers' attention during software maintenance. We visualize the recorded data with heatmaps and display switches between Java classes by coloring filenames. These attention representations aim to help developers finding and navigating to relevant code sections faster. We conducted an eye tracking experiment to investigate whether these attention visualizations help developers during software maintenance. The results show that both representations helped some of the participants for orientation and code finding purposes. The heatmaps slightly decreased the cognitive load as well. However, most participants, especially the more experienced ones, rated the attention visualizations as barely helpful or not helpful. Instead, the representations increased their visual effort, reduced the code's clarity and made the overall understanding of the program's functionality, as well as finding relevant areas, more difficult. By testing this specific implementation of the approach of attention transfer, we gained important lessons learned and provide several improvement suggestions.		978-1-7281-2243-4		attention transfer;focused attention;eye tracking;software maintenance;program comprehension	Task analysis;Gaze tracking;Software maintenance;Data visualization;Heating systems;History	cognition;data visualisation;Java;learning (artificial intelligence);program debugging;software maintenance	software maintenance;eye tracking study;software projects;agile development;relevant code sections;attention visualizations;visual effort;programs functionality;Java classes;transfer developers attention		3		22		12 Sep 2019			IEEE	IEEE Conferences
Delta extraction: An abstraction technique to comprehend why two objects could be related	delta extraction an abstraction technique to comprehend why two objects could be related	10.1109/ICSM.2015.7332452	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7332452	N. Nitta; T. Matsuoka	Graduate School of Natural Science, Konan University, Kobe, Japan; Graduate School of Natural Science, Konan University, Kobe, Japan	2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)	23 nov. 2015	2015			61	70	In an execution of a large scale program, even a simple observable behavior may be generated by a wide range of the source code. To comprehend how such a behavior is implemented in the code, a debugger would be helpful. However, when using a debugger, developers often encounter several types of cumbersome tasks and are often confused by the huge and complicated runtime information. To support such a debugger-based comprehension task, we propose an abstraction technique of runtime information, named delta, and present a delta extraction and visualization tool. Basically, a delta is defined for two linked objects in an object-oriented program's execution. It intuitively represents the reason why these objects could be related in the execution, and it can hide the details of how these objects were related. We have conducted experiments on four subject tasks from two real-world systems to evaluate how appropriately an extracted delta can answer the `why' question and how long the tool can reduce the working time to answer the question. The results show that each delta can successfully answer the question and a tens-of-minutes to one-hour debugger-based task can be reduced by extracting a delta.		978-1-4673-7532-0		dynamic analysis;back-in-time debugging;trace compression;debugger-based program comprehension	Runtime;Visualization;Java;Containers;Context;Electronic mail;Debugging	object-oriented programming;program debugging	source code;delta extraction;visualization tool;object-oriented program execution		3		18		23 nov. 2015			IEEE	IEEE Conferences
Semantic zooming of code change history	semantic zooming of code change history	10.1109/VLHCC.2015.7357203	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7357203	Y. Yoon; B. A. Myers	Institute for Software Research, Carnegie Mellon University Pittsburgh, PA, USA; Human-Computer Interaction Institute, Carnegie Mellon University Pittsburgh, PA, USA	2015 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)	17 Dec 2015	2015			95	99	Previously, we presented our technique for visualizing fine-grained code changes in a timeline view, designed to facilitate reviewing and interacting with the code change history. During user evaluations, it became evident that users often wanted to see the code changes at a higher level of abstraction. Therefore, we developed a novel approach to automatically summarize fine-grained code changes into more conceptual, higher-level changes in real time. Our system provides four collapse levels, which are integrated with the timeline via semantic zooming: raw level (no collapsing), statement level, method level, and type level. Compared to the raw level, the number of code changes shown in the timeline at each level is reduced by 55%, 77%, and 83%, respectively. This implies that the semantic zooming would help users better understand and interact with the history by minimizing the potential information overload.		978-1-4673-7457-6		semantic zooming;edit collapsing;program comprehension;software visualization;timeline visualization;Azurite		programming environments;user interfaces	code change history;raw level;statement level;method level;type level;semantic zooming		3		17		17 Dec 2015			IEEE	IEEE Conferences
Docio: Documenting API Input/Output Examples	docio documenting api input/output examples	10.1109/ICPC.2017.13	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961538	S. Jiang; A. Armaly; C. McMillan; Q. Zhi; R. Metoyer	Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN, USA; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN, USA; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN, USA; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN, USA; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN, USA	2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC)	29 jun. 2017	2017			364	367	When learning to use an Application Programming Interface (API), programmers need to understand the inputs and outputs (I/O) of the API functions. Current documentation tools automatically document the static information of I/O, such as parameter types and names. What is missing from these tools is dynamic information, such as I/O examples-actual valid values of inputs that produce certain outputs. In this paper, we demonstrate Docio, a prototype toolset we built to generate I/O examples. Docio logs I/O values when API functions are executed, for example in running test suites. Then, Docio puts I/O values into API documents as I/O examples. Docio has three programs: 1) funcWatch, which collects I/O values when API developers run test suites, 2) ioSelect, which selects one I/O example from a set of I/O values, and 3) ioPresent, which embeds the I/O examples into documents. In a preliminary evaluation, we used Docio to generate four hundred I/O examples for three C libraries: ffmpeg, libssh, and protobuf-c. Docio is open-source and available at: http://www3.nd.edu/~sjiang1/docio/.		978-1-5386-0535-6		api documentation;program comprehension;dynamic program analysis	Libraries;Tools;HTML;Layout;Visualization;Documentation;Prototypes	application program interfaces;system documentation	Docio;API input/output example documentation;application programming interface;I/O static information;dynamic information;funcWatch;I/O values;API developers;ioSelect;ioPresent;C libraries;ffmpeg;libssh;protobuf-c		3		18		29 jun. 2017			IEEE	IEEE Conferences
A Search Based Context-Aware Approach for Understanding and Localizing the Fault via Weighted Call Graph	a search based contextaware approach for understanding and localizing the fault via weighted call graph	10.1109/TSA.2016.20	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780227	J. Tu; X. Xie; Y. Zhou; B. Xu; L. Chen	Department of Computer Science and Technology, Nanjing University, Nanjing, China; State Key Laboratory of Software Engineering, Wuhan University, Wuhan, China; Department of Computer Science and Technology, Nanjing University, Nanjing, China; Department of Computer Science and Technology, Nanjing University, Nanjing, China; Department of Computer Science and Technology, Nanjing University, Nanjing, China	2016 Third International Conference on Trustworthy Systems and their Applications (TSA)	12 Dec 2016	2016			64	72	Strictly speaking, fault localization includes assessing the code risk of being faulty and identifying the real fault. In practice, only highlighting some possible faulty statements is not helpful enough to reason the roots of the observed failures in a system. Programmers need to manually inspect the highlighted risky statements one by one, reading and understanding their contexts, in order to identify the real faulty ones. However, most related works have been focusing on risk assessment by simply ignoring the fault identification, which makes such techniques much less practical in real world. Therefore, in this paper, we propose a context-aware approach to assist fault comprehension and identification. Built on risk assessment results, our approach searches for the faults on Weighted Call Graph. In our approach the risky statements are re-ordered by function call chains, which can provide much richer information to understand the context and hence reduce the efforts in manual code inspection. Case studies with three open-source systems show that the proposed approach could help to improve the effectiveness of the whole fault localization process.		978-1-5090-3539-7		Program comprehension;fault identification;fault localization;weighted call graph	Risk management;Fault diagnosis;Context;Navigation;Inspection;Testing;Debugging	graph theory;program debugging;public domain software;risk management	search based context-aware approach;weighted call graph;code risk assessment;risky statements;fault identification;fault comprehension;function call chains;open-source systems;software fault localization		3		37		12 Dec 2016			IEEE	IEEE Conferences
An Interactive Microarray Call-Graph Visualization	an interactive microarray callgraph visualization	10.1109/VISSOFT.2016.14	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780162	M. D. Shah; S. Z. Guyer	Tufts University, Medford, MA; Tufts University, Medford, MA	2016 IEEE Working Conference on Software Visualization (VISSOFT)	12 Dec 2016	2016			86	90	In this paper we present an interactive call-graph visualization tool for viewing large programs. Our space-filling grid-based visualization shows the functions of a programs call-graph. The grid view provides an overview of all of the methods, allowing the user to investigate and view subsets of functions, and finally jump to source code for more details on demand. Our tool assists programmers by reducing large call graphs into smaller subgraphs with function relationships that matter for program comprehension. In our benchmarks, we view and explore code relationships in programs with 18,720 functions at interactive frame rates. We provide two use cases with several findings on investigating profile-guided optimizations in C++ and critical sections in concurrent Java programs. Our software visualization tool is Java based and portable across multiple platforms.		978-1-5090-3850-3		Java;LLVM;Critical Sections;Concurrency;Program Comprehension;Software Visualization	Visualization;Data visualization;Software;Optimization;Java;Metadata	C++ language;concurrency control;interactive programming;Java;software tools;source code (software)	interactive microarray call-graph visualization tool;space-filling grid-based visualization;program call- graph;grid view;source code;function relationships;program comprehension;code relationships;interactive frame rates;profile-guided optimization;C++ language;concurrent Java programs;software visualization tool		2		20		12 Dec 2016			IEEE	IEEE Conferences
IDEAL: An Open-Source Identifier Name Appraisal Tool	ideal an opensource identifier name appraisal tool	10.1109/ICSME52107.2021.00064	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9609217	A. Peruma; V. Arnaoudova; C. D. Newman	Rochester Institute of Technology, Rochester, NY, USA; Washington State University, Pullman, WA, USA; Rochester Institute of Technology, Rochester, NY, USA	2021 IEEE International Conference on Software Maintenance and Evolution (ICSME)	24 nov. 2021	2021			599	603	Developers must comprehend the code they will maintain, meaning that the code must be legible and reasonably self-descriptive. Unfortunately, there is still a lack of research and tooling that supports developers in understanding their naming practices; whether the names they choose make sense, whether they are consistent, and whether they convey the information required of them. In this paper, we present IDEAL, a tool that will provide feedback to developers about their identifier naming practices. Among its planned features, it will support linguistic anti-pattern detection, which is what will be discussed in this paper. IDEAL is designed to, and will, be extended to cover further anti-patterns, naming structures, and practices in the near future. IDEAL is open-source and publicly available, with a demo video available at: https://youtu.be/fVoOYGe50zg	2576-3148	978-1-6654-2882-8	National Science Foundation(grant numbers:1850412); 	program comprehension;identifier names;linguistic anti-patterns	Software maintenance;Codes;Conferences;Tools;Linguistics;Feature extraction;Appraisal	computational linguistics;public domain software;software maintenance	identifier naming practices;IDEAL;open-source identifier name appraisal tool;linguistic antipattern detection;naming structures		2		31	IEEE	24 nov. 2021			IEEE	IEEE Conferences
Towards a Model to Appraise and Suggest Identifier Names	towards a model to appraise and suggest identifier names	10.1109/ICSME.2019.00103	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8918988	A. Peruma	Rochester Institute of Technology, Rochester, New York, USA	2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)	5 Dec 2019	2019			639	643	Unknowingly, identifiers in the source code of a software system play a vital role in determining the quality of the system. Ambiguous and confusing identifier names lead developers to not only misunderstand the behavior of the code but also increases comprehension time and thereby causes a loss in productivity. Even though correcting poor names through rename operations is a viable option for solving this problem, renaming itself is an act of rework and is not immune to defect injection. In this study, we aim to understand the motivations that drive developers to name and rename identifiers and the decisions they make in determining the name. Using our results, we propose the development of a linguistic model that determines identifier names based on the behavior of the identifier. As a prerequisite to constructing the model, we conduct multiple studies to determine the features that should feed into the model. In this paper, we discuss findings from our completed studies and justify the continuation of research on this topic through further studies.	2576-3148	978-1-7281-3094-1		Program Comprehension;Identifier Names	Semantics;Static analysis;Software maintenance;Linguistics;Software engineering;Appraisal	computational linguistics;human factors;Java;project management;public domain software;software quality	ambiguous identifier names;software system;source code;identifier names;linguistic model;rename operations;comprehension time;confusing identifier names		2		38		5 Dec 2019			IEEE	IEEE Conferences
On the use of visual clustering to identify landmarks in code navigation	on the use of visual clustering to identify landmarks in code navigation	10.1109/SERA.2017.7965731	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7965731	S. Reddivari; M. Kotapalli	School of Computing, University of North Florida, Jacksonville, Florida, USA; School of Computing, University of North Florida, Jacksonville, Florida, USA	2017 IEEE 15th International Conference on Software Engineering Research, Management and Applications (SERA)	3 jul. 2017	2017			219	228	Recovering the legibility features is key to reverse engineering as the legible software systems can ease developer's code navigation and comprehension. Landmarks are important legibility features that developers use as reference points. In this paper, we leverage visual clustering to explore how landmarks can be identified via static dependencies. Besides organizing software entities with coherent patterns, visual clustering offers additional insights by rigorously rendering a holistic picture of the code base to the two-dimensional space. We contribute a couple of heuristics based on the cluster layout to identify the landmark files. Our visual exploration of Eclipse Mylyn open source Java project reveals developer's reliance on the landmarks during code navigation and shows the promise of using static dependencies to uncover the landmarks in the software space.		978-1-5090-5756-6		software clustering;program comprehension;code navigation;visual clustering;software exploration;layout-based clustering;software visualization;static dependencies	Navigation;Visualization;Software systems;Reverse engineering;Layout;Urban areas	Java;pattern clustering;program visualisation;public domain software;reverse engineering;source code (software)	visual clustering;landmark identification;code navigation;legibility feature recovery;reverse engineering;legible software systems;code comprehension;static dependencies;software entities;2D space;Eclipse Mylyn open source Java project		2		53		3 jul. 2017			IEEE	IEEE Conferences
Keywords Guided Method Name Generation	keywords guided method name generation	10.1109/ICPC52881.2021.00027	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463019	F. Ge; L. Kuang	School of Computer Science and Engineering, Central South University, Changsha, China; School of Computer Science and Engineering, Central South University, Changsha, China	2021 IEEE/ACM 29th International Conference on Program Comprehension (ICPC)	28 jun. 2021	2021			196	206	High quality method names are descriptive and readable, which are helpful for code development and maintenance. The majority of recent research suggest method names based on the text summarization approach. They take the token sequence and abstract syntax tree of the source code as input, and generate method names through a powerful neural network based model. However, the tokens composing the method name are closely related to the entity name within its method implementation. Actually, high proportions of the tokens in method name can be found in its corresponding method implementation, which makes it possible for incorporating these common shared token information to improve the performance of method naming task. Inspired by this key observation, we propose a two-stage keywords guided method name generation approach to suggest method names. Specifically, we decompose the method naming task into two subtasks, including keywords extraction task and method name generation task. For the keywords extraction task, we apply a graph neural network based model to extract the keywords from source code. For the method name generation task, we utilize the extracted keywords to guide the method name generation model. We apply a dual selective gate in encoder to control the information flow, and a dual attention mechanism in decoder to combine the semantics of input code sequence and keywords. Experiment results on an open source dataset demonstrate that keywords guidance can facilitate method naming task, which enables our model to outperform the competitive state-of-the-art models by margins of 1.5%-3.5% in ROUGE metrics. Especially when programs share one common token with method names, our approach improves the absolute ROUGE-1 score by 7.8%.	2643-7171	978-1-6654-1403-6	National Natural Science Foundation of China; Natural Science Foundation of Hunan Province; 	method naming;program comprehension;neural networks;keywords guidance	Measurement;Semantics;Syntactics;Maintenance engineering;Logic gates;Graph neural networks;Decoding	graph theory;natural language processing;neural nets;software engineering;source code (software);text analysis	high quality method names;keywords extraction task;method name generation task;method name generation model;two-stage keywords guided method name generation approach;code development;code maintenance;text summarization approach;token sequence;abstract syntax tree;performance improvement;graph neural network based model;source code;dual selective gate;information flow;dual attention mechanism;open source dataset		2		33	IEEE	28 jun. 2021			IEEE	IEEE Conferences
Data access visualization for legacy application maintenance	data access visualization for legacy application maintenance	10.1109/SANER.2017.7884671	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7884671	K. Yano; A. Matsuo	Information Systems Technologies Laboratory, Fujitsu Laboratories, Kawasaki, Japan; Information Systems Technologies Laboratory, Fujitsu Laboratories, Kawasaki, Japan	2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER)	23 mar. 2017	2017			546	550	Software clustering techniques have been studied and applied to analyze and visualize the actual structure of legacy applications, which have used program information, e.g., dependencies, as input. However, business data also play an important role in a business system. Revealing which programs actually use data in the current system can give us a key insight when analyzing a long-lived complicated system. In this paper, we calculate indexes indicating how a data entity is used, making use of software clustering, which can be used to detect problematic or characteristic parts of the system. The developed technique can reveal the characteristics of a data entity; i.e., it is used like master data. We applied this technique to two business systems used for many years and found that our technique can help us understand the systems in terms of business data usage. Through case studies, we evaluated the validity of the indexes and showed that software visualization with the indexes can be used to investigate a system in an exploratory way.		978-1-5090-5501-2		Software clustering;software visualization;program comprehension;database	Indexes;Data visualization;Business;Maintenance engineering;Software systems;Writing	program diagnostics;software maintenance	data access visualization;legacy application maintenance;data entity;software clustering;software visualization		2		16		23 mar. 2017			IEEE	IEEE Conferences
Semantic Navigation Strategies for Scenario-Based Programming	semantic navigation strategies for scenariobased programming	10.1109/VLHCC.2010.38	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5635234	M. Gordon; D. Harel	Department of Computer Science and Applied Mathematics, Weizmann Institute of Science, Rehovot, Israel; Department of Computer Science and Applied Mathematics, Weizmann Institute of Science, Rehovot, Israel	2010 IEEE Symposium on Visual Languages and Human-Centric Computing	11 nov. 2010	2010			219	226	The scenario-based approach to specification and programming uses powerful extensions of sequence diagrams, such as LSCs (live sequence charts), to model system behavior. Previous work in this area presents interesting challenges related to the scalability of the approach and to better tool support for analysis, execution, and comprehension. Here we suggest new semantic-rich ways of viewing sequence diagrams and LSCs for better comprehension of both a single large chart and a full multi-chart specification, in a variety of software engineering tasks. Our method uses weighted messages to create a semantic order that enables semantic zooming and scrolling of different parts of a chart, providing visual hints about context.	1943-6106	978-1-4244-8485-0		Live Sequence Charts;Sequence Diagrams;Semantic Zoom;Program Navigation;Program Comprehension	Semantics;Navigation;Visualization;Programming;Context;Unified modeling language;Scalability	formal specification;navigation;programming languages	semantic navigation strategies;scenario-based programming;specification;sequence diagrams;tool support;live sequence charts		2		17		11 nov. 2010			IEEE	IEEE Conferences
Automated Recording and Semantics-Aware Replaying of High-Speed Eye Tracking and Interaction Data to Support Cognitive Studies of Software Engineering Tasks	automated recording and semanticsaware replaying of highspeed eye tracking and interaction data to support cognitive studies of software engineering tasks	10.1109/ICSME46990.2020.00051	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9240624	V. Zyrianov; D. T. Guarnera; C. S. Peterson; B. Sharif; J. I. Maletic	Department of Computer Science, University of Illinois at Urbana-Champaign, Champaign, Illinois, USA; Department of Computer Science, Kent State University, Kent, Ohio, USA; Dept. of Computer Science and Engineering, University of Nebraska-Lincoln, Lincoln, Nebraska, USA; Dept. of Computer Science and Engineering, University of Nebraska-Lincoln, Lincoln, Nebraska, USA; Department of Computer Science, Kent State University, Kent, Ohio, USA	2020 IEEE International Conference on Software Maintenance and Evolution (ICSME)	2 nov. 2020	2020			464	475	The paper introduces a fundamental technological problem with collecting high-speed eye tracking data while studying software engineering tasks in an integrated development environment. The use of eye trackers is quickly becoming an important means to study software developers and how they comprehend source code and locate bugs. High quality eye trackers can record upwards of 120 to 300 gaze points per second. However, it is not possible to map each of these points to a line and column position in a source code file (in the presence of scrolling and file switching) in real time at data rates over 60 gaze points per second without data loss. Unfortunately, higher data rates are more desirable as they allow for finer granularity and more accurate study analyses. To alleviate this technological problem, a novel method for eye tracking data collection is presented. Instead of performing gaze analysis in real time, all telemetry (keystrokes, mouse movements, and eye tracker output) data during a study is recorded as it happens. Sessions are then replayed at a much slower speed allowing for ample time to map gaze point positions to the appropriate file, line, and column to perform additional analysis. A description of the method and corresponding tool, Déjà Vu, is presented. An evaluation of the method and tool is conducted using three different eye trackers running at four different speeds (60Hz, 120Hz, 150Hz, and 300 Hz). This timing evaluation is performed in Visual Studio and Eclipse IDEs. Results show that Déjà Vu can playback 100% of the data recordings, correctly mapping the gaze to corresponding elements, making it a well-founded and suitable post processing step for future eye tracking studies in software engineering.	2576-3148	978-1-7281-5619-4	National Science Foundation; 	Eye Tracking;Empirical Studies;Program Comprehension;High-speed Eye Tracking	Visualization;Tracking;Gaze tracking;Tools;Real-time systems;Task analysis;Software engineering	eye;gaze tracking;program debugging;software engineering	eye tracking data collection;gaze analysis;eye tracker output;ample time;map gaze point positions;corresponding tool;eye trackers;timing evaluation;data recordings;future eye tracking studies;semantics-aware replaying;interaction data;cognitive studies;software engineering tasks;fundamental technological problem;high-speed eye tracking data;integrated development environment;software developers;high quality eye trackers;column position;source code file;scrolling file switching;gaze points;data loss		2		48		2 nov. 2020			IEEE	IEEE Conferences
Neural Comment Generation for Source Code with Auxiliary Code Classification Task	neural comment generation for source code with auxiliary code classification task	10.1109/APSEC48747.2019.00076	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8945708	M. Chen; X. Wan	Center for Data Science, The MOE Key Laboratory of Computational Linguistics, Peking University Wangxuan Institute of Computer Technology, Peking University, Peking University, Beijing, China; Center for Data Science, The MOE Key Laboratory of Computational Linguistics, Peking University Wangxuan Institute of Computer Technology, Peking University, Peking University, Beijing, China	2019 26th Asia-Pacific Software Engineering Conference (APSEC)	2 jan. 2020	2019			522	529	Code comments help program developers understand programs, read and navigate source code, thus resulting in more efficient software maintenance. Unfortunately, many codes are not commented adequately, or the code comments are missing. So developers have to spend additional time in reading source code. In this paper, we propose a new approach to automatically generating comments for source codes. Following the intuition behind the traditional sequence-to-sequence (Seq2Seq) model for machine translation, we propose a tree-to-sequence (Tree2Seq) model for code comment generation, which leverages an encoder to capture the structure information of source code. More importantly, code classification is involved as an auxiliary task for aiding the Tree2Seq model. We build a multi-task learning model to achieve this goal. We evaluate our models on a benchmark dataset with automatic metrics like BLEU, ROUGE, and METEOR. Experimental results show that our proposed Tree2Seq model outperforms traditional Seq2Seq model with attention, and our proposed multi-task learning model outperforms the state-of-the-art approaches by a substantial margin.	2640-0715	978-1-7281-4648-5		program comprehension, source code summarization, deep learning, multi task learning	Measurement;Software maintenance;Navigation;Benchmark testing;Machine translation;Task analysis;Software engineering	learning (artificial intelligence);natural language processing;neural nets;software maintenance;source code (software)	multitask learning model;Tree2Seq model;traditional Seq2Seq model;neural comment generation;auxiliary code classification task;source code;sequence-to-sequence model;tree-to-sequence model;code comment generation;machine translation;BLEU metric;ROUGE metric;METEOR metric		2		39		2 jan. 2020			IEEE	IEEE Conferences
Accuracy of Unit Under Test Identification Using Latent Semantic Analysis and Latent Dirichlet Allocation	accuracy of unit under test identification using latent semantic analysis and latent dirichlet allocation	10.1109/Informatics47936.2019.9119262	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9119262	M. Madeja; J. Porubän	Department of Computers and Informatics, Technical University of Košice, Košice, Slovakia; Department of Computers and Informatics, Technical University of Košice, Košice, Slovakia	2019 IEEE 15th International Scientific Conference on Informatics	17 jun. 2020	2019			161	166	Identification of unit under test (UUT) from a test is often difficult and requires wider source code comprehension. By automating this process it would be possible to support the program comprehension and reduce software maintenance process. In this paper the Latent Semantic Analysis (LSA) and the Latent Dirichlet Allocation (LDA) were used which proved to be inaccurate in the UUT identification. The experiment was conducted on 5 popular projects where 1,093,730 similarity results were obtained. It was found out that the best topic number for the LSA model is from 7 to 10, the LDA model had big differences in this value, so it was not possible to define a stable value. The best UUT identification accuracy compared to manual testing has been obtained with the LSA model with result of 7.63% success, where documents were preprocessed using words splitting based on naming conventions and Java keywords removal. The accuracy of the LDA model was almost zero. Further 8 manual identification errors were discovered during the experiment.		978-1-7281-3180-1		program comprehension;latent semantic analysis;latent dirichlet allocation;github mining;unit under test		program testing;software maintenance	LSA model;LDA model;UUT identification accuracy;manual testing;test identification;latent semantic analysis;latent Dirichlet allocation;source code comprehension;software maintenance process		2		19		17 jun. 2020			IEEE	IEEE Conferences
Investigating Program Behavior Using the Texada LTL Specifications Miner	investigating program behavior using the texada ltl specifications miner	10.1109/ASE.2015.94	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372082	C. Lemieux; I. Beschastnikh	Computer Science, University of British Columbia, Vancouver, BC, Canada; Computer Science, University of British Columbia, Vancouver, BC, Canada	2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)	7 jan. 2016	2015			870	875	Temporal specifications, relating program events through time, are useful for tasks ranging from bug detection to program comprehension. Unfortunately, such specifications are often lacking from system descriptions, leading researchers to investigate methods for inferring these specifications from code, execution traces, code comments, and other artifacts. This paper describes Texada, a tool to dynamically mine temporal specifications in LTL from traces of program activity. We review Texada's key features and demonstrate how it can be used to investigate program behavior through two scenarios: validating an implementation that solves the dining philosophers problem and supporting comprehension of a stack implementation. We also detail Texada's other, more advanced, usage options. Texada is an open source tool: https://bitbucket.org/bestchai/texada.		978-1-5090-0025-8		texada;specification mining;linear temporal logic;program comprehension	Runtime;Concurrent computing;Data structures;Java;Distance measurement	data mining;formal specification;program debugging;public domain software	program behavior;Texada LTL specification miner;program events;bug detection;program comprehension;execution traces;code comments;dynamic temporal specification mining;program activity;open source tool		2		19		7 jan. 2016			IEEE	IEEE Conferences
Software visualisation techniques adapted and extended for asynchronous hardware design	software visualisation techniques adapted and extended for asynchronous hardware design	10.1109/IV.2005.119	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1509100	L. Janin; D. Edwards	School of Computer Science, University of Manchester, Institute of Science and Technology, Manchester, UK; School of Computer Science, University of Manchester, Institute of Science and Technology, Manchester, UK	Ninth International Conference on Information Visualisation (IV'05)	19 Sep 2005	2005			347	356	Asynchronous circuit design shows many similarities with software design. This is due to the modular construction style associated with asynchronous circuits, where each asynchronous module can be designed as a standalone object communicating with other modules. We propose a visualisation system for asynchronous circuit design tools, based on clustered graph visualisation and coordinated views. The novelty of our approach is to apply classical software visualisation techniques to a hardware environment and take advantage of properties specific to our asynchronous design flow. This system is based on a control and data flow graph representation of the asynchronous circuit compiled from a high-level description by a syntax-directed transparent process and transferable to the final hardware circuit by a direct synthesis process. Compared to software compilation flows, this transparent design flow offers opportunities for visualisation, with representations at different stages being easily mapped onto each other to combine their visualisation qualities. Each representation also exhibits properties based on some physical attributes of the final hardware circuit, allowing us to render some abstract properties on top of real-world-based ones. This paper shows how the handshake circuit graph is used as the underlying structure onto which properties extracted from other structures are mapped, and then how this structured graph is used as the central piece in a coordinated views environment. These visualisation techniques have been exercised by designers optimising the design of a fully asynchronous ARM processor.	2375-0138	0-7695-2397-8		Software visualisation;coordinated views;program comprehension;asynchronous circuits	Visualization;Hardware;Asynchronous circuits;Software design;Modular construction;Flow graphs;Circuit synthesis;Control system synthesis;Software quality;Design optimization	program visualisation;integrated circuit design;asynchronous circuits;flow graphs;data flow graphs	software visualization;asynchronous hardware design;asynchronous circuit design;control flow graph representation;data flow graph representation;direct synthesis;handshake circuit graph;circuit design optimization;fully asynchronous ARM processor		2		15		19 Sep 2005			IEEE	IEEE Conferences
Executable Program Documentation Based on Debugging Break Points	executable program documentation based on debugging break points	10.1109/APSEC.2013.36	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6805407	Y. -P. Cheng; J. -H. Chen; Y. -Y. Yu	Dept. of Comp. Sci. and Info. Eng., National Central University, Zhongli City, Taiwan; Dept. of Comp. Sci. and Info. Eng., National Central University, Zhongli City, Taiwan; Dept. of Comp. Sci. and Info. Eng., National Taiwan Normal University, Taipei City, Taiwan	2013 20th Asia-Pacific Software Engineering Conference (APSEC)	28 Apr 2014	2013	1		199	206	Understanding an unfamiliar program is always a daunting task for any programmer, either experienced or inexperienced. Many studies have shown that even an experienced programmer who is already familiar with the code may still need to rediscover the code frequently during maintenance activities. Compared to that tracing the source code of an unfamiliar program is a totally different process of comprehension. Difficulties in such a process can be compounded if the code has poor or little internal program documentation. In practice, internal program documentation is often neglected or receives much less attention while most documentation techniques are designed to help programmers deal with familiar code, not unfamiliar code. In this paper, a novel internal program documentation method is proposed. In the approach, the multimedia documents, such as slides and voice recording, can be created along with a sequence of debugging break points, where the sequence of break points and its associated multimedia documents form a trace case. We show that trace cases can be very useful in documenting major control flows of a program using examples so that the time needed to construct a program model for understanding can be shortened. To demonstrate the idea, a prototype tool called polyTraceAid has been implemented as a plug-in in Visual Studio.	1530-1362	978-1-4799-2144-7		program documentation;program comprehension;executable documents;debugger;multimedia documents	Documentation;Multimedia communication;Debugging;Maintenance engineering;Software;Software engineering;Visualization	multimedia systems;program debugging;software maintenance;system documentation	executable program documentation;debugging break points;internal program documentation method;multimedia documents;trace case;program control flows;program model;polyTraceAid;Visual Studio plug-in;program comprehension;software maintenance		2		18		28 Apr 2014			IEEE	IEEE Conferences
RuntimeSearch: Ctrl+F for a running program	runtimesearch ctrl+f for a running program	10.1109/ASE.2017.8115651	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115651	M. Sulír; J. Porubän	Technical University of Kosice, Slovakia; Technical University of Kosice, Slovakia	2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)	23 nov. 2017	2017			388	393	Developers often try to find occurrences of a certain term in a software system. Traditionally, a text search is limited to static source code files. In this paper, we introduce a simple approach, RuntimeSearch, where the given term is searched in the values of all string expressions in a running program. When a match is found, the program is paused and its runtime properties can be explored with a traditional debugger. The feasibility and usefulness of RuntimeSearch is demonstrated on a medium-sized Java project.		978-1-5386-2684-9		program comprehension;dynamic analysis;debugger;text search;concept location	Runtime;Debugging;Java;Tools;Graphical user interfaces;Instruments	Java;program compilers;program debugging;program diagnostics	RuntimeSearch;ctrl+f;running program;software system;text search;static source code files;string expressions;traditional debugger;medium-sized Java project		2	1	27		23 nov. 2017			IEEE	IEEE Conferences
Relating Reading, Visualization, and Coding for New Programmers: A Neuroimaging Study	relating reading, visualization, and coding for new programmers a neuroimaging study	10.1109/ICSE43902.2021.00062	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9402035	M. Endres; Z. Karas; X. Hu; I. Kovelman; W. Weimer	Computer Science and Engineering, University of Michigan; Department of Psychology, University of Michigan; Department of Psychology, University of Michigan; Computer Science and Engineering, University of Michigan; Computer Science and Engineering, University of Michigan	2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)	7 May 2021	2021			600	612	Understanding how novices reason about coding at a neurological level has implications for training the next generation of software engineers. In recent years, medical imaging has been increasingly employed to investigate patterns of neural activity associated with coding activity. However, such studies have focused on advanced undergraduates and professionals. In a human study of 31 participants, we use functional near-infrared spectroscopy to measure the neural activity associated with introductory programming. In a controlled, contrast-based experiment, we relate brain activity when coding to that of reading natural language or mentally rotating objects (a spatial visualization task). Our primary result is that all three tasks-coding, prose reading, and mental rotation-are mentally distinct for novices. However, while those tasks are neurally distinct, we find more significant differences between prose and coding than between mental rotation and coding. Intriguingly, we generally find more activation in areas of the brain associated with spatial ability and task difficulty for novice coding compared to that reported in studies with more expert developers. Finally, in an exploratory analysis, we also find a neural activation pattern predictive of programming performance 11 weeks later. While preliminary, these findings both expand on previous results (e.g., relating expertise to a similarity between coding and prose reading) and also provide a new understanding of the cognitive processes underlying novice programming.	1558-1225	978-1-6654-0296-5		novice software engineers;program comprehension;spatial ability;reading ability;fNIRS;cognition	Training;Cognitive processes;Neural activity;Encoding;Software;Task analysis;Programming profession	brain;cognitive systems;medical image processing;neurophysiology;software engineering	functional near-infrared spectroscopy;novice programming;programming performance;neural activation pattern predictive;mental rotation;prose reading;spatial visualization task;mentally rotating objects;reading natural language;brain activity;controlled contrast-based experiment;coding activity;medical imaging;software engineers;neuroimaging study		2		73		7 May 2021			IEEE	IEEE Conferences
An Ensemble Approach for Annotating Source Code Identifiers With Part-of-Speech Tags	an ensemble approach for annotating source code identifiers with partofspeech tags	10.1109/TSE.2021.3098242	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9491989	C. D. Newman; M. J. Decker; R. S. Alsuhaibani; A. Peruma; M. W. Mkaouer; S. Mohapatra; T. Vishnoi; M. Zampieri; T. J. Sheldon; E. Hill	Software Engineering Deptartment, Rochester Institute of Techonology, Rochester, NY, USA; Software Engineering Department, Bowling Green State University, Bowling Green, OH, USA; Computer Science Department, Prince Sultan University, Riyadh, Saudi Arabia; Software Engineering Deptartment, Rochester Institute of Techonology, Rochester, NY, USA; Software Engineering Deptartment, Rochester Institute of Techonology, Rochester, NY, USA; Software Engineering Deptartment, Rochester Institute of Techonology, Rochester, NY, USA; Software Engineering Deptartment, Rochester Institute of Techonology, Rochester, NY, USA; Language Technology Group, Rochester Institute of Techonology, Rochester, NY, USA; Financial Services Sector, Risk and Compliance, BNY Mellon, Pittburgh, PA, USA; Department of Math and Computer Science, Drew University, Madison, NJ, USA	IEEE Transactions on Software Engineering	16 Sep 2022	2022	48	9	3506	3522	This paper presents an ensemble part-of-speech tagging approach for source code identifiers. Ensemble tagging is a technique that uses machine-learning and the output from multiple part-of-speech taggers to annotate natural language text at a higher quality than the part-of-speech taggers are able to obtain independently. Our ensemble uses three state-of-the-art part-of-speech taggers: SWUM, POSSE, and Stanford. We study the quality of the ensemble’s annotations on five different types of identifier names: function, class, attribute, parameter, and declaration statement at the level of both individual words and full identifier names. We also study and discuss the weaknesses of our tagger to promote the future amelioration of these problems through further research. Our results show that the ensemble achieves 75 percent accuracy at the identifier level and 84-86 percent accuracy at the word level. This is an increase of +17% points at the identifier level from the closest independent part-of-speech tagger.	1939-3520		National Science Foundation(grant numbers:1850412); 	Program comprehension;software maintenance;natural language processing;part-of-speech tagging	Grammar;Tagging;Natural languages;Tools;Annotations;Software engineering;Semantics	learning (artificial intelligence);natural language processing;text analysis	ensemble part-of-speech tagging approach;part-of-speech tagger;identifier names;identifier level;ensemble approach;annotating source code identifiers;part-of-speech tags;machine-learning;natural language text;SWUM;POSSE;Stanford;declaration statement;efficiency 75.0 percent		2		57	IEEE	20 jul. 2021			IEEE	IEEE Journals
Trace-Guided Synthesis of Reactive Behavior Models of Programmable Logic Controllers	traceguided synthesis of reactive behavior models of programmable logic controllers	10.1109/SEAA.2013.37	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6619520	R. Schatz; H. Prähofer	Institute for System Software, Johannes Kepler University of Linz, Linz, Austria; Institute for System Software, Johannes Kepler University of Linz, Linz, Austria	2013 39th Euromicro Conference on Software Engineering and Advanced Applications	10 Oct 2013	2013			260	267	Programmable Logic Controller (PLC) programs are programs that control physical devices by continuously reading sensor inputs and writing actuator outputs. A main challenge in designing and comprehending PLC programs is the emergent behavior which arises from the complex interaction between the dynamic behavior of the program and the physical device. In this paper we present an approach for building a formal model characterizing the reactive interaction behavior of a PLC program with the physical device it controls. Based on program recordings, first a model of the transition behavior of the program run is built. Then, using symbolic execution and a formal abstraction process, we generate a specification of the input/output behavior as a state model with transition labelings in terms of conditions on input values. We present the main ideas of the approach, a formal model for representing the reactive behavior, the abstraction process, and two application scenarios.	2376-9505	978-0-7695-5091-6		program comprehension;reverse engineering;symbolic execution;dynamic analysis;test coverage;programmable logic controllers	Reverse engineering;Symbolic execution;Programmable logic controllers;Optimization;Actuators	control engineering computing;program verification;programmable controllers;sensor fusion;symbol manipulation	trace-guided synthesis;reactive behavior models;programmable logic controller programs;physical device control;actuator output writing;sensor input reading;program dynamic behavior;formal model;PLC program reactive interaction behavior;program recordings;symbolic execution;formal abstraction process;input-output behavior;state model;transition labelings;abstraction process		2		18		10 Oct 2013			IEEE	IEEE Conferences
Enhancing the Analysis of Large Multimedia Applications Execution Traces with FrameMiner	enhancing the analysis of large multimedia applications execution traces with frameminer	10.1109/ICDMW.2012.95	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6406406	C. K. Kengne; L. C. Fopa; N. Ibrahim; A. Termier; M. C. Rousset; T. Washio	Communaute d'Universites et Etablissements Universite Grenoble Alpes, Saint-Martin-d'Heres, RhÃ´ne-Alpes, FR; LIG, University of Grenoble, Saint Martin d'Hères, France; LIG, University of Grenoble, Saint Martin d'Hères, France; LIG, University of Grenoble, Saint Martin d'Hères, France; LIG, University of Grenoble, Saint Martin d'Hères, France; Institute of Scientific and Industrial Research, Osaka University, Ibaraki, Osaka, Japan	2012 IEEE 12th International Conference on Data Mining Workshops	10 jan. 2013	2012			595	602	The analysis of multimedia application traces can reveal important information to enhance program comprehension. However traces can be very large, which hinders their effective exploitation. In this paper, we study the problem of finding a \textit{k-golden} set of blocks that best characterize data. Sequential pattern mining can help to automatically discover the blocks, and we called \textit{k-golden set}, a set of $k$ blocks that maximally covers the trace. These kind of blocks can simplify the exploration of large traces by allowing programmers to see an abstraction instead of low-level events. We propose an approach for mining golden blocks and finding coverage of frames. The experiments carried out on video and audio application decoding show very promising results.	2375-9259	978-1-4673-5164-5		Data mining;Trace Analysis;Program Comprehension;Software Engineering	Decoding;Approximation algorithms;Multimedia communication;Approximation methods;Streaming media;Data mining;Greedy algorithms	data mining;multimedia computing	large multimedia applications execution traces;FrameMiner;sequential pattern mining;k-golden set;low-level events;golden blocks mining;video application decoding;audio application decoding		2		23		10 jan. 2013			IEEE	IEEE Conferences
Fine-grained Pseudo-code Generation Method via Code Feature Extraction and Transformer	finegrained pseudocode generation method via code feature extraction and transformer	10.1109/APSEC53868.2021.00029	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9712127	G. Yang; Y. Zhou; X. Chen; C. Yu	School of Information Science and Technology, Nantong University, China; School of Information Science and Technology, Nantong University, China; The Key Laboratory of Cognitive Computing and Intelligent Information Processing of Fujian Education Institutions, Wuyi University, China; School of Information Science and Technology, Nantong University, China	2021 28th Asia-Pacific Software Engineering Conference (APSEC)	17 Feb 2022	2021			213	222	Pseudo-code written by natural language is helpful for novice developers' program comprehension. However, writing such pseudo-code is time-consuming and laborious. Motivated by the research advancements of sequence-to-sequence learning and code semantic learning, we propose a novel deep pseudo-code generation method DeepPseudo via code feature extraction and Transformer. In particular, DeepPseudo utilizes a Transformer encoder to perform encoding for source code and then use a code feature extractor to learn the knowledge of local features. Finally, it uses a pseudo-code generator to perform decoding, which can generate the corresponding pseudo-code. We choose two corpora (i.e., Django and SPoC) from real-world large-scale projects as our empirical subjects. We first compare DeepPseudo with seven state-of-the-art baselines from pseudo-code generation and neural machine translation domains in terms of four performance measures. Results show the competitiveness of DeepPseudo. Moreover, we also analyze the rationality of the component settings in DeepPseudo.	2640-0715	978-1-6654-3784-4	National Natural Science Foundation of China(grant numbers:61872263,61202006); 	Program Comprehension;Pseudo-code generation;Deep learning;Transformer;Code feature extraction	Codes;Semantics;Natural languages;Writing;Feature extraction;Transformers;Generators	feature extraction;language translation;learning (artificial intelligence);program compilers	deep pseudocode generation method DeepPseudo;code feature extraction;Transformer encoder;source code;code feature extractor;local features;pseudocode generator;corresponding pseudocode;fine-grained pseudocode generation method;novice developers;sequence-to-sequence learning;code semantic learning		2		52	IEEE	17 Feb 2022			IEEE	IEEE Conferences
Novice comprehension of Object-Oriented OO programs: An empirical study	novice comprehension of objectoriented oo programs an empirical study	10.1109/WCITCA.2015.7367057	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7367057	A. S. Alardawi; A. M. Agil	The College of Computer Technology, Tripoli, Libya; The College of Computer Technology, Tripoli, Libya	2015 World Congress on Information Technology and Computer Applications (WCITCA)	4 jan. 2016	2015			1	4	Class structure represents one of the essential concepts of Object-Oriented paradigm and therefore, a good understanding of this concept will positively affect the effectiveness of novice programmers. Comprehension underpins many programming activities such as program design and program implementation. Program comprehension represents in this context a mental model approach that involves interesting theoretical frameworks of program comprehension. Our starting point is Burkhardt cognitive model for OO program comprehension [1]. The model considers two distinct but interacting models: program and situation. Our focus does not rely primarily in distinguishing between these models, but use both of them to assess the influence on novices of class structure on program comprehension. We report on an empirical study that aims of to investigate the effect of class structure on program comprehension for novices using controlled experimentation in which the treatments were a simple program without class structure versus the same program with classes present; they are termed respectively as: Non-Class based program and as Class based program. Data was collected from three different sets of experiments comprising of a total of 211 undergraduate first year computer science students from different institutions. Preliminary findings of this investigation are reported, in particular results indicate that Class based programs were more understandable, readable, and accessible than the corresponding Non-Class based programs. Our findings align with and support those works that claim the cognitive benefits of the OO paradigm. Directions for future research are highlighted.		978-1-4673-6636-6		empirical study;program comprehension;class structure;mental model	Object oriented modeling;Encapsulation;Cognitive science;Software;Programming profession;Object recognition	computer science education;object-oriented programming	object-oriented program comprehension;OO program comprehension;class structure;novice programmers;mental model approach;Burkhardt cognitive model;program model;situation model;nonclass based program;class based programs		2		21		4 jan. 2016			IEEE	IEEE Conferences
Changeset-Based Topic Modeling of Software Repositories	changesetbased topic modeling of software repositories	10.1109/TSE.2018.2874960	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8486696	C. S. Corley; K. Damevski; N. A. Kraft	Department of Computer Science, University of Alabama, Tuscaloosa, AL, USA; Department of Computer Science, Virginia Commonwealth University, Richmond, VA, USA; ABB Corporate Research, Raleigh, NC, USA	IEEE Transactions on Software Engineering	14 Oct 2020	2020	46	10	1068	1080	The standard approach to applying text retrieval models to code repositories is to train models on documents representing program elements. However, code changes lead to model obsolescence and to the need to retrain the model from the latest snapshot. To address this, we previously introduced an approach that trains a model on documents representing changesets from a repository and demonstrated its feasibility for feature location. In this paper, we expand our work by investigating: a second task (developer identification), the effects of including different changeset parts in the model, the repository characteristics that affect the accuracy of our approach, and the effects of the time invariance assumption on evaluation results. Our results demonstrate that our approach is as accurate as the standard approach for projects with most changes localized to a subset of the code, but less accurate when changes are highly distributed throughout the code. Moreover, our results demonstrate that context and messages are key to the accuracy of changeset-based models and that the time invariance assumption has a statistically significant effect on evaluation results, providing overly-optimistic results. Our findings indicate that our approach is a suitable alternative to the standard approach, providing comparable accuracy while eliminating retraining costs.	1939-3520			Changesets;feature location;developer identification;program comprehension;mining software repositories;online topic modeling	Task analysis;Standards;Feature extraction;Resource management;Software maintenance;Maintenance engineering	information retrieval;software packages;source code (software);text analysis	changeset-based topic modeling;software repositories;text retrieval models;code repositories;program elements;code changes;time invariance assumption;changeset-based models		2		56	IEEE	9 Oct 2018			IEEE	IEEE Journals
Combining Dynamic Analysis and Visualization to Explore the Distribution of Unit Test Suites	combining dynamic analysis and visualization to explore the distribution of unit test suites	10.1109/WETSoM.2015.12	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181587	A. Tahir; S. G. MacDonell	Department of Information Science, University of Otago, Dunedin, New Zealand; Department of Information Science, University of Otago, Dunedin, New Zealand	2015 IEEE/ACM 6th International Workshop on Emerging Trends in Software Metrics	6 Aug 2015	2015			21	30	As software systems have grown in scale and complexity the test suites built alongside those systems have also become increasingly complex. Understanding key aspects of test suites, such as their coverage of production code, is important when maintaining or reengineering systems. This work investigates the distribution of unit tests in Open Source Software (OSS) systems through the visualization of data obtained from both dynamic and static analysis. Our long-term aim is to support developers in their understanding of test distribution and the relationship of tests to production code. We first obtain dynamic coupling information from five selected OSS systems and we then map the test and production code results. The mapping is shown in graphs that depict both the dependencies between classes and static test information. We analyze these graphs using Centrality metrics derived from graph theory and SNA. Our findings suggest that, for these five systems at least, unit test and dynamic coupling information 'do not match', in that unit tests do not appear to be distributed in line with the systems' dynamic coupling. We contend that, by mapping dynamic coupling data onto unit test information, and through the use of software metrics and visualization, we can locate central system classes and identify to which classes unit testing effort has (or has not) been dedicated.	2327-0969	978-1-4673-7103-2		test analysis;program comprehension;unit testing;visualization;dynamic metrics;dynamic analysis	Measurement;Couplings;Data visualization;Testing;Software systems	program diagnostics;program testing;public domain software;software metrics	dynamic analysis;unit test suites;software systems;open source software systems;static analysis;test distribution;centrality metrics;graph theory		2		40		6 Aug 2015			IEEE	IEEE Conferences
Identifying Knowledge Divergence by Vocabulary Monitoring in Software Projects	identifying knowledge divergence by vocabulary monitoring in software projects	10.1109/CSMR.2012.56	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6178918	J. Nonnen; P. Imhoff	Computer Science III, University of Bonn, Bonn, Germany; Computer Science III, University of Bonn, Bonn, Germany	2012 16th European Conference on Software Maintenance and Reengineering	5 Apr 2012	2012			441	446	During the development of a project, words used in source code add up to a big vocabulary, which may lead to a divergent word-understanding and word-knowledge between developers. Even the drop out of a single developer may lead to a big loss of knowledge about words and their meaning. By keeping track of the active developers vocabulary one is able to identify and react upon such situations, e.g., by applying pair programming to spread the knowledge around the team. In this work we propose a way to identify such situations by analysing the words contained in identifiers obtained through the commit history in a version control system. Initial empirical results are presented and analysed.	1534-5351	978-0-7695-4666-7		vocabulary;active vocabulary;vocabulary evolution;software evolution;history mining;program comprehension;project health	Vocabulary;History;Visualization;Software;Programming;Correlation;Measurement	knowledge management;software development management;vocabulary	knowledge divergence;vocabulary monitoring;software projects;source code;divergent word-understanding;divergent word-knowledge;pair programming;version control system		2		23		5 Apr 2012			IEEE	IEEE Conferences
On the effectiveness of accuracy of automated feature location technique	on the effectiveness of accuracy of automated feature location technique	10.1109/WCRE.2013.6671313	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6671313	T. Ishio; S. Hayashi; H. Kazato; T. Oshima	Osaka University, Osaka, Japan; Tokyo Institute of Technology, Tokyo, Japan; NTT DATA INTELLILINK CORPORATION, Tokyo, Japan; NTT Software Innovation Center, Tokyo, Japan	2013 20th Working Conference on Reverse Engineering (WCRE)	21 nov. 2013	2013			381	390	Automated feature location techniques have been proposed to extract program elements that are likely to be relevant to a given feature. A more accurate result is expected to enable developers to perform more accurate feature location. However, several experiments assessing traceability recovery have shown that analysts cannot utilize an accurate traceability matrix for their tasks. Because feature location deals with a certain type of traceability links, it is an important question whether the same phenomena are visible in feature location or not. To answer that question, we have conducted a controlled experiment. We have asked 20 subjects to locate features using lists of methods of which the accuracy is controlled artificially. The result differs from the traceability recovery experiments. Subjects given an accurate list would be able to locate a feature more accurately. However, subjects could not locate the complete implementation of features in 83% of tasks. Results show that the accuracy of automated feature location techniques is effective, but it might be insufficient for perfect feature location.	2375-5369	978-1-4799-2931-3		feature location;impact analysis;program comprehension;human factor	Feature extraction;Large scale integration;Gold;Benchmark testing;Accuracy;Manuals;Electronic mail	program diagnostics;software maintenance	automated feature location technique;program element extraction;traceability recovery;software maintenance		2		28		21 nov. 2013			IEEE	IEEE Conferences
Enhancing Polymetric Views with Coarse-Grained Views	enhancing polymetric views with coarsegrained views	10.1109/IV.2016.33	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7557904	R. Francese; M. Risi; G. Scanniello; G. Tortora	University of Salerno, Italy; University of Salerno, Italy; University of Basilicata, Italy; University of Salerno, Italy	2016 20th International Conference Information Visualisation (IV)	1 Sep 2016	2016			57	62	MetricAttitude is a visualization approach implemented in an environment that provides a mental picture by viewing an object-oriented software by means of polymetric views of classes (i.e., fine-grained). In this paper, we present an extension of MetricAttitude which visualizes a software by levels considering not only its class view but also its package views in terms of nested packages (i.e., coarse-grained). Packages are represented by using visual properties associated to Martin's metrics [15]. The new approach and its supporting visualization environment also allow showing relationships among packages.	2375-0138	978-1-4673-8942-6		Polymetric Views;Program Comprehension;Reverse Engineering;Software Evolution;Software Maintenance;Software Metrics;Software Visualization	Software;Visualization;Couplings;Concrete;Software metrics;Color	software maintenance;software metrics	polymetric view enhancement;coarse-grained views;MetricAttitude visualization approach;object-oriented software;polymetric class views;fine-grained views;software visualization;nested package views;visual properties;Martin metrics		1		24		1 Sep 2016			IEEE	IEEE Conferences
Mediating Turf Battles! Prioritizing Shared Modules in Locating Multiple Features	mediating turf battles! prioritizing shared modules in locating multiple features	10.1109/COMPSAC.2017.167	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8029629	M. Nakano; K. Noda; S. Hayashi; T. Kobayashi	Tokyo Institute of Technology, Tokyo, Japan; Tokyo Institute of Technology, Tokyo, Japan; Tokyo Institute of Technology, Tokyo, Japan; Tokyo Institute of Technology, Tokyo, Japan	2017 IEEE 41st Annual Computer Software and Applications Conference (COMPSAC)	11 Sep 2017	2017	1		363	368	Dynamic feature location techniques (DFLTs), which use execution profiles of scenarios that trigger a feature, are a promising approach to locating features in the source code. A sufficient set of scenarios is key to obtaining highly accurate results, however, its preparation is laborious and difficult in practice. In most cases, a scenario exercises not only the desired feature but also other features. We focus on the relationship between a module and multiple features that can be calculated with no extra scenarios, to improve the accuracy of locating the desired feature in the source code. In this paper, we propose a DFLT using the odds ratios of the multiple relationships between modules and features. We use the similarity coefficient, which is used in fault localization techniques, as a relationship. Our DFLT better orders shared modules compared with an existing DFLT. To reduce developer costs in our DFLT, we also propose a filtering technique that uses formal concept analysis. We evaluate our DFLT on the features of an open source software project with respect to developer costs and show that our DFLT outperforms the existing approach, the average cost of our DFLT is almost half that of the state-of-the-art DFLT.	0730-3157	978-1-5386-0367-3		Feature Location;Program Comprehension;Fault Localization;Dynamic Analysis;Formal Concept Analysis	Tools;Lattices;Formal concept analysis;Open source software;Conferences;Electronic mail	formal concept analysis;public domain software;software fault tolerance	shared modules;dynamic feature location techniques;DFLT;multiple features location;fault localization techniques;similarity coefficient;formal concept analysis;open source software project		1		14		11 Sep 2017			IEEE	IEEE Conferences
Awareness and Comprehension in Software/Systems Engineering Practice and Education: Trends and Research Directions	awareness and comprehension in software/systems engineering practice and education trends and research directions	10.1109/SBES.2012.25	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6337872	M. Schots; C. Werner; M. Mendonça	Systems Engineering and Computing Program, COPPE, Federal University of Rio de Janeiro, Rio de Janeiro, Brazil; Systems Engineering and Computing Program, COPPE, Federal University of Rio de Janeiro, Rio de Janeiro, Brazil; Computer Science Department, Federal University of Bahia, Rio de Janeiro, Brazil	2012 26th Brazilian Symposium on Software Engineering	25 Oct 2012	2012			186	190	The creation of tools, techniques and methodologies to support the manipulation of large data sets has been receiving special attention of both scientific and industrial communities, in order to discover new ways of dealing with the underlying information, including learning purposes, identification of patterns, decision making support, amongst others. However, making use of computing resources to enhance awareness and understanding of software information and the software itself is still a challenge in software/systems engineering, since it involves the identification of suitable mechanisms, adequate abstractions, and studies on stimulation of the human perceptive and cognitive abilities. This paper presents some of the challenges in this context, based on current trends of software development lifecycle, program comprehension, and software engineering education. At the end, a special focus is given on ongoing research on using and improving current mechanisms for supporting software reuse practices and software comprehension in general.		978-0-7695-4868-5		software engineering;awareness;program comprehension;software visualization;software engineering education;grand challenges	Software;Software engineering;Education;Visualization;Conferences;Industries;Data visualization	computer science education;software reusability	software-system engineering practice;software-system engineering education;software information awareness;software information understanding;human perceptive stimulation;cognitive ability;software development lifecycle;program comprehension;software engineering education;software reuse practices;software comprehension		1		40		25 Oct 2012			IEEE	IEEE Conferences
How to Interconnect Operational and Behavioral Views of Web Applications	how to interconnect operational and behavioral views of web applications	10.1109/ICPC.2008.25	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556141	D. C. da Cruz; R. F. C. d. Fonseca; P. M. R. S. Henriques; M. J. V. Pereira	Polytechnic Institute of Bragança, Campus de Sta, Portugal; Department of Computer Science, Campus de Gualtar, Braga, Portugal; Department of Computer Science, Campus de Gualtar, Braga, Portugal; Polytechnic Institute of Bragança, Campus de Sta, Braganca, Portugal	2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			263	267	In the context of our research project, we are looking for program comprehension tools that are able to interconnect operational and behavioral views, aiming at aiding the programmer to relate problem and program domains to reach a full understanding of software systems. In particular we have been studying the adaptation of that principle to Web applications. In this context, we had designed and implemented a tool called WebAppViewer. In this paper, we emphasize the development of the module (BORS) that is responsible for providing interconnection functionalities and we propose a tool demonstration. A dedicated Web server is included in the system to allow the execution of the piece of code selected by the user. This feature is used to relate the source text (html, php, etc) executed by the server, with the web page received by the client. Code instrumentation is used to collect dynamic information.	1092-8138	978-0-7695-3176-2		WebAppViewer;operational view;behavior view;web applications;program comprehension	Application software;Software systems;Web server;HTML;Dynamic programming;Data mining;Computer science;Programming profession;Web pages;Instruments	Internet;software engineering	Web applications;program comprehension tools;software systems;WebAppViewer;code instrumentation		1		15		2 jul. 2008			IEEE	IEEE Conferences
Explaining Why Methods Change Together	explaining why methods change together	10.1109/SCAM.2014.27	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6975652	A. Lozano; C. Noguera; V. Jonckers	Software Languages Lab., Vrije Universiteit, Brussel; Software Languages Lab., Vrije Universiteit, Brussel; Software Languages Lab., Vrije Universiteit, Brussel	2014 IEEE 14th International Working Conference on Source Code Analysis and Manipulation	6 Dec 2014	2014			185	194	By analyzing historical information from Source Code Management systems, previous research has observed that certain methods tend to change together consistently. Co-change has been identified as a good predictor of the entities that are likely to be affected by a change, which ones might be missing modifications, and which ones might change in the future. However, existing co-change analysis provides no insight on why methods consistently co-change. Being able to identify the rationale that explains co-changes could allow to document and enforce design knowledge. This paper proposes an automatic approach to derive the reason behind a co-change. We define the reason of a (set) of co-changes as a set of properties common to the elements that co-change. We consider two kinds of properties: structural properties which indicate explicit dependencies, and semantic properties which reveal implicit dependencies. Then we attempt to identify the reasons behind single commits, as well as the reasons behind co-changes that repeatedly affect the same set of methods. These sets of methods are identified by clustering methods that tend to be modified in the same commit-transactions. We perform our analysis over the history of two open-source systems, analyzing nearly 19.000 methods and over 3700 commits. We show that it is possible to automatically extract explanations for co-changes, that the quality of such explanations improves when structural and semantic properties are taken into account, and when the methods analyzed co-change recurrently.		978-1-4799-6148-1		Co-change;Empirical software engineering;Program comprehension	Semantics;History;Documentation;Measurement;Java;Libraries;Clustering methods	pattern clustering;program diagnostics;public domain software	co-change analysis;structural properties;explicit dependencies;semantic properties;implicit dependencies;clustering methods;commit-transactions;open-source systems		1		18		6 Dec 2014			IEEE	IEEE Conferences
Patcher: An Online Service for Detecting, Viewing and Patching Web Application Vulnerabilities	patcher an online service for detecting, viewing and patching web application vulnerabilities	10.1109/HICSS.2014.598	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6759201	F. Yu; Y. -Y. Tung	Department of Management Information Systems, National Chengchi University; Department of Management Information Systems, National Chengchi University	2014 47th Hawaii International Conference on System Sciences	10 mar. 2014	2014			4878	4886	Web application security becomes a critical issue as more and more web applications appear and serve common life and business routines in recent years. It is known that web applications are vulnerable due to software defects. Open to public users, vulnerable websites may encounter lots of malicious attacks from the Internet. We present a new web service platform where system developers can detect, view and patch potential vulnerabilities of their web applications online. Taking advantage of static string analysis techniques, our analysis ensures that the patched programs are free from vulnerabilities with respect to given attack patterns. Specifically, we integrate the service front end with program visualization techniques, developing a 3D interface/presentation for users to access and view the analysis result under visualization environment with the aim of improving users' comprehension on programs, especially how vulnerabilities get exploited and patched. We report our analysis result on several open source applications, finding and patching various unknown/known vulnerabilities.	1530-1605	978-1-4799-2504-9		visualization;web security;string analysis;program comprehension	Security;Visualization;Automata;Mobile handsets;Web services;Three-dimensional displays;Reachability analysis	program diagnostics;program visualisation;public domain software;security of data;software maintenance;Web services;Web sites	Patcher;online service;Web application vulnerability detection;Web application vulnerability viewing;Web application vulnerability patching;Web application security;software defects;Web sites;malicious attacks;Internet;Web service platform;static string analysis techniques;service front end integration;program visualization techniques;3D interface development;3D presentation development;open source applications;program comprehension		1		33		10 mar. 2014			IEEE	IEEE Conferences
Critical Section Investigator: Building Story Visualizations with Program Traces	critical section investigator building story visualizations with program traces	10.1109/VISSOFT.2016.13	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780170	M. D. Shah; S. Z. Guyer	Tufts University, Medford, MA; Tufts University, Medford, MA	2016 IEEE Working Conference on Software Visualization (VISSOFT)	12 Dec 2016	2016			136	140	Detecting performance problems that infrequently occur can be very difficult with traditional profilers. Most profilers only show the average time of execution or the total time a method contributes to the overall program's execution time. Most profilers do not explain or show why different control paths within a method executed may have resulted in variable execution times. When debugging concurrent programs for performance problems, the complexity and variability in execution time can potentially be even greater. In this paper we take a first step in visualizing individual method's different execution paths within multithreaded Java programs. We restrict our domain to looking at critical sections for this initial analysis, as variability in critical sections may cause more noticeable performance variation. Our software visualization tool, Critical Section Investigator (CSI), builds on the visualization and interaction techniques in previous works like KCachegrind with several enhancements. The result of our work is the first tool to our knowledge that visually shows potential performance differences in synchronized methods in Java programs using a profiling and storytelling structure.		978-1-5090-3850-3		Java;Critical Sections;Concurrency;Program Comprehension;Software Visualization	Data visualization;Java;Synchronization;Visualization;Software;Instruments	data visualisation;Java;multi-threading	critical section investigator;story visualizations;program traces;profilers;concurrent program debugging;performance problems;multithreaded Java programs;software visualization tool;CSI;KCachegrind;storytelling structure		1		17		12 Dec 2016			IEEE	IEEE Conferences
Toward Summary Extraction Method for Functional Topic	toward summary extraction method for functional topic	10.1109/QRS-C.2017.13	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8004289	W. Li; Y. Cao; J. Zhao; Y. Zou; B. Xie	MoE, Key Laboratory of High Confidence Software Technologies, Beijing, China; MoE, Key Laboratory of High Confidence Software Technologies, Beijing, China; MoE, Key Laboratory of High Confidence Software Technologies, Beijing, China; MoE, Key Laboratory of High Confidence Software Technologies, Beijing, China; MoE, Key Laboratory of High Confidence Software Technologies, Beijing, China	2017 IEEE International Conference on Software Quality, Reliability and Security Companion (QRS-C)	10 Aug 2017	2017			16	23	Understanding the function of software code is the basis for software reuse. Topic modeling technologies can mine functional topics from source code and help developers comprehend the functional concerns about a software system and the corresponding implementations in source code. However, lacking clear explanations makes these functional topics hard to be understood by the developers. Furthermore, giving proper interpretations to these topics manually is time consuming. In this paper, we firstly use self-parameter-optimizing Latent Dirichlet Allocation (LDA) technology to mine the functional topic for the software. Then we put forward an approach for calculating the relevancy between functional topics and software documents. The LexRank technology is used to automatically generate summary for those topics from software documents such as user manuals, pairs of question and answer, mailing lists and so on. The experiment results indicate that these summaries improve developers understanding the function of software code.		978-1-5386-2072-4		topic model;LDA;functional summarization;program comprehension	Data mining;Data models;Data preprocessing;Software reusability;Resource management;Manuals	data mining;software reusability;source code (software);text analysis	software code function;software reuse;source code;software system;self-parameter-optimizing latent Dirichlet allocation technology;functional topic mining;topic modeling;software documents;LexRank technology;summary extraction method		1		36		10 Aug 2017			IEEE	IEEE Conferences
Behavior-Informed Algorithms for Automatic Documentation Generation	behaviorinformed algorithms for automatic documentation generation	10.1109/ICSME.2017.73	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8094477	P. Rodeghero	Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN, USA	2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)	7 nov. 2017	2017			660	664	Programmers rely on source code documentation to quickly understand what the source code does and how they would use it. Unfortunately, many programmers do not have the time to write and maintain source code documentation. A solution to this problem is to document and summarize source code automatically. Unfortunately, research efforts to automatically generate documentation have stalled recently because the research community does not know exactly what a summary of source code should include. To solve this problem, my overall strategy is to study programmer behavior in order to write algorithms that mimic that behavior. I have four key areas of work in which I execute that strategy: First, I determine what areas of code programmers read when they create documentation. Second, I find patterns in programmers' eye movements when they reading code. Third, I use recordings of developer-client meetings to extract user story information. Finally, I propose to conduct a grounded theory study at a medium sized software company to determine whether factors outside the code influence source code summarization. This paper discusses the foundation for my career in the software engineering community, and I seek the community's advice.		978-1-5386-0992-7		Source code summaries;program comprehension	Documentation;Software;Tools;Data mining;Companies;Human factors	software engineering;source code (software);system documentation	automatic documentation generation;source code documentation;programmer behavior;code programmers;behavior-informed algorithms;developer-client meetings;medium sized software company;source code summarization;software engineering community		1		47		7 nov. 2017			IEEE	IEEE Conferences
Key Elements Extraction and Traces Comprehension Using Gestalt Theory and the Helmholtz Principle	key elements extraction and traces comprehension using gestalt theory and the helmholtz principle	10.1109/ICSME.2016.24	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7816498	R. Khoury; L. Shi; A. Hamou-Lhadj	Department of Computer Science and Mathematics, Université du Québec à Chicoutimi, Chicoutimi, Canada; Department of Computer Science and Mathematics, Université du Québec à Chicoutimi, Chicoutimi, Canada; Department of Electrical and Computer Engineering, Concordia University, Montreal, Canada	2016 IEEE International Conference on Software Maintenance and Evolution (ICSME)	16 jan. 2017	2016			478	482	Trace analysis techniques are used by software engineers to understand the behaviour of large systems. This understanding can facilitate various software maintenance activities including debugging and feature enhancement. However, traces usually tend to be very large, which makes it difficult for software engineers to unveil the key logic and functionalities embedded in a program's execution. Hence, it is necessary to develop methods and tools that can efficiently identify the important information contained in a large trace. In this paper, we propose an approach that builds on the concept of trace segmentation to extract the major components of a traced scenario. Our approach is based on Gestalt theory and the Helmholtz principle. We show the effectiveness of our approach by applying it to a dataset of large traces.		978-1-5090-3806-0		Trace analysis;trace segmentation;program Comprehension;Gestalt Theory;Helmholtz Principle	Shape;Psychology;Software maintenance;Debugging;Mathematical model;Phase detection	program diagnostics	key elements extraction;traces comprehension;Gestalt theory;helmholtz principle;trace analysis techniques;software engineers;trace segmentation concept		1		23		16 jan. 2017			IEEE	IEEE Conferences
Representing and Integrating Dynamic Collaborations in IDEs	representing and integrating dynamic collaborations in ides	10.1109/WCRE.2008.53	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656396	D. Röthlisberger; O. Greevy	Software Composition Group, University of Bern, Switzerland; Software Composition Group, University of Bern, Switzerland	2008 15th Working Conference on Reverse Engineering	24 Oct 2008	2008			74	78	Static views of object-oriented source code as presented in adevelopment environment (IDE) do not provide explicitrepresentations of dynamic collaboration to describe how sourceartifacts communicate at runtime.  Direct access within an IDE toexplicit representations of dynamic collaborations would providedevelopers with useful insights  into a system's behavior. In thispaper we describe how we  seamlessly integrate novel interactivevisual representations of dynamic collaborations between staticartifacts to complement traditional static concepts within the IDE.We motivate our work and introduce our enhancements in our prototypeIDE Hermion and provide validation for our work by means of casestudies and benchmarks.	2375-5369	978-0-7695-3429-9		dynamic analysis;dynamic collaborations;development environments;partial behavioral reflection;program comprehension	Collaboration;Runtime;Visualization;Navigation;Software;Benchmark testing;Reflection	object-oriented programming;program diagnostics;program visualisation;software engineering	object-oriented source code;integrated development environment;system behavior;interactive visual dynamic collaboration representation;static view;software developer		1		12		24 Oct 2008			IEEE	IEEE Conferences
Class Level Code Summarization Based on Dependencies and Micro Patterns	class level code summarization based on dependencies and micro patterns	10.1109/ICICCT.2018.8473199	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8473199	M. Malhotra; J. Kumar Chhabra	Department of Computer of Engineering, National Institute of Technology, Kurukshetra, Haryana, India; Department of Computer of Engineering, National Institute of Technology, Kurukshetra, Haryana, India	2018 Second International Conference on Inventive Communication and Computational Technologies (ICICCT)	27 Sep 2018	2018			1011	1016	Modifications in any software need to be carries out on various entities. Change in one entity may force some changes in many other dependent entities. Complete understanding of entities and there dependencies are highly desirable to carry out modifications in an efficient manner. Automated summarization of classes in object oriented software can be a good step in this direction. This paper proposes a natural language summary based code summarization of those java classes which are more change prone. Code summary is generated by using concept of micro patterns and change proneness is identified by computing different kinds of dependencies among classes. A threshold is decided to identify the classes which are more sensitive to change. The empirical evaluation of some open source classes has been carried out which clearly indicates the usefulness of the proposed work.		978-1-5386-1974-2		Program comprehension;Class level summarization;change sensitivity	Sensitivity;Java;Software systems;Natural languages;Maintenance engineering;Machine learning	Java;natural language processing;object-oriented programming	class level code summarization;micropatterns;dependent entities;complete understanding;automated summarization;object oriented software;natural language summary based code summarization;java classes;code summary;change proneness;open source classes		1		27		27 Sep 2018			IEEE	IEEE Conferences
gazel: Supporting Source Code Edits in Eye-Tracking Studies	gazel supporting source code edits in eyetracking studies	10.1109/ICSE-Companion52605.2021.00038	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9402486	S. Fakhoury; D. Roy; H. Pines; T. Cleveland; C. S. Peterson; V. Arnaoudova; B. Sharif; J. Maletic	Washington State University, USA; Washington State University, USA; Washington State University, USA; Washington State University, USA; University of Nebraska-Lincoln, USA; Washington State University, USA; University of Nebraska-Lincoln, USA; Kent State University, Kent, OH, USA	2021 IEEE/ACM 43rd International Conference on Software Engineering: Companion Proceedings (ICSE-Companion)	7 May 2021	2021			69	72	Eye tracking tools are used in software engineering research to study various software development activities. However, a major limitation of these tools is their inability to track gaze data for activities that involve source code editing. We present a novel solution to support eye tracking experiments for tasks involving source code edits as an extension of the iTrace [9] community infrastructure. We introduce the iTrace-Atom plugin and gazel [g@"zel]-a Python data processing pipeline that maps gaze information to changing source code elements and provides researchers with a way to query this dynamic data. iTrace-Atom is evaluated via a series of simulations and is over 99% accurate at high eye-tracking speeds of over 1,000Hz. iTrace and gazel completely revolutionize the way eye tracking studies are conducted in realistic settings with the presence of scrolling, context switching, and now editing. This opens the doors to support many day-to-day software engineering tasks such as bug fixing, adding new features, and refactoring.	2574-1926	978-1-6654-1219-3		eye tracking;empirical software engineering;program comprehension	Gaze tracking;Switches;Tools;Software;Task analysis;Software engineering;Python	gaze tracking;Python;software engineering;source code (software)	source code elements;gazel;software engineering tasks;eye tracking tools;software development activities;gaze data;iTrace-Atom plugin;Python data processing pipeline		1		12		7 May 2021			IEEE	IEEE Conferences
Towards a unified software attack model to assess software protections	towards a unified software attack model to assess software protections	10.1109/ICPC.2013.6613852	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613852	C. Basile; M. Ceccato	Politecnico di Torino, Torino, Italy; Fondazione Bruno Kessler, Trento, Italy	2013 21st International Conference on Program Comprehension (ICPC)	30 Sep 2013	2013			219	222	Attackers can tamper with programs to break usage conditions. Different software protection techniques have been proposed to limit the possibility of tampering. Some of them just limit the possibility to understand the (binary) code, others react more actively when a change attempt is detected. However, the validation of the software protection techniques has been always conducted without taking into consideration a unified process adopted by attackers to tamper with programs. In this paper we present an extension of the mini-cycle of change, initially proposed to model the process of changing program for maintenance, to describe the process faced by an attacker to defeat software protections. This paper also shows how this new model should support a developer when considering what are the most appropriate protections to deploy.	1092-8138	978-1-4673-3092-3		Program comprehension;Software protection;Software security	Software;Software protection;Testing;Context;Games;Maintenance engineering;Security	program verification;security of data;software maintenance	software security;program maintenance;binary code;program tampering;software protection techniques;usage conditions;software protection assessment;unified software attack model		1		17		30 Sep 2013			IEEE	IEEE Conferences
Generating suggestions for initial program investigation using Dynamic Analysis	generating suggestions for initial program investigation using dynamic analysis	10.1109/C-CODE.2017.7918934	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7918934	M. Kamran; M. Ali; A. Ahmed	Department of Computer Engineering, NUST, Islamabad, Pakistan; Department of Computer Science and IT, The University of Lahore, Gujrat, Pakistan; Department of Computer Science, Quaid-i-Azam University, Islamabad, Pakistan	2017 International Conference on Communication, Computing and Digital Systems (C-CODE)	4 May 2017	2017			233	237	The process of building an understanding of the existing system is time consuming and takes a big portion of the allocated time for a maintenance task. Numerous efforts have been made to reduce the time consumed in the program comprehension process by providing support to the programmer during this phase. The segments of the program that can be attractive from the comprehension viewpoint must be brought into the notice of the programmer. The key contribution of this paper is a heuristic approach that can aid the programmer by automatically suggesting the classes that are potentially interesting for the initial stages of the program comprehension process.		978-1-5090-4448-1		dynamic analysis;dynamic coupling metrics;most important classes;core classes;program comprehension	Couplings;Measurement;Documentation;Software systems;Performance analysis;Buildings	software architecture;software maintenance	dynamic analysis;maintenance task;program comprehension process;dynamic coupling metrics;software development		1		18		4 May 2017			IEEE	IEEE Conferences
Filtered mining in program code repositories	filtered mining in program code repositories	10.1109/InfRKM.2012.6204986	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6204986	F. Taibi	Faculty of Information Technology, University of Management and Technology, Malaysia	2012 International Conference on Information Retrieval & Knowledge Management	28 May 2012	2012			264	267	An approach to automatically mine program code repositories in order to support software reuse is proposed in this paper. Code attributes and structural relationships are used to find and rank the potential elements based on a given query. Static program analysis is used to allow a filtered mining through three well-established metrics that have a direct impact on code quality. The approach has been empirically evaluated and the results obtained were promising.		978-1-4673-1090-1		Mining Source Code Repositories;Static Program Analysis;Program Comprehension;Software Metrics;Software Reuse	Data mining;Measurement;Software reusability;Software engineering;Accuracy;Complexity theory	data mining;program diagnostics;software metrics;software quality;software reusability	filtered mining;program code repositories;software reuse;code attributes;structural relationships;potential elements;static program analysis;metrics;code quality		1		15		28 May 2012			IEEE	IEEE Conferences
Enhanced Visualization of Method Invocations by Extending Reverse-engineered Sequence Diagrams	enhanced visualization of method invocations by extending reverseengineered sequence diagrams	10.1109/VISSOFT51673.2020.00010	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9240498	T. A. Ghaleb; K. Aljasser; M. A. Alturki	School of Computing, Queen’s University, Kingston, Ontario, Canada; Information & Computer Science Department, King Fahd University of Petroleum and Minerals, Dhahran, Saudi Arabia; Information & Computer Science Department, King Fahd University of Petroleum and Minerals, Dhahran, Saudi Arabia	2020 Working Conference on Software Visualization (VISSOFT)	30 Oct 2020	2020			49	60	Software} maintainers employ reverse-engineered sequence diagrams to visually understand software behavior, especially when software documentation is absent or outdated. Much research has studied the adoption of reverse-engineered sequence diagrams to visualize program interactions. However, due to the forward-engineering nature of sequence diagrams, visualizing more complex programming scenarios can be challenging. In particular, sequence diagrams represent method invocations as unidirectional arrows. However, in practice, source code may contain compound method invocations that share values/objects implicitly. For example, method invocations can be nested, e.g., fun (foo ()), or chained, e.g., fun (). foo (). The standard notation of sequence diagrams does not have enough expressive power to precisely represent compound scenarios of method invocations. Understanding the flow of information between method invocations simplifies debugging, inspection, and exception handling operations for software maintainers. Despite the research invested to address the limitations of UML sequence diagrams, previous approaches fail to visualize compound scenarios of method invocations. In this paper, we propose sequence diagram extensions to enhance the visualization of (i) three widely used types of compound method invocations in practice (i.e., nested, chained, and recursive) and (ii) lifelines of objects returned from method invocations. We aim through our extensions to increase the level of abstraction and expressiveness of method invocation code. We develop a tool to reverse engineer compound method invocations and generate the corresponding extended sequence diagrams. We evaluate how our proposed extensions can improve the understandability of program interactions using a controlled experiment. We find that program interactions are significantly more comprehensible when visualized using our extensions.		978-1-7281-9914-6		Sequence diagram;extended notation;program comprehension;method invocation;controlled experiment	Visualization;Unified modeling language;Tools;Software;Compounds;Task analysis;Standards	diagrams;object-oriented programming;program visualisation;reverse engineering;software maintenance;source code (software);Unified Modeling Language	method invocation code;reverse-engineered sequence diagrams;software maintainers;UML sequence diagrams;program interactions visualization;software behavior		1		68		30 Oct 2020			IEEE	IEEE Conferences
TASSAL: Autofolding for Source Code Summarization	tassal autofolding for source code summarization		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7883362	J. Fowkes; P. Chanthirasegaran; R. Ranca; M. Allamanis; M. Lapata; C. Sutton	School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK	2016 IEEE/ACM 38th International Conference on Software Engineering Companion (ICSE-C)	23 mar. 2017	2016			649	652	We present a novel tool, TASSAL, that automatically creates a summary of each source file in a project by folding its least salient code regions. The intended use-case for our tool is the first-look problem: to help developers who are unfamiliar with a new codebase and are attempting to understand it. TASSAL is intended to aid developers in this task by folding away less informative regions of code and allowing them to focus their efforts on the most informative ones. While modern code editors do provide \emph{code folding} to selectively hide blocks of code, it is impractical to use as folding decisions must be made manually or based on simple rules. We find through a case study that TASSAL is strongly preferred by experienced developers over simple folding baselines, demonstrating its usefulness. In short, we strongly believe TASSAL can aid program comprehension by turning code folding into a usable and valuable tool. A video highlighting the main features of TASSAL can be found at https://youtu.be/_yu7JZgiBA4.		978-1-4503-4205-6		code summarization;code folding;program comprehension;topic modelling	Java;Standards;Turning;Optimization;Programming;Conferences;Software engineering	software tools;source code (software)	code folding turning;program comprehension;codebase;first-look problem;least salient code regions;source file summary;source code summarization;autofolding;TASSAL tool		1		21		23 mar. 2017			IEEE	IEEE Conferences
Towards A Catalog of Design Patterns Variants	towards a catalog of design patterns variants	10.1109/FIT47737.2019.00038	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8991617	G. Rasool; H. Akhtar	Department of Compute Science, COMSATS University Islamabad, Lahore, Pakistan; Department of Compute Science, COMSATS University Islamabad, Lahore, Pakistan	2019 International Conference on Frontiers of Information Technology (FIT)	13 Feb 2020	2019			156	161	With increasing applications of design patterns for the development of quality software applications, the accurate recovery of patterns from software applications remained active research area in the last one and half decade. The implementation variations for standard patterns hamper the accuracy of existing pattern recovery techniques and tools. There is no standard catalog on all variants of Gang of Four(GoF) design patterns in the literature. We present the first catalog on variations of GoF design patterns that are discussed in different publications, blogs and discussion forums at different levels of abstraction. A catalog with 107 variants of standard patterns might serve as a knowledge base for the design pattern research community and it might be helpful to specify GoF patterns and their variants. The critical analysis and observations on GoF design patterns and their variants are presented based on the whole study and our experience.	2334-3141	978-1-7281-6625-4		Design Patterns, Reverse Engineering, Variants of Patterns, Reusability, Program Comprehension		software quality	design patterns variants;quality software applications;pattern recovery techniques;GoF design patterns;design pattern research community;Gang of Four design patterns		1		63		13 Feb 2020			IEEE	IEEE Conferences
A Taxonomy of Interactions Introduced by Aspects	a taxonomy of interactions introduced by aspects	10.1109/COMPSAC.2008.159	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4591656	M. L. Bernardi; G. A. Di Lucca	Research Centre on Software Technology (RCOST), University of Sannio, Italy; Research Centre on Software Technology (RCOST), University of Sannio, Italy	2008 32nd Annual IEEE International Computer Software and Applications Conference	8 Aug 2008	2008			726	731	Aspects have a large impact on the static structure and dynamic behaviour of the system they belong. This is due to the intrinsic intrusive nature of aspects and the woven process allowing the alteration of the structure, the control and data flow of the components of the base system in aspect oriented (AO) systems. Several and different types of interactions among aspects and the other components can be introduced according to the different mechanisms provided by AO Programming. These interactions can make higher the complexity of the overall system affecting its comprehension. In this paper we propose a taxonomy to categorize these types of interactions among aspects and the components of the base system. The taxonomy can be used to understand how each type of interaction affects the complexity, and thus the comprehensibility, of the system.	0730-3157	978-0-7695-3262-2		Software Quality;Program comprehension;Aspect Oriented Programming	Taxonomy;Complexity theory;Software;Flow graphs;Programming;Observers;Object recognition	object-oriented programming;software quality	taxonomy;woven process;components data flow;aspect oriented systems;aspect oriented programming		1		14		8 Aug 2008			IEEE	IEEE Conferences
Visual Breakpoint Debugging for Sum and Product Formulae	visual breakpoint debugging for sum and product formulae	10.1109/VISSOFT51673.2020.00019	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9240489	O. Moseler; M. Wolz; S. Diehl	Computer Science University of Trier, Trier, Germany; Computer Science University of Trier, Trier, Germany; Computer Science University of Trier, Trier, Germany	2020 Working Conference on Software Visualization (VISSOFT)	30 Oct 2020	2020			133	137	Software debugging is one of the most time consuming source code related tasks. Hence, we propose a novel approach to breakpoint debugging for formula code, i.e. source code implementing mathematical formulae. In this work, the focus is on source code which computes a numerical value via arithmetic operations as well as sum- and product formulae. We introduce and discuss breakpoints placed on an automatically inferred mathematical representation, i.e. in a common mathematical notation or by a mixed form of source code artifacts and maths symbols. Furthermore, we present visual debugging features aiming to facilitate the dynamic inspection of the formula code leveraging the mathematical representation. We briefly present a first prototype implementation of our formula debugging approach and indicate future directions of our work.		978-1-7281-9914-6		debugging;breakpoint;formula code;maths;visualization;program comprehension	Visualization;Prototypes;Debugging;Inspection;Task analysis;Software debugging	program debugging	visual breakpoint debugging;software debugging;time consuming source code related tasks;mathematical formulae;source code artifacts;maths symbols;visual debugging features;formula debugging;formula code;sum and product formula		1		28		30 Oct 2020			IEEE	IEEE Conferences
Context-Aware Software Documentation	contextaware software documentation	10.1109/ICSME.2018.00090	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530093	E. Aghajani	Software Institute, REVEAL, Università della Svizzera italiana (USI), Lugano, Switzerland	2018 IEEE International Conference on Software Maintenance and Evolution (ICSME)	11 nov. 2018	2018			727	731	Software developers often do not possess the knowledge needed to understand a piece of code at hand, and the lack of code comments and outdated documentation exacerbates the problem. Asking for the help of colleagues, browsing the official documentation, or accessing online resources, such as Stack Overflow, can clearly help in this "code comprehension" activity that, however, still remains highly time-consuming and is not always successful. Enhancing this process has been addressed in different studies under the subject of automatic documentation of software artifacts. For example, "recommender systems" have been designed with the goal of retrieving and suggesting relevant pieces of information (e.g., Stack Overflow discussions) for a given piece of code inspected in an IDE. However, these techniques rely on limited contextual information, mainly solely source code. Our goal is to build a context-aware proactive recommender system supporting the code comprehension process. The system must be able to understand the context, consider the developer's profile, and help her by generating pieces of documentation at whatever granularity is required, e.g., going from summarizing the responsibilities implemented in a subsystem, to explaining how two classes collaborate to implement a functionality, down to documenting a single line of code. Generated documentation will be tailored for the current context (e.g., the task at hand, the developer's background knowledge, the history of interactions). In this paper we present our first steps toward our goal by introducing the ADANA project, a framework which generates fine-grained code comments for a given piece of code.	2576-3148	978-1-5386-7870-1		software documentation;program comprehension;context-aware;recommender system	Documentation;Recommender systems;Task analysis;Software;Knowledge based systems;Data mining;Cloning	document handling;information retrieval;Internet;recommender systems;software maintenance;system documentation;ubiquitous computing;Web sites	contextual information;context-aware proactive recommender system;code comprehension process;generated documentation;fine-grained code comments;context-aware software documentation;software developers;official documentation;online resources;automatic documentation;software artifacts;source code;time-consuming;developer profile;stack overflow;information retrieval		1		46		11 nov. 2018			IEEE	IEEE Conferences
How Does Feature Dependency Affect Configurable System Comprehensibility?	how does feature dependency affect configurable system comprehensibility	10.1109/ICPC.2019.00016	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813293	D. Santos; C. Sant' Anna	Federal Institute of Bahia, Federal University of Bahia Salvador, Brazil, Bahia; Department of Computer Science, Federal University of Bahia, Brazil, Bahia	2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC)	29 Aug 2019	2019			19	29	Background: Conditional compilation is often used to implement variability in configurable systems. This technique relies on #ifdefs to delimit feature code. Previous studies have shown that #ifdefs may hinder code comprehensibility. However, they did not explicitly took feature dependencies into account. Feature dependency occurs when different features refer to the same program element, such as a variable. Comprehensibility may be even more affected in the presence of feature dependency, as the developer must reason about different scenarios affecting the same variable. Aim: Our goal is to understand how feature dependency affects the comprehensibility of configurable system source code. Method: We carried out an experiment in which 30 developers debugged programs with different types of feature dependency. We recorded the time each of them had spent to find a bug. Also, we used an eye-tracking device to record developers' gaze movements while they debugged programs. Results: Debugging programs with global and interprocedural dependency required more time and higher visual effort. Conclusion: Our study showed that #ifdefs affect comprehensibility in different degrees depending on the type of feature dependency. Therefore, when possible, developers should take more care when dealing with code with global and interprocedural dependencies.	2643-7171	978-1-7281-1519-1		Feature dependency, Program comprehension, Configurable Systems, Variability bugs, Eye tracking	Computer bugs;Visualization;Debugging;Task analysis;Measurement;Computer science;Indexes	program compilers;program debugging;program diagnostics;software maintenance	feature code;feature dependency;configurable system source code;global dependency;interprocedural dependency;configurable system comprehensibility;program debugging;eye-tracking device;developer gaze movements		1		41		29 Aug 2019			IEEE	IEEE Conferences
GraphEvo: Characterizing and Understanding Software Evolution using Call Graphs	graphevo characterizing and understanding software evolution using call graphs	10.1109/BigData47090.2019.9005560	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9005560	V. Walunj; G. Gharibi; D. H. Ho; Y. Lee	School of Computing and Engineering, University of Missouri-Kansas City; School of Computing and Engineering, University of Missouri-Kansas City; School of Computing and Engineering, University of Missouri-Kansas City; School of Computing and Engineering, University of Missouri-Kansas City	2019 IEEE International Conference on Big Data (Big Data)	24 Feb 2020	2019			4799	4807	Understanding software evolution is an imperative prerequisite for software related activities such as testing, debugging, and maintenance. As a software system evolves, it increases in size and complexity, introducing new challenges of understating the inner system interactions and subsequently hinders the overall system comprehension. While tools that construct and visualize call graphs have been used to facilitate software comprehension, they are still limited to capturing the functionality of a single software system at a time. However, understanding the similarities and differences across multiple releases becomes an imperative and challenging task during software evolution. To this end, we present a tool, named GraphEvo, that focuses on automating the process of quantifying and visualizing the changes across multiple releases of a software system based on an information-theoretic approach to compare the call graphs. Specifically, GraphEvo can automatically (1) construct and visualize the call graph for one or more software releases, (2) calculate and display a set of graph-based metrics, and (3) construct color-coded call graphs to visualize system evolution. The main goal of GraphEvo is to assist software developers and testers in exploring and tracking software changes over time. We demonstrate the functionality of GraphEvo by analyzing and studying five real software systems throughout their entire lifespan. The tool, evaluation results, and a video demo are available at https://goo.gl/8edZ64.		978-1-7281-0858-2		static code analysis;call graph;program comprehension;software evolution	Software systems;Tools;Visualization;Measurement;Java;Maintenance engineering	data visualisation;graph theory;program testing;public domain software;software maintenance	GraphEvo;understanding software evolution;software related activities;inner system interactions;system comprehension;software comprehension;single software system;software releases;graph-based metrics;system evolution;software developers;testers		1		24		24 Feb 2020			IEEE	IEEE Conferences
Do Extracted State Machine Models Help to Understand Embedded Software?	do extracted state machine models help to understand embedded software	10.1109/ICPC.2019.00038	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813256	W. Said; J. Quante; R. Koschke	Robert Bosch GmbH, Renningen, Germany; Robert Bosch GmbH, Renningen, Germany; University of Bremen, Bremen, Germany	2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC)	29 Aug 2019	2019			191	196	Program understanding is a prerequisite for several software activities, such as maintenance, evolution, and reengineering. Code in itself is so detailed that it is often hard to understand. More abstract models describing its behaviour may ease program understanding. Manually building understandable abstractions from complex source code - as an explicit or just mental model - requires in-depth analysis of the code in the first place. Therefore, it is a time-consuming and tedious activity for developers. Model mining can support program comprehension by semi-automatically extracting high-level models from code. One helpful model is a state machine, which is an established formalism for specifying the behaviour of a software component. In this paper, we report on a controlled experiment that investigates the question: Do semi-automatically extracted state machines make understanding of complex embedded code more effective? The experiment was conducted with 30 participants on two industrial embedded C code functions. The results show that the share of correct answers increases and the required time to solve the tasks decreases significantly when extracted state machines are available. We conclude that mined state machines do in fact help in program understanding.	2643-7171	978-1-7281-1519-1		program comprehension, controlled experiment, reverse engineering, state machines, embedded legacy software		data mining;finite state machines;formal specification;object-oriented programming;program diagnostics;reverse engineering;software maintenance;source code (software)	complex source code;explicit model;model mining;program comprehension;software component;complex embedded code;mined state machines;program understanding;extracted state machine models;embedded software;software activities;abstract models;understandable abstractions;software maintenance;software evolution;software reengineering;code in-depth analysis;high-level model extraction;software component behaviour specification;industrial embedded C code functions		1		36		29 Aug 2019			IEEE	IEEE Conferences
VITALSE: Visualizing Eye Tracking and Biometric Data	vitalse visualizing eye tracking and biometric data		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9270404	D. Roy; S. Fakhoury; V. Arnaoudova	Washington State University, Pullman, Washington; Washington State University, Pullman, Washington; Washington State University, Pullman, Washington	2020 IEEE/ACM 42nd International Conference on Software Engineering: Companion Proceedings (ICSE-Companion)	1 Dec 2020	2020			57	60	Recent research in empirical software engineering is applying techniques from neurocognitive science and breaking new grounds in the ways that researchers can model and analyze the cognitive processes of developers as they interact with software artifacts. However, given the novelty of this line of research, only one tool exists to help researchers represent and analyze this kind of multimodal biometric data. While this tool does help with visualizing temporal eyetracking and physiological data, it does not allow for the mapping of physiological data to source code elements, instead projecting information over images of code. One drawback of this is that researchers are still unable to meaningfully combine and map physiological and eye tracking data to source code artifacts. The use of images also bars the support of long or multiple code les, which prevents researchers from analyzing data from experiments conducted in realistic settings. To address these drawbacks, we propose VITALSE, a tool for the interactive visualization of combined multi-modal biometric data for software engineering tasks. VITALSE provides interactive and customizable temporal heatmaps created with synchronized eyetracking and biometric data. The tool supports analysis on multiple les, user defined annotations for points of interest over source code elements, and high level customizable metric summaries for the provided dataset. VITALSE, a video demonstration, and sample data to demonstrate its capabilities can be found at http://www.vitalse.app.	2574-1926	978-1-4503-7122-3		eyetracking;biometrics;software engineering;data visualization;program comprehension;multi-modal eyetracking visualization	Data visualization;Tools;Biometrics (access control);Physiology;Heating systems;Gaze tracking;Task analysis	biometrics (access control);data analysis;data visualisation;gaze tracking;graphical user interfaces;interactive systems;software engineering	VITALSE;empirical software engineering;neurocognitive science;software artifacts;multimodal biometric data;source code elements;eye tracking data;source code artifacts;interactive visualization;software engineering tasks;sample data;temporal eye tracking visualization;combined multimodal biometric data;customizable temporal heatmaps;interactive temporal heatmaps;synchronized eye tracking;physiological data mapping				11		1 Dec 2020			IEEE	IEEE Conferences
Examining Programmer's Cognitive Skills Using Regular Language	examining programmers cognitive skills using regular language	10.1109/ACHI.2008.33	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4455990	A. Cox; M. Fisher	Faculty of Computer Science, Dalhousie University, Halifax, NS, Canada; Department of Psychology, Saint Mary''s University, Halifax, NS, Canada	First International Conference on Advances in Computer-Human Interaction	25 Feb 2008	2008			249	256	Regular expressions - a notation for regular languages - provide alternation and iteration operators, and can thus be viewed as highly simplified programming languages. Insight into the manipulation of regular expressions will consequently provide insight on the cognition underlying the human-computer interaction of programming. We predicted a relationship between accuracy and completeness, thereby indicating that no tradeoff exists, as one would expect to find in a pattern-matching task. As well, we hypothesised a close relationship between the tasks of pattern application and creation, since analogously to reading and writing, they potentially rely on associated cognitive abilities. Our findings indicate that one's skills in using regular expressions do not match one's ability to learn natural language, or to perform pattern matching. However, we do find evidence that the manipulation of regular expressions is similar to the manipulation of Boolean expressions and suggest that the ability to use formal languages, and hence program computers, is thus rooted in the skills associated with rule-based systems such as mathematics.		978-0-7695-3086-4		formal language;regular languages;regular expressions;cognitive skills;programming skills;program comprehension	Formal languages;Boolean algebra;Computer languages;Pattern matching;Humans;Computer science;Psychology;Cognition;Writing;Natural languages	formal languages;human computer interaction;human factors;pattern matching;programming languages	programmer cognitive skill;regular language;regular expressions;programming languages;human-computer interaction;pattern matching task;formal languages;Boolean expressions				14		25 Feb 2008			IEEE	IEEE Conferences
Improving Semantic Consistency of Variable Names with Use-Flow Graph Analysis	improving semantic consistency of variable names with useflow graph analysis	10.1109/APSEC53868.2021.00030	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9712045	Y. Shinyama; Y. Arahori; K. Gondow	dept. name of organization (of Aff.), Tokyo Institute of Technology, Meguro-ku, Tokyo, Japan; dept. name of organization (of Aff.), Tokyo Institute of Technology, Meguro-ku, Tokyo, Japan; dept. name of organization (of Aff.), Tokyo Institute of Technology, Meguro-ku, Tokyo, Japan	2021 28th Asia-Pacific Software Engineering Conference (APSEC)	17 Feb 2022	2021			223	232	Consistency is one of the keys to maintainable source code and hence a successful software project. We propose a novel method of extracting the intent of programmers from source code of a large project (~ 300 kLOC) and checking the semantic consistency of its variable names. Our system learns a project-specific naming convention for variables based on its role solely from source code, and suggest alternatives when it violates its internal consistency. The system can also show the reasoning why a certain variable should be named in a specific way. The system does not rely on any external knowledge. We applied our method to 12 open-source projects and evaluated its results with human reviewers. Our system proposed alternative variable names for 416 out of 1080 (39%) instances that are considered better than ones originally used by the developers. Based on the results, we created patches to correct the inconsistent names and sent them to its developers. Three open-source projects adopted it.	2640-0715	978-1-6654-3784-4		Program comprehension;Source code analysis;Dataflow analysis;Software maintenance;Naming;Semantic consistency	Codes;Semantics;Probabilistic logic;Cognition;Task analysis;Open source software;Testing	graph theory;information retrieval;program testing;public domain software;software maintenance;software metrics	semantic consistency;use-flow graph;maintainable source code;successful software project;project-specific naming convention;internal consistency;12 open-source projects;alternative variable names;inconsistent names				21	IEEE	17 Feb 2022			IEEE	IEEE Conferences
Let’s Ask Students About Their Programs, Automatically	let’s ask students about their programs, automatically	10.1109/ICPC52881.2021.00054	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463046	T. Lehtinen; A. L. Santos; J. Sorva	Aalto University, Espoo, Finland; Instituto Universitário de Lisboa (ISCTE-IUL), Lisboa, Portugal; Aalto University, Espoo, Finland	2021 IEEE/ACM 29th International Conference on Program Comprehension (ICPC)	28 jun. 2021	2021			467	475	Students sometimes produce code that works but that its author does not comprehend. For example, a student may apply a poorly-understood code template, stumble upon a working solution through trial and error, or plagiarize. Similarly, passing an automated functional assessment does not guarantee that the student understands their code. One way to tackle these issues is to probe students' comprehension by asking them questions about their own programs. We propose an approach to automatically generate questions about student-written program code. We moreover propose a use case for such questions in the context of automatic assessment systems: after a student's program passes unit tests, the system poses questions to the student about the code. We suggest that these questions can enhance assessment systems, deepen student learning by acting as self-explanation prompts, and provide a window into students' program comprehension. This discussion paper sets an agenda for future technical development and empirical research on the topic.	2643-7171	978-1-6654-1403-6		Automatic assessment;automatic question generation;program comprehension;programming education;self-explanation	Plagiarism;Education;Software;Proposals;Probes	computer aided instruction;computer science education;educational administrative data processing;program testing	code template;working solution;automated functional assessment;student-written program code;automatic assessment systems				48		28 jun. 2021			IEEE	IEEE Conferences
JMentor: An Ontology-Based Framework for Software Understanding and Reuse	jmentor an ontologybased framework for software understanding and reuse	10.1109/AICCSA47632.2019.9035293	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9035293	M. Rawashdeh; A. Alnusair; M. Almiani; L. Sawalha	Dept. of Business Information Technology, Princess Sumaya University for Technology, Amman, Jordan; Dept. of Informatics & Computer Science, Indiana University Kokomo, Kokomo, IN, USA; Computer Information Systems Dept., Al-Hussein Bin Talal University, Ma'an, Jordan; Dept. of Electrical and Computer Engineering, Western Michigan University, Kalamazoo, MI, USA	2019 IEEE/ACS 16th International Conference on Computer Systems and Applications (AICCSA)	16 mar. 2020	2019			1	8	Understanding and reusing complex APIs is a difficult and time consuming process, especially in legacy code and open-source software libraries and frameworks. While some primary API features are documented properly, most others lack enough documentation and design knowledge that can help developers find, understand, and reuse the needed software components and other library features. As such, the source-code itself is often the only reliable means for programmers to rely on when performing their reuse practices. In order to leverage program understanding and software reuse, this paper describes an ontology-based system named JMentor that we have developed for this purpose. Firstly, JMentor is capable of recovering the lost design decisions by reverse engineering design patterns. Secondly, JMentor provides a mechanism for locating and retrieving reusable software components. Thirdly, JMentor provides an approach for automatically recommending source-code snippets that show an example of how the user can properly reuse the retrieved components. JMentor mechanisms are based on ontology and semantic reasoning techniques. Its evaluation case studies show evidence that such techniques can improve software understanding and reuse practices.	2161-5330	978-1-7281-5052-9		software reuse;program comprehension;ontology reasoning;program analysis	Ontologies;Software;Semantics;Object oriented modeling;Software libraries;Task analysis	application program interfaces;object-oriented programming;ontologies (artificial intelligence);public domain software;reverse engineering;software libraries;software maintenance;software reusability	semantic reasoning;program understanding;JMentor mechanisms;source code snippets;reverse engineering design patterns;design decisions;software reuse;library features;design knowledge;documentation;API features;open source software libraries;legacy code;software understanding;ontology-based framework				18		16 mar. 2020			IEEE	IEEE Conferences
Visualizing traceability information with iTrace	visualizing traceability information with itrace		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7077112	I. Santiago; J. M. Vara; V. de Castro; E. Marcos	Kybele Research Group, Rey Juan Carlos University, Móstoles, Madrid, Spain; Kybele Research Group, Rey Juan Carlos University, Móstoles, Madrid, Spain; Kybele Research Group, Rey Juan Carlos University, Móstoles, Madrid, Spain; Kybele Research Group, Rey Juan Carlos University, Móstoles, Madrid, Spain	2014 9th International Conference on Evaluation of Novel Approaches to Software Engineering (ENASE)	2 Apr 2015	2014			1	11	The key role of models in Model-Driven Engineering (MDE) provides a new landscape for dealing with traceability. However, despite the certain maturity reached by some MDE tools, providing efficient views of traceability data is still in its early stages. To contribute in this direction, this work introduces the visualization mechanisms provided by iTrace, a framework for the management of traceability in MDE projects. In particular, a multipanel editor for trace models supports the low-level edition of traceability data whereas different dashboards provide high-level views of such data. Both proposals are illustrated by means of a running example.		978-989-758-065-9		Model-driven Engineering;Program Comprehension;Visualization Techniques and Tools	Unified modeling language;Data models;Data visualization;Proposals;Software;Production;Context						35		2 Apr 2015			IEEE	IEEE Conferences
Time-Traveling Debugging Queries: Faster Program Exploration	timetraveling debugging queries faster program exploration	10.1109/QRS54544.2021.00074	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9724738	M. Willembrinck; S. Costiou; A. Etien; S. Ducasse	Univ. Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, Lille, France; Univ. Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, Lille, France; Univ. Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, Lille, France; Univ. Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, Lille, France	2021 IEEE 21st International Conference on Software Quality, Reliability and Security (QRS)	10 mar. 2022	2021			642	653	Efficiently debugging a program requires program comprehension. To acquire it, developers explore the program execution, a task often performed using interactive debuggers. Unfortunately, exploring a program execution through standard interactive debuggers is a tedious and costly task. In this paper, we propose Time-Traveling Queries (TTQs) to ease program exploration. TTQs is a mechanism that automatically explores program executions to collect execution data. This data is used to time-travel through execution states, facilitating the exploration of program executions. We built a set of key TTQs based on typical questions developers ask when trying to understand programs. We conducted a user study with 34 participants to evaluate the impact of our queries on program comprehension activities. Results show that, compared to traditional debugging tools, TTQs significantly improve developers' precision, while reducing required time and efforts when performing program comprehension tasks.	2693-9177	978-1-6654-5813-9		debugging;program comprehension;time-traveling queries	Conferences;Debugging;Software quality;Software reliability;Security;Task analysis;IEEE activities						36	IEEE	10 mar. 2022			IEEE	IEEE Conferences
Visual Approach for Change Impact Analysis: A Controlled Experiment	visual approach for change impact analysis a controlled experiment	10.1109/ITNG.2015.69	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7113504	F. M. Delfim; L. P. Scatalon; J. M. Prates; R. E. Garcia	Dept. de Ciência da Computação, Universidade Federal de Uberlândia, Uberlândia, Brazil; Dept. de Sistemas de Computação, Universidade de São Paulo, São Carlos, Brazil; Dept. de Matemática e Computação, Universidade Estadual Paulista, Presidente Prudente, Brazil; Dept. de Matemática e Computação, Universidade Estadual Paulista, Presidente Prudente, Brazil	2015 12th International Conference on Information Technology - New Generations	1 jun. 2015	2015			391	396	In the context of Software Maintenance, when a source code element must be changed, there is the need to identify if other elements will be affected by the change, in order to keep the code consistent. This identification is performed during the activity of change impact analysis. Aiming to support maintainers during this activity, software visualization tools allow a visual exploration of source code elements. In this paper, we present a study aimed at evaluating the support provided to change impact analysis by visual representations of Java program elements and their associations. To this end, we conducted a controlled experiment involving 24 undergraduate students, comparing the visual support approach and an ad hoc approach, where only the source code is analyzed to estimate impact change. Results showed that the effectiveness obtained by using the visual approach is significantly superior. This is an indication that visual support should be considered to change impact analysis aiming at reducing software maintenance costs.		978-1-4799-8828-0		Software Maintenance;Program Comprehension;Change Impact Analysis;Software Visualization;Controlled Experiment	Visualization;Software;Training;Context;Java;Sun;Computer numerical control	Java;software maintenance;source code (software)	visual approach;change impact analysis;software maintenance;source code element;software visualization tool;Java program element;visual representations;visual support approach;ad hoc approach				28		1 jun. 2015			IEEE	IEEE Conferences
Toward a dynamic analysis technique to locate framework misuses that cause unexpected side effects	toward a dynamic analysis technique to locate framework misuses that cause unexpected side effects	10.1109/SNPD.2014.6888730	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6888730	I. Kume; M. Nakamura; N. Nitta; E. Shibayama	Graduate School of Information Science, Nara Institute of Science and Technology Ikoma, Nara, Japan; Graduate School of System Informatics, Kobe University Nada, Kobe, Japan; Faculty of Intelligence and Informatics, Konan University Higashinada, Kobe, Japan; Information Technology Center, The University of Tokyo Bunkyo, Tokyo, Japan	15th IEEE/ACIS International Conference on Software Engineering, Artificial Intelligence, Networking and Parallel/Distributed Computing (SNPD)	1 Sep 2014	2014			1	6	Recently many frameworks are used in software development without proper documentation, and are misused by application developers in calling framework APIs. Debugging a failure caused by a wrong API call is difficult and requires a proper supporting technique. In our preceding study we developed a dynamic analysis technique to detect possibly unexpected side effects that cause failures. In this paper, we introduce a case study to identify a wrong API call using this technique.		978-1-4799-5604-3		Application Frameworks;Debug;Side Effect;Symp-toms;Dynamic Analysis;Program Comprehension	Unified modeling language;Runtime;Educational institutions;Debugging;Java;Electronic mail;Image edge detection	application program interfaces;program debugging;system monitoring	dynamic analysis technique;software development;wrong API call;program debugging				16		1 Sep 2014			IEEE	IEEE Conferences
Unified Abstract Syntax Tree Representation Learning for Cross-Language Program Classification	unified abstract syntax tree representation learning for crosslanguage program classification	10.1145/3524610.3527915	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796351	K. Wang; M. Yan; H. Zhang; H. Hu	State Key Lab for Novel Software Technology, Nanjing University, Nanjing, China; School of Big Data & Software Engineering, Chongqing University, Chongqing, China; State Key Lab for Novel Software Technology, Nanjing University, Nanjing, China; School of Big Data & Software Engineering, Chongqing University, Chongqing, China	2022 IEEE/ACM 30th International Conference on Program Comprehension (ICPC)	22 jun. 2022	2022			390	400	Program classification can be regarded as a high-level abstraction of code, laying a foundation for various tasks related to source code comprehension, and has a very wide range of applications in the field of software engineering, such as code clone detection, code smell classification, defects classification, etc. The cross-language program classification can realize code transfer in different programming languages, and can also promote cross-language code reuse, thereby helping developers to write code quickly and reduce the development time of code transfer. Most of the existing studies focus on the semantic learning of the code, whilst few studies are devoted to cross-language tasks. The main challenge of cross-language program classification is how to extract semantic features of different programming languages. In order to cope with this difficulty, we propose a Unified Abstract Syntax Tree (namely UAST in this paper) neural network. In detail, the core idea of UAST consists of two unified mechanisms. First, UAST learns an AST representation by unifying the AST traversal sequence and graph-like AST structure for capturing semantic code features. Second, we construct a mechanism called unified vocabulary, which can reduce the feature gap between different programming languages, so it can achieve the role of cross-language program classification. Besides, we collect a dataset containing 20,000 files of five programming languages, which can be used as a benchmark dataset for the cross-language program classification task. We have done experiments on two datasets, and the results show that our proposed approach out-performs the state-of-the-art baselines in terms of four evaluation metrics (Precision, Recall, F1-score, and Accuracy).	2643-7171	978-1-4503-9298-3	National Natural Science Foundation of China(grant numbers:62072227); Research Council of Norway(grant numbers:309494); Natural Science Foundation of Chongqing(grant numbers:cstc2021jcyj-msxmX0538); 	Program Comprehension;Program Classification;Code Representation Learning;Cross-language Program Classification	Representation learning;Computer languages;Vocabulary;Codes;Semantics;Neural networks;Syntactics	data analysis;feature extraction;image classification;learning (artificial intelligence);natural language processing;neural nets;object-oriented programming;pattern classification;program compilers;program diagnostics;software engineering;software libraries;software maintenance;software metrics;tree data structures;trees (mathematics)	Unified abstract Syntax Tree representation learning;source code comprehension;code clone detection;code smell classification;code transfer;cross-language code reuse;cross-language tasks;semantic code features;cross-language program classification task				47		22 jun. 2022			IEEE	IEEE Conferences
Thinking Like a Developer? Comparing the Attention of Humans with Neural Models of Code	thinking like a developer comparing the attention of humans with neural models of code	10.1109/ASE51524.2021.9678712	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9678712	M. Paltenghi; M. Pradel	Department of Computer Science, University of Stuttgart, Stuttgart, Germany; Department of Computer Science, University of Stuttgart, Stuttgart, Germany	2021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)	20 jan. 2022	2021			867	879	Neural models of code are successfully tackling various prediction tasks, complementing and sometimes even outperforming traditional program analyses. While most work focuses on end-to-end evaluations of such models, it often remains unclear what the models actually learn, and to what extent their reasoning about code matches that of skilled humans. A poor understanding of the model reasoning risks deploying models that are right for the wrong reason, and taking decisions based on spurious correlations in the training dataset. This paper investigates to what extent the attention weights of effective neural models match the reasoning of skilled humans. To this end, we present a methodology for recording human attention and use it to gather 1,508 human attention maps from 91 participants, which is the largest such dataset we are aware of. Computing human-model correlations shows that the copy attention of neural models often matches the way humans reason about code (Spearman rank coefficients of 0.49 and 0.47), which gives an empirical justification for the intuition behind copy attention. In contrast, the regular attention of models is mostly uncorrelated with human attention. We find that models and humans sometimes focus on different kinds of tokens, e.g., strings are important to humans but mostly ignored by models. The results also show that human-model agreement positively correlates with accurate predictions by a model, which calls for neural models that even more closely mimic human reasoning. Beyond the insights from our study, we envision the release of our dataset of human attention maps to help understand future neural models of code and to foster work on human-inspired models.	2643-1572	978-1-6654-0337-5		Artificial intelligence for software engineering;Empirical software engineering;Program comprehension;Software analysis	Training;Codes;Correlation;Computational modeling;Predictive models;Syntactics;Cognition	inference mechanisms;learning (artificial intelligence);neural nets;reasoning about programs;source code (software)	traditional program analysis;end-to-end evaluations;model reasoning risks;attention weights;effective neural models;human attention maps;copy attention;regular attention;human-model agreement;human reasoning;future neural models;human-inspired models;human-model correlations;prediction tasks;training dataset				67	IEEE	20 jan. 2022			IEEE	IEEE Conferences
Estimating Developers' Cognitive Load at a Fine-grained Level Using Eye-tracking Measures	estimating developers cognitive load at a finegrained level using eyetracking measures	10.1145/3524610.3527890	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796206	A. Abbad-Andaloussi; T. Sorg; B. Weber	Institute of Computer Science, University of St. Gallen, St Gallen, Switzerland; Institute of Computer Science, University of St. Gallen, St Gallen, Switzerland; Institute of Computer Science, University of St. Gallen, St Gallen, Switzerland	2022 IEEE/ACM 30th International Conference on Program Comprehension (ICPC)	22 jun. 2022	2022			111	121	The comprehension of source code is a task inherent to many software development activities. Code change, code review and debugging are examples of these activities that depend heavily on developers' understanding of the source code. This ability is threatened when developers' cognitive load approaches the limits of their working memory, which in turn affects their understanding and makes them more prone to errors. Measures capturing humans' behavior and changes in their physiological state have been proposed in a number of studies to investigate developers' cognitive load. However, the majority of the existing approaches operate at a coarse-grained task level estimating the difficulty of the source code as a whole. Hence, they cannot be used to pinpoint the mentally demanding parts of it. We address this limitation in this paper through a non-intrusive approach based on eye-tracking. We collect users' behavioral and physiological features while they are engaging with source code and train a set of machine learning models to estimate the mentally demanding parts of code. The evaluation of our models returns F1, recall, accuracy and precision scores up to 85.65%, 84.25%, 86.24% and 88.61%, respectively, when estimating the mental demanding fragments of code. Our approach enables a fine-grained analysis of cognitive load and allows identifying the parts challenging the comprehension of source code. Such an approach provides the means to test new hypotheses addressing the characteristics of specific parts within the source code and paves the road for novel techniques for code review and adaptive e-learning.	2643-7171	978-1-4503-9298-3	University of St. Gallen(grant numbers:1031574); 	Program comprehension;source code;cognitive load;eye-tracking;machine learning	Measurement;Training;Codes;Roads;Physiology;Software;Planning	cognition;gaze tracking;learning (artificial intelligence);social aspects of automation;software engineering;statistical analysis	software development activities;code change;code review;source code;coarse-grained task level;developer cognitive load;debugging;machine learning;adaptive e-learning;eye-trackig measures;precision scores;fine-grained analysis				56		22 jun. 2022			IEEE	IEEE Conferences
Inferring Use-cases from GUI Analysis	inferring usecases from gui analysis	10.1109/TLA.2015.7404931	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7404931	E. Miranda; C. Abdelahad; M. Beron; D. Riesco	Universidad Nacional de San Luis, San Luis, Argentina; Universidad Nacional de San Luis, San Luis, Argentina; Universidad Nacional de San Luis, San Luis, Argentina; Universidad Nacional de San Luis, San Luis, Argentina	IEEE Latin America Transactions	11 Feb 2016	2015	13	12	3942	3952	One of the most arduous and tedious tasks in the life cycle of an application is Software Maintenance and Evolution. In this context, the most time-consuming activities are those that the programmer must execute to get a complete understanding of the system. Based on this need, Program Comprehension (PC), a Software Engineering discipline, arises to tackle the problem. This article presents SSPIA, a strategy that assists software engineers to understand a system by inferring its use case model. SSPIA uses concepts, techniques and tools of PC to carry out its purposes. In order to extract use cases, some specific system static information is collected. This information serves as input to a process that implements a clustering technique based on system's Graphical User Interface (GUI). Almost all clustering techniques take as main criteria graph's structural properties. However, in the context of PC, some Problem Domain information must be considered. The strategy proposed in this article takes into account an essential component strongly related to system's Problem Domain: Graphic User Interfaces. As a main aim, the proposed strategy seeks to assist the arduous cognitive process that involves understanding a system.	1548-0992			Clustering;Information Extraction;Program Comprehension;Reverse Engineering	Graphical user interfaces;Software;Silicon;Unified modeling language;Context;Data mining;Context modeling	graphical user interfaces;pattern clustering;software maintenance	GUI analysis;software maintenance;program comprehension;software engineering discipline;SSPIA;use case model inferring;system static information;graphical user interface;clustering technique;problem domain information;cognitive process						11 Feb 2016			IEEE	IEEE Journals
The Effect of Poor Source Code Lexicon and Readability on Developers' Cognitive Load	the effect of poor source code lexicon and readability on developers cognitive load		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8972994	S. Fakhoury; Y. Ma; V. Arnaoudova; O. Adesope	School of Electrical Engineering and Computer Science, Washington State University, Pullman, WA, USA; School of Electrical Engineering and Computer Science, Washington State University, Pullman, WA, USA; School of Electrical Engineering and Computer Science, Washington State University, Pullman, WA, USA; School of Electrical Engineering and Computer Science, Washington State University, Pullman, WA, USA	2018 IEEE/ACM 26th International Conference on Program Comprehension (ICPC)	30 jan. 2020	2018			286	28610	It has been well documented that a large portion of the cost of any software lies in the time spent by developers in understanding a program's source code before any changes can be undertaken. One of the main contributors to software comprehension, by subsequent developers or by the authors themselves, has to do with the quality of the lexicon, (i.e., the identifiers and comments) that is used by developers to embed domain concepts and to communicate with their teammates. In fact, previous research shows that there is a positive correlation between the quality of identifiers and the quality of a software project. Results suggest that poor quality lexicon impairs program comprehension and consequently increases the effort that developers must spend to maintain the software. However, we do not yet know or have any empirical evidence, of the relationship between the quality of the lexicon and the cognitive load that developers experience when trying to understand a piece of software. Given the associated costs, there is a critical need to empirically characterize the impact of the quality of the lexicon on developers' ability to comprehend a program. In this study, we explore the effect of poor source code lexicon and readability on developers' cognitive load as measured by a cutting-edge and minimally invasive functional brain imaging technique called functional Near Infrared Spectroscopy (fNIRS). Additionally, while developers perform software comprehension tasks, we map cognitive load data to source code identifiers using an eye tracking device. Our results show that the presence of linguistic antipatterns in source code significantly increases the developers' cognitive load.	2643-7171	978-1-4503-5714-2		Source code lexicon;biometrics;fNIRS;cognitive load;eyetracking;program comprehension		brain;cognitive systems;gaze tracking;infrared spectroscopy;medical image processing;reverse engineering;software maintenance;software management;source code (software)	poor source code lexicon;software project;poor quality lexicon;program comprehension;software comprehension tasks;source code identifiers;developer cognitive load;program source code;minimally invasive functional brain imaging technique;functional near infrared spectroscopy;fNIRS;eye tracking device;linguistic antipatterns				40		30 jan. 2020			IEEE	IEEE Conferences
Android Repository Mining for Detecting Publicly Accessible Functions Missing Permission Checks	android repository mining for detecting publicly accessible functions missing permission checks	10.1109/ICPC.2017.14	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961531	H. H. Nguyen; L. Jiang; T. Quan	Singapore Management University, Singapore, Singapore, SG; School of Information Systems, Singapore Management University, Singapore; Faculty of Computer Science and Engineering, Bach Khoa University, Vietnam	2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC)	29 jun. 2017	2017			324	327	Android has become the most popular mobile operating system. Millions of applications, including many malware, haven been developed for it. Even though its overall system architecture and many APIs are documented, many other methods and implementation details are not, not to mention potential bugs and vulnerabilities that may be exploited. Manual documentation may also be easily outdated as Android evolves constantly with changing features and higher complexities. Techniques and tool supports are thus needed to automatically extract information from different versions of Android to facilitate whole-system analysis of undocumented code. This paper presents an approach for alleviating the challenges associated with whole-system analysis. It performs usual program analysis for different versions of Android by control-flow and data-flow analyses. More importantly, it integrates information retrieval and query heuristics to customize the graphs for purposes related to the queries and make whole-system analyses more efficient. In particular, we use the approach to identify functions in Android that can be invoked by applications in either benign or malicious way, which are referred to as publicly accessible functions in this paper, and with the queries we provided, identify functions that may access sensitive system and/or user data and should be protected by certain permission checks. Based on such information, we can detect some publicly accessible functions in the system that may miss sufficient permission checks. As a proof of concept, this paper has analyzed six Android versions and shows basic statistics about the publicly accessible functions in the Android versions, and detects and verifies several system functions that miss permission checks and may have security implications.		978-1-5386-0535-6		android;program comprehension;program analysis;information retrieval;call graph;dependency	Androids;Humanoid robots;Information retrieval;Analytical models;Object recognition;Malware;Security	Android (operating system);application program interfaces;data flow analysis;data mining;graph theory;invasive software;mobile computing;program debugging;query processing	Android repository mining;publicly accessible function missing permission check detection;mobile operating system;malware;overall system architecture;API;potential bugs;potential vulnerabilities;automatic information extraction;whole-system analysis;program analysis;control-flow analysis;data-flow analysis;information retrieval;query heuristics;function identification				22		29 jun. 2017			IEEE	IEEE Conferences
Understanding Digits in Identifier Names: An Exploratory Study	understanding digits in identifier names an exploratory study	10.1145/3528588.3528657	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9808632	A. Peruma; C. D. Newman	Rochester Institute of Technology, Rochester, New York, USA; Rochester Institute of Technology, Rochester, New York, USA	2022 IEEE/ACM 1st International Workshop on Natural Language-Based Software Engineering (NLBSE)	30 jun. 2022	2022			9	16	Before any software maintenance can occur, developers must read the identifier names found in the code to be maintained. Thus, high-quality identifier names are essential for productive program comprehension and maintenance activities. With developers free to construct identifier names to their liking, it can be difficult to automatically reason about the quality and semantics behind an identifier name. Studying the structure of identifier names can help alleviate this problem. Existing research focuses on studying words within identifiers, but there are other symbols that appear in identifier names–such as digits. This paper explores the presence and purpose of digits in identifier names through an empirical study of 800 open-source Java systems. We study how digits contribute to the semantics of identifier names and how identifier names that contain digits evolve over time through renaming. We envision our findings improving the efficiency of name appraisal and recommendation tools and techniques.		978-1-4503-9343-0		Program Comprehension;Natural Language Processing;Identifier Names;Rename Refactoring;Software Refactoring;Software Maintenance	Software maintenance;Java;Codes;Conferences;Semantics;Symbols;Maintenance engineering	Java;public domain software;software maintenance	high-quality identifier names;software maintenance;productive program comprehension;program maintenance activities;digits;open-source Java systems;identifier name semantics;name appraisal				40		30 jun. 2022			IEEE	IEEE Conferences
DualSC: Automatic Generation and Summarization of Shellcode via Transformer and Dual Learning	dualsc automatic generation and summarization of shellcode via transformer and dual learning	10.1109/SANER53432.2022.00052	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9825869	G. Yang; X. Chen; Y. Zhou; C. Yu	School of Information Science and Technology, Nantong University, China; State Key Laboratory of Information Security, Institute of Information Engineering, Chinese Academy of Sciences, China; School of Information Science and Technology, Nantong University, China; School of Information Science and Technology, Nantong University, China	2022 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)	21 jul. 2022	2022			361	372	A shellcode is a small piece of code and it is executed to exploit a software vulnerability, which allows the target computer to execute arbitrary commands from the attacker through a code injection attack. Similar to the purpose of automated vulnerability generation techniques, the automated generation of shellcode can generate attack instructions, which can be used to detect vulnerabilities and implement defensive measures. While the automated summarization of shellcode can help users unfamiliar with shellcode and network information security understand the intent of shellcode attacks. In this study, we propose a novel approach DualSC to solve the automatic shellcode generation and summarization tasks. Specifically, we formalize automatic shellcode generation and summarization as dual tasks, use a shallow Transformer for model construction, and design a normalization method Adjust_QKNorm to adapt these low-resource tasks (i.e., insufficient training data). Finally, to alleviate the out-of-vocabulary problem, we propose a rule-based repair component to improve the performance of automatic shellcode generation. In our empirical study, we select a high-quality corpus Shellcode_IA32 as our empirical subject. This corpus was gathered from two real-world projects based on the line-by-line granularity. We first compare DualSC with six state-of-the-art baselines from the code generation and code summarization domains in terms of four performance measures. The comparison results show the competitiveness of DualSC. Then, we verify the effectiveness of the component setting in DualSC. Finally, we conduct a human study to further verify the effectiveness of DualSC.	1534-5351	978-1-6654-3786-8	National Natural Science Foundation of China(grant numbers:61872263); Chinese Academy of Sciences(grant numbers:2020-MS-07); 	Program comprehension;Shellcode generation;Shellcode summarization;Shallow Transformer;Dual learning	Codes;Design methodology;Conferences;Training data;Information security;Maintenance engineering;Transformers	computer network security;learning (artificial intelligence);program diagnostics;security of data	DualSC;automatic generation;code injection attack;automated vulnerability generation techniques;automated generation;automated summarization;shellcode attacks;automatic shellcode generation;summarization tasks;high-quality corpus Shellcode_IA32;code generation;code summarization				75	IEEE	21 jul. 2022			IEEE	IEEE Conferences
Decoding Confusing Code: Social Representations among Developers	decoding confusing code social representations among developers	10.1109/CHASE52884.2021.00010	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463284	R. de Mello; J. A. da Costa; B. de Oliveira; M. Ribeiro; B. Fonseca; R. Gheyi; A. Garcia; W. Tiengo	CEFET/RJ, Rio de Janeiro, Brazil; UFCG, Campina Grande, Brazil; UFAL, Maceió, Brazil; UFAL, Maceió, Brazil; UFAL, Maceió, Brazil; UFCG, Campina Grande, Brazil; PUC-Rio, Rio de Janeiro, Brazil; UFAL, Maceió, Brazil	2021 IEEE/ACM 13th International Workshop on Cooperative and Human Aspects of Software Engineering (CHASE)	28 jun. 2021	2021			11	20	Context. Confusing code is any code element in which developers have considerable difficulty reaching its comprehension. These difficulties may result from a plethora of characteristics of the source code and external issues. In this way, there is still a lack of knowledge on the core issues of confusing code. This knowledge is important for optimizing efforts in promoting program comprehension. Goal. In this paper, we investigate the social representations of confusing code among two distinct communities of software developers from industry. Method. We conducted free association tasks with the developers to characterize what is in their minds about confusing code. Then, we compiled and classified the associations composing the social representations of confusing code by each community. Finally, we compared the social representations from both communities. Results. We found that developers of both communities strongly associate confusing code with a common set of undesirable characteristics of the source code, such as different types of code smells and the badly naming of code elements. Besides, we found that the incidence of confusing code is a potential source of discouragement and conflict. In this way, we discuss alternatives for development teams overcoming these issues. Conclusion. The findings of our study reveal an initial set of core issues of confusing code. These issues can drive future investigations on technologies for promoting code comprehension.	2574-1837	978-1-6654-1409-8	CNPq(grant numbers:152179/2020-8,427787/2018-1); 	social representations;confusing code;program comprehension;free association	Industries;Conferences;Software;Decoding;Task analysis;Software engineering	software maintenance;source code (software)	social representations;code element;source code;confusing code decoding;code comprehension				38		28 jun. 2021			IEEE	IEEE Conferences
Software Musification	software musification	10.1109/iV.2017.28	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8107958	A. Mancino; G. Scanniello	University of Basilicata; University of Basilicata	2017 21st International Conference Information Visualisation (IV)	16 nov. 2017	2017			127	132	In this paper, we propose an approach that uses software metrics to comprehend attributes of a codebase: maintainability, reusability, or complexity. This approach is new because it uses gathered metrics as the basis to associate musical sounds to source code classes. These sounds are arranged to compose a melody that can be both visualized (as a musical score) and played. We named this new way to deal with a codebase: software musification. To prove the validity of our proposal, we show a sample of its application. The main goal of this paper is to show our promising idea and to present research achievements at the early stages of our research.	2375-0138	978-1-5386-0831-9		Musification;Program Comprehension;Software Complexity;Software Reusability;Software Maintainability	Software;Music;Complexity theory;Data visualization;Software metrics	music;software maintenance;software metrics;software reusability	software musification;software metrics;musical sounds;source code classes;musical score;software complexity;codebase attributes;software maintainability;software reusability				25		16 nov. 2017			IEEE	IEEE Conferences
Comprehension oriented software fault location	comprehension oriented software fault location	10.1109/ICCSNT.2011.6181971	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6181971	Wang Tiantian; Su Xiaohong; Ma Peijun; Wang Kechao	School of Computer Science and Technology, Harbin Institute of Technology, Harbin, China; School of Computer Science and Technology, Harbin Institute of Technology, Harbin, China; School of Computer Science and Technology, Harbin Institute of Technology, Harbin, China; School of Software, Harbin University, Harbin, China	Proceedings of 2011 International Conference on Computer Science and Network Technology	12 Apr 2012	2011	1		340	343	Software errors can potentially lead to disastrous consequences. Unfortunately, debugging software errors can be difficult and time-consuming. A comprehension oriented software fault location approach (COFL) is proposed in this paper to provide automated assistance in bug location. It not only locates program predicates predicting bugs, but also provides high efficiency demand-driven data flow and control flow analysis to help developers understand the causes and contexts of bugs.		978-1-4577-1587-7		fault location;program comprehension;statistics-based;demand-driven	Software;Instruments;Computer bugs;Debugging;Fault location;Prediction algorithms;Conferences	data flow analysis;program debugging;software fault tolerance	comprehension oriented software fault location;software errors;COFL;bug location;high efficiency demand-driven data flow;flow analysis;software debugging				24		12 Apr 2012			IEEE	IEEE Conferences
Towards Understanding Programs by Counting Objects	towards understanding programs by counting objects	10.1109/ASWEC.2018.00009	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8587280	E. Tempero; P. Ralph	Department of Computer Science, University of Auckland, Auckland, New Zealand; Department of Computer Science, University of Auckland, Auckland, New Zealand	2018 25th Australasian Software Engineering Conference (ASWEC)	27 Dec 2018	2018			1	10	A question familiar to any developer facing legacy code for the first time is, where to start? Understanding the entire code base of any large project is impractical, so techniques for identifying the most relevant code are needed. We discuss one potential technique, which we call "object counts:"' a report of the number of objects created during the execution of an object-oriented program. We show how object counts can help when comparing small designs, and comprehending a larger design-specifically JUnit. Our results indicate that the small amount of data provided by object counts can provide significant insight into a system's design.	2377-5408	978-1-7281-1241-1		Object counts;Dynamic Analysis;Program Comprehension	Task analysis;Games;Performance analysis;Software	object-oriented programming;program testing	object-oriented program;object counts;legacy code;program understanding;JUnit design				24		27 Dec 2018			IEEE	IEEE Conferences
Understanding source code through projectional editor	understanding source code through projectional editor	10.1109/EMES.2015.7158422	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7158422	J. Juhár; L. Vokorokos	Department of Computers and Informatics, Technical University of Košice; Department of Computers and Informatics, Technical University of Košice	2015 13th International Conference on Engineering of Modern Electric Systems (EMES)	16 jul. 2015	2015			1	4	The purpose of this paper is to give a report of an observational study involving program comprehension with the projectional editor that enables custom views of the source code. We briefly discuss the issues of program comprehension and motives behind projectional code editing. We also give an overview of two projectional editors focused on concern location and compare their features and use cases. The Code Bubbles editor is evaluated in an observational study observing the process of a source code comprehension. The study suggests the benefits of code projections even for large, unknown code base.		978-1-4799-7650-8		code bubbles;concern-oriented source code projections;program comprehension tools;projectional editors	Syntactics;User interfaces;Context;Buildings;Java;Software	knowledge acquisition;object-oriented programming;source code (software)	source code;program comprehension;projectional code editing;Code Bubbles editor;knowledge extraction;object-oriented design				12		16 jul. 2015			IEEE	IEEE Conferences
Improving software maintenance efficiency with behavior-based cognitive models	improving software maintenance efficiency with behaviorbased cognitive models	10.1109/ICSMC.2008.4811815	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4811815	R. Bayer; A. E. Milewski	Winter Springs, SICES Limited Liability Company, FL, USA; Department of Software Engineering, Monmouth University, NJ, USA	2008 IEEE International Conference on Systems, Man and Cybernetics	7 Apr 2009	2008			3353	3358	Currently, in most software maintenance environments, the fundamental tool used by software maintainers to perform system maintenance is the integrated development environment (IDE). Current IDEs have inadequate usability and offer little design information to the user, which may impair program comprehension activities required for efficient maintenance. We have developed and tested a prototype IDE that provides behavioral design information in graphical form, with the intent of allowing software maintainers the ability to more easily learn how a system works and locate relevant source code without the need to consult outside documentation. We show that in two experimental maintenance tasks, users were able to find and modify appropriate code more quickly when using an IDE based on a behavioral view of the software compared with a more traditional, structurally-oriented IDE. Moreover, when using an IDE with a behavioral view, users noticed software patterns more readily and more often used a top-down strategy for solving the maintenance tasks.	1062-922X	978-1-4244-2383-5		Integrated Development Environment;usability;software maintenance;program comprehension	Software maintenance;Documentation;Software systems;Software performance;Software tools;Usability;Software prototyping;Costs;Springs;Software testing	cognitive systems;inference mechanisms;object-oriented programming;software maintenance	software maintenance efficiency;behavior-based cognitive models;integrated development environment;graphical form;software patterns				19		7 Apr 2009			IEEE	IEEE Conferences
Developer Interaction Traces Backed by IDE Screen Recordings from Think Aloud Sessions	developer interaction traces backed by ide screen recordings from think aloud sessions		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8595177	A. Yamashita; F. Petrillo; F. Khomh; Y. -G. Guéhéneuc	Oslo Metropolitan University; Concordia University; Polytechnique Montréal; Oslo Metropolitan University	2018 IEEE/ACM 15th International Conference on Mining Software Repositories (MSR)	30 Dec 2018	2018			50	53	There are two well-known difficulties to test and interpret methodologies for mining developer interaction traces: first, the lack of enough large datasets needed by mining or machine learning approaches to provide reliable results; and second, the lack of "ground truth" or empirical evidence that can be used to triangulate the results, or to verify their accuracy and correctness. Moreover, relying solely on interaction traces limits our ability to take into account contextual factors that can affect the applicability of mining techniques in other contexts, as well hinders our ability to fully understand the mechanics behind observed phenomena. The data presented in this paper attempts to alleviate these challenges by providing 600+ hours of developer interaction traces, from which 26+ hours are backed with video recordings of the IDE screen and developer's comments. This data set is relevant to researchers interested in investigating program comprehension, and those who are developing techniques for interaction traces analysis and mining.	2574-3864	978-1-4503-5716-6		empirical study;industrial data;interaction traces;log mining;program comprehension;programming flow	Data mining;Software;Companies;Programming;Java;Machine learning;Reliability	data mining;learning (artificial intelligence);user interfaces	IDE screen recordings;video recordings;Think Aloud Sessions;mining techniques;developer interaction traces;developer comments				21		30 Dec 2018			IEEE	IEEE Conferences
Tool-Based Interactive Software Parallelization: A Case Study	toolbased interactive software parallelization a case study		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449242	A. Wilhelm; F. Cakaric; T. Schuele; M. Gerndt	Technical University of Munich, Munich, Germany; Technical University of Munich, Munich, Germany; Technical University of Munich, Munich, Germany; Siemens Corporate Technology, Munich, Germany	2018 IEEE/ACM 40th International Conference on Software Engineering: Software Engineering in Practice Track (ICSE-SEIP)	30 Aug 2018	2018			115	123	Continuous advances in multicore processor technology have placed immense pressure on the software industry. Developers are forced to parallelize their applications to make them scalable. However, applications are often very large and inherently complex; here, automatic parallelization methods are inappropriate. A dependable software redesign requires profound comprehension of the underlying software architecture and its dynamic behavior. To address this problem, we propose Parceive, a tool that supports identification of parallelization scenarios at various levels of abstraction. Parceive collects behavior information at runtime and combines it with reconstructed software architecture information to generate useful visualizations for parallelization. In this paper, we motivate our approach and explain the main components of Parceive. A case study demonstrates the usefulness of the tool.		978-1-4503-5659-6		Parallelization;Software Visualization;Program Comprehension;Software Architecture	Tools;Software;Software architecture;Runtime;Data visualization;Parallel processing;Computer architecture	interactive systems;multiprocessing systems;software architecture;software maintenance	tool-based interactive software parallelization;continuous advances;multicore processor technology;software industry;automatic parallelization methods;dependable software redesign;underlying software architecture;parallelization scenarios;behavior information;reconstructed software architecture information				27		30 Aug 2018			IEEE	IEEE Conferences
Runtime Invocation Analysis of API Objects in Large Code Base	runtime invocation analysis of api objects in large code base	10.1109/CSA.2013.114	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6835641	M. A. Khan; S. Muhammad; T. Muhammad	College of Computer Engineering and Science, Prince Mohammad Bin Fahd University (PMU), Khobar, KSA; College of Computer Engineering and Science, Prince Mohammad Bin Fahd University (PMU), Khobar, KSA; Faculty of Computer Sciences and Engineering, Ghulam Ishaq Khan Institute (GIKI), Topi, Pakistan	2013 International Conference on Computer Sciences and Applications	19 jun. 2014	2013			463	468	Software systems use several third party libraries via their available interfaces popularly known as the application programming interface (API). The runtime usage of the API in an object-oriented software system can be defined by several characteristics including the type and number of API objects created, the methods invoked on those objects, and the source code locations from where the objects were created or invoked during their lifetime. These characteristics can be used to identify the source code locations exhibiting different types of runtime behavior which can be used for program comprehension, debugging, performance monitoring and fault detection. In this paper, we define object invocation model based on above-mentioned characteristics. We also propose an implementation framework that can be used to extract key model parameters from any source code. The Java Collections API is one of the most widely used Java APIs. We demonstrate effectiveness of our proposed approach by analyzing object invocation model for Java Collection API in a large open source project.		978-0-7695-5125-8		runtime program analysis;api usage analysis;api invocation analysis;object invocation model;Java Collection API analysis;program comprehension;bytecode instrumentation	Instruments;Java;Runtime;Object recognition;Software systems;Data mining;Analytical models	application program interfaces;Java;object-oriented programming;program debugging;public domain software;software libraries;source code (software)	runtime invocation analysis;API objects;large code base;third party libraries;application programming interface;object-oriented software system;source code locations;program comprehension;program debugging;performance monitoring;fault detection;object invocation model;source code;Java collection API				18		19 jun. 2014			IEEE	IEEE Conferences
Recording, Visualising and Understanding Developer Programming Behaviour	recording, visualising and understanding developer programming behaviour	10.1109/SANER50967.2021.00066	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9425961	M. Schr&#x00F6;er; R. Koschke	Software Engineering Group University of Bremen, Bremen, Germany; Software Engineering Group University of Bremen, Bremen, Germany	2021 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)	11 May 2021	2021			561	566	To understand how developers solve programming tasks, it is necessary to observe what they are doing, i.e., what specific actions they perform, which strategies they apply and how they make use of possibly present, but not yet known or otherwise not yet available information that is needed to solve a task. To do so, we implemented a plug-in for the Eclipse IDE which captures nearly every interaction with the IDE a developer performs when working on a programming task. This enables us to comprehensively track a developer’s behaviour, e.g., whether and when a code edit needed for solving a given task was performed, and even more interesting, what were the preceding steps that led the developer to do so. In a first experiment conducted with the new plug-in, we were able to observe action patterns and program comprehension stages that confirm results of previous studies as well as were partly only suspected until now by recent literature, but never truly observed before.Screencast of the tool: https://youtu.be/GeZI-vCdgfoClosed caption version: https://youtu.be/mgt6Q-t7U00	1534-5351	978-1-7281-9630-5		program comprehension;software maintenance;human factors;developer interactions;visualisation	Visualization;Navigation;Conferences;Tools;Programming;Inspection;Software	program testing;software development management	action patterns;program comprehension stages;programming task;Eclipse IDE;developer programming				33	IEEE	11 May 2021			IEEE	IEEE Conferences
Applying Markov Models to Identify Grammatical Patterns of Function Identifiers	applying markov models to identify grammatical patterns of function identifiers	10.1109/ICSME.2019.00097	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8918952	R. S. Alsuhaibani	Department of Computer Science, Kent State University, Kent, Ohio, USA	2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)	5 Dec 2019	2019			610	614	An empirical study to evaluate the effectiveness of using Markov chains in finding and predicting the grammatical patterns of function identifiers found in source code is presented. The study uses a specialized part-of-speech tagger to annotate function identifiers extracted from 20 C++ open-source systems. A dataset of 93K annotated unique function identifiers is created for analysis. The analysis includes using a first-order Markov chain to model part of speech tag sequences of the identifier names, using a probability transition matrix. The evaluation of the model is via a 10-fold cross validation over the entire set of annotated function identifier names. The preliminary results are promising in terms of applicability and accuracy. The model achieved an accuracy median of 91.53% in predicting the most common part of speech tag on a test set. Future work involves utilizing these results in creating a quality assessment and automatic repairing tool for source code function identifiers.	2576-3148	978-1-7281-3094-1		program comprehension, natural language processing, part-of-speech tagging, identifier analysis, software quality, automated program repair.	Markov processes;Grammar;Hidden Markov models;Natural languages;Speech coding;Java;Task analysis	grammars;Markov processes;natural language processing;probability;speech processing	first-order Markov chain;function identifiers;open-source systems;part-of-speech tagger;grammatical patterns;Markov models;source code function identifiers;annotated function identifier names;speech tag sequences				35		5 Dec 2019			IEEE	IEEE Conferences
An Approach to Automatically Assess Method Names	an approach to automatically assess method names	10.1145/3524610.3527780	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796230	R. S. Alsuhaibani; C. D. Newman; M. J. Decker; M. L. Collard; J. I. Maletic	Computer Science, Kent State University, Prince Sultan University, Kent, Ohio, USA; Software Engineering, Rochester Institute of Technology, Rochester, New York, USA; Computer Science, Bowling Green State University, Bowling Green, Ohio, USA; Computer Science, The University of Akron, Akron, Ohio, USA; Kent State University, Kent, Ohio, USA	2022 IEEE/ACM 30th International Conference on Program Comprehension (ICPC)	22 jun. 2022	2022			202	213	An approach is presented to automatically assess the quality of method names by providing a score and feedback. The approach implements ten method naming standards to evaluate the names. The naming standards are taken from work that validated the standards via a large survey of software professionals. Natural language processing techniques such as part-of-speech tagging, identifier splitting, and dictionary lookup are required to implement the standards. The approach is evaluated by first manually constructing a large golden set of method names. Each method name is rated by several developers and labeled as conforming to each standard or not. These ratings allow for comparing the results of the approach against expert assessment. Additionally, the approach is applied to several systems and the results are manually inspected for accuracy.	2643-7171	978-1-4503-9298-3		Program comprehension;Method names;Method naming standards;Identifier quality	Fault diagnosis;Dictionaries;Tagging;Linguistics;Natural language processing;Software;Appraisal	dictionaries;natural language processing;software engineering;source code (software);text analysis	naming standards;method name assessment;name evaluation;natural language processing technique;part-of-speech tagging;identifier splitting;dictionary lookup				53		22 jun. 2022			IEEE	IEEE Conferences
A Method to Comprehend Feature Dependencies Based on Semi-Static Structures	a method to comprehend feature dependencies based on semistatic structures	10.1109/ICSME52107.2021.00020	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9609184	N. Kande; N. Nitta	Graduate School of Natural Science Konan University, Kobe, Japan; Graduate School of Natural Science Konan University, Kobe, Japan	2021 IEEE International Conference on Software Maintenance and Evolution (ICSME)	24 nov. 2021	2021			148	158	To understand why features of existing software can depend on each other is important for correct addition of a new feature to the software. Although some work has been done to detect feature dependency, it is not clear how effective such existing approaches are when they are applied to feature dependency comprehension because they are aimed at detection of runtime dependency between features. Therefore in this paper, we present an extraction method of source code that can be used to comprehend feature dependency. The method can extract a wider range of source code than existing techniques of feature dependency detection by using delta extraction. We conducted a controlled experiment with 20 professional programmers and confirmed that the difference of the extracted range has a positive effect on feature dependency comprehension. To figure out an internal mechanism to enable feature dependency, we also defined semi-static parts of object graphs that can be used to make features depend on each other. Finally, we confirmed that semi-static structures are actually used in feature dependencies in three open source programs and can be effectively extracted by our method.	2576-3148	978-1-6654-2882-8		feature dependency;program comprehension;dynamic analysis	Software maintenance;Codes;Runtime;Conferences;Feature extraction	feature extraction;graph theory;public domain software;software maintenance;system monitoring	comprehend feature dependencies;semistatic structures;feature dependency comprehension;runtime dependency;feature dependency detection;professional programmers				23	IEEE	24 nov. 2021			IEEE	IEEE Conferences
An Inquisitive Code Editor for Addressing Novice Programmers' Misconceptions of Program Behavior	an inquisitive code editor for addressing novice programmers misconceptions of program behavior	10.1109/ICSE-SEET52601.2021.00026	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9402182	A. Henley; J. Ball; B. Klein; A. Rutter; D. Lee	University of Tennessee, USA; University of Tennessee, Knoxville, Tennessee; University of Tennessee, Knoxville, Tennessee; University of Tennessee, Knoxville, Tennessee; University of Tennessee, Knoxville, Tennessee	2021 IEEE/ACM 43rd International Conference on Software Engineering: Software Engineering Education and Training (ICSE-SEET)	7 May 2021	2021			165	170	Novice programmers face numerous barriers while attempting to learn how to code that may deter them from pursuing a computer science degree or career in software development. In this work, we propose a tool concept to address the particularly challenging barrier of novice programmers holding misconceptions about how their code behaves. Specifically, the concept involves an inquisitive code editor that: (1) identifies misconceptions by periodically prompting the novice programmer with questions about their program's behavior, (2) corrects the misconceptions by generating explanations based on the program's actual behavior, and (3) prevents further misconceptions by inserting test code and utilizing other educational resources. We have implemented portions of the concept as plugins for the Atom code editor and conducted informal surveys with students and instructors. Next steps include deploying the tool prototype to students enrolled in introductory programming courses.		978-1-6654-0138-8	National Science Foundation; 	code editor;program comprehension;novice programmers	Training;Computer bugs;Tools;Software;Statistics;Programming profession;Software engineering	computer aided instruction;computer science education;educational courses;programming;software engineering	inquisitive code editor;novice programmer;computer science degree;test code;Atom code editor;novice programmers misconceptions;software development;introductory programming courses				55		7 May 2021			IEEE	IEEE Conferences
NeuralVis: Visualizing and Interpreting Deep Learning Models	neuralvis visualizing and interpreting deep learning models	10.1109/ASE.2019.00113	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952427	X. Zhang; Z. Yin; Y. Feng; Q. Shi; J. Liu; Z. Chen	State Key Laboratory for Novel Software Technology, Nanjing University, China; State Key Laboratory for Novel Software Technology, Nanjing University, China; State Key Laboratory for Novel Software Technology, Nanjing University, China; State Key Laboratory for Novel Software Technology, Nanjing University, China; State Key Laboratory for Novel Software Technology, Nanjing University, China; State Key Laboratory for Novel Software Technology, Nanjing University, China	2019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)	9 jan. 2020	2019			1106	1109	Deep Neural Network (DNN) techniques have been prevalent in software engineering. They are employed to facilitate various software engineering tasks and embedded into many software applications. However, because DNNs are built upon a rich data-driven programming paradigm that employs plenty of labeled data to train a set of neurons to construct the internal system logic, analyzing and understanding their behaviors becomes a difficult task for software engineers. In this paper, we present an instance-based visualization tool for DNN, namely NeuralVis, to support software engineers in visualizing and interpreting deep learning models. NeuralVis is designed for: 1). visualizing the structure of DNN models, i.e., neurons, layers, as well as connections; 2). visualizing the data transformation process; 3). integrating existing adversarial attack algorithms for test input generation; 4). comparing intermediate layers' outputs of different inputs. To demonstrate the effectiveness of NeuralVis, we design a task-based user study involving ten participants on two classic DNN models, i.e., LeNet and VGG-12. The result shows NeuralVis can assist engineers in identifying critical features that determine the prediction results. Video: https://youtu.be/solkJri4Z44.	2643-1572	978-1-7281-2508-4		Visualization;Neural Network Visualization;Program Comprehension	Task analysis;Data visualization;Visualization;Software;Load modeling;Tools;Neural networks	data visualisation;learning (artificial intelligence);neural nets;software engineering	NeuralVis;deep neural network techniques;software engineering tasks;software applications;rich data-driven programming paradigm;neurons;internal system logic;software engineers;instance-based visualization tool;data transformation process;task-based user study;classic DNN models;deep learning model visualization;deep learning model interpretation				14		9 jan. 2020			IEEE	IEEE Conferences
QuLog: Data-Driven Approach for Log Instruction Quality Assessment	qulog datadriven approach for log instruction quality assessment	10.1145/3524610.3527906	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796196	J. Bogatinovski; S. Nedelkoski; A. Acker; J. Cardoso; O. Kao	Technical University Berlin, Berlin, Germany; Technical University Berlin, Berlin, Germany; Technical University Berlin, Berlin, Germany; Huawei Munich Research Center, Munich, Germany; Technical University Berlin, Berlin, Germany	2022 IEEE/ACM 30th International Conference on Program Comprehension (ICPC)	22 jun. 2022	2022			275	286	In the current IT world, developers write code while system operators run the code mostly as a black box. The connection between both worlds is typically established with log messages: the developer provides hints to the (unknown) operator, where the cause of an occurred issue is, and vice versa, the operator can report bugs during operation. To fulfil this purpose, developers write log instructions that are structured text commonly composed of a log level (e.g., “info”, “error”), static text (“IP {} cannot be reached”), and dynamic variables (e.g. IP {}). However, opposed to well-adopted coding practices, there are no widely adopted guidelines on how to write log instructions with good quality properties. For example, a developer may assign a high log level (e.g., “error”) for a trivial event that can confuse the operator and increase maintenance costs. Or the static text can be insufficient to hint at a specific issue. In this paper, we address the problem of log quality assessment and provide the first step towards its automation. We start with an in-depth analysis of quality log instruction properties in nine software systems and identify two quality properties: 1) correct log level assignment assessing the correctness of the log level, and 2) sufficient linguistic structure assessing the minimal richness of the static text necessary for verbose event description. Based on these findings, we developed a data-driven approach that adapts deep learning methods for each of the two properties. An extensive evaluation on large-scale open-source systems shows that our approach correctly assesses log level assignments with an accuracy of 0.88, and the sufficient linguistic structure with an F1 score of 0.99, outperforming the baselines. Our study highlights the potential of the data-driven methods in assessing log instructions quality.	2643-7171	978-1-4503-9298-3		log quality;deep learning;log analysis;program comprehension	Codes;Linguistics;Writing;Predictive models;Maintenance engineering;Software systems;Quality assessment	computational linguistics;deep learning (artificial intelligence);inference mechanisms;object-oriented programming;program compilers;program debugging;software quality;system monitoring;text analysis	data-driven approach;log instruction quality assessment;system operators;black box;log messages;static text;IP;software systems;large-scale open-source systems;log level assignments;linguistic structure;data-driven methods;log instructions quality;deep learning methods				53		22 jun. 2022			IEEE	IEEE Conferences
Toward Interaction-Based Evaluation of Visualization Approaches to Comprehending Program Behavior	toward interactionbased evaluation of visualization approaches to comprehending program behavior	10.1109/MAINT.2019.8666933	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8666933	L. Kaixie; K. Noda; T. Kobayashi	School of Computing, Tokyo Institute of Technology, Japan; School of Computing, Tokyo Institute of Technology, Japan; School of Computing, Tokyo Institute of Technology, Japan	2019 IEEE Workshop on Mining and Analyzing Interaction Histories (MAINT)	14 mar. 2019	2019			19	23	Reverse-engineered sequence diagrams are promising tools to comprehend the runtime behavior of object-oriented programs. To improve the readability and understandability of massive-scale sequence diagrams, various techniques for effectively exploring or compressing sequence diagrams have been proposed in the literature.When researchers analyze the effectiveness of these approaches through user studies, it is important to reveal not only what techniques can improve developer productivity but also how developers explore reverse-engineered sequence diagrams and how exploration and compression features are utilized.We developed a feature to record interactions between a developer and recovered sequence diagrams in our tool, SDExplorer. We show how the recorded interaction data can be used for in-depth analysis of developer activities, toward the evaluation of visualization approaches to helping behavioral comprehension.		978-1-7281-0956-5		interaction data analysis;scalable sequence diagram explorer;visualization;program comprehension	Tools;Navigation;Data visualization;Task analysis;Runtime;Software;Databases	data visualisation;object-oriented programming;reverse engineering	visualization approaches;reverse-engineered sequence diagrams;runtime behavior;object-oriented programs;massive-scale sequence diagrams;developer productivity;compression features;behavioral comprehension;interaction-based evaluation;program behavior;SDExplorer				27		14 mar. 2019			IEEE	IEEE Conferences
SDExplorer: A Generic Toolkit for Smoothly Exploring Massive-Scale Sequence Diagram	sdexplorer a generic toolkit for smoothly exploring massivescale sequence diagram		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8973065	K. Lyu; K. NODA; T. KOBAYASHI	Tokyo Institute of Technology, Tokyo, Japan; Tokyo Institute of Technology, Tokyo, Japan; Tokyo Institute of Technology, Tokyo, Japan	2018 IEEE/ACM 26th International Conference on Program Comprehension (ICPC)	30 jan. 2020	2018			380	3804	To understand program's behavior, using reverse-engineered sequence diagram is a valuable technique. In practice, researchers usually record execution traces and generate a sequence diagram according to them. However, the diagram can be too large to read while treating real-world software due to the massiveness of execution traces. Several studies on minimizing/compressing sequence diagrams have been proposed; however, the resulting diagram may be either still large or losing important information. Besides, existing tools are highly customized for a certain research purpose. To address these problems, we present a generic toolkit SDExplorer in this paper, which is a flexible and lightweight tool to effectively explore a massive-scale sequence diagram in a highly scalable manner. Additionally, SDExplorer supports popular features of existing tools (i.e. search, filter, grouping, etc.). We believe it is an easy-to-use and promising tool in future research to evaluate and compare the minimizing/compressing techniques in real maintenance tasks.	2643-7171	978-1-4503-5714-2		scalable sequence diagram explorer;reverse engineering;visualization;program comprehension		reverse engineering;software maintenance	massive-scale sequence diagram;reverse-engineered sequence diagram;execution traces;SDExplorer generic toolkit				14		30 jan. 2020			IEEE	IEEE Conferences
Creating Important Statement Type Comments in Autocomment: Automatic Comment Generation Framework	creating important statement type comments in autocomment automatic comment generation framework	10.1109/UBMK.2018.8566660	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8566660	E. Yildiz; E. Ekin	Huawei Turkey R&D Center Huawei, Istanbul, Turkey; Computer Engineering Department, Işik University, Istanbul, Turkey	2018 3rd International Conference on Computer Science and Engineering (UBMK)	9 Dec 2018	2018			642	647	This study explains important statement comments generated by Autocomment, which is an automatic comment generation framework described in [1]. To create the comments, the source code is not expected to be runnable, but to conform to the syntax rules of the Java programming language. Two types of comments are created: summary comments and important statement comments. How the important statements are extracted in a given Java source, how they are classified, how comments are generated for each type of important statement have been explained in this work.		978-1-5386-7893-0		source code summarization;documentation generation;program comprehension	Java;Grammar;Syntactics;Tools;Natural languages;Arrays	Java;public domain software;question answering (information retrieval);software maintenance	automatic comment generation framework;summary comments;important statement type comments;Java source;Java programming language;syntax rules;source code				17		9 Dec 2018			IEEE	IEEE Conferences
Atoms of Confusion in Java	atoms of confusion in java	10.1109/ICPC52881.2021.00012	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9462963	C. Langhout; M. Aniche	Software Engineering Research Group, Delft University of Technology, Delft, The Netherlands; Software Engineering Research Group, Delft University of Technology, Delft, The Netherlands	2021 IEEE/ACM 29th International Conference on Program Comprehension (ICPC)	28 jun. 2021	2021			25	35	Although writing code seems trivial at times, problems arise when humans misinterpret what the code actually does. One of the potential causes are "atoms of confusion", the smallest possible patterns of misinterpretable source code. Previous research has investigated the impact of atoms of confusion in C code. Results show that developers make significantly more mistakes in code where atoms are present. In this paper, we replicate the work of Gopstein et al. to the Java language. After deriving a set of atoms of confusion for Java, we perform a two-phase experiment with 132 computer science students (i.e., novice developers). Our results show that participants are 2.7 up to 56 times more likely to make mistakes in code snippets affected by 7 out of the 14 studied atoms of confusion, and when faced with both versions of the code snippets, participants perceived the version affected by the atom of confusion to be more confusing and/or less readable in 10 out of the 14 studied atoms of confusion.	2643-7171	978-1-6654-1403-6		software engineering;program comprehension;atoms of confusion;empirical software engineering	Atomic measurements;Productivity;Java;Software maintenance;Writing;Particle measurements;Encoding	C language;computer science education;educational courses;Java;object-oriented methods;source code (software)	Java language;code snippets;source code patterns;C code;code writing;atoms of confusion				27	IEEE	28 jun. 2021			IEEE	IEEE Conferences
Fine-Grained Code-Comment Semantic Interaction Analysis	finegrained codecomment semantic interaction analysis	10.1145/3524610.3527887	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796273	M. Geng; S. Wang; D. Dong; S. Gu; F. Peng; W. Ruan; X. Liao	College of Computer Science, National University of Defense Technology, Changsha, China; College of Computer Science, National University of Defense Technology, Changsha, China; College of Computer Science, National University of Defense Technology, Changsha, China; Hunan Huishiwei Intelligent Technology Co., Ltd., Changsha, China; University of Chinese Academy of Sciences, Shenzhen, China; Shenzhen Institutes of Advanced Technology, Chinese Academy of Sciences, Shenzhen, China; College of Computer Science, National University of Defense Technology, Changsha, China	2022 IEEE/ACM 30th International Conference on Program Comprehension (ICPC)	22 jun. 2022	2022			585	596	Code comment, i.e., the natural language text to describe code, is considered as a killer for program comprehension. Current literature approaches mainly focus on comment generation or comment update, and thus fall short on explaining which part of the code leads to a specific content in the comment. In this paper, we propose that addressing such a challenge can better facilitate code under-standing. We propose Fosterer, which can build fine-grained se-mantic interactions between code statements and comment tokens. It not only leverages the advanced deep learning techniques like cross-modal learning and contrastive learning, but also borrows the weapon of pre-trained vision models. Specifically, it mimics the comprehension practice of developers, treating code statements as image patches and comments as texts, and uses contrastive learning to match the semantically-related part between the visual and tex-tual information. Experiments on a large-scale manually-labelled dataset show that our approach can achieve an Fl-score around 80%, and such a performance exceeds a heuristic-based baseline to a large extent. We also find that Fosterer can work with a high efficiency, i.e., it only needs 1.5 seconds for inferring the results for a code-comment pair. Furthermore, a user study demonstrates its usability: for 65% cases, its prediction results are considered as useful for improving code understanding. Therefore, our research sheds light on a promising direction for program comprehension.	2643-7171	978-1-4503-9298-3		program comprehension;code comment;cross-modal learning;contrastive learning	Deep learning;Visualization;Codes;Weapons;Semantics;Natural languages;MIMICs	deep learning (artificial intelligence);program compilers;programming language semantics;text analysis	code statements;Fosterer;code-comment pair;code understanding;program comprehension;natural language text;comment generation;comment tokens;deep learning;fine-grained code-comment semantic interaction analysis				66		22 jun. 2022			IEEE	IEEE Conferences
A Conceptual Framework for Application Comprehension	a conceptual framework for application comprehension	10.1109/ITNG.2008.1	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4492526	V. N. Gudivada; J. Nandigam; J. Bhuyan	Engineering and Computer Science, Marshall University, Huntington, WV, USA; Computing & Information Systems, Grand Valley State University, Allendale, MI, USA; Computer Science, Franklin University, Columbus, OH, USA	Fifth International Conference on Information Technology: New Generations (itng 2008)	18 Apr 2008	2008			483	488	The scope and purpose of application comprehension is much broader than that of program comprehension. Application comprehension can be viewed as a spectrum spanning the gamut comprising code-level understanding at one end (low level) and understanding the architecture of interorganizational systems at the other end (high level). The nature and the depth of knowledge sought through application comprehension is directly related to the purpose at hand. In this paper, we propose a unified conceptual framework for application comprehension. The framework is influenced by Bloom's taxonomy. The proposed framework considers several aspects of application comprehension and draws upon our experience in developing large-scale, multi-tier distributed applications for brokerage and financial services. We discuss how the proposed conceptual framework can be implemented by leveraging the sophisticated tools that are available as open-source software. We conclude the paper by indicating how the proposed framework can be used to learn software engineering principles, tools, and practices in education and training contexts.		978-0-7695-3099-4		Application comprehension;Program comprehension;Bloom's taxonomy;Open Source;Eclipse.	Application software;Computer architecture;Taxonomy;Software systems;Computer science;Open source software;Software engineering;Service oriented architecture;Java;Information technology	data flow analysis;financial data processing;public domain software	application comprehension;spectrum spanning;code-level understanding;interorganizational systems;Bloom taxonomy;large-scale distributed applications;multitier distributed applications;brokerage;financial services;open-source software;software engineering				20		18 Apr 2008			IEEE	IEEE Conferences
A Feature Model of Framework Applications	a feature model of framework applications	10.1109/SNPD.2013.14	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6598512	I. Kume; M. Nakamura; N. Nitta; E. Shibayama	Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Nara, Japan; Graduate School of System Informatics, Kobe University, Kobe, Japan; Faculty of Intelligence and Informatics, Konan University, Kobe, Japan; Information Technology Center, University of Tokyo, Bunkyo, Tokyo, Japan	2013 14th ACIS International Conference on Software Engineering, Artificial Intelligence, Networking and Parallel/Distributed Computing	16 Sep 2013	2013			511	516	Learning how to use application frameworks effectively becomes important in their widespread use in software development. Learning frameworks is often difficult because of lack of their documentation and their complexity. In order to help framework learning, we propose a behavioral model, called feature component model, which abstracts internal behaviors of framework applications in terms of their behavioral characteristics such as inversion of controls. We apply our behavioral model to an example misuse of a practical framework developed by a third party in order to show its practical usefulness.		978-0-7695-5005-3		application frameworks;framework learning;feature model;feature interactions;program comprehension	Unified modeling language;Runtime;Java;Educational institutions;Libraries;Arrays;Electronic mail	application program interfaces;software maintenance	framework application feature model;application framework learning;software development;behavioral model;feature component model;internal behavioral characteristics;inversion-of-control method;dependency abstraction;software maintenance				19		16 Sep 2013			IEEE	IEEE Conferences
A Multi-Module Based Method for Generating Natural Language Descriptions of Code Fragments	a multimodule based method for generating natural language descriptions of code fragments	10.1109/ACCESS.2021.3055955	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9343307	X. Gao; X. Jiang; Q. Wu; X. Wang; L. Lyu; C. Lyu	School of Information Science and Engineering, Shandong Normal University, Jinan, China; School of Information Science and Engineering, Shandong Normal University, Jinan, China; School of Information Science and Engineering, Shandong Normal University, Jinan, China; School of Information Science and Engineering, Shandong Normal University, Jinan, China; School of Information Science and Engineering, Shandong Normal University, Jinan, China; School of Information Science and Engineering, Shandong Normal University, Jinan, China	IEEE Access	5 Feb 2021	2021	9		21579	21592	Code fragment natural language description generation, also known as code summarization, refers to obtaining a natural language sequence describing a given code fragment’s functionality. It is broadly agreed that applying code summarization into production can significantly improve the efficiency of software development and maintenance. In recent years, syntactic analysis (SA) technology and Latent Dirichlet Allocation (LDA) has been widely used in code summarization and has achieved good results. However, most of the existing techniques focus on core code statements, and thus their generated code summarization lacks a logical description of the code fragment’s holistic information. To this end, we propose a code summarization method based on multiple modules to generate natural language for each code statement by constructing a new type of natural language template. Meanwhile, to utilize the code fragment’s holistic information, we adopt the code statement partition rules and cosine similarity measure to rank and optimize the weight of the overall information of the code fragment, and finally generate the holistic natural language description of the code fragment. The experimental results demonstrate that our method can generate more concise and logical natural language descriptions than existing models.	2169-3536		National Natural Science Foundation of China(grant numbers:61602286,61976127); Shandong Key Research and Development Program(grant numbers:2018GGX101003); Shandong Province Higher Educational Science and Technology Program(grant numbers:J16LN09); 	Source code summarization;program comprehension;program description	Natural languages;Software;Semantics;Task analysis;Java;Standards;Resource management	natural language processing;software maintenance;text analysis	natural language template;code statement partition rules;holistic natural language description;logical natural language descriptions;multimodule based method;code fragment natural language description generation;generated code summarization;latent Dirichlet allocation;syntactic analysis;software development;software maintenance				45	CCBY	1 Feb 2021			IEEE	IEEE Journals
On the Use of Evolutionary Coupling for Software Architecture Recovery	on the use of evolutionary coupling for software architecture recovery	10.1109/UYMS54260.2021.9659761	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9659761	A. Saydemir; M. E. Simitcioglu; H. Sozer	Department of Computer Science, Ozyegin University, Istanbul, Turkey; Department of Computer Science, Ozyegin University, Istanbul, Turkey; Department of Computer Science, Ozyegin University, Istanbul, Turkey	2021 15th Turkish National Software Engineering Symposium (UYMS)	5 jan. 2022	2021			1	6	Software architecture documentation can be partially obtained automatically by means of software architecture recovery tools. These tools mainly cluster software modules to provide a high level structural organization of these modules. They use dependency graphs as input. These graphs reflect various types of coupling among software modules. In this paper, we present an empirical evaluation of using evolutionary coupling as a complementary source of information for software architecture recovery. We use 3 open source projects as subject systems. We derive inter-module dependencies for these systems based on various levels of evolutionary coupling among their modules. We investigate the accuracy of software architecture recovery when input dependency graphs are extended with these additional dependencies. Results show that involving evolutionary coupling in the process can increase the accuracy of architecture recovery by up to 40%.		978-1-6654-1070-0		Software architecture recovery;software architecture reconstruction;evolutionary coupling;empirical software engineering;software maintenance;program comprehension	Couplings;Software architecture;Computer architecture;Organizations;Documentation;Software	graph theory;software architecture;software maintenance	software architecture documentation;software architecture recovery tools;software modules;high level structural organization;evolutionary coupling;input dependency graphs;intermodule dependencies				30	IEEE	5 jan. 2022			IEEE	IEEE Conferences
Malware System Calls Detection Using Hybrid System	malware system calls detection using hybrid system	10.1109/SysCon48628.2021.9447094	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9447094	Y. Guan; N. Ezzati-Jivan	Brock University, St.Catharines, Canada; Brock University, St.Catharines, Canada	2021 IEEE International Systems Conference (SysCon)	9 jun. 2021	2021			1	8	Due to the rapid and continuous increase of network intrusion, the need to protect computer systems and underlying infrastructure becomes inevitable. Beside this, the systems have additionally gotten extremely intricate as they fill in both scale and usefulness;hence,intrusion/anomaly detection becomes essential. The intrusion or anomaly detection poses several challenges including data collections due to the inherent datasets imbalance, caused by systems' reliability requirements causing the event of an anomaly a irregularity phenomenon. Therefore, only a small percentage of available datasets captures the anomaly, which brings in the second challenge, i.e, model selection, and a specific approach for detecting an anomaly. While much research has been concentrated on the data collection part and statistical techniques, the focus of this work is devoted to a multi-module system call anomalies detection technique. We propose a novel approach based on Long Short Term Memory(LSTM) and attention using transformers that can learn a sequence of a system call efficiently. Experimental results showed that the proposed deep learning model is 92.6% precise with a recall of 93.8% to classify the malicious process in the system.	2472-9647	978-1-6654-4439-2		Performance analysis;program comprehension;root-cause analysis;program debugging;system tracing	Deep learning;Computer hacking;Conferences;Data collection;Malware;Reliability;Network intrusion	invasive software;learning (artificial intelligence);recurrent neural nets;transforms	malware system calls detection;hybrid system;network intrusion;computer system protection;anomaly detection;data collections;multimodule system;transformers;long short-term memory;LSTM;attention;intrusion detection				37		9 jun. 2021			IEEE	IEEE Conferences
Reviewing Dynamic Feature Location Techniques: Basic Elements and Challenges	reviewing dynamic feature location techniques basic elements and challenges	10.1109/3ICT53449.2021.9581921	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9581921	F. Buzaid; M. Hammad	Department of Computer Science, University of Bahrain, Sakhir, Bahrain; Department of Computer Science, University of Bahrain, Sakhir, Bahrain	2021 International Conference on Innovation and Intelligence for Informatics, Computing, and Technologies (3ICT)	4 nov. 2021	2021			242	249	Dynamic Feature Location Techniques (DFLTs) seek to pertain the software functionalities artifacts which are known as software features, to the relevant source code based on execution trace. These techniques enhance developers to comprehend a software system to perform various activities such as software maintenance, code refactoring, and others. For instance, comprehend a software application at runtime support the developers to map source code to the relevant software feature based on the feature software execution trace analysis. This work introduces a systematic literature review for several works in DFLTs top. An illustration is presented to show their common structure approach and idealize the used solution on an industrial software application. Moreover, we review their characterization, advantages, disadvantages and administer a possible framework that would be utilized by researchers and developers to boost their decision to opt for the correct DFLTs to solve a problem. A basic comparison between DFLTs is provided by classifying the located techniques into corpus-based analysis, execution trace analysis, and dependencies analysis. The three points of comparison results and the taxonomy diagram lead to examine possible directions for standardizing DFLTs architecture to improve the accuracy and increase the ease of mapping software functionalities to the related software artifact based on the execution trace. The review paper also discusses unsolved issues and defines future directions in the field of Dynamic Feature Location (DFL).		978-1-6654-4032-5		Feature Location;Dynamic Analysis;Execution Trace;Program Comprehension;Software Engineering	Software maintenance;Technological innovation;Codes;Systematics;Runtime;Bibliographies;Taxonomy	software architecture;software maintenance;software reviews;source code (software)	feature software execution trace analysis;systematic literature review;industrial software application;corpus-based analysis;standardizing DFLTs architecture;software functionalities artifacts;source code;software system;software maintenance;code refactoring;dynamic feature location techniques				40	IEEE	4 nov. 2021			IEEE	IEEE Conferences
Understanding Similar Code through Comparative Comprehension	understanding similar code through comparative comprehension	10.1109/VL/HCC53370.2022.9833117	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9833117	J. Middleton; K. T. Stolee	Department of Computer Science, North Carolina State University; Department of Computer Science, North Carolina State University	2022 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)	17 Aug 2022	2022			1	11	Any problem in code may have multiple solutions that differ in details large and small. Because modern software development is characterized by an abundance of searchable and reusable code, effective developers must be able to judge not only the meaning of new algorithms but also the differences between alternatives. Therefore, we use a multi-method study to explore how developers perform comparative comprehension— the cognitive activity of understanding how algorithms behave relative to each other.To explore how developers compare code, we performed a controlled experiment with 16 developers in a mixed think-aloud and interview format and another 95 developers in a survey format. In this experiment, participants investigated whether a pair of code snippets would demonstrate equivalent behavior when run, controlling for differences in behavior, programming languages, algorithmic structures, and meaningful names. Overall, our results describe how comparison fits into learning, reviewing, and reusing code. Our task observations shed light on how developers move between code similarities at different levels—textual, structural, and schematic—when simultaneously inspecting multiple snippets. In our experiment, developers made more accurate conclusions about behavior given similar languages and structures, with names acting as additional evidence in interaction with other cues, but they also overestimated whether behavior is equivalent in many cases. From this, we identify challenges developers face in comprehending alternatives and we highlight opportunities to better support developers in comparison activities.	1943-6106	978-1-6654-4214-5		comparative comprehension;program comprehension;code clones;human studies	Visualization;Computer languages;Codes;Navigation;Software algorithms;Software;Behavioral sciences						51	IEEE	17 Aug 2022			IEEE	IEEE Conferences
DeepTC-Enhancer: Improving the Readability of Automatically Generated Tests	deeptcenhancer improving the readability of automatically generated tests		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9285992	D. Roy; Z. Zhang; M. Ma; V. Arnaoudova; A. Panichella; S. Panichella; D. Gonzalez; M. Mirakhorli	Washington State University; Washington State University; Infra Supply Chain & Automation, Amazon; Washington State University; Delft University of Technology; Zurich University of Applied Science; Rochester Institute of Technology; Rochester Institute of Technology	2020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)	24 Dec 2020	2020			287	298	Automated test case generation tools have been successfully proposed to reduce the amount of human and infrastructure resources required to write and run test cases. However, recent studies demonstrate that the readability of generated tests is very limited due to (i) uninformative identifiers and (ii) lack of proper documentation. Prior studies proposed techniques to improve test readability by either generating natural language summaries or meaningful methods names. While these approaches are shown to improve test readability, they are also affected by two limitations: (1) generated summaries are often perceived as too verbose and redundant by developers, and (2) readable tests require both proper method names but also meaningful identifiers (within-method readability). In this work, we combine template based methods and Deep Learning (DL) approaches to automatically generate test case scenarios (elicited from natural language patterns of test case statements) as well as to train DL models on path-based representations of source code to generate meaningful identifier names. Our approach, called DeepTC-Enhancer, recommends documentation and identifier names with the ultimate goal of enhancing readability of automatically generated test cases. An empirical evaluation with 36 external and internal developers shows that (1) DeepTC-Enhancer outperforms significantly the baseline approach for generating summaries and performs equally with the baseline approach for test case renaming, (2) the transformation proposed by DeepTC-Enhancer results in a significant increase in readability of automatically generated test cases, and (3) there is a significant difference in the feature preferences between external and internal developers.	2643-1572	978-1-4503-6768-4		software testing, deep learning, test case generation, program comprehension, empirical study, maintenance, evolution	Deep learning;Natural languages;Documentation;Tools;Software engineering	automatic test pattern generation;deep learning (artificial intelligence);program testing	automatically generated tests;automated test case generation tools;test readability;natural language summaries;template based methods;test case scenarios;test case statements;identifier names;documentation;automatically generated test cases;test case renaming;DeepTC-Enhancer				46		24 Dec 2020			IEEE	IEEE Conferences
A Data Set of Program Invariants and Error Paths	a data set of program invariants and error paths	10.1109/MSR.2019.00026	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8816801	D. Beyer	LMU, Munich, Germany	2019 IEEE/ACM 16th International Conference on Mining Software Repositories (MSR)	29 Aug 2019	2019			111	115	The analysis of correctness proofs and counterexamples of program source code is an important way to gain insights into methods that could make it easier in the future to find invariants to prove a program correct or to find bugs. The availability of high-quality data is often a limiting factor for researchers who want to study real program invariants and real bugs. The described data set provides a large collection of concrete verification results, which can be used in research projects as data source or for evaluation purposes. Each result is made available as verification witness, which represents either program invariants that were used to prove the program correct (correctness witness) or an error path to replay the actual bug (violation witness). The verification results are taken from actual verification runs on 10522 verification problems, using the 31 verification tools that participated in the 8th edition of the International Competition on Software Verification (SV-COMP). The collection contains a total of 125720 verification witnesses together with various meta data and a map to relate a witness to the C program that it originates from. Data set is available at: https://doi.org/10.5281/zenodo.2559175.	2574-3864	978-1-7281-3412-3		Invariant Mining, Program Comprehension, Formal Verification, Model Checking, Program Analysis, Verification Witnesses, Program Invariants, Error Paths, Bugs	Software;Tools;Metadata;Computer bugs;Benchmark testing;Automata;Standards	program debugging;program verification	verification witness;program invariants;correctness witness;correctness proofs;program source code;bugs;verification tools;software verification;error paths;violation witness				43		29 Aug 2019			IEEE	IEEE Conferences
The Effect Of Crowding On The Reading Of Program Code For Programmers With Dyslexia	the effect of crowding on the reading of program code for programmers with dyslexia	10.1109/ICPC52881.2021.00036	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463028	I. McChesney; R. Bond	School of Computing, Ulster University, Newtownabbey, United Kingdom; School of Computing, Ulster University, Newtownabbey, United Kingdom	2021 IEEE/ACM 29th International Conference on Program Comprehension (ICPC)	28 jun. 2021	2021			300	310	Good program layout and consistent application of style facilitates code readability and comprehension. Appropriate use of white space, in particular vertical space, is useful for organising code into logical groupings of text. Where this style is not followed then the code manifests crowding and can inhibit comprehension. When reading natural text, crowding has been recognised as disproportionately affecting the reading efficiency of dyslexic readers. We present an independent two-factorial study which examines the extent to which crowding in program code affects programmers with dyslexia. The study involved 30 participants (14 dyslexia, 16 control) reading and describing crowded and spaced versions of three Java programs. Comprehension time and accuracy were measured. An eye tracker was used to collect gaze metrics. Results are presented relating to the interaction between dyslexia and crowding. Noting the small sample size, the results show that, while there is an interaction effect on gaze metrics for some program features, the results do not suggest any significant effect whereby programmers with dyslexia are disproportionately affected by crowding in computer programs.	2643-7171	978-1-6654-1403-6		program comprehension;code layout;crowding;dyslexia;eye tracking	Java;Text recognition;Atmospheric measurements;Layout;White spaces;Programming;Particle measurements	gaze tracking;Java;program diagnostics;statistical analysis	white space;vertical space;code manifests crowding;programmers with dyslexia;Java programs;program features;computer programs;good program layout;consistent application;program code reading;code readability;code comprehension;logical groupings;eye tracker;gaze metrics;interaction effect;natural text reading				25		28 jun. 2021			IEEE	IEEE Conferences
Here We Go Again: Why Is It Difficult for Developers to Learn Another Programming Language?	here we go again why is it difficult for developers to learn another programming language		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9284077	N. Shrestha; C. Botta; T. Barik; C. Parnin	NC State University, Raleigh, North Carolina; NC State University, Raleigh, North Carolina; Microsoft, Redmond, Washington; NC State University, Raleigh, North Carolina	2020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)	21 Dec 2020	2020			691	701	Once a programmer knows one language, they can leverage concepts and knowledge already learned, and easily pick up another programming language. But is that always the case? To understand if programmers have difficulty learning additional programming languages, we conducted an empirical study of Stack Overflow questions across 18 different programming languages. We hypothesized that previous knowledge could potentially interfere with learning a new programming language. From our inspection of 450 Stack Overflow questions, we found 276 instances of interference that occurred due to faulty assumptions originating from knowledge about a different language. To understand why these difficulties occurred, we conducted semi-structured interviews with 16 professional programmers. The interviews revealed that programmers make failed attempts to relate a new programming language with what they already know. Our findings inform design implications for technical authors, toolsmiths, and language designers, such as designing documentation and automated tools that reduce interference, anticipating uncommon language transitions during language design, and welcoming programmers not just into a language, but its entire ecosystem.	1558-1225	978-1-4503-7121-6	National Science Foundation(grant numbers:1559593,1755762,1814798); 	interference theory;learning;program comprehension;programming environments;programming languages	Computer languages;Ecosystems;Interference;Documentation;Tools;Syntactics;Interviews	computer aided instruction;software tools;Web sites	programming language;stack overflow questions;language designers;uncommon language transitions;language design;semistructured interviews;professional programmers				72		21 Dec 2020			IEEE	IEEE Conferences
Deep Code Comment Generation	deep code comment generation		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8973050	X. Hu; G. Li; X. Xia; D. Lo; Z. Jin	Key Laboratory of High Confidence Software Technologies, Peking University, Beijing, China; Key Laboratory of High Confidence Software Technologies, Peking University, Beijing, China; Faculty of Information Technology, Monash University, Clayton, VIC, Australia; School of Information Systems, Singapore Management University, Singapore, Singapore; Key Laboratory of High Confidence Software Technologies, Peking University, Beijing, China	2018 IEEE/ACM 26th International Conference on Program Comprehension (ICPC)	30 jan. 2020	2018			200	20010	During software maintenance, code comments help developers comprehend programs and reduce additional time spent on reading and navigating source code. Unfortunately, these comments are often mismatched, missing or outdated in the software projects. Developers have to infer the functionality from the source code. This paper proposes a new approach named DeepCom to automatically generate code comments for Java methods. The generated comments aim to help developers understand the functionality of Java methods. DeepCom applies Natural Language Processing (NLP) techniques to learn from a large code corpus and generates comments from learned features. We use a deep neural network that analyzes structural information of Java methods for better comments generation. We conduct experiments on a large-scale Java corpus built from 9,714 open source projects from GitHub. We evaluate the experimental results on a machine translation metric. Experimental results demonstrate that our method DeepCom outperforms the state-of-the-art by a substantial margin.	2643-7171	978-1-4503-5714-2		program comprehension;comment generation;deep learning		Java;learning (artificial intelligence);natural language processing;neural nets;public domain software;software maintenance	code comments;software projects;Java methods;natural language processing techniques;code corpus;deep neural network;comments generation;deep code comment generation;software maintenance;source code navigation;DeepCom				48		30 jan. 2020			IEEE	IEEE Conferences
Reverse Engineering of Web Based Systems	reverse engineering of web based systems	10.1109/IIT.2007.4430375	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4430375	A. Hamou-Lhadj; A. En-Nouaary; K. Sultan	Electrical and Computer Engineering Department, Concordia University, Montreal, Canada; Electrical and Computer Engineering Department, Concordia University, Montreal, Canada; Electrical and Computer Engineering Department, Concordia University, Montreal, Canada	2007 Innovations in Information Technologies (IIT)	14 jan. 2008	2007			193	197	Maintaining a poorly documented Web application is not an easy task; software engineers must understand various parts of an application before they can make changes that preserve reliability and other system attributes. In recent years, there has been a noticeable increase in the number of studies that aim at reverse engineering web applications. These studies embody a rich set of techniques that differ in a variety of ways. In this paper, we study several techniques for reverse engineering of Web applications. The objective is to understand the trends in this area as well as uncover key research questions that remain unaddressed.		978-1-4244-1840-4		Reverse engineering;web applications;program comprehension;software maintenance	Reverse engineering;Application software;Software maintenance;Computer architecture;Maintenance engineering;Reliability engineering;Internet;Software engineering;HTML;Java	Internet;reverse engineering;software reliability	reverse engineering;Web based systems;software engineers;reliability;system attributes				17		14 jan. 2008			IEEE	IEEE Conferences
Bytecode-based class dependency extraction tool: Bytecode-CDET	bytecodebased class dependency extraction tool bytecodecdet	10.1109/ICITEED.2015.7408903	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7408903	A. Nanthaamornphong; A. Leatongkam; T. Kitpanich; P. Thongnuan	Department of Information and Communication Technology, Prince of Songkla University, Phuket, Thailand; Department of Information and Communication Technology, Prince of Songkla University, Phuket, Thailand; Department of Information and Communication Technology, Prince of Songkla University, Phuket, Thailand; Department of Information and Communication Technology, Prince of Songkla University, Phuket, Thailand	2015 7th International Conference on Information Technology and Electrical Engineering (ICITEE)	18 Feb 2016	2015			6	11	Program comprehension is an important task in the software maintenance process. One of the challenges faced by Java developers is the inability to determine the correct number of class dependencies. The ability to recover class dependencies would help developers to understand the design of an existing system prior to modifying it. Many Java dependency analysis tools for this purpose have been proposed, but few are able to analyze the dependency types associated with Java bytecode. In this paper, we propose a reverse engineering tool to extract the dependencies from a compiled Java program. The tool provides a visualization of the recovered dependencies in a form that facilitates the developer's ability to examine the classes and class relationships in the software system. The resulting dependency extraction capability will also enhance software maintenance and evolution. The results of experiments conducted with the intent of evaluating the proposed tool demonstrate both its accuracy and a few of its limitations.		978-1-4673-7863-5		Software Engineering;Program Comprehension;Dependency Tool;Java Programming	Java;XML;Data mining;Software maintenance;Data visualization;Image color analysis	Java;program compilers;program visualisation;reverse engineering;software maintenance	bytecode-based class dependency extraction tool;bytecode-CDET;program comprehension;software maintenance process;Java dependency analysis tools;reverse engineering tool;compiled Java program;recovered dependency visualization;software maintenance enhancement				22		18 Feb 2016			IEEE	IEEE Conferences
On Understanding Contextual Changes of Failures	on understanding contextual changes of failures	10.1109/QRS54544.2021.00112	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9724653	F. Ribeiro; R. Abreu; J. Saraiva	HASLab/INESC TEC University of Minho, Braga, Portugal; INESC-ID & FEUP University of Porto, Porto, Portugal; HASLab/INESC TEC University of Minho, Braga, Portugal	2021 IEEE 21st International Conference on Software Quality, Reliability and Security (QRS)	10 mar. 2022	2021			1036	1047	Recent studies show that many real-world software faults are due to slight modifications (mutations) to the program. Thus, analyzing transformations made by a developer and associating them with well-known mutation operators can help pinpoint and repair the root cause of failures. This paper proposes a mutation operator inference technique: given the original program and one of its subsequent forms, it infers which mutation operators would transform the original and produce such a version. Moreover, we implemented this technique as a tool called Morpheus, which analyzes faulty Java programs. We have also validated both the technique and tool by analyzing a repository with 1753 modifications for 20 different programs, successfully inferring mutation operators 78% of times. Furthermore, we also show that several program versions result from not just a single mutation operator but multiple ones. In the end, we resort to real-world case studies to demonstrate the advantages of this approach regarding program repair.	2693-9177	978-1-6654-5813-9		program comprehension;program mutation;program repair	Java;Conferences;Transforms;Software quality;Maintenance engineering;Software reliability;Security						40	IEEE	10 mar. 2022			IEEE	IEEE Conferences
Barriers in Front-End Web Development	barriers in frontend web development	10.1109/VL/HCC53370.2022.9833127	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9833127	D. I. Samudio; T. D. LaToza	Department of Computer Science, George Mason University, Fairfax, VA, USA; Department of Computer Science, George Mason University, Fairfax, VA, USA	2022 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)	17 Aug 2022	2022			1	11	Developers building web applications constantly face challenges, particularly in working with complex APIs. In response, developers often turn to Stack Overflow, offering a window into the programming barriers developers face. We examined 301 posts on Stack Overflow related to front-end web development and systematically characterized the challenges present in these posts. We found that most challenges reflected not a request for new code or an explanation of an error message but a request about how a specific code snippet might be edited to make its behavior as desired. Many challenges also reflected an underlying need to gather information about how specific code idioms are implemented within a framework or library. We identified 28 barriers developers face in front-end web development. Our findings suggest opportunities for facilitating more effective interactions with complex APIs through new types of programming content and tools that better address barriers in working with code idioms.	1943-6106	978-1-6654-4214-5	National Science Foundation; 	debugging;information needs;programming barriers;program comprehension;web development	Visualization;Codes;Design methodology;Debugging;Programming;Libraries;Behavioral sciences						49	IEEE	17 Aug 2022			IEEE	IEEE Conferences
Deriving a State Model of a Control Program by Symbolic Execution	deriving a state model of a control program by symbolic execution	10.1109/INDIN.2018.8472013	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8472013	H. Prähofer; T. Böhm; J. Pichler	Institute for System Software, Johannes Kepler University, Linz, Austria; Institute for System Software, Johannes Kepler University, Linz, Austria; Software Competence Center Hagenberg, Hagenberg, Austria	2018 IEEE 16th International Conference on Industrial Informatics (INDIN)	27 Sep 2018	2018			754	759	This paper presents an approach for deriving a state transition model which represents the behavior of a control component using symbolic execution. Symbolic execution is a technique for executing a program using symbolic values for unknowns. It explores execution paths in a program and then uses a SAT/SMT solver to prove that paths are feasible. Further, the approach allows using constraints on the environment and simplifications with a widening operator similar to abstract interpretation.We present the formal foundation of the approach, depict the the tool implementation, present results from a preliminary evaluation, and discuss various application scenarios.	2378-363X	978-1-5386-4829-2		Symbolic execution;program comprehension;programmable logic controllers;state transition model	Unified modeling language;Automata;Safety;Electronic mail;Tools;System software	computability;program testing;program verification	state transition model;control component;symbolic execution;control program;SAT solver;SMT solver;program execution;satisfiability				17		27 Sep 2018			IEEE	IEEE Conferences
How Explicit Feature Traces Did Not Impact Developers’ Memory	how explicit feature traces did not impact developers’ memory	10.1109/SANER50967.2021.00075	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9425954	J. Krüger; G. Çalıklı; T. Berger; T. Leich	Otto-von-Guericke University Magdeburg, Germany; University of Zurich, Switzerland; Ruhr-University Bochum, Germany & Chalmers | University of Gothenburg, Sweden; Harz University of Applied Sciences Wernigerode & METOP GmbH Magdeburg, Germany	2021 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)	11 May 2021	2021			610	613	Software features are intuitive entities used to abstract and manage the functionalities of a software system, for instance, in product-line engineering and agile software development. Nonetheless, developers rarely make features explicit in code, which is why they have to perform costly program comprehension and particularly feature location to (re-)gain knowledge about the code. In a previous paper, we conducted an experiment on how explicit feature traces impact developers' program comprehension by facilitating feature location. We found that annotating features in code improved program comprehension, while decomposing them into classes had a negative impact. Additionally, but not reported in that paper, we were concerned with understanding whether the different traces would impact developers' memory regarding the code and its features. To this end, we repeatedly asked our participants questions about the code on different levels of detail within time periods of two weeks. Since developers' memory decays over time, we expected that our participants would provide fewer correct answers over time, with differences depending on the feature traces in their code. Unfortunately, the actual results were inconclusive and up for interpretation, particularly due to challenges in designing an experiment on developers' memory. In this paper, we discuss our experimental design, the null results, and challenges for improving the methodology of future studies in this direction.	1534-5351	978-1-7281-9630-5	Vetenskapsrådet; 	Feature orientation;traceability;human memory;program comprehension;psychology	Conferences;Agile software development;Software systems	industrial psychology;software development management;software maintenance;software prototyping	explicit feature traces;software features;software system;product-line engineering;agile software development;program comprehension;feature location;code improved program comprehension				36		11 May 2021			IEEE	IEEE Conferences
How Do Programmers Express High-Level Concepts using Primitive Data Types?	how do programmers express highlevel concepts using primitive data types	10.1109/APSEC53868.2021.00043	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9712114	Y. Shinyama; Y. Arahori; K. Gondow	Dept. name of organization (of Aft.), Tokyo Institute of Technology, Meguro-ku, Tokyo, Japan; Dept. name of organization (of Aft.), Tokyo Institute of Technology, Meguro-ku, Tokyo, Japan; Dept. name of organization (of Aft.), Tokyo Institute of Technology, Meguro-ku, Tokyo, Japan	2021 28th Asia-Pacific Software Engineering Conference (APSEC)	17 Feb 2022	2021			360	368	We investigated how programmers express high-level concepts such as path names and coordinates using primitive data types. While relying too much on primitive data types is sometimes criticized as a bad smell, it is still a common practice among programmers. We propose a novel way to accurately identify expressions for certain predefined concepts by examining API calls. We defined twelve conceptual types used in the Java Standard API. We then obtained expressions for each conceptual type from 26 open source projects. Based on the expressions obtained, we trained a decision tree-based classifier. It achieved 83 % F -score for correctly predicting the conceptual type for a given expression. Our result indicates that it is possible to infer a conceptual type from a source code reasonably well once enough examples are given. The obtained classifier can be used for potential bug detection, test case generation and documentation.	2640-0715	978-1-6654-3784-4		Program comprehension;Software maintenance;Source code analysis;Dataflow analysis;Conceptual types	Java;Codes;Computer bugs;Documentation;Software;Decision trees;Standards	application program interfaces;decision trees;Java;pattern classification;program debugging;program testing	programmers express high-level concepts;primitive data types;predefined concepts;conceptual type;given expression;standard API;API calls;F-score;bug detection;test case generation				22	IEEE	17 Feb 2022			IEEE	IEEE Conferences
Aiding Comprehension of Unit Test Cases and Test Suites with Stereotype-Based Tagging	aiding comprehension of unit test cases and test suites with stereotypebased tagging		https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8973019	B. Li; C. Vendome; M. Linares-Vasquez; D. Poshyvanyk	College of William and Mary, Williamsburg, VA, USA; College of William and Mary, Williamsburg, VA, USA; Universidad de los Andes Bogotá, Andes, Colombia; College of William and Mary, Williamsburg, VA, USA	2018 IEEE/ACM 26th International Conference on Program Comprehension (ICPC)	30 jan. 2020	2018			52	5211	Techniques to automatically identify the stereotypes of different software artifacts (e.g., classes, methods, commits) were previously presented. Those approaches utilized the techniques to support comprehension of software artifacts, but those stereotype-based approaches were not designed to consider the structure and purpose of unit tests, which are widely used in software development to increase the quality of source code. Moreover, unit tests are different than production code, since they are designed and written by following different principles and workflows. In this paper, we present a novel approach, called TeStereo, for automated tagging of methods in unit tests. The tagging is based on an original catalog of stereotypes that we have designed to improve the comprehension and navigation of unit tests in a large test suite. The stereotype tags are automatically selected by using static control-flow, data-flow, and API call based analyses. To evaluate the benefits of the stereotypes and the tagging reports, we conducted a study with 46 students and another survey with 25 Apache developers to (i) validate the accuracy of the inferred stereotypes, (ii) measure the usefulness of the stereotypes when writing/understanding unit tests, and (iii) collect feedback on the usefulness of the generated tagging reports.	2643-7171	978-1-4503-5714-2		Unit test cases;program comprehension;maintaining software		program testing;software engineering;software tools	test suite;stereotype tags;unit test cases;stereotype-based tagging;software artifacts;stereotype-based approaches;software development;API call based analyses;static control-flow;data-flow				68		30 jan. 2020			IEEE	IEEE Conferences
WSC `06 Program Structure and Track Coordinators	wsc `06 program structure and track coordinators	10.1109/WSC.2006.323002	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4117574			Proceedings of the 2006 Winter Simulation Conference	5 mar. 2007	2006			xxxi	xxxiii	Provides a listing of current society officers.	1558-4305	1-4244-0500-9											5 mar. 2007			IEEE	IEEE Conferences
Corrections to "the effectiveness of control structure diagrams in source code comprehension activities"	corrections to the effectiveness of control structure diagrams in source code comprehension activities	10.1109/TSE.2002.1010064	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1010064	D. Hendrix; J. H. Cross; S. Maghsoodloo	Computer Science and Software Engineering Department, Auburn University, AL; Computer Science and Software Engineering Department, Auburn University, AL; Industrial and Systems Engineering Department, Auburn University, AL	IEEE Transactions on Software Engineering	7 Aug 2002	2002	28	6	624	624		1939-3520				Java;Senior members;Back;Visualization;Computer science;Software engineering;Systems engineering and theory						1		7 Aug 2002			IEEE	IEEE Journals
Evolving a Legacy Application Portfolio at Sallie Mae: Program Comprehension and Beyond	evolving a legacy application portfolio at sallie mae program comprehension and beyond	10.1109/ICPC.2006.22	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631098	R. S. Autor	SLM Corporation	14th IEEE International Conference on Program Comprehension (ICPC'06)	26 jun. 2006	2006			xiii	xiii	Robert Autor is the executive vice president and chief information officer of SLM Corporation, where he leads the company’s information technology division, loan consolidation business and corporate procurement division.	1092-8138	0-7695-2601-2											26 jun. 2006			IEEE	IEEE Conferences
Theories, methods and tools in program comprehension: past, present and future	theories, methods and tools in program comprehension past, present and future	10.1109/WPC.2005.38	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421034	M. . -A. Storey	Department of Computer Science, University of Victoria, Canada	13th International Workshop on Program Comprehension (IWPC'05)	23 May 2005	2005			181	191	Program comprehension research can be characterized by both the theories that provide rich explanations about how programmers comprehend software, as well as the tools that are used to assist in comprehension tasks. During this talk the author review some of the key cognitive theories of program comprehension that have emerged. Using these theories as a canvas, the author then explores how tools that are popular today have evolved to support program comprehension. Specifically, the author discusses how the theories and tools are related and reflect on the research methods that were used to construct the theories and evaluate the tools. The reviewed theories and tools will be further differentiated according to human characteristics, program characteristics, and the context for the various comprehension tasks. Finally, the author predicts how these characteristics will change in the future and speculate on how a number of important research directions could lead to improvements in program comprehension tools and methods.	1092-8138	0-7695-2254-8			Programming profession;Software tools;Software engineering;Computer science;Electronic mail;Humans;Silver;Buildings;History;Conferences	software tools;cognition;reverse engineering	program comprehension tools;human characteristics;program characteristics		92		49		23 May 2005			IEEE	IEEE Conferences
Code understanding	code understanding	10.1109/VLHCC.2012.6344493	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6344493			2012 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)	10 nov. 2012	2012			109	109	Start of the above-titled section of the conference proceedings record.	1943-6106	978-1-4673-0853-3											10 nov. 2012			IEEE	IEEE Conferences
Program Structure	program structure	10.1109/IC2IE53219.2021.9649138	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9649138			2021 4th International Conference of Computer and Informatics Engineering (IC2IE)	27 Dec 2021	2021			i	vii	Provides a schedule of conference events and a listing of which papers were presented in each session.		978-1-6654-4288-6											27 Dec 2021			IEEE	IEEE Conferences
Code Comprehension and Help Seeking	code comprehension and help seeking	10.1109/VL/HCC53370.2022.9833137	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9833137			2022 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)	17 Aug 2022	2022			i	ii		1943-6106	978-1-6654-4214-5										IEEE	17 Aug 2022			IEEE	IEEE Conferences
Proceedings of the 2009 IEEE 17th International Conference on Program Comprehension [USB welcome page]	proceedings of the 2009 ieee 17th international conference on program comprehension [usb welcome page]	10.1109/ICPC.2009.5090013	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090013			2009 IEEE 17th International Conference on Program Comprehension	19 jun. 2009	2009			ii	ii	USB welcome page for the 2009 IEEE 17th International Conference on Program Comprehension.	1092-8138	978-1-4244-3998-0							1				19 jun. 2009			IEEE	IEEE Conferences
Proceedings 11th IEEE International Workshop on Program Comprehension	proceedings 11th ieee international workshop on program comprehension	10.1109/WPC.2003.1199183	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199183			11th IEEE International Workshop on Program Comprehension, 2003.	21 May 2003	2003					The following topics are dealt with: static analysis techniques; program understanding tools and techniques; dynamic analysis techniques; program comprehension approaches; fact extraction techniques; comprehension frameworks and evaluation; clustering applications and evaluation.	1092-8138	0-7695-1883-4				reverse engineering;systems analysis;program debugging	static analysis techniques;program understanding tools;dynamic analysis;program comprehension;fact extraction techniques;comprehension frameworks						21 May 2003			IEEE	IEEE Conferences
Proceedings. 6th International Workshop on Program Comprehension. IWPC'98 (Cat. No.98TB100242)	proceedings. 6th international workshop on program comprehension. iwpc98 (cat. no.98tb100242)	10.1109/WPC.1998.693270	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=693270			Proceedings. 6th International Workshop on Program Comprehension. IWPC'98 (Cat. No.98TB100242)	6 Aug 2002	1998			iii		Presents the title page of the proceedings record.	1092-8138	0-8186-8560-3				reverse engineering;systems re-engineering;software maintenance;grammars	program visualisation;software architecture;integration frameworks;comprehension strategies;parsing;program decomposition;empirical studies;program analysis;program comprehension						6 Aug 2002			IEEE	IEEE Conferences
Research track: Session I — Program comprehension	research track session i — program comprehension	10.1109/ICSM.2012.6405246	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6405246			2012 28th IEEE International Conference on Software Maintenance (ICSM)	10 jan. 2013	2012			5	5	Start of the above-titled section of the conference proceedings record.	1063-6773	978-1-4673-2312-3											10 jan. 2013			IEEE	IEEE Conferences
15th IEEE International Conference on Program Comprehension - Cover	15th ieee international conference on program comprehension cover	10.1109/ICPC.2007.3	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268226			15th IEEE International Conference on Program Comprehension (ICPC '07)	9 jul. 2007	2007			c1	c1	Presents the front and back cover art for the 15th IEEE International Conference on Program Comprehension (ICPC '07) proceedings.	1092-8138	0-7695-2860-0											9 jul. 2007			IEEE	IEEE Conferences
15th IEEE International Conference on Program Comprehension - Copyright	15th ieee international conference on program comprehension copyright	10.1109/ICPC.2007.2	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268228			15th IEEE International Conference on Program Comprehension (ICPC '07)	9 jul. 2007	2007			iv	iv	Copyright and Reprint Permissions: Abstracting is permitted with credit to the source. Libraries may photocopy beyond the limits of US copyright law, for private use of patrons, those articles in this volume that carry a code at the bottom of the first page, provided that the per-copy fee indicated in the code is paid through the Copyright Clearance Center. The papers in this book comprise the proceedings of the meeting mentioned on the cover and title page. They reflect the authors' opinions and, in the interests of timely dissemination, are published as presented and without change. Their inclusion in this publication does not necessarily constitute endorsement by the editors or the Institute of Electrical and Electronics Engineers, Inc.	1092-8138	0-7695-2860-0											9 jul. 2007			IEEE	IEEE Conferences
Proceedings. 12th IEEE International Workshop on Program Comprehension	proceedings. 12th ieee international workshop on program comprehension	10.1109/WPC.2004.1311035	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311035			Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.	12 jul. 2004	2004					Presents the title page of the proceedings record.	1092-8138	0-7695-2149-5				reverse engineering;program visualisation;Unified Modeling Language;Internet	program comprehension;UML;software comprehension;analysis techniques;reverse engineering;software visualization;software artifacts;Web-based systems;program clustering						12 jul. 2004			IEEE	IEEE Conferences
14th IEEE International Conference on Program Comprehension - Title Page	14th ieee international conference on program comprehension title page	10.1109/ICPC.2006.4	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631091			14th IEEE International Conference on Program Comprehension (ICPC'06)	26 jun. 2006	2006			i	iii	The following topics are dealt with: program comprehension; software engineering; software maintenance; software system evolution; static analysis; quality assessment; dynamic analysis; tool demonstration; cognitive approaches; program traceability; programming languages	1092-8138	0-7695-2601-2				reverse engineering;software maintenance;software prototyping;software quality;software tools;system monitoring	program comprehension;software engineering;software maintenance;software system evolution;static analysis;quality assessment;dynamic analysis;tool demonstration;cognitive approaches;program traceability;programming languages						26 jun. 2006			IEEE	IEEE Conferences
18th IEEE International Conference on Program Comprehension [Cover art]	18th ieee international conference on program comprehension [cover art]	10.1109/ICPC.2010.56	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5521784			2010 IEEE 18th International Conference on Program Comprehension	26 jul. 2010	2010			C1	C1	Presents the cover of the 2010 IEEE 18th International Conference on Program Comprehension proceedings.	1092-8138	978-1-4244-7603-9											26 jul. 2010			IEEE	IEEE Conferences
Proceedings: Fourth Workshop on Program Comprehension	proceedings fourth workshop on program comprehension	10.1109/WPC.1996.501114	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=501114			WPC '96. 4th Workshop on Program Comprehension	6 Aug 2002	1996			i		Presents the front cover of the proceedings record.	1092-8138	0-8186-7283-8											6 Aug 2002			IEEE	IEEE Conferences
14th IEEE International Conference on Program Comprehension - Table of Contents	14th ieee international conference on program comprehension table of contents	10.1109/ICPC.2006.3	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631093			14th IEEE International Conference on Program Comprehension (ICPC'06)	26 jun. 2006	2006			v	vii	Presents the table of contets for the 14th IEEE International Conference on Program Comprehension (ICPC'06) proceedings.	1092-8138	0-7695-2601-2											26 jun. 2006			IEEE	IEEE Conferences
Proceedings Fifth International Workshop on Program Comprehension. IWPC'97	proceedings fifth international workshop on program comprehension. iwpc97	10.1109/WPC.1997.601255	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601255			Proceedings Fifth International Workshop on Program Comprehension. IWPC'97	6 Aug 2002	1997			iii		Presents the title page of the proceedings record.	1092-8138	0-8186-7993-X				reverse engineering;software engineering	software comprehension;automated program understanding;program analysis;program comprehension;reusable assets;panel infrastructure;software reengineering;software tools						6 Aug 2002			IEEE	IEEE Conferences
Proceedings. 13th International Workshop on Program Comprehension	proceedings. 13th international workshop on program comprehension	10.1109/WPC.2005.16	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421004			13th International Workshop on Program Comprehension (IWPC'05)	23 May 2005	2005					The following topics are dealt with: program comprehension; program framework understanding; object-oriented programming; software tools; code refactoring; dynamic program analysis; software visualization; software clustering; software components; reverse engineering.	1092-8138	0-7695-2254-8				reverse engineering;software tools;system monitoring;object-oriented programming;systems re-engineering	program comprehension;program framework understanding;object-oriented programming;software tools;code refactoring;dynamic program analysis;software visualization;software clustering;software components;reverse engineering						23 May 2005			IEEE	IEEE Conferences
16th IEEE International Conference on Program Comprehension [Cover art]	16th ieee international conference on program comprehension [cover art]	10.1109/ICPC.2008.48	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556101			2008 16th IEEE International Conference on Program Comprehension	2 jul. 2008	2008			C1	C1	The following topics are discussed: program comprehension; software evolution; dynamic analysis; domain terms; software metrics; cloning, slicing and parsing; and revision history analysis.	1092-8138	978-0-7695-3176-2				configuration management;program compilers;program slicing;software maintenance;software metrics	program comprehension;software evolution;dynamic analysis;domain terms;software metrics;software cloning;software slicing;parsing;revision history analysis						2 jul. 2008			IEEE	IEEE Conferences
10th International Workshop on Program Comprehension	10th international workshop on program comprehension	10.1109/WPC.2002.1021302	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021302			Proceedings 10th International Workshop on Program Comprehension	10 Dec 2002	2002			iii	vii	Presents the title page of the proceedings record.	1092-8138	0-7695-1495-2											10 Dec 2002			IEEE	IEEE Conferences
Proceedings 9th International Workshop on Program Comprehension. IWPC 2001	proceedings 9th international workshop on program comprehension. iwpc 2001	10.1109/WPC.2001.921707	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=921707			Proceedings 9th International Workshop on Program Comprehension. IWPC 2001	7 Aug 2002	2001			iii		Presents the title page of the proceedings record.	1092-8138	0-7695-1131-7				reverse engineering;software engineering	program comprehension;program visualization;program analysis;program understanding;software tools;design recovery;case studies;analysis tools;re-documentation						7 Aug 2002			IEEE	IEEE Conferences
Proceedings IWPC 2000. 8th International Workshop on Program Comprehension	proceedings iwpc 2000. 8th international workshop on program comprehension	10.1109/WPC.2000.852473	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852473			Proceedings IWPC 2000. 8th International Workshop on Program Comprehension	6 Aug 2002	2000			i			1092-8138	0-7695-0656-9				reverse engineering;software quality;software architecture;software maintenance;system recovery;software tools;program diagnostics;software metrics;pattern clustering	program comprehension;software quality analysis;architecture recovery;reverse engineering;tools;software metrics;slicing;clustering techniques;concept analysis						6 Aug 2002			IEEE	IEEE Conferences
Proceedings IEEE Second Workshop on Program Comprehension (Cat. No.93TH0551-2)	proceedings ieee second workshop on program comprehension (cat. no.93th05512)	10.1109/WPC.1993.263913	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=263913			[1993] IEEE Second Workshop on Program Comprehension	6 Aug 2002	1993			0_1		Presents the front cover of the proceedings record.	1092-8138	0-8186-4042-1				software maintenance;software reusability;software tools	software maintenance;software reusability;program comprehension;program representations;documents;tools						6 Aug 2002			IEEE	IEEE Conferences
Proceedings Seventh International Workshop on Program Comprehension	proceedings seventh international workshop on program comprehension	10.1109/WPC.1999.777731	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=777731			Proceedings Seventh International Workshop on Program Comprehension	6 Aug 2002	1999			iii		Presents the title page of the proceedings record.	1092-8138	0-7695-0180-x				reverse engineering;program slicing;software maintenance	parsing;visualization;architectures for understanding;comprehension strategies;integration frameworks;decomposition;empirical aspects;program analysis;composition						6 Aug 2002			IEEE	IEEE Conferences
Proceedings 12th International Workshop on Program Comprehension	proceedings 12th international workshop on program comprehension	10.1109/WPC.2004.1311032	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311032			Proceedings. 12th IEEE International Workshop on Program Comprehension, 2004.	12 jul. 2004	2004			0_1	0_1	Presents the front cover or splash screen of the proceedings.	1092-8138	0-7695-2149-5											12 jul. 2004			IEEE	IEEE Conferences
15th IEEE International Conference on Program Comprehension - Title	15th ieee international conference on program comprehension title	10.1109/ICPC.2007.5	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268227			15th IEEE International Conference on Program Comprehension (ICPC '07)	9 jul. 2007	2007			i	iii	The following topics are dealt with: program comprehension; software engineering; formal concept analysis; object-oriented reverse engineering; UML; software repository mining; dynamic program analysis; conceptual model; static program analysis and program visualization.	1092-8138	0-7695-2860-0				reverse engineering;system monitoring	program comprehension;software engineering;formal concept analysis;object-oriented reverse engineering;UML;software repository mining;dynamic program analysis;conceptual model;static program analysis;program visualization						9 jul. 2007			IEEE	IEEE Conferences
14th IEEE International Conference on Program Comprehension - Cover	14th ieee international conference on program comprehension cover	10.1109/ICPC.2006.2	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631090			14th IEEE International Conference on Program Comprehension (ICPC'06)	26 jun. 2006	2006			c1	c1	Presents the cover of the 14th IEEE International Conference on Program Comprehension (ICPC'06) proceedings.	1092-8138	0-7695-2601-2											26 jun. 2006			IEEE	IEEE Conferences
15th IEEE International Conference on Program Comprehension - Table of Contents	15th ieee international conference on program comprehension table of contents	10.1109/ICPC.2007.4	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268229			15th IEEE International Conference on Program Comprehension (ICPC '07)	9 jul. 2007	2007			v	viii	Presents the table of contents for the 15th IEEE International Conference on Program Comprehension (ICPC '07).	1092-8138	0-7695-2860-0											9 jul. 2007			IEEE	IEEE Conferences
14th IEEE International Conference on Program Comprehension - Copyright	14th ieee international conference on program comprehension copyright	10.1109/ICPC.2006.1	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631092			14th IEEE International Conference on Program Comprehension (ICPC'06)	26 jun. 2006	2006			iv	iv	Copyright and Reprint Permissions: Abstracting is permitted with credit to the source. Libraries may photocopy beyond the limits of US copyright law, for private use of patrons, those articles in this volume that carry a code at the bottom of the first page, provided that the per-copy fee indicated in the code is paid through the Copyright Clearance Center. The papers in this book comprise the proceedings of the meeting mentioned on the cover and title page. They reflect the authors' opinions and, in the interests of timely dissemination, are published as presented and without change. Their inclusion in this publication does not necessarily constitute endorsement by the editors or the Institute of Electrical and Electronics Engineers, Inc.	1092-8138	0-7695-2601-2											26 jun. 2006			IEEE	IEEE Conferences
Proceedings 1994 IEEE 3rd Workshop on Program Comprehension - WPC '94	proceedings 1994 ieee 3rd workshop on program comprehension wpc 94	10.1109/WPC.1994.341232	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=341232			Proceedings 1994 IEEE 3rd Workshop on Program Comprehension- WPC '94	6 Aug 2002	1994			0_1		Presents the front cover of the proceedings record.	1092-8138	0-8186-5647-6				reverse engineering;program diagnostics;system documentation;object-oriented programming;parallel programming;database management systems;software tools	software tools;object oriented programming;program comprehension;methodology;reverse engineering;documentation;parallel programming;database management systems						6 Aug 2002			IEEE	IEEE Conferences
Proceeding Program Structure	proceeding program structure	10.1109/IC2IE50715.2020.9274569	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9274569			2020 3rd International Conference on Computer and Informatics Engineering (IC2IE)	4 Dec 2020	2020			i	viii	Provides a schedule of conference events and a listing of which papers were presented in each session.		978-1-7281-8247-6											4 Dec 2020			IEEE	IEEE Conferences